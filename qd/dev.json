[
    {
        "id": "e968c73bf4c0d4b6fa12af529a4c949f561b0a51ef8510f0029c9dee84948ba4",
        "question": "How many singers do we have?",
        "query": "SELECT count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM concert_singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM concert_singer.singer",
        "qd": "#1 = Scan the table singer and retrieve a constant value of 1 for each singer ; #2 = Aggregate the count of records in #1 to find the total number of singers"
    },
    {
        "id": "de71b4f79c1ad3c71f523f6436acef9f69f5ca098b441f5055416ac23bf9bb75",
        "question": "What is the total number of singers?",
        "query": "SELECT count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM concert_singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM concert_singer.singer",
        "qd": "#1 = Scan the table singer and retrieve a constant value of 1 for each singer ; #2 = Aggregate the number of records from #1 to find the total number of singers"
    },
    {
        "id": "e394ac9df4f6eff3fff54c2cd85d37190b1ae1f4e30dd63e1577150115b277d3",
        "question": "Show name, country, age for all singers ordered by age from the oldest to the youngest.",
        "query": "SELECT name , country , age FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Name , Country , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Country , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Country, Age FROM concert_singer.singer ) SELECT Name, Country, Age FROM Scan_1 ORDER BY Age DESC",
        "clean_query": "SELECT name , country , age FROM concert_singer.singer  ORDER BY age DESC",
        "qd": "#1 = Scan the table singer and retrieve the names, countries, and ages of all singers ; #2 = Sort the records from #1 based on the age of the singers in descending order and retrieve the names, countries, and ages of all singers ordered from the oldest to the youngest."
    },
    {
        "id": "b67ff822c24588338ffb03a8d5dfa10d171e0b5e7187fc901ceb178b9e60260e",
        "question": "What are the names, countries, and ages for every singer in descending order of age?",
        "query": "SELECT name , country , age FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Name , Country , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Country , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Country, Age FROM concert_singer.singer ) SELECT Name, Country, Age FROM Scan_1 ORDER BY Age DESC",
        "clean_query": "SELECT name , country , age FROM concert_singer.singer  ORDER BY age DESC",
        "qd": "#1 = Scan the table singer and retrieve the names, countries, and ages of all singers ; #2 = Sort the records from #1 based on the age in descending order and retrieve the names, countries, and ages of all singers"
    },
    {
        "id": "53334ecd19e94f941108a87084020b87e9f5c41dc547b09d9aae53339cc69b0d",
        "question": "What is the average, minimum, and maximum age of all singers from France?",
        "query": "SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer WITH (FORCESCAN) WHERE country = 'France' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Country = 'France' ] Output [ Country , Age ] ; #2 = Aggregate [ #1 ] Output [ MIN(Age) AS Min_Age , AVG(Age) AS Avg_Age , MAX(Age) AS Max_Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Country, Age FROM concert_singer.singer WHERE Country = 'France' ), Aggregate_2 AS ( SELECT MIN(Age) AS Min_Age, AVG(Age) AS Avg_Age, MAX(Age) AS Max_Age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer  WHERE country = 'France'",
        "qd": "#1 = Scan the table singer and retrieve the country and age of all singers from France ; #2 = Aggregate the minimum, average, and maximum age of the singers from #1 and retrieve the minimum age as Min_Age, average age as Avg_Age, and maximum age as Max_Age"
    },
    {
        "id": "2c9124545e4b80beca6be6f312295f8cefc9dacdef86c65bcb177ccb138f723b",
        "question": "What is the average, minimum, and maximum age for all French singers?",
        "query": "SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer WITH (FORCESCAN) WHERE country = 'France' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Country = 'France' ] Output [ Country , Age ] ; #2 = Aggregate [ #1 ] Output [ MIN(Age) AS Min_Age , AVG(Age) AS Avg_Age , MAX(Age) AS Max_Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Country, Age FROM concert_singer.singer WHERE Country = 'France' ), Aggregate_2 AS ( SELECT MIN(Age) AS Min_Age, AVG(Age) AS Avg_Age, MAX(Age) AS Max_Age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer  WHERE country = 'France'",
        "qd": "#1 = Scan the table singer and retrieve the country and age of all French singers ; #2 = Aggregate the minimum, average, and maximum age of all French singers"
    },
    {
        "id": "950b12210f92f7fe8accf0f9ee01cdde5d5eddbb4ee55d11c62f35fcbd04a945",
        "question": "Show the name and the release year of the song by the youngest singer.",
        "query": "SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Song_Name , Song_release_year , Age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Song_Name , Song_release_year , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Song_Name, Song_release_year, Age FROM concert_singer.singer ), TopSort_2 AS ( SELECT TOP 1 Song_Name, Song_release_year, Age FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer  ORDER BY age",
        "qd": "#1 = Scan the table singer and retrieve the song name, release year, and age of all singers. ; #2 = Sort the records from #1 based on the age of the singers in ascending order, select the first record, and retrieve the song name and release year of the youngest singer."
    },
    {
        "id": "4f7180a6789311e9ad1d037c95fcb731331d0639d72e703d6dd5e1c58b5c24d8",
        "question": "What are the names and release years for all the songs of the youngest singer?",
        "query": "SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Song_Name , Song_release_year , Age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Song_Name , Song_release_year , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Song_Name, Song_release_year, Age FROM concert_singer.singer ), TopSort_2 AS ( SELECT TOP 1 Song_Name, Song_release_year, Age FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer  ORDER BY age",
        "qd": "#1 = Scan the table singer and retrieve the song names, release years, and ages of all singers ; #2 = Sort the records from #1 based on the age of the singers in ascending order, select the first record, and retrieve the song name and release year of the youngest singer"
    },
    {
        "id": "510cd2705d653711d8a98af4c2f583205aad0b5adf2325464970f860083224cd",
        "question": "What are all distinct countries where singers above age 20 are from?",
        "query": "SELECT DISTINCT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age > 20 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Age > 20 ] Distinct [ true ] Output [ Country ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Country FROM concert_singer.singer WHERE Age > 20 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT country FROM concert_singer.singer  WHERE age > 20",
        "qd": "#1 = Scan the table singer and retrieve all the distinct countries where singers above age 20 are from."
    },
    {
        "id": "caaf4a80c883edab18f4e7e85da3f3348e643534f21bcb95b97ba3db14647a8d",
        "question": "What are  the different countries with singers above age 20?",
        "query": "SELECT DISTINCT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age > 20 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Age > 20 ] Distinct [ true ] Output [ Country ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Country FROM concert_singer.singer WHERE Age > 20 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT country FROM concert_singer.singer  WHERE age > 20",
        "qd": "#1 = Scan the table singer and retrieve the countries of all singers with age above 20"
    },
    {
        "id": "eafbe8022e6e84b49effffba29e56d289b5d1e4c269a3c3933fb377ba09b6cb9",
        "question": "Show all countries and the number of singers in each country.",
        "query": "SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) GROUP BY country OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM concert_singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer  GROUP BY country",
        "qd": "#1 = Scan the table singer and retrieve the country of all singers ; #2 = Group #1 by country and count the number of singers in each country, and retrieve the count of singers and the country"
    },
    {
        "id": "e8e546b0d9e9fefa4c5f113010413fe3e77ee7f4f56456dc19a3d3ddb8314793",
        "question": "How many singers are from each country?",
        "query": "SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) GROUP BY country OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM concert_singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer  GROUP BY country",
        "qd": "#1 = Scan the table singer and retrieve the country of each singer. ; #2 = Group the records from #1 by country and aggregate the count per country to find the number of singers from each country."
    },
    {
        "id": "b622b7727c2f59b8d9162a06af9d125c7b91f2b7cad4d9ba976a52a14dcbd86b",
        "question": "List all song names by singers above the average age.",
        "query": "SELECT song_name FROM concert_singer.singer WITH (FORCESCAN) WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer WITH (FORCESCAN) ) ",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ] ; #3 = Scan Table [ singer ] Output [ Song_Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Age > #2.Avg_Age ] Output [ #3.Song_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Age FROM concert_singer.singer ), Aggregate_2 AS ( SELECT AVG(Age) AS Avg_Age FROM Scan_1 ), Scan_3 AS ( SELECT Song_Name, Age FROM concert_singer.singer ), Join_4 AS ( SELECT Song_Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Age > Aggregate_2.Avg_Age ) SELECT * FROM Join_4",
        "clean_query": "SELECT song_name FROM concert_singer.singer  WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer  )",
        "qd": "#1 = Scan the table singer to retrieve the age of all singers ; #2 = Aggregate the average age from #1 and assign it as Avg_Age ; #3 = Scan the table singer to retrieve the song names and age of all singers ; #4 = Join #2 and #3 based on the comparison of age and average age, and retrieve the song names by singers above the average age"
    },
    {
        "id": "bc82973d8a4f671f6ef6a3b4e3a994c811d7f72d0410a6437d4195f8c5b8a0ce",
        "question": "What are all the song names by singers who are older than average?",
        "query": "SELECT song_name FROM concert_singer.singer WITH (FORCESCAN) WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer WITH (FORCESCAN) ) ",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ] ; #3 = Scan Table [ singer ] Output [ Song_Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Age > #2.Avg_Age ] Output [ #3.Song_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Age FROM concert_singer.singer ), Aggregate_2 AS ( SELECT AVG(Age) AS Avg_Age FROM Scan_1 ), Scan_3 AS ( SELECT Song_Name, Age FROM concert_singer.singer ), Join_4 AS ( SELECT Song_Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Age > Aggregate_2.Avg_Age ) SELECT * FROM Join_4",
        "clean_query": "SELECT song_name FROM concert_singer.singer  WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer  )",
        "qd": "#1 = Scan the table singer and retrieve the ages of all singers ; #2 = Calculate the average age of all singers ; #3 = Scan the table singer and retrieve the song names and ages of all singers ; #4 = Join #2 and #3 based on the ages of the singers and retrieve the song names of singers who are older than the average age"
    },
    {
        "id": "702b793672d277ed4c482f92123e570d1e078e384702f2391b7b7bde241442cd",
        "question": "Show location and name for all stadiums with a capacity between 5000 and 10000.",
        "query": "SELECT LOCATION , name FROM concert_singer.stadium WITH (FORCESCAN) WHERE capacity BETWEEN 5000 AND 10000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Predicate [ Capacity >= 5000 AND Capacity <= 10000 ] Output [ Name , Location , Capacity ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Location, Capacity FROM concert_singer.stadium WHERE Capacity >= 5000 AND Capacity <= 10000 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT LOCATION , name FROM concert_singer.stadium  WHERE capacity BETWEEN 5000 AND 10000",
        "qd": "#1 = Scan the table stadium and retrieve the location and name of all stadiums with a capacity between 5000 and 10000."
    },
    {
        "id": "03d124ae45b4ce58b2dcbf28e5bd3e207107ab62ee5a796cf67d278f03da5991",
        "question": "What are the locations and names of all stations with capacity between 5000 and 10000?",
        "query": "SELECT LOCATION , name FROM concert_singer.stadium WITH (FORCESCAN) WHERE capacity BETWEEN 5000 AND 10000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Predicate [ Capacity >= 5000 AND Capacity <= 10000 ] Output [ Name , Location , Capacity ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Location, Capacity FROM concert_singer.stadium WHERE Capacity >= 5000 AND Capacity <= 10000 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT LOCATION , name FROM concert_singer.stadium  WHERE capacity BETWEEN 5000 AND 10000",
        "qd": "#1 = Scan the table stadium and retrieve the names and locations of all stadiums with a capacity between 5000 and 10000."
    },
    {
        "id": "9d0778eb0707002333a0bf777d868b7a14384e4a6da008beda575d4c56628f95",
        "question": "What is the maximum capacity and the average of all stadiums ?",
        "query": "select max ( capacity ) AS Max_capacity , average from concert_singer.stadium group by average",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Average , Capacity ] ; #2 = Aggregate [ #1 ] GroupBy [ Average ] Output [ Average , MAX(Capacity) AS Max_Capacity ]",
        "cte": "WITH Scan_1 AS ( SELECT Average, Capacity FROM concert_singer.stadium ), Aggregate_2 AS ( SELECT Average, MAX(Capacity) AS Max_Capacity FROM Scan_1 GROUP BY Average ) SELECT * FROM Aggregate_2",
        "clean_query": "select max ( capacity ) AS Max_capacity , average from concert_singer.stadium group by average",
        "qd": "#1 = Scan the table stadium and retrieve the average and capacity of all stadiums. ; #2 = Group the records from #1 based on the average and aggregate the maximum capacity to find the maximum capacity and average of all stadiums."
    },
    {
        "id": "b9856abd94006487ca31911b34964cc7e41c7ac610e84c761ed5d107e75be80b",
        "question": "What is the average and maximum capacities for all stadiums ?",
        "query": "select avg ( capacity ) AS Avg_capacity , max ( capacity ) AS Max_capacity FROM concert_singer.stadium WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity ] ; #2 = Aggregate [ #1 ] Output [ MAX(Capacity) AS Max_Capacity , AVG(Capacity) AS Avg_Capacity ]",
        "cte": "WITH Scan_1 AS ( SELECT Capacity FROM concert_singer.stadium ), Aggregate_2 AS ( SELECT MAX(Capacity) AS Max_Capacity, AVG(Capacity) AS Avg_Capacity FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "select avg ( capacity ) AS Avg_capacity , max ( capacity ) AS Max_capacity FROM concert_singer.stadium",
        "qd": "#1 = Scan the table stadium and retrieve the capacity of all stadiums ; #2 = Aggregate the maximum and average values of the capacities from #1 to find the maximum and average capacities for all stadiums"
    },
    {
        "id": "f2d22804f55d8c9889b17e685d05553725cce3ad4a081019ff11f72de7e9c8f1",
        "question": "What is the name and capacity for the stadium with highest average attendance?",
        "query": "SELECT TOP 1 name , capacity FROM concert_singer.stadium WITH (FORCESCAN) ORDER BY average DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Average , Capacity ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Average DESC ] Output [ Name , Average , Capacity ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Average, Capacity FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Name, Average, Capacity FROM Scan_1 ORDER BY Average DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 name , capacity FROM concert_singer.stadium  ORDER BY average DESC",
        "qd": "#1 = Scan the table stadium and retrieve the name, average attendance, and capacity of all stadiums ; #2 = Sort the records from #1 based on the average attendance in descending order, select the first record, and identify the name and capacity of the stadium with the highest average attendance."
    },
    {
        "id": "567783c3df80bd4ff5f729ab5c7b8fc416c10a71799c470a6d2c3beb6ed5fcc9",
        "question": "What is the name and capacity for the stadium with the highest average attendance?",
        "query": "SELECT TOP 1 name , capacity FROM concert_singer.stadium WITH (FORCESCAN) ORDER BY average DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Average , Capacity ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Average DESC ] Output [ Name , Average , Capacity ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Average, Capacity FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Name, Average, Capacity FROM Scan_1 ORDER BY Average DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 name , capacity FROM concert_singer.stadium  ORDER BY average DESC",
        "qd": "#1 = Scan the table stadium and retrieve the names, average attendance, and capacities of all the stadiums ; #2 = Sort the records from #1 based on the average attendance in descending order, select the first record, and retrieve the name and capacity of the stadium with the highest average attendance"
    },
    {
        "id": "b8c847904e750fe4416bc380d732457def4ae381a28aa719d6a951f5fc9d7fad",
        "question": "How many concerts are there in year 2014 or 2015?",
        "query": "SELECT count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) WHERE YEAR = 2014 OR YEAR = 2015 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 OR Year = 2015 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert WHERE Year = 2014 OR Year = 2015 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM concert_singer.concert  WHERE YEAR = 2014 OR YEAR = 2015",
        "qd": "#1 = Scan the table concert and retrieve the year of all concerts that occurred in either 2014 or 2015 ; #2 = Aggregate the number of records in #1 to find the total number of concerts that occurred in 2014 or 2015"
    },
    {
        "id": "c3d09bbd5ef44b3e809bb09034af2f560f4d623215e8376b9b7c125a7a724849",
        "question": "How many concerts occurred in 2014 or 2015?",
        "query": "SELECT count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) WHERE YEAR = 2014 OR YEAR = 2015 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 OR Year = 2015 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert WHERE Year = 2014 OR Year = 2015 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM concert_singer.concert  WHERE YEAR = 2014 OR YEAR = 2015",
        "qd": "#1 = Scan the table concert and retrieve the years of all concerts that occurred in 2014 or 2015 ; #2 = Aggregate the number of records in #1 to find the total number of concerts that occurred in 2014 or 2015"
    },
    {
        "id": "dcd57f330d2deb88d06e3aa786b8bad819dc63de5e9110d4fbb94cbab2d57c1f",
        "question": "Show the stadium name and the number of concerts in each stadium.",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Output [ Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Stadium_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Name , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Scan_2 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_1.Stadium_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Stadium_ID, Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id",
        "qd": "#1 = Scan the table concert and retrieve the stadium IDs of all concerts ; #2 = Scan the table stadium and retrieve the stadium names and IDs ; #3 = Join #1 and #2 based on the matching stadium IDs and retrieve the stadium IDs and names ; #4 = Group #3 by stadium ID and aggregate the count of records for each stadium to find the number of concerts in each stadium. Retrieve the stadium names and the count of concerts."
    },
    {
        "id": "d011124ee39b8a8168783bbde992cc343aa3b925ea416d5262d1d21b8276ec93",
        "question": "For each stadium, how many concerts play there?",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Output [ Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Stadium_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Name , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Scan_2 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_1.Stadium_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Stadium_ID, Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id",
        "qd": "#1 = Scan the table concert and retrieve the stadium IDs of all the concerts ; #2 = Scan the table stadium and retrieve the names and stadium IDs of all stadiums ; #3 = Join #1 and #2 based on the matching stadium IDs and retrieve the stadium IDs and names ; #4 = Group #3 by stadium ID and aggregate the count of concerts per stadium to find the number of concerts played at each stadium, and retrieve the stadium names and the count of concerts."
    },
    {
        "id": "1b4ff28beddb2e20b5b98772dc08dc31b033b25d3bb666da28b6bfc81b517174",
        "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.",
        "query": "SELECT TOP 1 T2.name , T2.capacity FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.year > = 2014 GROUP BY T2.name , T2.capacity , T2.stadium_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year >= 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Capacity , Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Capacity , Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year >= 2014 ), Scan_2 AS ( SELECT Capacity, Stadium_ID, Name FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_2.Stadium_ID, Scan_2.Capacity, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Capacity, Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Stadium_ID, Name, Capacity ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Capacity, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.name , T2.capacity FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.year > = 2014 GROUP BY T2.name , T2.capacity , T2.stadium_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table concert and retrieve the years and stadium IDs of all concerts that occurred in 2014 or after ; #2 = Scan the table stadium and retrieve the capacity, stadium IDs, and names of all stadiums ; #3 = Join #1 and #2 based on the matching Stadium IDs and retrieve the stadium IDs, capacities, and names ; #4 = Group #3 by Stadium ID and aggregate the count of concerts per stadium to find the number of concerts for each stadium ; #5 = Sort the records from #4 based on the count of concerts in descending order, select the first record, and retrieve the count of concerts, capacity, and name of the stadium with the most number of concerts in 2014 or after"
    },
    {
        "id": "6b4498103b5d61a19827ce25667aea3019ce7675511bd6745692252c786e1437",
        "question": "What is the name and capacity of the stadium with the most concerts after 2013 ?",
        "query": "select TOP 1 t2.name , t2.capacity FROM concert_singer.concert AS t1 WITH (FORCESCAN) join concert_singer.stadium as t2 WITH (FORCESCAN) on t1.stadium_id = t2.stadium_id where t1.year > 2013 group by t2.name , t2.capacity , t2.stadium_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year > 2013 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Capacity , Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Capacity , Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year > 2013 ), Scan_2 AS ( SELECT Capacity, Stadium_ID, Name FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_2.Stadium_ID, Scan_2.Capacity, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Capacity, Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Stadium_ID, Name, Capacity ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Capacity, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 t2.name , t2.capacity FROM concert_singer.concert AS t1  join concert_singer.stadium as t2  on t1.stadium_id = t2.stadium_id where t1.year > 2013 group by t2.name , t2.capacity , t2.stadium_id order by count ( * ) desc",
        "qd": "#1 = Scan the table concert and retrieve the years and stadium IDs of all concerts that occurred after 2013 ; #2 = Scan the table stadium and retrieve the capacity, stadium IDs, and names of all stadiums ; #3 = Join #1 and #2 based on the matching Stadium IDs and retrieve the stadium IDs, capacity, and names ; #4 = Group #3 by stadium ID and aggregate the count of concerts per stadium to find the stadium with the most concerts after 2013 ; #5 = Sort the records from #4 based on the count of concerts in descending order, select the first record, and identify the capacity and name of the stadium with the most concerts after 2013"
    },
    {
        "id": "aa6bf7301371f2cff46a9c496cf9c22dbbb4cb140dfc89f2ac109fd69c17017a",
        "question": "Which year has most number of concerts?",
        "query": "SELECT TOP 1 YEAR FROM concert_singer.concert WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Output [ Year ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Year , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert ), Aggregate_2 AS ( SELECT Year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Year ), TopSort_3 AS ( SELECT TOP 1 Year, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 YEAR FROM concert_singer.concert  GROUP BY YEAR ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table concert and retrieve the years of all concerts ; #2 = Group #1 by year and aggregate the count of concerts per year ; #3 = Sort the records from #2 based on the count of concerts in descending order, select the first record, and identify the year with the most number of concerts and its count of concerts."
    },
    {
        "id": "8314cff444da4190f678444cf54af0f671ea099bf1fd89b5c3d7fd8992206b6e",
        "question": "What is the year that had the most concerts?",
        "query": "SELECT TOP 1 YEAR FROM concert_singer.concert WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Output [ Year ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Year , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert ), Aggregate_2 AS ( SELECT Year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Year ), TopSort_3 AS ( SELECT TOP 1 Year, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 YEAR FROM concert_singer.concert  GROUP BY YEAR ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table concert and retrieve the years of all the concerts. ; #2 = Group #1 by year and aggregate the count of concerts per year. ; #3 = Sort the records from #2 based on the count of concerts in descending order, select the first record, and retrieve the year that had the most concerts and its count."
    },
    {
        "id": "a2ffbc395f534bbcc3f680bff6c1171efc495cd5e4a165fd980fb0040bac4623",
        "question": "Show the stadium names without any concert.",
        "query": "SELECT name FROM concert_singer.stadium WITH (FORCESCAN) WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert WITH (FORCESCAN) ) ",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #2 = Scan Table [ concert ] Output [ Stadium_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Stadium_ID IS NULL OR #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Scan_2 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT name FROM concert_singer.stadium  WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert  )",
        "qd": "#1 = Scan the table stadium and retrieve the names and IDs of all stadiums ; #2 = Scan the table concert and retrieve the stadium IDs of all concerts ; #3 = Return the names from #1 of the stadiums without any concerts, which are either stadiums with no concerts or stadiums with IDs not present in #2."
    },
    {
        "id": "9891f13461359514e80f559cbff62c2204692fb32e2b850d48f587e0a2f068b0",
        "question": "What are the names of the stadiums without any concerts?",
        "query": "SELECT name FROM concert_singer.stadium WITH (FORCESCAN) WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert WITH (FORCESCAN) ) ",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #2 = Scan Table [ concert ] Output [ Stadium_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Stadium_ID IS NULL OR #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Scan_2 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT name FROM concert_singer.stadium  WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert  )",
        "qd": "#1 = Scan the table stadium and retrieve the names and IDs of all stadiums ; #2 = Scan the table concert and retrieve the stadium IDs of all concerts ; #3 = Return the names from #1 that do not have any corresponding stadium IDs in #2 to find the names of the stadiums without any concerts"
    },
    {
        "id": "66e090db2c6354463561fac293917d6c63cedb67424cde7983e0d0e45c06013f",
        "question": "Show countries where a singer above age 40 and a singer below 30 are from.",
        "query": "SELECT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age > 40 INTERSECT SELECT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age < 30 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Age > 40 ] Distinct [ true ] Output [ Country , Age ] ; #2 = Scan Table [ singer ] Predicate [ Age < 30 ] Output [ Country , Age ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Country = #2.Country ] Output [ #1.Country ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Country, Age FROM concert_singer.singer WHERE Age > 40 ), Scan_2 AS ( SELECT Country, Age FROM concert_singer.singer WHERE Age < 30 ), Intersect_3 AS ( SELECT Scan_1.Country FROM Scan_1 WHERE Country IN (SELECT Country FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT country FROM concert_singer.singer  WHERE age > 40 INTERSECT SELECT country FROM concert_singer.singer  WHERE age < 30",
        "qd": "#1 = Scan the table singer and retrieve the countries and ages of all singers above 40 without duplicates ; #2 = Scan the table singer and retrieve the countries and ages of all singers below 30 ; #3 = Intersect #1 and #2 based on the matching countries and retrieve the countries"
    },
    {
        "id": "6461e8c73ff28757df50984fd488bc500623f7b97be11073ca02266be64c7ea5",
        "question": "Show names for all stadiums except for stadiums having a concert in year 2014.",
        "query": "SELECT name FROM concert_singer.stadium WITH (FORCESCAN) EXCEPT SELECT T2.name FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Distinct [ true ] Output [ Name ] ; #2 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #3 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Name FROM concert_singer.stadium ), Scan_2 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_3 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.Stadium_ID = Scan_3.Stadium_ID ), Except_5 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT name FROM concert_singer.stadium  EXCEPT SELECT T2.name FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014",
        "qd": "#1 = Scan the table stadium and retrieve the names of all stadiums without duplicates. ; #2 = Scan the table concert and retrieve the stadiums IDs of all concerts that occurred in 2014. ; #3 = Scan the table stadium and retrieve the names and stadium IDs of all stadiums. ; #4 = Join #2 and #3 based on the matching stadium IDs and retrieve the names of the stadiums. ; #5 = Return all the stadium names from #1 that are not in #4."
    },
    {
        "id": "e216cdd1ff98c38427880127f0d408f230492aace2ab20e4d7e13def209ba0cf",
        "question": "What are the names of all stadiums that did not have a concert in 2014?",
        "query": "SELECT name FROM concert_singer.stadium WITH (FORCESCAN) EXCEPT SELECT T2.name FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Distinct [ true ] Output [ Name ] ; #2 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #3 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Name FROM concert_singer.stadium ), Scan_2 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_3 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.Stadium_ID = Scan_3.Stadium_ID ), Except_5 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT name FROM concert_singer.stadium  EXCEPT SELECT T2.name FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014",
        "qd": "#1 = Scan the table stadium and retrieve the names of all stadiums without duplicates ; #2 = Scan the table concert and retrieve the years and stadium IDs of all concerts in 2014 ; #3 = Scan the table stadium and retrieve the names and stadium IDs of all stadiums ; #4 = Join #2 and #3 based on the matching stadium IDs and retrieve the names of the stadiums ; #5 = Return all the stadium names from #1 that are not in #4 to find the names of all stadiums that did not have a concert in 2014"
    },
    {
        "id": "b6618cc926b5b8cc6e09139cb718b03092808549394e8287aafb2b9044c491bf",
        "question": "Show the name and theme for all concerts and the number of singers in each concert.",
        "query": "SELECT T2.concert_name , T2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.concert AS T2 WITH (FORCESCAN) ON T1.concert_id = T2.concert_id GROUP BY T2.concert_name , T2.theme , T2.concert_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ concert_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ concert_ID ] Output [ countstar AS Count_Star , concert_ID ] ; #3 = Scan Table [ concert ] Output [ Theme , concert_Name , concert_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.concert_ID = #3.concert_ID ] Output [ #3.Theme , #2.Count_Star , #3.concert_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT concert_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, concert_ID FROM Scan_1 GROUP BY concert_ID ), Scan_3 AS ( SELECT Theme, concert_Name, concert_ID FROM concert_singer.concert ), Join_4 AS ( SELECT Scan_3.Theme, Aggregate_2.Count_Star, Scan_3.concert_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.concert_ID = Scan_3.concert_ID ) SELECT * FROM Join_4",
        "clean_query": "SELECT T2.concert_name , T2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.concert AS T2  ON T1.concert_id = T2.concert_id GROUP BY T2.concert_name , T2.theme , T2.concert_id",
        "qd": "#1 = Scan the table singer_in_concert and retrieve the concert IDs ; #2 = Group #1 by concert ID and aggregate the count of singers in each concert ; #3 = Scan the table concert and retrieve the theme, concert name, and concert ID of all concerts ; #4 = Join #2 and #3 based on the matching concert IDs and retrieve the theme, count of singers, and concert name for all concerts"
    },
    {
        "id": "7acbdc4f7c108ce2c675170ef55882c7b9871fe3b5c8dbfee26a6f757a027492",
        "question": "What are the names , themes , and number of singers for every concert ?",
        "query": "select t2.concert_name , t2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS t1 WITH (FORCESCAN) join concert_singer.concert as t2 WITH (FORCESCAN) on t1.concert_id = t2.concert_id group by t2.concert_name , t2.theme , t2.concert_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ concert_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ concert_ID ] Output [ countstar AS Count_Star , concert_ID ] ; #3 = Scan Table [ concert ] Output [ Theme , concert_Name , concert_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.concert_ID = #3.concert_ID ] Output [ #3.Theme , #2.Count_Star , #3.concert_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT concert_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, concert_ID FROM Scan_1 GROUP BY concert_ID ), Scan_3 AS ( SELECT Theme, concert_Name, concert_ID FROM concert_singer.concert ), Join_4 AS ( SELECT Scan_3.Theme, Aggregate_2.Count_Star, Scan_3.concert_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.concert_ID = Scan_3.concert_ID ) SELECT * FROM Join_4",
        "clean_query": "select t2.concert_name , t2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS t1  join concert_singer.concert as t2  on t1.concert_id = t2.concert_id group by t2.concert_name , t2.theme , t2.concert_id",
        "qd": "#1 = Scan the table singer_in_concert and retrieve all the concert IDs ; #2 = Group #1 by concert ID and aggregate the count of records per concert ID to find the number of singers for each concert ; #3 = Scan the table concert and retrieve the themes, names, and IDs of all concerts ; #4 = Join #2 and #3 based on the matching concert IDs and retrieve the themes, number of singers, and names of concerts"
    },
    {
        "id": "8dcbaac89354f86302d6a16bc620ce64674b57a5369eb808b45bf41afe1560de",
        "question": "List singer names and number of concerts for each singer.",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ Singer_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Singer_ID ] Output [ Singer_ID , countstar AS Count_Star ] ; #3 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Singer_ID = #3.Singer_ID ] Output [ #3.Name , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT Singer_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Singer_ID ), Scan_3 AS ( SELECT Singer_ID, Name FROM concert_singer.singer ), Join_4 AS ( SELECT Scan_3.Name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Singer_ID = Scan_3.Singer_ID ) SELECT * FROM Join_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id",
        "qd": "#1 = Scan the table singer_in_concert and retrieve all the singer IDs ; #2 = Group #1 by singer ID and aggregate the count of concerts for each singer ; #3 = Scan the table singer and retrieve the singer IDs and names ; #4 = Join #2 and #3 based on the matching singer IDs and retrieve the singer names and the count of concerts for each singer"
    },
    {
        "id": "3b794e094e7479a816e8818a7514d0e91bc737440da6b6c76c26a0f6041aab68",
        "question": "What are the names of the singers and number of concerts for each person?",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ Singer_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Singer_ID ] Output [ Singer_ID , countstar AS Count_Star ] ; #3 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Singer_ID = #3.Singer_ID ] Output [ #3.Name , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT Singer_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Singer_ID ), Scan_3 AS ( SELECT Singer_ID, Name FROM concert_singer.singer ), Join_4 AS ( SELECT Scan_3.Name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Singer_ID = Scan_3.Singer_ID ) SELECT * FROM Join_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id",
        "qd": "#1 = Scan the table singer_in_concert and retrieve the singer IDs of all the concerts ; #2 = Group #1 by singer ID and aggregate the count of concert per singer ID to find the number of concerts for each person ; #3 = Scan the table singer and retrieve the singer IDs and names of all singers ; #4 = Join #2 and #3 based on the matching singer IDs and retrieve the names and number of concerts for each person"
    },
    {
        "id": "e0e10dd96631c9a039a0f6b68747d5eef73a3e9e37063de7381bdd2b09913603",
        "question": "List all singer names in concerts in year 2014.",
        "query": "SELECT T2.name FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3 WITH (FORCESCAN) ON T1.concert_id = T3.concert_id WHERE T3.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , concert_ID ] ; #2 = Scan Table [ singer_in_concert ] Output [ Singer_ID , concert_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.concert_ID = #2.concert_ID ] Output [ #2.Singer_ID ] ; #4 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Singer_ID = #4.Singer_ID ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, concert_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT Singer_ID, concert_ID FROM concert_singer.singer_in_concert ), Join_3 AS ( SELECT Scan_2.Singer_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.concert_ID = Scan_2.concert_ID ), Scan_4 AS ( SELECT Singer_ID, Name FROM concert_singer.singer ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Singer_ID = Scan_4.Singer_ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T2.name FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3  ON T1.concert_id = T3.concert_id WHERE T3.year = 2014",
        "qd": "#1 = Scan the table concert to find all the concerts that occurred in 2014 ; #2 = Scan the table singer_in_concert to find all the singer IDs and concert IDs ; #3 = Join #1 and #2 based on the matching concert IDs and retrieve the singer IDs ; #4 = Scan the table singer to find all the singer IDs and names ; #5 = Join #3 and #4 based on the matching singer IDs and retrieve the singer names"
    },
    {
        "id": "647d2db94feaabbbdd3eecac3a26c557b1fb2a27a9e69a1f852d55b418ac6428",
        "question": "What are the names of the singers who performed in a concert in 2014?",
        "query": "SELECT T2.name FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3 WITH (FORCESCAN) ON T1.concert_id = T3.concert_id WHERE T3.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , concert_ID ] ; #2 = Scan Table [ singer_in_concert ] Output [ Singer_ID , concert_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.concert_ID = #2.concert_ID ] Output [ #2.Singer_ID ] ; #4 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Singer_ID = #4.Singer_ID ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, concert_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT Singer_ID, concert_ID FROM concert_singer.singer_in_concert ), Join_3 AS ( SELECT Scan_2.Singer_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.concert_ID = Scan_2.concert_ID ), Scan_4 AS ( SELECT Singer_ID, Name FROM concert_singer.singer ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Singer_ID = Scan_4.Singer_ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T2.name FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3  ON T1.concert_id = T3.concert_id WHERE T3.year = 2014",
        "qd": "#1 = Scan the table concert and retrieve the concert IDs of all the concerts that occurred in 2014 ; #2 = Scan the table singer_in_concert and retrieve the singer IDs, concert IDs of all singers in concerts ; #3 = Join #1 and #2 based on the matching concert IDs and retrieve the singer IDs ; #4 = Scan the table singer and retrieve the singer IDs, names of all singers ; #5 = Join #3 and #4 based on the matching singer IDs and retrieve the names of the singers who performed in a concert in 2014"
    },
    {
        "id": "b2572fa21c59deecda02eba022c89a012ca1699008c53c14477974811d2ab2b7",
        "question": "what is the name and nation of the singer who have a song having 'Hey' in its name?",
        "query": "SELECT name , country FROM concert_singer.singer WITH (FORCESCAN) WHERE song_name LIKE '%Hey%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Song_Name like '%Hey%' ] Output [ Name , Song_Name , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Song_Name, Country FROM concert_singer.singer WHERE Song_Name like '%Hey%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , country FROM concert_singer.singer  WHERE song_name LIKE '%Hey%'",
        "qd": "#1 = Scan the table singer and retrieve the names and nations of the singers who have a song with 'Hey' in its name"
    },
    {
        "id": "ffae8b56f4857f97c781656cf84ccfa69b2b5afec94b6ada88e32db83cf75a0d",
        "question": "What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?",
        "query": "SELECT name , country FROM concert_singer.singer WITH (FORCESCAN) WHERE song_name LIKE '%Hey%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ singer ] Predicate [ Song_Name like '%Hey%' ] Output [ Name , Song_Name , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Song_Name, Country FROM concert_singer.singer WHERE Song_Name like '%Hey%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , country FROM concert_singer.singer  WHERE song_name LIKE '%Hey%'",
        "qd": "#1 = Scan the table singer and retrieve the names, song names, and countries of origin for all singers who have a song with the word 'Hey' in its title."
    },
    {
        "id": "41d3e92c786b0b23ab2969a8beed1284689a19b42473d98e6fdd654c6b4f7a2a",
        "question": "Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
        "query": "SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Location , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Distinct [ true ] Output [ #2.Location , #2.Name ] ; #4 = Scan Table [ concert ] Predicate [ Year = 2015 ] Output [ Year , Stadium_ID ] ; #5 = Scan Table [ stadium ] Output [ Name , Location , Stadium_ID ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Stadium_ID = #5.Stadium_ID ] Output [ #5.Location , #5.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Output [ #3.Name , #3.Location ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT Name, Location, Stadium_ID FROM concert_singer.stadium ), Join_3 AS ( SELECT DISTINCT Scan_2.Location, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Scan_4 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2015 ), Scan_5 AS ( SELECT Name, Location, Stadium_ID FROM concert_singer.stadium ), Join_6 AS ( SELECT Scan_5.Location, Scan_5.Name FROM Scan_4 JOIN Scan_5 ON Scan_4.Stadium_ID = Scan_5.Stadium_ID ), Intersect_7 AS ( SELECT Join_3.Name, Join_3.Location FROM Join_3 WHERE Name IN (SELECT Name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015",
        "qd": "#1 = Scan the table concert and retrieve the year and stadium IDs of all the concerts that occurred in 2014 ; #2 = Scan the table stadium and retrieve the names, locations, and stadium IDs of all stadiums ; #3 = Join #1 and #2 based on the matching Stadium IDs and retrieve the locations and names ; #4 = Scan the table concert and retrieve the year and stadium IDs of all the concerts that occurred in 2015 ; #5 = Scan the table stadium and retrieve the names, locations, and stadium IDs of all stadiums ; #6 = Join #4 and #5 based on the matching Stadium IDs and retrieve the locations and names ; #7 = Intersect #3 and #6 based on the matching names and retrieve the names and locations of the stadiums"
    },
    {
        "id": "e12cf91c771fa037e6783e5800ff94968bc131b55bf15a098ff231834fa087d0",
        "question": "What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
        "query": "SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Location , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Distinct [ true ] Output [ #2.Location , #2.Name ] ; #4 = Scan Table [ concert ] Predicate [ Year = 2015 ] Output [ Year , Stadium_ID ] ; #5 = Scan Table [ stadium ] Output [ Name , Location , Stadium_ID ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Stadium_ID = #5.Stadium_ID ] Output [ #5.Location , #5.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Output [ #3.Name , #3.Location ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT Name, Location, Stadium_ID FROM concert_singer.stadium ), Join_3 AS ( SELECT DISTINCT Scan_2.Location, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Scan_4 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2015 ), Scan_5 AS ( SELECT Name, Location, Stadium_ID FROM concert_singer.stadium ), Join_6 AS ( SELECT Scan_5.Location, Scan_5.Name FROM Scan_4 JOIN Scan_5 ON Scan_4.Stadium_ID = Scan_5.Stadium_ID ), Intersect_7 AS ( SELECT Join_3.Name, Join_3.Location FROM Join_3 WHERE Name IN (SELECT Name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015",
        "qd": "#1 = Scan the table concert and retrieve the years and stadium IDs of all the concerts that occurred in 2014 ; #2 = Scan the table stadium and retrieve the names, locations, and stadium IDs of all stadiums ; #3 = Join #1 and #2 based on the matching Stadium IDs and retrieve the locations and names ; #4 = Scan the table concert and retrieve the years and stadium IDs of all the concerts that occurred in 2015 ; #5 = Scan the table stadium and retrieve the names, locations, and stadium IDs of all stadiums ; #6 = Join #4 and #5 based on the matching Stadium IDs and retrieve the locations and names ; #7 = Intersect #3 and #6 based on the matching names and retrieve the names and locations"
    },
    {
        "id": "42d93c17d3b56bb252b66f63ab587d51a87c7c5714ad70b39b5c3bc9b6206343",
        "question": "Find the number of concerts happened in the stadium with the highest capacity .",
        "query": "select count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium WITH (FORCESCAN) order by capacity desc ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Capacity DESC ] Output [ Capacity , Stadium_ID ] ; #3 = Scan Table [ concert ] Output [ Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #2.Capacity , #2.Stadium_ID ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Capacity, Stadium_ID FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Capacity, Stadium_ID FROM Scan_1 ORDER BY Capacity DESC ), Scan_3 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Join_4 AS ( SELECT TopSort_2.Capacity, TopSort_2.Stadium_ID FROM TopSort_2 JOIN Scan_3 ON TopSort_2.Stadium_ID = Scan_3.Stadium_ID ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "select count ( * ) AS Count_Star FROM concert_singer.concert  where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium  order by capacity desc )",
        "qd": "#1 = Scan the table stadium and retrieve the capacity and stadium ID of all stadiums. ; #2 = Sort the records from #1 based on the capacity of the stadiums in descending order, select the first record, and identify the stadium with the highest capacity. ; #3 = Scan the table concert and retrieve the stadium IDs of all concerts. ; #4 = Join #2 and #3 based on the matching stadium ID and retrieve the capacity and stadium ID. ; #5 = Aggregate the number of records in #4 to find the number of concerts that happened in the stadium with the highest capacity."
    },
    {
        "id": "d96c4aa465d4471e493741e9b5bd593cb4cee234edcbb652473be660899b21cf",
        "question": "What are the number of concerts that occurred in the stadium with the largest capacity ?",
        "query": "select count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium WITH (FORCESCAN) order by capacity desc ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Capacity DESC ] Output [ Capacity , Stadium_ID ] ; #3 = Scan Table [ concert ] Output [ Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #2.Capacity , #2.Stadium_ID ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Capacity, Stadium_ID FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Capacity, Stadium_ID FROM Scan_1 ORDER BY Capacity DESC ), Scan_3 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Join_4 AS ( SELECT TopSort_2.Capacity, TopSort_2.Stadium_ID FROM TopSort_2 JOIN Scan_3 ON TopSort_2.Stadium_ID = Scan_3.Stadium_ID ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "select count ( * ) AS Count_Star FROM concert_singer.concert  where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium  order by capacity desc )",
        "qd": "#1 = Scan the table stadium and retrieve the capacity and stadium ID of all stadiums. ; #2 = Sort the records from #1 based on the capacity in descending order, select the first record, and retrieve the capacity and stadium ID of the stadium with the largest capacity. ; #3 = Scan the table concert and retrieve the stadium ID of all concerts. ; #4 = Join #2 and #3 based on the matching stadium ID and retrieve the capacity and stadium ID. ; #5 = Aggregate the count of all records in #4 to find the number of concerts that occurred in the stadium with the largest capacity."
    },
    {
        "id": "11f48bff71b58facc88ca7563664da98e0dda72f64e9130e8c18ead0c00c7bc8",
        "question": "Find the number of pets whose weight is heavier than 10.",
        "query": "SELECT count ( * ) AS Count_Star FROM pets_1.pets WITH (FORCESCAN) WHERE weight > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ weight > 10.0 ] Output [ weight ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT weight FROM pets_1.Pets WHERE weight > 10.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM pets_1.pets  WHERE weight > 10",
        "qd": "#1 = Scan the table Pets and retrieve the weight of all pets that weigh more than 10 ; #2 = Aggregate the number of records in #1 to find the count of pets whose weight is heavier than 10"
    },
    {
        "id": "b2964fe5bd1fd23fa2bcdde07996f8745f21fd16c8c9228fced51de099028872",
        "question": "How many pets have a greater weight than 10?",
        "query": "SELECT count ( * ) AS Count_Star FROM pets_1.pets WITH (FORCESCAN) WHERE weight > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ weight > 10.0 ] Output [ weight ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT weight FROM pets_1.Pets WHERE weight > 10.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM pets_1.pets  WHERE weight > 10",
        "qd": "#1 = Scan the table Pets and retrieve the weight of all pets that have a weight greater than 10. ; #2 = Aggregate the count of all records from #1 to find the number of pets that have a weight greater than 10."
    },
    {
        "id": "cbc8c9742f9ae63285f58dd8ef3664a68b1c4c9ca8cbd40a5b1fec608cd59749",
        "question": "Find the weight of the youngest dog.",
        "query": "SELECT TOP 1 weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT weight, pet_age FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 weight, pet_age FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 weight FROM pets_1.pets  ORDER BY pet_age",
        "qd": "#1 = Scan the table Pets and retrieve the weight and age of all pets. ; #2 = Sort the records from #1 based on the age of the pet in ascending order, select the first record, and retrieve the weight of the youngest dog."
    },
    {
        "id": "126dcbf655e9d0632f315fe6f8ed028a2c9578c87310dbb69752079828e3552c",
        "question": "How much does the youngest dog weigh?",
        "query": "SELECT TOP 1 weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT weight, pet_age FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 weight, pet_age FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 weight FROM pets_1.pets  ORDER BY pet_age",
        "qd": "#1 = Scan the table Pets and retrieve the weight and age of all pets. ; #2 = Sort the records from #1 based on the age of the pets in ascending order, select the first record, and retrieve the weight of the youngest dog."
    },
    {
        "id": "c5a692afde2f7670bc43c3d670e2d9235236da86cfd5f2e53f5c8b520a96a5a3",
        "question": "Find the maximum weight for each type of pet. List the maximum weight and pet type.",
        "query": "SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets WITH (FORCESCAN) GROUP BY petType OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , weight ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ PetType , MAX(weight) AS Max_weight ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, weight FROM pets_1.Pets ), Aggregate_2 AS ( SELECT PetType, MAX(weight) AS Max_weight FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets  GROUP BY petType",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and weight of all pets ; #2 = Group #1 by pet type and aggregate the maximum weight per pet type to find the maximum weight for each type of pet. Retrieve the maximum weight and pet type."
    },
    {
        "id": "dbf216d50046bffe3525bbf214859163bbb25370ba59b212e66125d6db158dd4",
        "question": "List the maximum weight and type for each type of pet.",
        "query": "SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets WITH (FORCESCAN) GROUP BY petType OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , weight ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ PetType , MAX(weight) AS Max_weight ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, weight FROM pets_1.Pets ), Aggregate_2 AS ( SELECT PetType, MAX(weight) AS Max_weight FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets  GROUP BY petType",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and weight of all pets ; #2 = Group #1 by pet type and aggregate the maximum weight for each type to find the maximum weight and type for each type of pet."
    },
    {
        "id": "92e4d4fbc8091177b07c249b6d37d5ae85675b91bec3b9f0ad37339fbf223c48",
        "question": "Find number of pets owned by students who are older than 20.",
        "query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.age > 20 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Predicate [ Age > 20 ] Output [ StuID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #1.StuID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Age FROM pets_1.Student WHERE Age > 20 ), Join_3 AS ( SELECT Scan_1.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.age > 20",
        "qd": "#1 = Scan the table Has_Pet to find the StuIDs of all students who own pets ; #2 = Scan the table Student and retrieve the StuIDs and Ages of all students who are older than 20 ; #3 = Join #1 and #2 based on the matching StuID and retrieve the StuIDs ; #4 = Aggregate the number of records in #3 to find the number of pets owned by students who are older than 20"
    },
    {
        "id": "025e0f3fdad5dd9c427fe7336fda1a25861b44bd961230fd0d51ebfe02eae5d6",
        "question": "How many pets are owned by students that have an age greater than 20?",
        "query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.age > 20 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Predicate [ Age > 20 ] Output [ StuID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #1.StuID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Age FROM pets_1.Student WHERE Age > 20 ), Join_3 AS ( SELECT Scan_1.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.age > 20",
        "qd": "#1 = Scan the table Has_Pet and retrieve the student IDs of all students who have pets ; #2 = Scan the table Student and retrieve the student IDs and ages of all students with age greater than 20 ; #3 = Join #1 and #2 based on the matching student IDs and retrieve the student IDs ; #4 = Aggregate the count of all records in #3 to find the number of pets owned by students with an age greater than 20"
    },
    {
        "id": "80c3435a30611055d27a8c5e7b6cb75d19f7ffd652eb663fe6b6cb388ab74697",
        "question": "Find the number of dog pets that are raised by female students (with sex F).",
        "query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Predicate [ Sex = 'F' ] Output [ StuID , Sex ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #3.StuID ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Sex FROM pets_1.Student WHERE Sex = 'F' ), Join_5 AS ( SELECT Join_3.StuID FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and IDs of all dog pets. ; #2 = Scan the table Has_Pet and retrieve the student IDs and pet IDs of all students who have pets. ; #3 = Join #1 and #2 based on the matching pet ID and retrieve the student IDs. ; #4 = Scan the table Student and retrieve the student IDs and sex of all female students. ; #5 = Join #3 and #4 based on the matching student ID and retrieve the student IDs. ; #6 = Aggregate the number of records from #5 to find the count of dog pets raised by female students."
    },
    {
        "id": "d0add8ef7ebdb8bb0c8c3c4c33b8775c08dde1c736f9ad1398a7cbddcafa4776",
        "question": "How many dog pets are raised by female students?",
        "query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Predicate [ Sex = 'F' ] Output [ StuID , Sex ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #3.StuID ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Sex FROM pets_1.Student WHERE Sex = 'F' ), Join_5 AS ( SELECT Join_3.StuID FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and ID of all dog pets ; #2 = Scan the table Has_Pet and retrieve the student ID and pet ID of all students with pets ; #3 = Join #1 and #2 based on the matching pet ID and retrieve the student IDs ; #4 = Scan the table Student and retrieve the student ID and sex of all female students ; #5 = Join #3 and #4 based on the matching student ID and retrieve the student IDs ; #6 = Aggregate the count of all student IDs from #5 to find the number of dog pets raised by female students."
    },
    {
        "id": "2a006605914d62ef4da26c68c384d0d57d1cb62ea9722f1a6f3676efc0c57456",
        "question": "Find the number of distinct type of pets.",
        "query": "SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Distinct [ true ] Output [ PetType ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT PetType) AS Count_Dist_PetType ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT COUNT(DISTINCT PetType) AS Count_Dist_PetType FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets",
        "qd": "#1 = Scan the table Pets and retrieve all the distinct types of pets ; #2 = Aggregate the count of distinct pet types to find the number of distinct types of pets."
    },
    {
        "id": "964ffeff8f8a7b60a06ed97e9100a6c16331a8a237ac29efec1b336be3eeca13",
        "question": "How many different types of pet are there?",
        "query": "SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Distinct [ true ] Output [ PetType ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT PetType) AS Count_Dist_PetType ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT COUNT(DISTINCT PetType) AS Count_Dist_PetType FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets",
        "qd": "#1 = Scan the table Pets and retrieve all the different types of pets ; #2 = Aggregate the number of distinct pet types to find how many different types of pets are there"
    },
    {
        "id": "f188a37bade4eaee7d3ab43541a2979675922644d5338853df3bf004604a9d03",
        "question": "Find the first name of students who have cat or dog pet.",
        "query": "SELECT DISTINCT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' OR PetType = 'dog' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' OR PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog'",
        "qd": "#1 = Scan the table Pets to find all the pets with cat or dog type ; #2 = Scan the table Has_Pet and retrieve all the student IDs and pet IDs ; #3 = Join #1 and #2 based on the matching pet ID and retrieve the student IDs ; #4 = Scan the table Student and retrieve the student IDs and first names of all students ; #5 = Join #3 and #4 based on the matching student ID and retrieve the first names of students who have a cat or dog pet"
    },
    {
        "id": "8257705ad9837960caf1153fa275f73bdb5e7c98cbbd9bd8f4d35ef3843d7e21",
        "question": "What are the first names of every student who has a cat or dog as a pet?",
        "query": "SELECT DISTINCT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' OR PetType = 'dog' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' OR PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and pet ID of all pets that are either cats or dogs ; #2 = Scan the table Has_Pet and retrieve all student IDs and pet IDs ; #3 = Join #1 and #2 based on the matching pet IDs and retrieve the student IDs ; #4 = Scan the table Student and retrieve the student IDs and first names of all students ; #5 = Join #3 and #4 based on the matching student IDs and retrieve the first names of the students who have a cat or dog as a pet"
    },
    {
        "id": "1e89d560ac01a52205cd8edb1ad7d22d0084f87bb2d16c76405f82f6eed14cf0",
        "question": "Find the first name of students who have both cat and dog pets .",
        "query": "select t1.fname FROM pets_1.student AS t1 WITH (FORCESCAN) join pets_1.has_pet as t2 WITH (FORCESCAN) on t1.stuid = t2.stuid join pets_1.pets as t3 WITH (FORCESCAN) on t3.petid = t2.petid where t3.pettype = 'cat' intersect select t1.fname FROM pets_1.student AS t1 WITH (FORCESCAN) join pets_1.has_pet as t2 WITH (FORCESCAN) on t1.stuid = t2.stuid join pets_1.pets as t3 WITH (FORCESCAN) on t3.petid = t2.petid where t3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ] ; #6 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetType , PetID ] ; #7 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.PetID = #7.PetID ] Output [ #7.StuID ] ; #9 = Scan Table [ Student ] Output [ StuID , Fname ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.StuID = #9.StuID ] Output [ #9.Fname ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Fname = #10.Fname ] Output [ #5.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_7 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_8 AS ( SELECT Scan_7.StuID FROM Scan_6 JOIN Scan_7 ON Scan_6.PetID = Scan_7.PetID ), Scan_9 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_10 AS ( SELECT Scan_9.Fname FROM Join_8 JOIN Scan_9 ON Join_8.StuID = Scan_9.StuID ), Intersect_11 AS ( SELECT Join_5.Fname FROM Join_5 WHERE Fname IN (SELECT Fname FROM Join_10) ) SELECT * FROM Intersect_11",
        "clean_query": "select t1.fname FROM pets_1.student AS t1  join pets_1.has_pet as t2  on t1.stuid = t2.stuid join pets_1.pets as t3  on t3.petid = t2.petid where t3.pettype = 'cat' intersect select t1.fname FROM pets_1.student AS t1  join pets_1.has_pet as t2  on t1.stuid = t2.stuid join pets_1.pets as t3  on t3.petid = t2.petid where t3.pettype = 'dog'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and pet ID of all the cats ; #2 = Scan the table Has_Pet and retrieve the student ID and pet ID of all the students who have pets ; #3 = Join #1 and #2 based on the matching pet ID and retrieve the student IDs ; #4 = Scan the table Student and retrieve the student ID and first name of all the students ; #5 = Join #3 and #4 based on the matching student ID and retrieve the first names ; #6 = Scan the table Pets and retrieve the pet type and pet ID of all the dogs ; #7 = Scan the table Has_Pet and retrieve the student ID and pet ID of all the students who have pets ; #8 = Join #6 and #7 based on the matching pet ID and retrieve the student IDs ; #9 = Scan the table Student and retrieve the student ID and first name of all the students ; #10 = Join #8 and #9 based on the matching student ID and retrieve the first names ; #11 = Intersect #5 and #10 based on the matching first names and retrieve the first names"
    },
    {
        "id": "18410d6eea9eaaa4ded15500a3cfd28e14e048a9c0b11d9c6c27f1ebd20ba32c",
        "question": "What are the students' first names who have both cats and dogs as pets?",
        "query": "SELECT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' INTERSECT SELECT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ] ; #6 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetType , PetID ] ; #7 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.PetID = #7.PetID ] Output [ #7.StuID ] ; #9 = Scan Table [ Student ] Output [ StuID , Fname ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.StuID = #9.StuID ] Output [ #9.Fname ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Fname = #10.Fname ] Output [ #5.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_7 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_8 AS ( SELECT Scan_7.StuID FROM Scan_6 JOIN Scan_7 ON Scan_6.PetID = Scan_7.PetID ), Scan_9 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_10 AS ( SELECT Scan_9.Fname FROM Join_8 JOIN Scan_9 ON Join_8.StuID = Scan_9.StuID ), Intersect_11 AS ( SELECT Join_5.Fname FROM Join_5 WHERE Fname IN (SELECT Fname FROM Join_10) ) SELECT * FROM Intersect_11",
        "clean_query": "SELECT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' INTERSECT SELECT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'dog'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and IDs of all the cats. ; #2 = Scan the table Has_Pet and retrieve the student IDs and pet IDs. ; #3 = Join #1 and #2 based on the matching pet IDs and retrieve the student IDs. ; #4 = Scan the table Student and retrieve the student IDs and first names of all the students. ; #5 = Join #3 and #4 based on the matching student IDs and retrieve the first names without duplicates. ; #6 = Scan the table Pets and retrieve the pet type and IDs of all the dogs. ; #7 = Scan the table Has_Pet and retrieve the student IDs and pet IDs. ; #8 = Join #6 and #7 based on the matching pet IDs and retrieve the student IDs. ; #9 = Scan the table Student and retrieve the student IDs and first names of all the students. ; #10 = Join #8 and #9 based on the matching student IDs and retrieve the first names without duplicates. ; #11 = Intersect #5 and #10 based on the matching first names and retrieve the first names of students who have both cats and dogs as pets."
    },
    {
        "id": "b231dc84cc5a3164c7790160a3d477c445f337f31d5eb74b92fa01a38341a47c",
        "question": "Find the major and age of students who do not have a cat pet.",
        "query": "SELECT major , age FROM pets_1.student WITH (FORCESCAN) WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Major , Age ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.Major , #1.Age ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID, Major, Age FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.Major, Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT major , age FROM pets_1.student  WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )",
        "qd": "#1 = Scan the table Student to retrieve the student IDs, majors, and ages of all students ; #2 = Scan the table Student to retrieve all the student IDs ; #3 = Scan the table Pets and retrieve the pet types and IDs for all cats ; #4 = Scan the table Has_Pet and retrieve all the student IDs and pet IDs ; #5 = Join #3 and #4 based on the matching pet IDs and retrieve the student IDs ; #6 = Intersect #2 and #5 based on the matching student IDs and retrieve the student IDs ; #7 = Except #1 and #6 based on the non-matching student IDs and retrieve the majors and ages of the students who do not have a cat pet."
    },
    {
        "id": "8532df23cc7ba7610e55c027c11135e66dc3952524392a8ea9873a347c0e18b8",
        "question": "What major is every student who does not own a cat as a pet, and also how old are they?",
        "query": "SELECT major , age FROM pets_1.student WITH (FORCESCAN) WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Major , Age ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.Major , #1.Age ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID, Major, Age FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.Major, Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT major , age FROM pets_1.student  WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )",
        "qd": "#1 = Scan the table Student and retrieve the student ID, major, and age for all students ; #2 = Scan the table Student and retrieve all student IDs ; #3 = Scan the table Pets and retrieve the pet type and IDs for all cats ; #4 = Scan the table Has_Pet and retrieve all student IDs and pet IDs ; #5 = Join #3 and #4 based on the matching pet IDs and retrieve the student IDs ; #6 = Intersect #2 and #5 based on the matching student IDs and retrieve the common student IDs ; #7 = Return the major and age from #1 for all the students who do not own a cat as a pet"
    },
    {
        "id": "2ae88df2c4162c1fe98dc4ae1452e2b0dfd06263c9a682b94df0f969d32a241f",
        "question": "Find the id of students who do not have a cat pet.",
        "query": "SELECT stuid FROM pets_1.student WITH (FORCESCAN) EXCEPT SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.StuID ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.StuID FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT stuid FROM pets_1.student  EXCEPT SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat'",
        "qd": "#1 = Scan the table Student and retrieve the student IDs of all students ; #2 = Scan the table Student and retrieve the student IDs of all students ; #3 = Scan the table Pets and retrieve the pet types and IDs of all cat pets ; #4 = Scan the table Has_Pet and retrieve the student IDs and pet IDs of all student-pet relationships ; #5 = Join #3 and #4 based on the matching pet IDs and retrieve the student IDs ; #6 = Intersect #2 and #5 based on the matching student IDs and retrieve the student IDs ; #7 = Find the student IDs from #1 that are not in #6 to find the student IDs who do not have a cat pet"
    },
    {
        "id": "e24d36718f19f2c01300c0eb31b9ef1c7049290a48400f756e3898c3de1ba7cd",
        "question": "What are the ids of the students who do not own cats as pets?",
        "query": "SELECT stuid FROM pets_1.student WITH (FORCESCAN) EXCEPT SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.StuID ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.StuID FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT stuid FROM pets_1.student  EXCEPT SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat'",
        "qd": "#1 = Scan the table Student and retrieve the student IDs of all students ; #2 = Scan the table Student and retrieve the student IDs of all students ; #3 = Scan the table Pets and retrieve the pet types and IDs of all cats ; #4 = Scan the table Has_Pet and retrieve the student IDs and pet IDs of all students who own pets ; #5 = Join #3 and #4 based on the matching pet IDs and retrieve the student IDs ; #6 = Intersect #2 and #5 based on the matching student IDs and retrieve the student IDs who own cats as pets ; #7 = Return the student IDs from #1 that are not in #6 to find the student IDs who do not own cats as pets"
    },
    {
        "id": "5c3b7fe9487dc73740aedb8cf7af43aa29068d1db0bd2ceb247e499df33f354c",
        "question": "Find the first name and age of students who have a dog but do not have a cat as a pet.",
        "query": "SELECT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.Fname , #4.StuID , #4.Age ] ; #6 = Scan Table [ Student ] Output [ StuID ] ; #7 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #8 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.PetID = #8.PetID ] Output [ #8.StuID ] ; #10 = Intersect [ #6 , #9 ] Predicate [ #9.StuID = #6.StuID ] Output [ #6.StuID ] ; #11 = Except [ #5 , #10 ] Predicate [ #5.StuID = #10.StuID ] Output [ #5.Age , #5.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.Fname, Scan_4.StuID, Scan_4.Age FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT StuID FROM pets_1.Student ), Scan_7 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_8 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_9 AS ( SELECT Scan_8.StuID FROM Scan_7 JOIN Scan_8 ON Scan_7.PetID = Scan_8.PetID ), Intersect_10 AS ( SELECT Scan_6.StuID FROM Scan_6 WHERE StuID IN (SELECT StuID FROM Join_9) ), Except_11 AS ( SELECT Join_5.Age, Join_5.Fname FROM Join_5 WHERE StuID NOT IN (SELECT StuID FROM Intersect_10) ) SELECT * FROM Except_11",
        "clean_query": "SELECT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and IDs of all the dogs ; #2 = Scan the table Has_Pet and retrieve all the student IDs and pet IDs ; #3 = Join #1 and #2 based on the matching pet IDs and retrieve the student IDs ; #4 = Scan the table Student and retrieve the student IDs, first names, and ages of all students ; #5 = Join #3 and #4 based on the matching student IDs and retrieve the first names and ages ; #6 = Scan the table Student and retrieve all the student IDs ; #7 = Scan the table Pets and retrieve the pet type and IDs of all the cats ; #8 = Scan the table Has_Pet and retrieve all the student IDs and pet IDs ; #9 = Join #7 and #8 based on the matching pet IDs and retrieve the student IDs ; #10 = Intersect #6 and #9 based on the matching student IDs and retrieve the common student IDs ; #11 = Return the ages and first names from #5 for the students whose IDs are not in #10, i.e., students who have a dog but do not have a cat as a pet"
    },
    {
        "id": "28003ee356dcce5bec7b0a6b0ac8b51f30bc4cfa2b0b8310e8dd3fb0007706b7",
        "question": "What is the first name of every student who has a dog but does not have a cat?",
        "query": "SELECT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetType , PetID ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.Fname , #4.StuID , #4.Age ] ; #6 = Scan Table [ Student ] Output [ StuID ] ; #7 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetType , PetID ] ; #8 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.PetID = #8.PetID ] Output [ #8.StuID ] ; #10 = Intersect [ #6 , #9 ] Predicate [ #9.StuID = #6.StuID ] Output [ #6.StuID ] ; #11 = Except [ #5 , #10 ] Predicate [ #5.StuID = #10.StuID ] Output [ #5.Age , #5.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.Fname, Scan_4.StuID, Scan_4.Age FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT StuID FROM pets_1.Student ), Scan_7 AS ( SELECT PetType, PetID FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_8 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_9 AS ( SELECT Scan_8.StuID FROM Scan_7 JOIN Scan_8 ON Scan_7.PetID = Scan_8.PetID ), Intersect_10 AS ( SELECT Scan_6.StuID FROM Scan_6 WHERE StuID IN (SELECT StuID FROM Join_9) ), Except_11 AS ( SELECT Join_5.Age, Join_5.Fname FROM Join_5 WHERE StuID NOT IN (SELECT StuID FROM Intersect_10) ) SELECT * FROM Except_11",
        "clean_query": "SELECT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )",
        "qd": "#1 = Scan the table Pets and retrieve the PetType and PetID of all dogs ; #2 = Scan the table Has_Pet and retrieve the StuID and PetID of all students with pets ; #3 = Join #1 and #2 based on the matching PetIDs and retrieve the StuIDs of students with dogs ; #4 = Scan the table Student and retrieve the StuID, Fname, and Age of all students ; #5 = Join #3 and #4 based on the matching StuIDs and retrieve the first names and StuIDs of students with dogs ; #6 = Scan the table Student and retrieve the StuIDs of all students ; #7 = Scan the table Pets and retrieve the PetType and PetID of all cats ; #8 = Scan the table Has_Pet and retrieve the StuID and PetID of all students with pets ; #9 = Join #7 and #8 based on the matching PetIDs and retrieve the StuIDs of students with cats ; #10 = Intersect #6 and #9 to retrieve the StuIDs of students with cats ; #11 = Find the difference between #5 and #10 to retrieve the StuIDs of students with dogs but not cats, and retrieve their ages and first names"
    },
    {
        "id": "fe924a806ef085407a4c416512b5a8145323d4427e751f280efeb70d1bc2c1cf",
        "question": "Find the type and weight of the youngest pet.",
        "query": "SELECT TOP 1 pettype , weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ PetType , weight , pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, weight, pet_age FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 PetType, weight, pet_age FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 pettype , weight FROM pets_1.pets  ORDER BY pet_age",
        "qd": "#1 = Scan the table Pets and retrieve the type and weight of all pets ; #2 = Sort the records from #1 based on the age of the pets in ascending order, select the first record, and identify the type and weight of the youngest pet"
    },
    {
        "id": "4aaffeb328aed243160907dfc6c6886143ddfb519b5bdddd61990f46ad20f2a1",
        "question": "What type of pet is the youngest animal, and how much does it weigh?",
        "query": "SELECT TOP 1 pettype , weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ PetType , weight , pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, weight, pet_age FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 PetType, weight, pet_age FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 pettype , weight FROM pets_1.pets  ORDER BY pet_age",
        "qd": "#1 = Scan the table Pets and retrieve the pet type, weight, and age of all pets ; #2 = Sort the records from #1 based on the age of the pets in ascending order, select the first record, and identify the type of pet which is the youngest animal and its weight."
    },
    {
        "id": "d8a40ee798a91a25e6fb481a445890439fc51d9a7674fac4b8bba65179b56c41",
        "question": "Find the id and weight of all pets whose age is older than 1.",
        "query": "SELECT petid , weight FROM pets_1.pets WITH (FORCESCAN) WHERE pet_age > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age > 1 ] Output [ weight , PetID , pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT weight, PetID, pet_age FROM pets_1.Pets WHERE pet_age > 1 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT petid , weight FROM pets_1.pets  WHERE pet_age > 1",
        "qd": "#1 = Scan the table Pets and retrieve the weight and id of all pets whose age is older than 1."
    },
    {
        "id": "d55de3ff73f29e284106d565743be9d15c6776d3c50766545ca8af24e2fff9e4",
        "question": "What is the id and weight of every pet who is older than 1?",
        "query": "SELECT petid , weight FROM pets_1.pets WITH (FORCESCAN) WHERE pet_age > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age > 1 ] Output [ weight , PetID , pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT weight, PetID, pet_age FROM pets_1.Pets WHERE pet_age > 1 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT petid , weight FROM pets_1.pets  WHERE pet_age > 1",
        "qd": "#1 = Scan the table Pets and retrieve the weight and ID of every pet that is older than 1 year."
    },
    {
        "id": "14675f95b778f27a99a45c1da9ba1a4976478bf0be82d56d97978b9952346a78",
        "question": "Find the average and maximum age for each type of pet.",
        "query": "SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , pet_age ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ PetType , AVG(pet_age) AS Avg_pet_age , MAX(pet_age) AS Max_pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, pet_age FROM pets_1.Pets ), Aggregate_2 AS ( SELECT PetType, AVG(pet_age) AS Avg_pet_age, MAX(pet_age) AS Max_pet_age FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets  GROUP BY pettype",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and age of all pets. ; #2 = Group #1 by pet type and aggregate the average and maximum age per pet type to find the average and maximum age for each type of pet."
    },
    {
        "id": "e627d88639a10d9d3ab45b0ed4ded75eb7a6be53aa1884abb1b57143a09899af",
        "question": "What is the average and maximum age for each pet type?",
        "query": "SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , pet_age ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ PetType , AVG(pet_age) AS Avg_pet_age , MAX(pet_age) AS Max_pet_age ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, pet_age FROM pets_1.Pets ), Aggregate_2 AS ( SELECT PetType, AVG(pet_age) AS Avg_pet_age, MAX(pet_age) AS Max_pet_age FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets  GROUP BY pettype",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and pet age for all pets ; #2 = Group #1 by pet type and calculate the average and maximum age for each pet type"
    },
    {
        "id": "1358270cfa743c906e3f59a8ee2e396a495b714ff53cab341c222aa87d9924c2",
        "question": "Find the average weight for each pet type.",
        "query": "SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , weight ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ PetType , AVG(weight) AS Avg_weight ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, weight FROM pets_1.Pets ), Aggregate_2 AS ( SELECT PetType, AVG(weight) AS Avg_weight FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets  GROUP BY pettype",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and weight of each pet. ; #2 = Group #1 by pet type and aggregate the average weight for each pet type."
    },
    {
        "id": "5481005a8259bb52b06468461cad920f76cbbd9d0c5d8f0b587715fe6a11b912",
        "question": "What is the average weight for each type of pet?",
        "query": "SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Output [ PetType , weight ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ PetType , AVG(weight) AS Avg_weight ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, weight FROM pets_1.Pets ), Aggregate_2 AS ( SELECT PetType, AVG(weight) AS Avg_weight FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets  GROUP BY pettype",
        "qd": "#1 = Scan the table Pets and retrieve the pet type and weight of all pets ; #2 = Group #1 by pet type and aggregate the average weight for each type of pet"
    },
    {
        "id": "f169ba7a72e220db320e37e251c8cb9711d7acc0bee315013137bf2271abee10",
        "question": "Find the first name and age of students who have a pet.",
        "query": "SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Distinct [ true ] Output [ #2.Age , #2.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_3 AS ( SELECT DISTINCT Scan_2.Age, Scan_2.Fname FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid",
        "qd": "#1 = Scan the table Has_Pet to retrieve the student IDs of all students who have a pet ; #2 = Scan the table Student and retrieve the student IDs, first names, and ages of all students ; #3 = Join #1 and #2 based on the matching student IDs and retrieve the ages and first names of the students who have a pet."
    },
    {
        "id": "0e930a583ef614f6f0b41fb786e062d289fc26ba0edd412723f27bf935248a70",
        "question": "What are the different first names and ages of the students who do have pets?",
        "query": "SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Distinct [ true ] Output [ #2.Age , #2.Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_3 AS ( SELECT DISTINCT Scan_2.Age, Scan_2.Fname FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid",
        "qd": "#1 = Scan the table Has_Pet to retrieve the student IDs of all the students who have pets ; #2 = Scan the table Student and retrieve the student IDs, first names, and ages of all the students ; #3 = Join #1 and #2 based on the matching student IDs and retrieve the ages and first names distinctively of the students who have pets"
    },
    {
        "id": "27252c0db0413b8693acfca670aa3ed42cd52d470b30fac453a92b3cf2e9ce82",
        "question": "Find the id of the pet owned by student whose last name is \u2018Smith\u2019.",
        "query": "SELECT T2.petid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Predicate [ LName = 'Smith' ] Output [ StuID , LName ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #2.PetID ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID, LName FROM pets_1.Student WHERE LName = 'Smith' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.PetID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.petid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith'",
        "qd": "#1 = Scan the table Student to find the student with the last name 'Smith' ; #2 = Scan the table Has_Pet to find the pet IDs of all students ; #3 = Join #1 and #2 based on the matching student IDs and retrieve the pet ID owned by the student with the last name 'Smith'"
    },
    {
        "id": "21558cf97f26dbb4214a9eae6e5df3b4c1b408de7847a6c459d57a3021c58c3b",
        "question": "What is the id of the pet owned by the student whose last name is 'Smith'?",
        "query": "SELECT T2.petid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Predicate [ LName = 'Smith' ] Output [ StuID , LName ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #2.PetID ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID, LName FROM pets_1.Student WHERE LName = 'Smith' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.PetID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.petid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith'",
        "qd": "#1 = Scan the table Student to find the student with the last name 'Smith' and retrieve their ID ; #2 = Scan the table Has_Pet and retrieve all the student IDs and pet IDs ; #3 = Join #1 and #2 based on the matching student ID and retrieve the ID of the pet owned by the student with the last name 'Smith'"
    },
    {
        "id": "ec8b526c55f9a125041bfebfcd2a771dfccddcf370f22042f6b1147afdcaafe4",
        "question": "Find the number of pets for each student who has any pet and student id.",
        "query": "SELECT count ( * ) AS Count_Star , T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid GROUP BY T1.stuid OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ countstar AS Count_Star , StuID ] ; #3 = Scan Table [ Student ] Output [ StuID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.StuID , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, StuID FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.StuID, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ) SELECT * FROM Join_4",
        "clean_query": "SELECT count ( * ) AS Count_Star , T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid GROUP BY T1.stuid",
        "qd": "#1 = Scan the table Has_Pet and retrieve the student IDs of all students who have any pet ; #2 = Group #1 by student ID and aggregate the count of pets for each student ; #3 = Scan the table Student and retrieve all student IDs ; #4 = Join #2 and #3 based on the matching student ID and retrieve the student ID and the count of pets for each student"
    },
    {
        "id": "c3e439034b6fe1bfae33907fecac07de08ca1c6e4692dd9426bffe18b4777f26",
        "question": "For students who have pets , how many pets does each student have ? list their ids instead of names .",
        "query": "select count ( * ) AS Count_Star , t1.stuid FROM pets_1.student AS t1 WITH (FORCESCAN) join pets_1.has_pet as t2 WITH (FORCESCAN) on t1.stuid = t2.stuid group by t1.stuid OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ countstar AS Count_Star , StuID ] ; #3 = Scan Table [ Student ] Output [ StuID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.StuID , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, StuID FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.StuID, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ) SELECT * FROM Join_4",
        "clean_query": "select count ( * ) AS Count_Star , t1.stuid FROM pets_1.student AS t1  join pets_1.has_pet as t2  on t1.stuid = t2.stuid group by t1.stuid",
        "qd": "#1 = Scan the table Has_Pet and retrieve the student IDs ; #2 = Group #1 by student ID and aggregate the count of rows to find the number of pets each student has ; #3 = Scan the table Student and retrieve the student IDs ; #4 = Join #2 and #3 based on the matching student ID and retrieve the student ID and the count of pets for each student"
    },
    {
        "id": "a7461adf7f778f867afb8fde575dd4680f7c8c40ac917ef8e354e11a8e01b73b",
        "question": "Find the first name and gender of student who have more than one pet.",
        "query": "SELECT T1.fname , T1.sex FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ countstar AS Count_Star , StuID ] ; #3 = Scan Table [ Student ] Output [ StuID , Sex , Fname ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.Sex , #2.Count_Star , #3.Fname ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Sex , Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, StuID FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID, Sex, Fname FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.Sex, Aggregate_2.Count_Star, Scan_3.Fname FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ), Filter_5 AS ( SELECT Sex, Fname FROM Join_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.fname , T1.sex FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table Has_Pet to retrieve the Student IDs of all students who have pets ; #2 = Group #1 by Student ID and aggregate the count of Student IDs to find the number of pets per student ; #3 = Scan the table Student to retrieve the Student IDs, genders, and first names of all students ; #4 = Join #2 and #3 based on the matching Student IDs and retrieve the genders, count of pets, and first names ; #5 = Filter from #4 all the students with a count of pets greater than 1 and retrieve the genders and first names"
    },
    {
        "id": "c07bf8a5269d2f7e7fb84ce9604b7842d48ec4c1986c122f1982a9ad675efea5",
        "question": "What is the first name and gender of the all the students who have more than one pet?",
        "query": "SELECT T1.fname , T1.sex FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ countstar AS Count_Star , StuID ] ; #3 = Scan Table [ Student ] Output [ StuID , Sex , Fname ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.Sex , #2.Count_Star , #3.Fname ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Sex , Fname ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, StuID FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID, Sex, Fname FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.Sex, Aggregate_2.Count_Star, Scan_3.Fname FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ), Filter_5 AS ( SELECT Sex, Fname FROM Join_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.fname , T1.sex FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table Has_Pet to retrieve the student IDs of all students who have pets ; #2 = Group #1 by student ID and aggregate the count of pets per student ; #3 = Scan the table Student to retrieve the student IDs, gender, and first names of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the gender, count of pets, and first names ; #5 = Filter from #4 the records where the count of pets is greater than 1 and retrieve the genders and first names"
    },
    {
        "id": "6fe75339376762c506c994080ce1289b6391db7a92fe1aad3b3a7528e9c66869",
        "question": "Find the last name of the student who has a cat that is age 3.",
        "query": "SELECT T1.lname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age = 3 AND PetType = 'cat' ] Output [ PetType , PetID , pet_age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , LName ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.LName ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID, pet_age FROM pets_1.Pets WHERE pet_age = 3 AND PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, LName FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.LName FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T1.lname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type, pet ID, and age of all cats that are age 3 ; #2 = Scan the table Has_Pet and retrieve the student IDs and pet IDs of all students who have pets ; #3 = Join #1 and #2 based on the matching pet ID and retrieve the student IDs ; #4 = Scan the table Student and retrieve the student IDs and last names of all students ; #5 = Join #3 and #4 based on the matching student ID and retrieve the last name of the student who has a cat that is age 3"
    },
    {
        "id": "546ff06611de4b3ac4065c402b00c84c621762013d5a957cafdab6b13860ac83",
        "question": "What is the last name of the student who has a cat that is 3 years old?",
        "query": "SELECT T1.lname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age = 3 AND PetType = 'cat' ] Output [ PetType , PetID , pet_age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , LName ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.LName ]",
        "cte": "WITH Scan_1 AS ( SELECT PetType, PetID, pet_age FROM pets_1.Pets WHERE pet_age = 3 AND PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, LName FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.LName FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T1.lname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat'",
        "qd": "#1 = Scan the table Pets and retrieve the pet type, pet ID, and age of all pets that are cats and 3 years old ; #2 = Scan the table Has_Pet and retrieve the student ID and pet ID of all students who have pets ; #3 = Join #1 and #2 based on the matching pet ID and retrieve the student ID ; #4 = Scan the table Student and retrieve the student ID and last name of all students ; #5 = Join #3 and #4 based on the matching student ID and retrieve the last name of the student who has a cat that is 3 years old"
    },
    {
        "id": "dbfcc50884c2d7e4346c3172892aa8910971ebcd3c46dba825586dd3347b9a24",
        "question": "Find the average age of students who do not have any pet .",
        "query": "select avg ( age ) AS Avg_age FROM pets_1.student WITH (FORCESCAN) where stuid not in ( select stuid FROM pets_1.has_pet WITH (FORCESCAN) ) ",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.StuID IS NULL OR #1.StuID = #2.StuID ] Output [ #1.Age ] ; #4 = Aggregate [ #3 ] Output [ AVG(Age) AS Avg_Age ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID, Age FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Has_Pet ), Except_3 AS ( SELECT Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(Age) AS Avg_Age FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "select avg ( age ) AS Avg_age FROM pets_1.student  where stuid not in ( select stuid FROM pets_1.has_pet  )",
        "qd": "#1 = Scan the table Student to find the student IDs and ages of all students ; #2 = Scan the table Has_Pet to find the student IDs of all students who have pets ; #3 = Return the ages of all students from #1 that do not have pets by excluding the student IDs from #2, and retrieve the average age ; #4 = Calculate the average age by aggregating the ages from #3 and retrieve the average age of students who do not have any pet."
    },
    {
        "id": "ba1ee9f549168c44bb796a2bbdc8075e64e6df7ca595e5b4dd6c3ab0e7dc817c",
        "question": "What is the average age for all students who do not own any pets ?",
        "query": "select avg ( age ) AS Avg_age FROM pets_1.student WITH (FORCESCAN) where stuid not in ( select stuid FROM pets_1.has_pet WITH (FORCESCAN) ) ",
        "qpl": "pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.StuID IS NULL OR #1.StuID = #2.StuID ] Output [ #1.Age ] ; #4 = Aggregate [ #3 ] Output [ AVG(Age) AS Avg_Age ]",
        "cte": "WITH Scan_1 AS ( SELECT StuID, Age FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Has_Pet ), Except_3 AS ( SELECT Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(Age) AS Avg_Age FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "select avg ( age ) AS Avg_age FROM pets_1.student  where stuid not in ( select stuid FROM pets_1.has_pet  )",
        "qd": "#1 = Scan the table Student and retrieve the student IDs and ages of all students ; #2 = Scan the table Has_Pet and retrieve the student IDs of all students who own pets ; #3 = Get the students who do not own any pets by excluding the student IDs from #2 and retrieve their ages ; #4 = Calculate the average age of the students from #3 and return the result as the average age for all students who do not own any pets"
    },
    {
        "id": "473d7b41fadce5025b641f1cbfabfb4e0142a9cf4a859267322201b8fc5f9040",
        "question": "How many continents are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ continents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.continents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS",
        "qd": "#1 = Scan the table continents and retrieve the value 1 for each record ; #2 = Aggregate the number of records of #1 and retrieve the count of continents"
    },
    {
        "id": "0d5508ac8b087357c9f03f1531347cce564d823440b751d59a250ecf04a7a379",
        "question": "What is the number of continents?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ continents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.continents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS",
        "qd": "#1 = Scan the table continents and retrieve a constant value of 1 for each continent ; #2 = Aggregate the number of records from #1 to find the total count of continents"
    },
    {
        "id": "2914754a1a51a5b100d4ff75aff0952ddcad058096534f9be42de91ed54669db",
        "question": "How many countries does each continent have? List the continent id, continent name and the number of countries.",
        "query": "SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Output [ Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ countstar AS Count_Star , Continent ] ; #3 = Scan Table [ continents ] Output [ ContId , Continent ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Continent = #3.ContId ] Output [ #3.Continent , #2.Count_Star , #3.ContId ]",
        "cte": "WITH Scan_1 AS ( SELECT Continent FROM car_1.countries ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Continent FROM Scan_1 GROUP BY Continent ), Scan_3 AS ( SELECT ContId, Continent FROM car_1.continents ), Join_4 AS ( SELECT Scan_3.Continent, Aggregate_2.Count_Star, Scan_3.ContId FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Continent = Scan_3.ContId ) SELECT * FROM Join_4",
        "clean_query": "SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent",
        "qd": "#1 = Scan the table countries and retrieve the continent of each country ; #2 = Group #1 by continent and aggregate the count of countries per continent ; #3 = Scan the table continents and retrieve the continent ID and name ; #4 = Join #2 and #3 based on the matching continent and continent ID and retrieve the continent ID, continent name, and the count of countries"
    },
    {
        "id": "be8751acd82b0091ce91e727267eb60c7b15c95c21bf3d8d9f7e241ed60fd7a3",
        "question": "For each continent, list its id, name, and how many countries it has?",
        "query": "SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Output [ Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ countstar AS Count_Star , Continent ] ; #3 = Scan Table [ continents ] Output [ ContId , Continent ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Continent = #3.ContId ] Output [ #3.Continent , #2.Count_Star , #3.ContId ]",
        "cte": "WITH Scan_1 AS ( SELECT Continent FROM car_1.countries ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Continent FROM Scan_1 GROUP BY Continent ), Scan_3 AS ( SELECT ContId, Continent FROM car_1.continents ), Join_4 AS ( SELECT Scan_3.Continent, Aggregate_2.Count_Star, Scan_3.ContId FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Continent = Scan_3.ContId ) SELECT * FROM Join_4",
        "clean_query": "SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent",
        "qd": "#1 = Scan the table countries and retrieve the continents of all countries ; #2 = Group #1 by continent and aggregate the count of countries per continent ; #3 = Scan the table continents and retrieve the continent IDs and names ; #4 = Join #2 and #3 based on the matching continent ID and retrieve the continent name, count of countries, and continent ID for each continent"
    },
    {
        "id": "6c99977d3e70f4f90d745fa4f3116ae0f4423f66a5b9d7157fcf3fd8f13451ce",
        "question": "How many countries are listed?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.countries ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES",
        "qd": "#1 = Scan the table countries and retrieve a constant value of 1 for each country ; #2 = Aggregate the number of records of #1 to find the total count of countries listed"
    },
    {
        "id": "b8e08896d0063efdc88fa6a6bffae66141b6086c3f792920f68aeffd8998b42f",
        "question": "How many countries exist?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.countries ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES",
        "qd": "#1 = Scan the table countries and retrieve a constant value of 1 for each record. ; #2 = Aggregate the records from #1 to count the total number of countries that exist."
    },
    {
        "id": "9185b99e6274a74f1074d9390674f68dc176f3bd9f95bc67ad3b09b878fccc3a",
        "question": "How many models does each car maker produce? List maker full name, id and the number.",
        "query": "SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.FullName , #3.Id , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT FullName, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.FullName, Scan_3.Id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
        "clean_query": "SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id",
        "qd": "#1 = Scan the table model_list to retrieve the makers of each model ; #2 = Group the records from #1 by the maker and count the number of models produced by each maker ; #3 = Scan the table car_makers and retrieve the full name and id of each car maker ; #4 = Join #2 and #3 based on the matching maker and id and retrieve the full name, id, and the count of models produced by each car maker"
    },
    {
        "id": "1f4b6b8fe58168e372e3265b1dd9ea23b4530538ad134a2ffba2567cc80d9b8e",
        "question": "What is the full name of each car maker, along with its id and how many models it produces?",
        "query": "SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.FullName , #3.Id , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT FullName, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.FullName, Scan_3.Id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
        "clean_query": "SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id",
        "qd": "#1 = Scan the table model_list and retrieve the name of the car maker for each model ; #2 = Group #1 by car maker and count the number of models produced by each car maker ; #3 = Scan the table car_makers and retrieve the full name and id of each car maker ; #4 = Join #2 and #3 based on the car maker and retrieve the full name, id, and number of models produced for each car maker"
    },
    {
        "id": "ed11ccc0c371befb3ffe3ea94cf16a1727cea5fdbd0c2379b78d4891bcd8f1a9",
        "question": "Which model of the car has the minimum horsepower?",
        "query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Horsepower , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #2.Model , #1.Horsepower ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower ASC ] Output [ Horsepower , Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Horsepower, Id FROM car_1.cars_data ), Scan_2 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_3 AS ( SELECT Scan_2.Model, Scan_1.Horsepower FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower ASC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC",
        "qd": "#1 = Scan the table cars_data and retrieve the horsepower and ID of all cars ; #2 = Scan the table car_names and retrieve the Make ID and model of all cars ; #3 = Join #1 and #2 based on the matching IDs and retrieve the model and horsepower ; #4 = Sort the records from #3 based on the horsepower in ascending order, select the first record, and identify the model of the car with the minimum horsepower"
    },
    {
        "id": "4403cae911a936dae540f929868bd1cf333130dd770d1fd8be82c3244f48249c",
        "question": "What is the model of the car with the smallest amount of horsepower?",
        "query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Horsepower , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #2.Model , #1.Horsepower ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower ASC ] Output [ Horsepower , Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Horsepower, Id FROM car_1.cars_data ), Scan_2 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_3 AS ( SELECT Scan_2.Model, Scan_1.Horsepower FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower ASC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC",
        "qd": "#1 = Scan the table cars_data to retrieve the horsepower and ID of all cars ; #2 = Scan the table car_names to retrieve the make ID and model of all cars ; #3 = Join #1 and #2 based on the matching IDs and retrieve the model and horsepower ; #4 = Sort the records from #3 based on the horsepower in ascending order, select the first record, and identify the model of the car with the smallest amount of horsepower"
    },
    {
        "id": "08dc2bd47d43756549ebaa3fc4b93ef053b8ccb78cf36090fb8b63aa8b29c96f",
        "question": "Find the model of the car whose weight is below the average weight.",
        "query": "SELECT T1.model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA WITH (FORCESCAN) ) ",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #2 = Scan Table [ cars_data ] Output [ Weight ] ; #3 = Aggregate [ #2 ] Output [ AVG(Weight) AS Avg_Weight ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Weight < #3.Avg_Weight ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.Model ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Model FROM car_1.car_names ), Scan_2 AS ( SELECT Weight FROM car_1.cars_data ), Aggregate_3 AS ( SELECT AVG(Weight) AS Avg_Weight FROM Scan_2 ), Scan_4 AS ( SELECT Weight, Id FROM car_1.cars_data ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Weight < Aggregate_3.Avg_Weight ), Join_6 AS ( SELECT Scan_1.Model FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
        "clean_query": "SELECT T1.model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA  )",
        "qd": "#1 = Scan the table car_names and retrieve the make ID and model of all cars ; #2 = Scan the table cars_data and retrieve the weight of all cars ; #3 = Calculate the average weight of all cars ; #4 = Scan the table cars_data and retrieve the weight and ID of all cars ; #5 = Join #3 and #4 based on the condition that the weight of the car is below the average weight and retrieve the IDs ; #6 = Join #1 and #5 based on the matching ID and retrieve the models of the cars whose weight is below the average weight"
    },
    {
        "id": "bd50cd3346fb9f7ff49fe956873de002222ca6019f59ecc9c76a1e5b989eb493",
        "question": "What is the model for the car with a weight smaller than the average?",
        "query": "SELECT T1.model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA WITH (FORCESCAN) ) ",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #2 = Scan Table [ cars_data ] Output [ Weight ] ; #3 = Aggregate [ #2 ] Output [ AVG(Weight) AS Avg_Weight ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Weight < #3.Avg_Weight ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.Model ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Model FROM car_1.car_names ), Scan_2 AS ( SELECT Weight FROM car_1.cars_data ), Aggregate_3 AS ( SELECT AVG(Weight) AS Avg_Weight FROM Scan_2 ), Scan_4 AS ( SELECT Weight, Id FROM car_1.cars_data ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Weight < Aggregate_3.Avg_Weight ), Join_6 AS ( SELECT Scan_1.Model FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
        "clean_query": "SELECT T1.model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA  )",
        "qd": "#1 = Scan the table car_names and retrieve the make IDs and models of all cars ; #2 = Scan the table cars_data and retrieve the weights of all cars ; #3 = Aggregate the average weight from #2 ; #4 = Scan the table cars_data and retrieve the weights and IDs of all cars ; #5 = Join #3 and #4 based on cars with weights smaller than the average weight and retrieve the IDs ; #6 = Join #1 and #6 based on the matching make IDs and retrieve the models for the cars with weights smaller than the average weight"
    },
    {
        "id": "f13a210a276fb5976c3336f04458fd9194497a3627777813ef7e4bed4ddb8d7c",
        "question": "Find the name of the makers that produced some cars in the year of 1970?",
        "query": "SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3 WITH (FORCESCAN) ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T3.MakeId = T4.id WHERE T4.year = '1970'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #2 = Scan Table [ cars_data ] Predicate [ Year = 1970 ] Output [ Year , Id ] ; #3 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Scan Table [ model_list ] Output [ Model , Maker ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.Maker ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.Maker ] Distinct [ true ] Output [ #1.Maker ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker, Id FROM car_1.car_makers ), Scan_2 AS ( SELECT Year, Id FROM car_1.cars_data WHERE Year = 1970 ), Scan_3 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Scan_5 AS ( SELECT Model, Maker FROM car_1.model_list ), Join_6 AS ( SELECT Scan_5.Maker FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Scan_1.Maker FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.Maker ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3  ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4  ON T3.MakeId = T4.id WHERE T4.year = '1970'",
        "qd": "#1 = Scan the table car_makers to find the makers and their corresponding IDs ; #2 = Scan the table cars_data to find the cars with the year 1970 and retrieve their IDs ; #3 = Scan the table car_names to find the make IDs and corresponding models ; #4 = Join #2 and #3 based on the matching IDs and retrieve the models ; #5 = Scan the table model_list to find the models and their corresponding makers ; #6 = Join #4 and #5 based on the matching models and retrieve the makers ; #7 = Join #1 and #6 based on the matching IDs to find the makers that produced cars in the year 1970"
    },
    {
        "id": "d435cfadf939ca48c701dd06598c00e6e2ef5bc5c0d70ad308404adeb96b8b4e",
        "question": "What is the name of the different car makers who produced a car in 1970?",
        "query": "SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3 WITH (FORCESCAN) ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T3.MakeId = T4.id WHERE T4.year = '1970'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #2 = Scan Table [ cars_data ] Predicate [ Year = 1970 ] Output [ Year , Id ] ; #3 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Scan Table [ model_list ] Output [ Model , Maker ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.Maker ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.Maker ] Distinct [ true ] Output [ #1.Maker ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker, Id FROM car_1.car_makers ), Scan_2 AS ( SELECT Year, Id FROM car_1.cars_data WHERE Year = 1970 ), Scan_3 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Scan_5 AS ( SELECT Model, Maker FROM car_1.model_list ), Join_6 AS ( SELECT Scan_5.Maker FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Scan_1.Maker FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.Maker ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3  ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4  ON T3.MakeId = T4.id WHERE T4.year = '1970'",
        "qd": "#1 = Scan the table car_makers and retrieve the car maker names and ids ; #2 = Scan the table cars_data and retrieve the car ids produced in 1970 ; #3 = Scan the table car_names and retrieve the make ids and models ; #4 = Join #2 and #3 based on the matching car ids and retrieve the models ; #5 = Scan the table model_list and retrieve the models and car maker names ; #6 = Join #4 and #5 based on the matching models and retrieve the car maker names ; #7 = Join #1 and #6 based on the car maker ids and retrieve the distinct car maker names"
    },
    {
        "id": "ad21629f0a4e48341926c3e116c4f3ae3e68f41715b9f118146b1b81010b5be1",
        "question": "Find the make and production time of the cars that were produced in the earliest year?",
        "query": "SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) )  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Year) as Min_Year ] ; #3 = Scan Table [ cars_data ] Output [ Id , Year ] ; #4 = Join [ #2, #3 ] Predicate [ #3.Year = #2.Min_Year ] Output [ #3.Id , #3.Year ] ; #5 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.MakeId = #4.Id ] Output [ #4.Year , #5.Make ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MIN(Year) as Min_Year FROM Scan_1 ), Scan_3 AS ( SELECT Id, Year FROM car_1.cars_data ), Join_4 AS ( SELECT Scan_3.Id, Scan_3.Year FROM Aggregate_2 JOIN Scan_3 ON Scan_3.Year = Aggregate_2.Min_Year ), Scan_5 AS ( SELECT Make, MakeId FROM car_1.car_names ), Join_6 AS ( SELECT Join_4.Year, Scan_5.Make FROM Join_4 JOIN Scan_5 ON Scan_5.MakeId = Join_4.Id ) SELECT * FROM Join_6",
        "clean_query": "SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA  )",
        "qd": "#1 = Scan the cars_data table and retrieve the production years of all cars. ; #2 = Aggregate to find the minimum production year among all cars. ; #3 = Scan the cars_data table and retrieve the IDs and production years of all cars. ; #4 = Join #2 and #3 based on the matching production year and retrieve the IDs and production years of the cars produced in the earliest year. ; #5 = Scan the car_names table and retrieve the makes and make IDs of all cars. ; #6 = Join #4 and #5 based on the matching car IDs and retrieve the makes and production years of the cars produced in the earliest year."
    },
    {
        "id": "71b8e3eee7e7618b7730a3dc215c5d838411a0a424df17b4823a8f1ed6b56062",
        "question": "What is the maker of the carr produced in the earliest year and what year was it?",
        "query": "SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) )  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Year) as Min_Year ] ; #3 = Scan Table [ cars_data ] Output [ Id , Year ] ; #4 = Join [ #2, #3 ] Predicate [ #3.Year = #2.Min_Year ] Output [ #3.Id , #3.Year ] ; #5 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.MakeId = #4.Id ] Output [ #4.Year , #5.Make ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MIN(Year) as Min_Year FROM Scan_1 ), Scan_3 AS ( SELECT Id, Year FROM car_1.cars_data ), Join_4 AS ( SELECT Scan_3.Id, Scan_3.Year FROM Aggregate_2 JOIN Scan_3 ON Scan_3.Year = Aggregate_2.Min_Year ), Scan_5 AS ( SELECT Make, MakeId FROM car_1.car_names ), Join_6 AS ( SELECT Join_4.Year, Scan_5.Make FROM Join_4 JOIN Scan_5 ON Scan_5.MakeId = Join_4.Id ) SELECT * FROM Join_6",
        "clean_query": "SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA  )",
        "qd": "#1 = Scan the table cars_data and retrieve the year of production for all cars ; #2 = Aggregate the records from #1 and find the minimum year of production ; #3 = Scan the table cars_data and retrieve the car ID and year of production for all cars ; #4 = Join #2 and #3 based on the matching year of production and retrieve the car ID and year of the earliest produced car ; #5 = Scan the table car_names and retrieve the car make and its ID ; #6 = Join #4 and #5 based on the matching car ID and retrieve the year and make of the earliest produced car"
    },
    {
        "id": "63184492d88ed5c4c27ba64d205fbe596fe665ec2cc7351381b9572871047832",
        "question": "Which distinct car models are the produced after 1980?",
        "query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.id WHERE T3.year > 1980  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Model ] ; #2 = Scan Table [ cars_data ] Predicate [ Year > 1980 ] Output [ Year , Id ] ; #3 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Model = #4.Model ] Distinct [ true ] Output [ #1.Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Model FROM car_1.model_list ), Scan_2 AS ( SELECT Year, Id FROM car_1.cars_data WHERE Year > 1980 ), Scan_3 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Join_5 AS ( SELECT DISTINCT Scan_1.Model FROM Scan_1 JOIN Join_4 ON Scan_1.Model = Join_4.Model ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.id WHERE T3.year > 1980",
        "qd": "#1 = Scan the table model_list and retrieve all the distinct car models ; #2 = Scan the table cars_data and retrieve the years and IDs of all cars produced after 1980 ; #3 = Scan the table car_names and retrieve the make IDs and models of all cars ; #4 = Join #2 and #3 based on the matching IDs and retrieve the models ; #5 = Join #1 and #4 based on the matching models and retrieve all the distinct car models produced after 1980"
    },
    {
        "id": "3060597756a5391c591fd7056a8c19f57f2d440c443ea414541bc487cacf96a2",
        "question": "What are the different models for the cards produced after 1980?",
        "query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.id WHERE T3.year > 1980  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Model ] ; #2 = Scan Table [ cars_data ] Predicate [ Year > 1980 ] Output [ Year , Id ] ; #3 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Model = #4.Model ] Distinct [ true ] Output [ #1.Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Model FROM car_1.model_list ), Scan_2 AS ( SELECT Year, Id FROM car_1.cars_data WHERE Year > 1980 ), Scan_3 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Join_5 AS ( SELECT DISTINCT Scan_1.Model FROM Scan_1 JOIN Join_4 ON Scan_1.Model = Join_4.Model ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.id WHERE T3.year > 1980",
        "qd": "#1 = Scan the table model_list and retrieve all the different models ; #2 = Scan the table cars_data and retrieve the years and ids of all cars produced after 1980 ; #3 = Scan the table car_names and retrieve the make ids and models of all cars ; #4 = Join #2 and #3 based on the matching ids and retrieve the models ; #5 = Join #1 and #4 based on the matching models and retrieve the distinct models for the cars produced after 1980"
    },
    {
        "id": "1dd789dce8dca1a681e95be275697f6194aebfedc41b85f2d3c370144d719682",
        "question": "How many car makers are there in each continents? List the continent name and the count.",
        "query": "SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3 WITH (FORCESCAN) ON T2.CountryId = T3.Country GROUP BY T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ continents ] Output [ ContId , Continent ] ; #2 = Scan Table [ countries ] Output [ CountryId , Continent ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.Continent ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.ContId = #4.Continent ] Output [ #1.Continent ] ; #6 = Aggregate [ #5 ] GroupBy [ Continent ] Output [ countstar AS Count_Star , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT ContId, Continent FROM car_1.continents ), Scan_2 AS ( SELECT CountryId, Continent FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.Continent FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Join_5 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Join_4 ON Scan_1.ContId = Join_4.Continent ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star, Continent FROM Join_5 GROUP BY Continent ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3  ON T2.CountryId = T3.Country GROUP BY T1.Continent",
        "qd": "#1 = Scan the table continents and retrieve the continent IDs and names of all continents ; #2 = Scan the table countries and retrieve the country IDs and continents of all countries ; #3 = Scan the table car_makers and retrieve the countries of all car makers ; #4 = Join #2 and #3 based on the matching country and retrieve the continents of all car makers ; #5 = Join #1 and #4 based on the matching continent and retrieve the continent names ; #6 = Group #5 by continent and aggregate the count of records per continent to find the number of car makers in each continent. Retrieve the count of car makers and the continent name."
    },
    {
        "id": "5bb4eec216228c8f823b9444d1035d1d7f90937c23381a3a303840923469d256",
        "question": "What is the name of each continent and how many car makers are there in each one?",
        "query": "SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3 WITH (FORCESCAN) ON T2.CountryId = T3.Country GROUP BY T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ continents ] Output [ ContId , Continent ] ; #2 = Scan Table [ countries ] Output [ CountryId , Continent ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.Continent ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.ContId = #4.Continent ] Output [ #1.Continent ] ; #6 = Aggregate [ #5 ] GroupBy [ Continent ] Output [ countstar AS Count_Star , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT ContId, Continent FROM car_1.continents ), Scan_2 AS ( SELECT CountryId, Continent FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.Continent FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Join_5 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Join_4 ON Scan_1.ContId = Join_4.Continent ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star, Continent FROM Join_5 GROUP BY Continent ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3  ON T2.CountryId = T3.Country GROUP BY T1.Continent",
        "qd": "#1 = Scan the table continents and retrieve the continent IDs and names of all continents ; #2 = Scan the table countries and retrieve the country IDs and continents of all countries ; #3 = Scan the table car_makers and retrieve the countries of all car makers ; #4 = Join #2 and #3 based on the matching country and retrieve the continents ; #5 = Join #1 and #4 based on the matching continent ID and retrieve the continent names ; #6 = Group #5 by continent and aggregate the count of records per continent to find the number of car makers in each continent"
    },
    {
        "id": "eb3cde0276a0fc8b1f8d2f8fafb35798919522c42a6092dd8e015b09b31af5f9",
        "question": "Which of the countries has the most car makers? List the country name.",
        "query": "SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ CountryName , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), TopSort_5 AS ( SELECT TOP 1 CountryName, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC",
        "qd": "#1 = Scan the table car_makers and retrieve the countries of all car makers ; #2 = Group #1 by country and aggregate the count of car makers per country ; #3 = Scan the table countries and retrieve the country IDs and names of all countries ; #4 = Join #2 and #3 based on the matching country ID and retrieve the country names and the count of car makers ; #5 = Sort the records from #4 based on the count of car makers in descending order, select the first record, and identify the country name with the most car makers"
    },
    {
        "id": "1cc43d0dd4258523da70628365e645be9219fddc3472704ea11ef01afdc90b4d",
        "question": "What is the name of the country with the most car makers?",
        "query": "SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ CountryName , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), TopSort_5 AS ( SELECT TOP 1 CountryName, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC",
        "qd": "#1 = Scan the table car_makers and retrieve the countries of all car makers ; #2 = Group #1 by country and aggregate the count of car makers per country ; #3 = Scan the table countries and retrieve the country IDs and names ; #4 = Join #2 and #3 based on the matching country ID and retrieve the country names and count of car makers ; #5 = Sort the records from #4 based on the count of car makers in descending order, select the first record, and identify the name of the country with the most car makers and the count of car makers."
    },
    {
        "id": "0f511d2d227935024ef20380b60fb30dd28ff843040398025d6c1cb4cff1ce93",
        "question": "How many car models are produced by each maker ? Only list the count and the maker full name .",
        "query": "select count ( * ) AS Count_Star , t2.fullname FROM car_1.model_list AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.maker = t2.id group by t2.fullname , t2.id  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.FullName , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT FullName, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.FullName, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
        "clean_query": "select count ( * ) AS Count_Star , t2.fullname FROM car_1.model_list AS t1  join car_1.car_makers as t2  on t1.maker = t2.id group by t2.fullname , t2.id",
        "qd": "#1 = Scan the table model_list and retrieve the maker of each car model ; #2 = Group #1 by maker and aggregate the count of car models produced by each maker ; #3 = Scan the table car_makers and retrieve the full name and ID of each car maker ; #4 = Join #2 and #3 based on the matching maker ID and retrieve the full name and the count of car models produced by each maker"
    },
    {
        "id": "587619e0bf6dca2cc715654f4d71bcfd092fea72301454feec993fd1010054e2",
        "question": "What is the number of car models that are produced by each maker and what is the id and full name of each maker?",
        "query": "SELECT Count ( * ) AS Count_Star , T2.FullName , T2.id FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.Maker = T2.Id GROUP BY T2.FullName , T2.id  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.FullName , #3.Id , #2.Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT FullName, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.FullName, Scan_3.Id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
        "clean_query": "SELECT Count ( * ) AS Count_Star , T2.FullName , T2.id FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.Maker = T2.Id GROUP BY T2.FullName , T2.id",
        "qd": "#1 = Scan the table model_list and retrieve the maker name of all car models ; #2 = Group #1 by maker and aggregate the count of car models per maker ; #3 = Scan the table car_makers and retrieve the full name and id of all car makers ; #4 = Join #2 and #3 based on the matching maker name and id and retrieve the full name, id, and count of car models for each car maker"
    },
    {
        "id": "6b4935ecf21e96347d09f914c1134d872dd90cea1d200906b8422cec79050abe",
        "question": "What is the accelerate of the car make amc hornet sportabout (sw)?",
        "query": "SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Predicate [ Make = 'amc hornet sportabout (sw)' ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Make FROM car_1.car_names WHERE Make = 'amc hornet sportabout (sw)' ), Scan_2 AS ( SELECT Accelerate, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Accelerate FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'",
        "qd": "#1 = Scan the table car_names and retrieve the MakeId and Make of the car make 'amc hornet sportabout (sw)' ; #2 = Scan the table cars_data and retrieve the Accelerate and Id of all cars ; #3 = Join #1 and #2 based on the matching MakeId and Id and retrieve the Accelerate of the car make 'amc hornet sportabout (sw)'"
    },
    {
        "id": "9f6ea46405112628df6ab798bc562f0bebb75f5ea0d962a455271e949a879db5",
        "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?",
        "query": "SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Predicate [ Make = 'amc hornet sportabout (sw)' ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Make FROM car_1.car_names WHERE Make = 'amc hornet sportabout (sw)' ), Scan_2 AS ( SELECT Accelerate, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Accelerate FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'",
        "qd": "#1 = Scan the table car_names and retrieve the MakeId and Make of the car that makes amc hornet sportabout (sw) ; #2 = Scan the table cars_data and retrieve the Accelerate and Id of all cars ; #3 = Join #1 and #2 based on the matching MakeId and Id and retrieve the Accelerate of the car that makes amc hornet sportabout (sw)"
    },
    {
        "id": "7c03fdfb4bdd1f01de1be9c484bed41e27e47fc1fbfbf8b8c8258bc22293fd9e",
        "question": "How many car makers are there in france?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'france' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'france' ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'",
        "qd": "#1 = Scan the table countries and retrieve the country ID and name for France ; #2 = Scan the table car_makers and retrieve the country ; #3 = Join #1 and #2 based on the matching country and retrieve the country ID and name ; #4 = Aggregate the count of the records from #3 to find the number of car makers in France"
    },
    {
        "id": "0ed3028cce8847cc6d514f0cf58b7033f1af4dc410e9a4a107a33b12e6c7dcd6",
        "question": "What is the number of makers of care in France?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'france' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'france' ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'",
        "qd": "#1 = Scan the table countries and retrieve the country ID and name of France. ; #2 = Scan the table car_makers and retrieve the country of all car makers. ; #3 = Join #1 and #2 based on the matching country and retrieve the country ID and name of France. ; #4 = Aggregate the count of the records from #3 to find the number of car makers in France."
    },
    {
        "id": "04d01fafdfe0a2fc87f5e6a971770df71d346fe8153bd78a6c9fa41da7e500a4",
        "question": "How many car models are produced in the usa?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3 WITH (FORCESCAN) ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'usa' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #2.Id ] ; #4 = Scan Table [ model_list ] Output [ Maker ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Id = #4.Maker ] Output [ #3.Id ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'usa' ), Scan_2 AS ( SELECT Country, Id FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_2.Id FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Scan_4 AS ( SELECT Maker FROM car_1.model_list ), Join_5 AS ( SELECT Join_3.Id FROM Join_3 JOIN Scan_4 ON Join_3.Id = Scan_4.Maker ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3  ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'",
        "qd": "#1 = Scan the table countries and retrieve the country ID and name of the country with the name 'usa' ; #2 = Scan the table car_makers and retrieve the country and ID of all car makers ; #3 = Join #1 and #2 based on the matching country ID and retrieve the IDs ; #4 = Scan the table model_list and retrieve the maker names of all car models ; #5 = Join #3 and #4 based on the matching IDs and retrieve the IDs ; #6 = Aggregate the count of records in #5 to find the number of car models produced in the USA"
    },
    {
        "id": "2686e428ed6dee19e01cd063666a64aeceba24051c34ee875917395fcb3c1cfb",
        "question": "What is the count of the car models produced in the United States?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3 WITH (FORCESCAN) ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'usa' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #2.Id ] ; #4 = Scan Table [ model_list ] Output [ Maker ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Id = #4.Maker ] Output [ #3.Id ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'usa' ), Scan_2 AS ( SELECT Country, Id FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_2.Id FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Scan_4 AS ( SELECT Maker FROM car_1.model_list ), Join_5 AS ( SELECT Join_3.Id FROM Join_3 JOIN Scan_4 ON Join_3.Id = Scan_4.Maker ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3  ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'",
        "qd": "#1 = Scan the table countries and retrieve the country ID and name of all countries with the name 'usa' ; #2 = Scan the table car_makers and retrieve the country and ID of all car makers ; #3 = Join #1 and #2 based on the matching country ID and retrieve the IDs of car makers located in the United States ; #4 = Scan the table model_list and retrieve the names of all car makers ; #5 = Join #3 and #4 based on the matching car maker ID and retrieve the IDs of car models produced in the United States ; #6 = Aggregate the number of car model records from #5 to find the count of car models produced in the United States"
    },
    {
        "id": "d008496febb26c97a226a63cf4430e16490d2020d9a76a94f3440235c54a99f8",
        "question": "What is the average miles per gallon(mpg) of the cars with 4 cylinders?",
        "query": "SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders = 4  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Cylinders , MPG ] ; #2 = Aggregate [ #1 ] Output [ AVG(MPG) AS Avg_MPG ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, MPG FROM car_1.cars_data WHERE Cylinders = 4 ), Aggregate_2 AS ( SELECT AVG(MPG) AS Avg_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA  WHERE Cylinders = 4",
        "qd": "#1 = Scan the table cars_data and retrieve the cylinders and miles per gallon (MPG) of all cars with 4 cylinders ; #2 = Calculate the average MPG of the cars from #1 and retrieve the average as \"Average Miles per Gallon\""
    },
    {
        "id": "30d1ee42433721023f9e094e933c912d93f73b99e7b74ebcee784b5b31fe5f57",
        "question": "What is the average miles per gallon of all the cards with 4 cylinders?",
        "query": "SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders = 4  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Cylinders , MPG ] ; #2 = Aggregate [ #1 ] Output [ AVG(MPG) AS Avg_MPG ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, MPG FROM car_1.cars_data WHERE Cylinders = 4 ), Aggregate_2 AS ( SELECT AVG(MPG) AS Avg_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA  WHERE Cylinders = 4",
        "qd": "#1 = Scan the table cars_data to find all the cars with 4 cylinders and retrieve the number of cylinders and miles per gallon ; #2 = Aggregate the average miles per gallon from #1 and calculate the average miles per gallon of all the cars with 4 cylinders"
    },
    {
        "id": "181a002a5e4f8fec27048244b795b5b3f13c9550a5947e3599925be1edb96f8a",
        "question": "What is the smallest weight of the car produced with 8 cylinders on 1974 ?",
        "query": "select min ( weight ) AS Min_weight FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 and year = 1974 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 AND Year = 1974 ] Output [ Year , Cylinders , Weight ] ; #2 = Aggregate [ #1 ] Output [ MIN(Weight) AS Min_Weight ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Cylinders, Weight FROM car_1.cars_data WHERE Cylinders = 8 AND Year = 1974 ), Aggregate_2 AS ( SELECT MIN(Weight) AS Min_Weight FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "select min ( weight ) AS Min_weight FROM car_1.cars_data  where cylinders = 8 and year = 1974",
        "qd": "#1 = Scan the table cars_data and retrieve the year, number of cylinders, and weight of all cars produced in 1974 with 8 cylinders ; #2 = Aggregate the minimum weight from #1 to find the smallest weight of the car produced with 8 cylinders in 1974"
    },
    {
        "id": "7724849737aab7b098851c89a0fd1ee146c0b00594fc5f0f2b2f6789ce855c51",
        "question": "What is the minimum weight of the car with 8 cylinders produced in 1974 ?",
        "query": "select min ( weight ) AS Min_weight FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 and year = 1974 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 AND Year = 1974 ] Output [ Year , Cylinders , Weight ] ; #2 = Aggregate [ #1 ] Output [ MIN(Weight) AS Min_Weight ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Cylinders, Weight FROM car_1.cars_data WHERE Cylinders = 8 AND Year = 1974 ), Aggregate_2 AS ( SELECT MIN(Weight) AS Min_Weight FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "select min ( weight ) AS Min_weight FROM car_1.cars_data  where cylinders = 8 and year = 1974",
        "qd": "#1 = Scan the table cars_data and retrieve the year, number of cylinders, and weight of all cars produced in 1974 with 8 cylinders ; #2 = Aggregate the minimum weight from #1 to find the minimum weight of the car with 8 cylinders produced in 1974"
    },
    {
        "id": "4a94a6a7efd98efae436bb2d28b838c67c042c12a753e7c5dd6189f43f8d246d",
        "question": "What are all the makers and models?",
        "query": "SELECT Maker , Model FROM car_1.MODEL_LIST WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Model , Maker ]",
        "cte": "WITH Scan_1 AS ( SELECT Model, Maker FROM car_1.model_list ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Maker , Model FROM car_1.MODEL_LIST",
        "qd": "#1 = Scan the table model_list and retrieve the names of all car makers and models."
    },
    {
        "id": "9b93bef7838b4084eaaadeee2fb378c1b0abb129005052733376c12410782d8f",
        "question": "What are the makers and models?",
        "query": "SELECT Maker , Model FROM car_1.MODEL_LIST WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Model , Maker ]",
        "cte": "WITH Scan_1 AS ( SELECT Model, Maker FROM car_1.model_list ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Maker , Model FROM car_1.MODEL_LIST",
        "qd": "#1 = Scan the table model_list and retrieve the models and makers of all cars"
    },
    {
        "id": "94d08d95b346a6cac868d8fad31eb0e5183488ba52e84f42ebb956b97efcf487",
        "question": "What are the countries having at least one car maker? List name and id.",
        "query": "SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star , #3.CountryId ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 1 ] Output [ CountryId , CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Aggregate_2.Count_Star, Scan_3.CountryId FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT CountryId, CountryName FROM Join_4 WHERE Count_Star >= 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1",
        "qd": "#1 = Scan the table car_makers and retrieve the country of all car makers ; #2 = Group #1 by country and aggregate the count of car makers per country ; #3 = Scan the table countries and retrieve the country IDs and names of all countries ; #4 = Join #2 and #3 based on the matching country and country ID and retrieve the country names, count of car makers, and country IDs ; #5 = Filter from #4 all the countries with at least 1 car maker and retrieve the country IDs and names"
    },
    {
        "id": "462c2d108962edbbd5ff717ecf50a4f519aa59429596a9368897cbebb5f5f36f",
        "question": "What are the names and ids of all countries with at least one car maker?",
        "query": "SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star , #3.CountryId ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 1 ] Output [ CountryId , CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Aggregate_2.Count_Star, Scan_3.CountryId FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT CountryId, CountryName FROM Join_4 WHERE Count_Star >= 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1",
        "qd": "#1 = Scan the table car_makers and retrieve the countries of all car makers ; #2 = Group #1 by country and aggregate the count of car makers per country ; #3 = Scan the table countries and retrieve the country IDs and names ; #4 = Join #2 and #3 based on the matching country and country ID, and retrieve the country names, count of car makers, and country IDs ; #5 = Filter from #4 all the records with a count of car makers greater than or equal to 1, and retrieve the country IDs and names"
    },
    {
        "id": "59be649e519f17773648586a228606126215c8567bd97545d66fc8e90ecb75d5",
        "question": "What is the number of the cars with horsepower more than 150?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE horsepower > 150  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Horsepower > 150.0 ] Output [ Horsepower ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Horsepower FROM car_1.cars_data WHERE Horsepower > 150.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE horsepower > 150",
        "qd": "#1 = Scan the table cars_data and retrieve the horsepower of all cars with horsepower more than 150 ; #2 = Aggregate the count of records from #1 to find the number of cars with horsepower more than 150"
    },
    {
        "id": "fbac0a412afaaebdda79a93fc97de8b3c3e4f837db81219eb1e3f4c895f50186",
        "question": "What is the number of cars with a horsepower greater than 150?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE horsepower > 150  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Horsepower > 150.0 ] Output [ Horsepower ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Horsepower FROM car_1.cars_data WHERE Horsepower > 150.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE horsepower > 150",
        "qd": "#1 = Scan the table cars_data and retrieve the horsepower of all cars with a horsepower greater than 150 ; #2 = Aggregate the count of all records from #1 to find the number of cars with a horsepower greater than 150."
    },
    {
        "id": "becf4ca70f8cd646140303dd9052c30e59cd6a3ef9f406a2c78bcfcddbac61ed",
        "question": "What is the average weight of cars each year?",
        "query": "SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY YEAR  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Year , Weight ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , AVG(Weight) AS Avg_Weight ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Weight FROM car_1.cars_data ), Aggregate_2 AS ( SELECT Year, AVG(Weight) AS Avg_Weight FROM Scan_1 GROUP BY Year ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA  GROUP BY YEAR",
        "qd": "#1 = Scan the table cars_data and retrieve the year and weight of all cars ; #2 = Group #1 by year and calculate the average weight of cars for each year"
    },
    {
        "id": "d007f7e960ee7114376f5b06337325a6a3415ddde9d9fc135cad7075ac451bb9",
        "question": "What is the average weight and year for each year?",
        "query": "SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY YEAR  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Year , Weight ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , AVG(Weight) AS Avg_Weight ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Weight FROM car_1.cars_data ), Aggregate_2 AS ( SELECT Year, AVG(Weight) AS Avg_Weight FROM Scan_1 GROUP BY Year ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA  GROUP BY YEAR",
        "qd": "#1 = Scan the table cars_data and retrieve the year and weight of all cars ; #2 = Group the records from #1 by year and calculate the average weight per year"
    },
    {
        "id": "facbfa3fe4d0040431b7fdd4be746af38a6d427ca8d70f509c31b82ad1ae117b",
        "question": "Which countries in europe have at least 3 car manufacturers?",
        "query": "SELECT T1.CountryName FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CONTINENTS AS T2 WITH (FORCESCAN) ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ continents ] Predicate [ Continent = 'europe' ] Output [ ContId , Continent ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName , Continent ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ContId = #2.Continent ] Output [ #2.CountryId , #2.CountryName ] ; #4 = Scan Table [ car_makers ] Output [ Country ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryId = #4.Country ] Output [ #3.CountryName ] ; #6 = Aggregate [ #5 ] GroupBy [ CountryName ] Output [ countstar AS Count_Star , CountryName ] ; #7 = Filter [ #6 ] Predicate [ Count_Star >= 3 ] Output [ CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT ContId, Continent FROM car_1.continents WHERE Continent = 'europe' ), Scan_2 AS ( SELECT CountryId, CountryName, Continent FROM car_1.countries ), Join_3 AS ( SELECT Scan_2.CountryId, Scan_2.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.ContId = Scan_2.Continent ), Scan_4 AS ( SELECT Country FROM car_1.car_makers ), Join_5 AS ( SELECT Join_3.CountryName FROM Join_3 JOIN Scan_4 ON Join_3.CountryId = Scan_4.Country ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star, CountryName FROM Join_5 GROUP BY CountryName ), Filter_7 AS ( SELECT CountryName FROM Aggregate_6 WHERE Count_Star >= 3 ) SELECT * FROM Filter_7",
        "clean_query": "SELECT T1.CountryName FROM car_1.COUNTRIES AS T1  JOIN car_1.CONTINENTS AS T2  ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3  ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3",
        "qd": "#1 = Scan the table continents and retrieve the ID and name of the continent where it is Europe. ; #2 = Scan the table countries and retrieve the ID, name of the country and continent information. ; #3 = Join #1 and #2 based on the matching continent ID and retrieve the country ID and name where it is in Europe. ; #4 = Scan the table car_makers and retrieve the country information. ; #5 = Join #3 and #4 based on the matching country name and retrieve the country name. ; #6 = Group #5 by country name and aggregate the count per country name to find the number of car manufacturers in each country. ; #7 = Filter from #6 all the countries that have at least 3 car manufacturers and retrieve the country names."
    },
    {
        "id": "df86c873292dcf609490b4289dedb15016c2b143c99e52d6908ecdb4262ae8c0",
        "question": "What are the names of all European countries with at least 3 manufacturers?",
        "query": "SELECT T1.CountryName FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CONTINENTS AS T2 WITH (FORCESCAN) ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ continents ] Predicate [ Continent = 'europe' ] Output [ ContId , Continent ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName , Continent ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ContId = #2.Continent ] Output [ #2.CountryId , #2.CountryName ] ; #4 = Scan Table [ car_makers ] Output [ Country ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryId = #4.Country ] Output [ #3.CountryName ] ; #6 = Aggregate [ #5 ] GroupBy [ CountryName ] Output [ countstar AS Count_Star , CountryName ] ; #7 = Filter [ #6 ] Predicate [ Count_Star >= 3 ] Output [ CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT ContId, Continent FROM car_1.continents WHERE Continent = 'europe' ), Scan_2 AS ( SELECT CountryId, CountryName, Continent FROM car_1.countries ), Join_3 AS ( SELECT Scan_2.CountryId, Scan_2.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.ContId = Scan_2.Continent ), Scan_4 AS ( SELECT Country FROM car_1.car_makers ), Join_5 AS ( SELECT Join_3.CountryName FROM Join_3 JOIN Scan_4 ON Join_3.CountryId = Scan_4.Country ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star, CountryName FROM Join_5 GROUP BY CountryName ), Filter_7 AS ( SELECT CountryName FROM Aggregate_6 WHERE Count_Star >= 3 ) SELECT * FROM Filter_7",
        "clean_query": "SELECT T1.CountryName FROM car_1.COUNTRIES AS T1  JOIN car_1.CONTINENTS AS T2  ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3  ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3",
        "qd": "#1 = Scan the table continents and retrieve the continent ID and name of all continents. ; #2 = Scan the table countries and retrieve the country ID, name, and continent of all countries. ; #3 = Join #1 and #2 based on the matching continent ID and continent to retrieve the country ID and name of all European countries. ; #4 = Scan the table car_makers and retrieve the country of all car manufacturers. ; #5 = Join #3 and #4 based on the matching country ID and country to retrieve the names of European countries that have car manufacturers. ; #6 = Group #5 by country name and aggregate the count of records to find the number of manufacturers in each European country. ; #7 = Filter #6 and retrieve the country names where the count of manufacturers is greater than or equal to 3."
    },
    {
        "id": "b95a8aefa5bfc0f7d9606648e7afb9ffe2f3381c9f6147255b4f9af1b166c581",
        "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?",
        "query": "SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 3 ] Output [ Cylinders , Horsepower , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Make ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Make ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Make ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, Horsepower, Id FROM car_1.cars_data WHERE Cylinders = 3 ), Scan_2 AS ( SELECT MakeId, Make FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Make FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Make FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC",
        "qd": "#1 = Scan the table cars_data to find the car models with 3 cylinders and retrieve the number of cylinders, horsepower, and ID ; #2 = Scan the table car_names to retrieve the car make ID and make name ; #3 = Join #1 and #2 based on the matching IDs and retrieve the horsepower and make ; #4 = Sort the records from #3 based on the horsepower in descending order, select the first record, and identify the maximum horsepower and the make of the car models with 3 cylinders"
    },
    {
        "id": "adefbd4e9ba07e8bb82a8588229dab1e6e1b09b92df70ea6bd801b28f5656147",
        "question": "What is the largest amount of horsepower for the models with 3 cylinders and what make is it?",
        "query": "SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 3 ] Output [ Cylinders , Horsepower , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Make ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Make ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Make ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, Horsepower, Id FROM car_1.cars_data WHERE Cylinders = 3 ), Scan_2 AS ( SELECT MakeId, Make FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Make FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Make FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC",
        "qd": "#1 = Scan the table cars_data and retrieve the cylinders, horsepower, and IDs of all cars with 3 cylinders ; #2 = Scan the table car_names and retrieve the make IDs and makes of all car names ; #3 = Join #1 and #2 based on the matching IDs and retrieve the horsepower and makes ; #4 = Sort the records from #3 based on the horsepower in descending order, select the first record, and identify the largest amount of horsepower for the models with 3 cylinders and its make."
    },
    {
        "id": "ac7e3e3adfb4715eccfa332d41fb30d7348936c72be0b770bd95702e9377cd8e",
        "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.",
        "query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id ORDER BY T2.mpg DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ MPG , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #2.Model , #1.MPG ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ MPG DESC ] Output [ Model , MPG ]",
        "cte": "WITH Scan_1 AS ( SELECT MPG, Id FROM car_1.cars_data ), Scan_2 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_3 AS ( SELECT Scan_2.Model, Scan_1.MPG FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Model, MPG FROM Join_3 ORDER BY MPG DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id ORDER BY T2.mpg DESC",
        "qd": "#1 = Scan the table cars_data and retrieve the MPG and IDs of all cars ; #2 = Scan the table car_names and retrieve the Make IDs and Models of all cars ; #3 = Join #1 and #2 based on the matching IDs and retrieve the Models and MPG scores ; #4 = Sort the records from #3 based on the MPG score in descending order, select the first record, and identify the model that saves the most gasoline."
    },
    {
        "id": "a271ea14ee9ab5f826f8435851bff6696ec77d2382036bb6174344f6a211ff5c",
        "question": "What is the car model with the highest mpg ?",
        "query": "select TOP 1 t1.model FROM car_1.car_names AS t1 WITH (FORCESCAN) join car_1.cars_data as t2 WITH (FORCESCAN) on t1.makeid = t2.id order by t2.mpg desc  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ MPG , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #2.Model , #1.MPG ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ MPG DESC ] Output [ Model , MPG ]",
        "cte": "WITH Scan_1 AS ( SELECT MPG, Id FROM car_1.cars_data ), Scan_2 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_3 AS ( SELECT Scan_2.Model, Scan_1.MPG FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Model, MPG FROM Join_3 ORDER BY MPG DESC ) SELECT * FROM TopSort_4",
        "clean_query": "select TOP 1 t1.model FROM car_1.car_names AS t1  join car_1.cars_data as t2  on t1.makeid = t2.id order by t2.mpg desc",
        "qd": "#1 = Scan the table cars_data and retrieve the MPG and ID of all cars ; #2 = Scan the table car_names and retrieve the Make ID and Model of all cars ; #3 = Join #1 and #2 based on the matching ID and Make ID and retrieve the Model and MPG ; #4 = Sort the records from #3 based on the MPG in descending order, select the first record, and identify the car model with the highest MPG."
    },
    {
        "id": "5f3e14ec082234fc4bddff7754ddeef043a6e8f0f62b789c3def9fb2df884b1e",
        "question": "What is the average horsepower of the cars before 1980?",
        "query": "SELECT avg ( horsepower ) AS Avg_horsepower FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE YEAR < 1980  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year < 1980 ] Output [ Year , Horsepower ] ; #2 = Aggregate [ #1 ] Output [ AVG(Horsepower) AS Avg_Horsepower ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Horsepower FROM car_1.cars_data WHERE Year < 1980 ), Aggregate_2 AS ( SELECT AVG(Horsepower) AS Avg_Horsepower FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( horsepower ) AS Avg_horsepower FROM car_1.CARS_DATA  WHERE YEAR < 1980",
        "qd": "#1 = Scan the table cars_data and retrieve the year and horsepower of all cars before 1980 ; #2 = Calculate the average horsepower of the cars before 1980 and output it as Avg_Horsepower"
    },
    {
        "id": "47a6d2e06009bae4ce2b0899e83998340dd9d23146d200cab07b8592300f8254",
        "question": "What is the average horsepower for all cars produced before 1980 ?",
        "query": "select avg ( horsepower ) AS Avg_horsepower FROM car_1.cars_data WITH (FORCESCAN) where year < 1980  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year < 1980 ] Output [ Year , Horsepower ] ; #2 = Aggregate [ #1 ] Output [ AVG(Horsepower) AS Avg_Horsepower ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Horsepower FROM car_1.cars_data WHERE Year < 1980 ), Aggregate_2 AS ( SELECT AVG(Horsepower) AS Avg_Horsepower FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "select avg ( horsepower ) AS Avg_horsepower FROM car_1.cars_data  where year < 1980",
        "qd": "#1 = Scan the table cars_data and retrieve the year and horsepower of all cars produced before 1980 ; #2 = Aggregate the average horsepower from #1 to find the average horsepower for all cars produced before 1980"
    },
    {
        "id": "c0c3b1cbaa2da81a562a00b83e42f0c9667e93d3156777f71ac2f1d636cfd4a6",
        "question": "What is the average edispl of the cars of model volvo?",
        "query": "SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ MakeId , Model ] ; #2 = Scan Table [ cars_data ] Output [ Edispl , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Edispl ] ; #4 = Aggregate [ #3 ] Output [ AVG(Edispl) AS Avg_Edispl ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Model FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Edispl, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Edispl FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), Aggregate_4 AS ( SELECT AVG(Edispl) AS Avg_Edispl FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'",
        "qd": "#1 = Scan the table car_names and retrieve the make IDs and models of all cars with the model name 'volvo' ; #2 = Scan the table cars_data and retrieve the engine displacement and IDs of all cars ; #3 = Join #1 and #2 based on the matching make IDs and IDs and retrieve the engine displacement ; #4 = Calculate the average engine displacement of all cars from #3 and retrieve the average engine displacement of the cars of model 'volvo'"
    },
    {
        "id": "7150c07fb04ec364ebd00863c0abea6344eefeff62b6937753626258890e1907",
        "question": "What is the average edispl for all volvos?",
        "query": "SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ MakeId , Model ] ; #2 = Scan Table [ cars_data ] Output [ Edispl , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Edispl ] ; #4 = Aggregate [ #3 ] Output [ AVG(Edispl) AS Avg_Edispl ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Model FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Edispl, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Edispl FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), Aggregate_4 AS ( SELECT AVG(Edispl) AS Avg_Edispl FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'",
        "qd": "#1 = Scan the table car_names to find all the car models with the name 'volvo' ; #2 = Scan the table cars_data to retrieve the edispl values for all cars ; #3 = Join #1 and #2 based on the matching MakeId and Id and retrieve the edispl values for all 'volvo' cars ; #4 = Calculate the average edispl from the edispl values obtained from #3 to find the average edispl for all volvos."
    },
    {
        "id": "245ef4bfa9b7661d4d74c480d37bfbbd1e0120f0ccb0f6c4f281bf958b53d2a7",
        "question": "What is the maximum accelerate for different number of cylinders?",
        "query": "SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY Cylinders  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Cylinders , Accelerate ] ; #2 = Aggregate [ #1 ] GroupBy [ Cylinders ] Output [ MAX(Accelerate) AS Max_Accelerate , Cylinders ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, Accelerate FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MAX(Accelerate) AS Max_Accelerate, Cylinders FROM Scan_1 GROUP BY Cylinders ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA  GROUP BY Cylinders",
        "qd": "#1 = Scan the table cars_data and retrieve the number of cylinders and acceleration of all cars ; #2 = Group #1 by the number of cylinders and aggregate the maximum acceleration for each number of cylinders"
    },
    {
        "id": "4e2a3009bf1eeef36db8e5fde67079e87dc569572f0683cc2aa31d95e6f5b471",
        "question": "What is the maximum accelerate for all the different cylinders?",
        "query": "SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY Cylinders  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Cylinders , Accelerate ] ; #2 = Aggregate [ #1 ] GroupBy [ Cylinders ] Output [ MAX(Accelerate) AS Max_Accelerate , Cylinders ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, Accelerate FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MAX(Accelerate) AS Max_Accelerate, Cylinders FROM Scan_1 GROUP BY Cylinders ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA  GROUP BY Cylinders",
        "qd": "#1 = Scan the table cars_data and retrieve the number of cylinders and the acceleration for all cars data ; #2 = Group the records from #1 by the number of cylinders and aggregate the maximum acceleration per number of cylinders to find the maximum accelerate for all the different cylinders."
    },
    {
        "id": "e630d361fd786cda956fb2025a82fdc0fa6c5815f9737403f9f381688f2661c1",
        "question": "Which model has the most version(make) of cars?",
        "query": "SELECT TOP 1 Model FROM car_1.CAR_NAMES WITH (FORCESCAN) GROUP BY Model ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Output [ Model ] ; #2 = Aggregate [ #1 ] GroupBy [ Model ] Output [ countstar AS Count_Star , Model ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Model , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Model FROM car_1.car_names ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Model FROM Scan_1 GROUP BY Model ), TopSort_3 AS ( SELECT TOP 1 Model, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Model FROM car_1.CAR_NAMES  GROUP BY Model ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table car_names and retrieve the models of all cars ; #2 = Group #1 by model and aggregate the count of car names per model ; #3 = Sort the records from #2 based on the count of car names in descending order, select the first record, and identify the model that has the most versions (makes) of cars and its count of versions (makes)."
    },
    {
        "id": "59affccbb588b409c985a1028b9e13bd2266620f0fdf99638a6fbb8439490855",
        "question": "What model has the most different versions?",
        "query": "SELECT TOP 1 Model FROM car_1.CAR_NAMES WITH (FORCESCAN) GROUP BY Model ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Output [ Model ] ; #2 = Aggregate [ #1 ] GroupBy [ Model ] Output [ countstar AS Count_Star , Model ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Model , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Model FROM car_1.car_names ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Model FROM Scan_1 GROUP BY Model ), TopSort_3 AS ( SELECT TOP 1 Model, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Model FROM car_1.CAR_NAMES  GROUP BY Model ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table car_names and retrieve the models of all cars ; #2 = Group #1 by model and aggregate the count per model to find the number of different versions of each model ; #3 = Sort the records from #2 based on the count of different versions in descending order, select the first record, and identify the model that has the most different versions and its count of versions."
    },
    {
        "id": "1da527580c9c855544ac3513a1908359742acd8cd9962f04b70bd6599508a14b",
        "question": "How many cars have more than 4 cylinders?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 4  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 4 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 4 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 4",
        "qd": "#1 = Scan the table cars_data and retrieve the number of cylinders of all cars with more than 4 cylinders ; #2 = Aggregate the count of records from #1 to find the number of cars that have more than 4 cylinders"
    },
    {
        "id": "11df8747ba360172906df15c76c2aa949c4feade99a36210c6558fd502edde93",
        "question": "What is the number of cars with more than 4 cylinders?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 4  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 4 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 4 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 4",
        "qd": "#1 = Scan the table cars_data and retrieve the number of cylinders of all cars with more than 4 cylinders ; #2 = Aggregate the number of records from #1 to find the total number of cars with more than 4 cylinders"
    },
    {
        "id": "cf86a2583a04d0373d4ca4b2b0464985067d246fde2c58d8e2de54134a4528c4",
        "question": "how many cars were produced in 1980?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE YEAR = 1980  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year = 1980 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data WHERE Year = 1980 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE YEAR = 1980",
        "qd": "#1 = Scan the table cars_data and retrieve the year of all cars produced ; #2 = Aggregate the count of records from #1 to find the number of cars that were produced in 1980"
    },
    {
        "id": "d4a04c0e1753c6236ee149512841790fd345f9394462bbf66a484f68764d52ee",
        "question": "In 1980, how many cars were made?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE YEAR = 1980  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year = 1980 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data WHERE Year = 1980 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE YEAR = 1980",
        "qd": "#1 = Scan the table cars_data and retrieve the records with the year 1980 ; #2 = Aggregate the count of records from #1 to find how many cars were made in 1980"
    },
    {
        "id": "f30af95f9ee63fc7e4a5af67b0549b85c2b14a445a84b52ce75454c22eaaed7a",
        "question": "How many car models were produced by the maker with full name American Motor Company?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Predicate [ FullName = 'American Motor Company' ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Maker ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.Maker ] Output [ #1.Id , #1.FullName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT FullName, Id FROM car_1.car_makers WHERE FullName = 'American Motor Company' ), Scan_2 AS ( SELECT Maker FROM car_1.model_list ), Join_3 AS ( SELECT Scan_1.Id, Scan_1.FullName FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.Maker ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'",
        "qd": "#1 = Scan the table car_makers and retrieve the ID and Full Name of the maker with Full Name 'American Motor Company' ; #2 = Scan the table model_list and retrieve the Maker of all the car models ; #3 = Join #1 and #2 based on the matching Maker and retrieve the ID and Full Name ; #4 = Aggregate the count of all the records in #3 to find the number of car models produced by the maker with Full Name 'American Motor Company'."
    },
    {
        "id": "00b406cd591e370b0ca414e76c4edb78d82b3c13b4b63b505216c99f888eb002",
        "question": "What is the number of car models created by the car maker American Motor Company?",
        "query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Predicate [ FullName = 'American Motor Company' ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Maker ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.Maker ] Output [ #1.Id , #1.FullName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT FullName, Id FROM car_1.car_makers WHERE FullName = 'American Motor Company' ), Scan_2 AS ( SELECT Maker FROM car_1.model_list ), Join_3 AS ( SELECT Scan_1.Id, Scan_1.FullName FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.Maker ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'",
        "qd": "#1 = Scan table car_makers and retrieve the ID and full name of the car maker American Motor Company ; #2 = Scan table model_list and retrieve the makers of all car models ; #3 = Join #1 and #2 based on the matching ID and retrieve the IDs and full names of the car maker American Motor Company ; #4 = Aggregate the number of records in #3 to find the number of car models created by the car maker American Motor Company"
    },
    {
        "id": "018da303b9516c988e9c24f88bd456d97adba3d25ba308c366e8eaa9027a509f",
        "question": "Which makers designed more than 3 car models? List full name and the id.",
        "query": "SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.FullName , #3.Id , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ FullName , Id ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT FullName, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.FullName, Scan_3.Id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT FullName, Id FROM Join_4 WHERE Count_Star > 3 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3",
        "qd": "#1 = Scan the table model_list and retrieve the maker of all car models. ; #2 = Group #1 by maker and aggregate the count of car models per maker. ; #3 = Scan the table car_makers and retrieve the full name and id of all car makers. ; #4 = Join #2 and #3 based on the matching maker and id. ; #5 = Filter the records from #4 to select the car makers who designed more than 3 car models, and retrieve their full name and id."
    },
    {
        "id": "532d1e15f99ebc54005a555098c494296d44412ee0fd0a417574833f09b82c13",
        "question": "What are the names and ids of all makers with more than 3 models?",
        "query": "SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.FullName , #3.Id , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ FullName , Id ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT FullName, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.FullName, Scan_3.Id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT FullName, Id FROM Join_4 WHERE Count_Star > 3 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3",
        "qd": "#1 = Scan the table model_list and retrieve the names of all makers ; #2 = Group #1 by maker and aggregate the count of models per maker ; #3 = Scan the table car_makers and retrieve the full names and ids of all car makers ; #4 = Join #2 and #3 based on the matching maker and id, and retrieve the full names, ids, and counts of models ; #5 = Filter from #4 all the records with a count of models greater than 3, and retrieve the full names and ids of the car makers"
    },
    {
        "id": "7e07965719bdc4b883c84663dcc9b66ffdf2d7e962e4fcf8cebbdc95bad61b70",
        "question": "Which distinctive models are produced by maker with the full name General Motors or weighing more than 3500?",
        "query": "SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Model , Maker ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Id = #3.MakeId ] Output [ #3.Model , #4.Weight ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.Model = #2.Model ] Output [ #2.Model , #2.Maker , #5.Weight ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.Maker = #1.Id ] Output [ #6.Model , #6.Weight , #1.FullName ] ; #8 = Filter [ #7 ] Predicate [ Weight > 3500 Or FullName = 'General Motors' ] Distinct [ true ] Output [ Model ]",
        "cte": "WITH Scan_1 AS ( SELECT FullName, Id FROM car_1.car_makers ), Scan_2 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Scan_4 AS ( SELECT Weight, Id FROM car_1.cars_data ), Join_5 AS ( SELECT Scan_3.Model, Scan_4.Weight FROM Scan_3 JOIN Scan_4 ON Scan_4.Id = Scan_3.MakeId ), Join_6 AS ( SELECT Scan_2.Model, Scan_2.Maker, Join_5.Weight FROM Scan_2 JOIN Join_5 ON Join_5.Model = Scan_2.Model ), Join_7 AS ( SELECT Join_6.Model, Join_6.Weight, Scan_1.FullName FROM Scan_1 JOIN Join_6 ON Join_6.Maker = Scan_1.Id ), Filter_8 AS ( SELECT DISTINCT Model FROM Join_7 WHERE Weight > 3500 Or FullName = 'General Motors' ) SELECT * FROM Filter_8",
        "clean_query": "SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3  ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4  ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500",
        "qd": "#1 = Scan the table car_makers and retrieve the full names and IDs of all makers ; #2 = Scan the table model_list and retrieve the models and makers ; #3 = Scan the table car_names and retrieve the models and make IDs ; #4 = Scan the table cars_data and retrieve the weights and IDs ; #5 = Join #3 and #4 based on the matching IDs and retrieve the models and weights ; #6 = Join #2 and #5 based on the matching models and retrieve the models, makers, and weights ; #7 = Join #1 and #6 based on the matching IDs and retrieve the models, weights, and full names ; #8 = Filter from #7 the records with weights greater than 3500 or full names equal to 'General Motors' and retrieve the distinct models"
    },
    {
        "id": "869d090908c20d389878b3c1a8c760b86d77771817c2396a1fe57ce4f1537348",
        "question": "What are the different models created by either the car maker General Motors or weighed more than 3500?",
        "query": "SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Model , Maker ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Id = #3.MakeId ] Output [ #3.Model , #4.Weight ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.Model = #2.Model ] Output [ #2.Model , #2.Maker , #5.Weight ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.Maker = #1.Id ] Output [ #6.Model , #6.Weight , #1.FullName ] ; #8 = Filter [ #7 ] Predicate [ Weight > 3500 Or FullName = 'General Motors' ] Distinct [ true ] Output [ Model ]",
        "cte": "WITH Scan_1 AS ( SELECT FullName, Id FROM car_1.car_makers ), Scan_2 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Scan_4 AS ( SELECT Weight, Id FROM car_1.cars_data ), Join_5 AS ( SELECT Scan_3.Model, Scan_4.Weight FROM Scan_3 JOIN Scan_4 ON Scan_4.Id = Scan_3.MakeId ), Join_6 AS ( SELECT Scan_2.Model, Scan_2.Maker, Join_5.Weight FROM Scan_2 JOIN Join_5 ON Join_5.Model = Scan_2.Model ), Join_7 AS ( SELECT Join_6.Model, Join_6.Weight, Scan_1.FullName FROM Scan_1 JOIN Join_6 ON Join_6.Maker = Scan_1.Id ), Filter_8 AS ( SELECT DISTINCT Model FROM Join_7 WHERE Weight > 3500 Or FullName = 'General Motors' ) SELECT * FROM Filter_8",
        "clean_query": "SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3  ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4  ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500",
        "qd": "#1 = Scan the table car_makers and retrieve the full name and ID of all car makers ; #2 = Scan the table model_list and retrieve the model and maker of all car models ; #3 = Scan the table car_names and retrieve the model and make ID of all car names ; #4 = Scan the table cars_data and retrieve the weight and ID of all cars ; #5 = Join #3 and #4 based on the matching make ID and retrieve the model and weight ; #6 = Join #2 and #5 based on the matching model and retrieve the model, maker, and weight ; #7 = Join #1 and #6 based on the matching maker ID and retrieve the model, weight, and full name of car makers ; #8 = Filter from #7 all the models with weight greater than 3500 or made by General Motors, retrieve the distinct model names"
    },
    {
        "id": "36c7b520f8030b3154a34e0448f53c05b97574743e8f106665ad05142e78acc2",
        "question": "In which years cars were produced weighing no less than 3000 and no more than 4000 ?",
        "query": "select distinct year FROM car_1.cars_data WITH (FORCESCAN) where weight between 3000 and 4000  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight >= 3000 AND Weight <= 4000 ] Distinct [ true ] Output [ Year ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Year FROM car_1.cars_data WHERE Weight >= 3000 AND Weight <= 4000 ) SELECT * FROM Scan_1",
        "clean_query": "select distinct year FROM car_1.cars_data  where weight between 3000 and 4000",
        "qd": "#1 = Scan the table cars_data and retrieve the distinct years in which cars were produced with a weight of no less than 3000 and no more than 4000."
    },
    {
        "id": "133810f0e3f5f4b7d84f4b9d31f3fc19932e5f2965fdb8a9d6f5ee92cc706dd9",
        "question": "What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?",
        "query": "select distinct year FROM car_1.cars_data WITH (FORCESCAN) where weight between 3000 and 4000  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight >= 3000 AND Weight <= 4000 ] Distinct [ true ] Output [ Year ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Year FROM car_1.cars_data WHERE Weight >= 3000 AND Weight <= 4000 ) SELECT * FROM Scan_1",
        "clean_query": "select distinct year FROM car_1.cars_data  where weight between 3000 and 4000",
        "qd": "#1 = Scan the table cars_data and retrieve the distinct years in which there were cars produced that weighed between 3000 and 4000 pounds."
    },
    {
        "id": "34a29224cb1a2db69920126c04ee5270c88f451260a25f12974f6cb81799530a",
        "question": "What is the horsepower of the car with the largest accelerate?",
        "query": "SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) ORDER BY T1.accelerate DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Accelerate DESC ] Output [ Accelerate , Horsepower ]",
        "cte": "WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Accelerate DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1  ORDER BY T1.accelerate DESC",
        "qd": "#1 = Scan the table cars_data and retrieve the accelerate and horsepower of all cars ; #2 = Sort the records from #1 based on the accelerate in descending order, select the first record, and identify the horsepower of the car with the largest accelerate."
    },
    {
        "id": "8b218ce8c7ce351dc037f9bf3d576f76412eeef674548ace0b382309f73f1fbe",
        "question": "What is the horsepower of the car with the greatest accelerate?",
        "query": "SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) ORDER BY T1.accelerate DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Accelerate DESC ] Output [ Accelerate , Horsepower ]",
        "cte": "WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Accelerate DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1  ORDER BY T1.accelerate DESC",
        "qd": "#1 = Scan the table cars_data and retrieve the accelerate and horsepower of all cars ; #2 = Sort the records from #1 based on the accelerate in descending order, select the first record, and identify the horsepower of the car with the greatest accelerate"
    },
    {
        "id": "20aad5ec8be072a2fc801c6afcad66ba64d69ce743b9ab6f3f5237766dfde98f",
        "question": "For model volvo, how many cylinders does the car with the least accelerate have?",
        "query": "SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ MakeId , Model ] ; #2 = Scan Table [ cars_data ] Output [ Cylinders , Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate , #2.Cylinders ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Accelerate ASC ] Output [ Cylinders , Accelerate ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Model FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Cylinders, Accelerate, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Accelerate, Scan_2.Cylinders FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), TopSort_4 AS ( SELECT TOP 1 Cylinders, Accelerate FROM Join_3 ORDER BY Accelerate ASC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC",
        "qd": "#1 = Scan the table car_names and retrieve the make ID and model name of all cars with the model name 'volvo' ; #2 = Scan the table cars_data and retrieve the number of cylinders and acceleration values of all cars ; #3 = Join #1 and #2 based on the matching make ID and car ID and retrieve the acceleration and number of cylinders ; #4 = Sort the records from #3 based on the acceleration in ascending order, select the first record, and retrieve the number of cylinders of the car with the least acceleration for the model 'volvo'"
    },
    {
        "id": "a1e86640236a193701c725b90a1521cb34923dc534777912bbdc11ee29853b4b",
        "question": "For a volvo model, how many cylinders does the version with least accelerate have?",
        "query": "SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ MakeId , Model ] ; #2 = Scan Table [ cars_data ] Output [ Cylinders , Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate , #2.Cylinders ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Accelerate ASC ] Output [ Cylinders , Accelerate ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Model FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Cylinders, Accelerate, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Accelerate, Scan_2.Cylinders FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), TopSort_4 AS ( SELECT TOP 1 Cylinders, Accelerate FROM Join_3 ORDER BY Accelerate ASC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC",
        "qd": "#1 = Scan the table car_names and retrieve the make ID and model of all models with the name Volvo ; #2 = Scan the table cars_data and retrieve the cylinders and accelerate of all cars ; #3 = Join #1 and #2 based on the matching make ID and car ID and retrieve the accelerate and cylinders ; #4 = Sort the records from #3 based on the accelerate in ascending order, select the first record, and identify the number of cylinders for the Volvo model with the least accelerate."
    },
    {
        "id": "48a734d28ac0d45d15214f304ffedb1c3b0821398f90f0c5e93a378f96bf9bfc",
        "question": "How many cars have a larger accelerate than the car with the largest horsepower?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA WITH (FORCESCAN) ORDER BY Horsepower DESC )  ",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Accelerate , Horsepower ] ; #3 = Scan Table [ cars_data ] Output [ Accelerate ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Accelerate > #3.Accelerate ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Horsepower DESC ), Scan_3 AS ( SELECT Accelerate FROM car_1.cars_data ), Join_4 AS ( SELECT 1 AS One FROM TopSort_2 CROSS JOIN Scan_3 WHERE Scan_3.Accelerate > TopSort_2.Accelerate ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA  ORDER BY Horsepower DESC )",
        "qd": "#1 = Scan the table cars_data and retrieve the accelerate and horsepower of all cars ; #2 = Sort the records from #1 based on the horsepower in descending order, select the first record, and retrieve the accelerate and horsepower of the car with the largest horsepower ; #3 = Scan the table cars_data and retrieve the accelerate of all cars ; #4 = Join #2 and #3 based on the condition that the accelerate of #2 is larger than the accelerate of #3, and retrieve a record with a value of 1 as a placeholder ; #5 = Count the number of records in #4 to find the number of cars that have a larger accelerate than the car with the largest horsepower"
    },
    {
        "id": "5a89af6cde45af39529cde237524a39a4b5bf5f6e805cf069bc3fd29ad32b8c0",
        "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA WITH (FORCESCAN) ORDER BY Horsepower DESC )  ",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Accelerate , Horsepower ] ; #3 = Scan Table [ cars_data ] Output [ Accelerate ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Accelerate > #3.Accelerate ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Horsepower DESC ), Scan_3 AS ( SELECT Accelerate FROM car_1.cars_data ), Join_4 AS ( SELECT 1 AS One FROM TopSort_2 CROSS JOIN Scan_3 WHERE Scan_3.Accelerate > TopSort_2.Accelerate ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA  ORDER BY Horsepower DESC )",
        "qd": "#1 = Scan the table cars_data and retrieve the accelerate and horsepower of all cars ; #2 = Sort the records from #1 based on the horsepower in descending order and select the first record, retrieve the accelerate and horsepower ; #3 = Scan the table cars_data and retrieve the accelerate of all cars ; #4 = Join #2 and #3 based on the condition that the accelerate of #2 is greater than the accelerate of #3 ; #5 = Aggregate the count of all records in #4 to find the number of cars with a greater accelerate than the one with the most horsepower"
    },
    {
        "id": "c41addc8cbd0fa2c9fcc48cbd0054859755fe0a2789378a6df2c3208334df8e8",
        "question": "How many countries has more than 2 car makers ?",
        "query": "select count ( * ) AS Count_Star FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = Scan Table [ countries ] Output [ CountryId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId FROM car_1.countries ), Join_4 AS ( SELECT Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT Count_Star FROM Join_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
        "clean_query": "select count ( * ) AS Count_Star FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2",
        "qd": "#1 = Scan the table car_makers and retrieve the country of all car makers. ; #2 = Group #1 by country and aggregate the count of car makers for each country. ; #3 = Scan the table countries and retrieve all country IDs. ; #4 = Join #2 and #3 based on the matching country and country ID and retrieve the count of car makers. ; #5 = Filter from #4 the records where the count of car makers is greater than 2 and retrieve the count of car makers."
    },
    {
        "id": "8ae45237a4b14c518c470ccdb33ff70e8b3fdd9499e1d452bdde3806f222c183",
        "question": "What is the number of countries with more than 2 car makers ?",
        "query": "select count ( * ) AS Count_Star FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = Scan Table [ countries ] Output [ CountryId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId FROM car_1.countries ), Join_4 AS ( SELECT Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT Count_Star FROM Join_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
        "clean_query": "select count ( * ) AS Count_Star FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2",
        "qd": "#1 = Scan the table car_makers and retrieve the country of each car maker ; #2 = Group #1 by country and aggregate the count of car makers per country ; #3 = Scan the table countries and retrieve the country IDs ; #4 = Join #2 and #3 based on the matching country and country ID and retrieve the count of car makers per country ; #5 = Filter the records from #4 and retrieve the count of countries that have more than 2 car makers"
    },
    {
        "id": "4f5fe3262a45fa6129aae57814c7c9a3f1a980933296e4d19dd4e2edd73f005d",
        "question": "How many cars has over 6 cylinders?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 6  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 6 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 6 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 6",
        "qd": "#1 = Scan the table cars_data and retrieve the number of cylinders of all cars that have more than 6 cylinders ; #2 = Aggregate the count of the records from #1 to find the total number of cars that have over 6 cylinders"
    },
    {
        "id": "aa943ef5c6203ba597019088c094ed685eea371be148c25ce154a9b373dc2c15",
        "question": "What is the number of carsw ith over 6 cylinders?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 6  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 6 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 6 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 6",
        "qd": "#1 = Scan the table cars_data to find all the cars with more than 6 cylinders ; #2 = Aggregate the count of all the records in #1 to find the number of cars with over 6 cylinders"
    },
    {
        "id": "d62f00c18f52de786886bd8891a3d2bf89ffa4b15a55048cd99820de47c66fb2",
        "question": "For the cars with 4 cylinders, which model has the largest horsepower?",
        "query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Cylinders , Horsepower , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #2.Model , #1.Horsepower ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, Horsepower, Id FROM car_1.cars_data WHERE Cylinders = 4 ), Scan_2 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_3 AS ( SELECT Scan_2.Model, Scan_1.Horsepower FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC",
        "qd": "#1 = Scan the table cars_data to find all the cars with 4 cylinders and retrieve the number of cylinders, horsepower, and car ID ; #2 = Scan the table car_names and retrieve the car make ID and model ; #3 = Join #1 and #2 based on the matching car ID and retrieve the car model and horsepower ; #4 = Sort the records from #3 based on the horsepower in descending order, select the first record, and identify the model of the car with the largest horsepower among cars with 4 cylinders."
    },
    {
        "id": "2e4abbe3322902bb4a641597f938f81afeaba7aa81b1943b46b40b6db2d0f182",
        "question": "For all of the 4 cylinder cars, which model has the most horsepower?",
        "query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Cylinders , Horsepower , Id ] ; #2 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #2.Model , #1.Horsepower ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Cylinders, Horsepower, Id FROM car_1.cars_data WHERE Cylinders = 4 ), Scan_2 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_3 AS ( SELECT Scan_2.Model, Scan_1.Horsepower FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC",
        "qd": "#1 = Scan the table cars_data and retrieve the Cylinders, Horsepower, and Id of all cars with 4 cylinders ; #2 = Scan the table car_names and retrieve the MakeId and Model of all car names ; #3 = Join #1 and #2 based on the matching Id and MakeId and retrieve the Model and Horsepower ; #4 = Sort the records from #3 based on the Horsepower in descending order, select the first record, and identify the model with the highest horsepower among all 4 cylinder cars."
    },
    {
        "id": "f9daf85575404c5b449d54a8baa0724475494e972fe99743b94ee039c21ade56",
        "question": "Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.",
        "query": "SELECT T2.MakeId , T2.Make FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T1.Horsepower > ( SELECT min ( Horsepower ) AS Min_Horsepower FROM car_1.CARS_DATA WITH (FORCESCAN) ) AND T1.Cylinders < = 3  ",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Horsepower ] ; #3 = Aggregate [ #2 ] Output [ MIN(Horsepower) AS Min_Horsepower ] ; #4 = Scan Table [ cars_data ] Predicate [ Cylinders <= 3 ] Output [ Cylinders , Horsepower , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Horsepower > #3.Min_Horsepower ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.MakeId , #1.Make ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Make FROM car_1.car_names ), Scan_2 AS ( SELECT Horsepower FROM car_1.cars_data ), Aggregate_3 AS ( SELECT MIN(Horsepower) AS Min_Horsepower FROM Scan_2 ), Scan_4 AS ( SELECT Cylinders, Horsepower, Id FROM car_1.cars_data WHERE Cylinders <= 3 ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Horsepower > Aggregate_3.Min_Horsepower ), Join_6 AS ( SELECT Scan_1.MakeId, Scan_1.Make FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
        "clean_query": "SELECT T2.MakeId , T2.Make FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T1.Horsepower > ( SELECT min ( Horsepower ) AS Min_Horsepower FROM car_1.CARS_DATA  ) AND T1.Cylinders < = 3",
        "qd": "#1 = Scan the table car_names and retrieve the make IDs and make names of all cars ; #2 = Scan the table cars_data and retrieve the horsepower of all cars ; #3 = Aggregate the minimum horsepower from #2 to find the lowest horsepower value among all cars ; #4 = Scan the table cars_data and retrieve the cylinders, horsepower, and IDs of all cars with 3 or less cylinders ; #5 = Join #3 and #4 based on the condition that the car's horsepower is greater than the lowest horsepower value ; #6 = Join #1 and #5 based on the matching IDs and retrieve the make IDs and make names of the cars that satisfy the conditions (more than lowest horsepower and less than or equal to 3 cylinders)"
    },
    {
        "id": "0d767c181e12d55eb4c6543cc27fd975df0309e40c6def682cfc56597fc5faed",
        "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?",
        "query": "select t2.makeid , t2.make FROM car_1.cars_data AS t1 WITH (FORCESCAN) join car_1.car_names as t2 WITH (FORCESCAN) on t1.id = t2.makeid where t1.horsepower > ( select min ( horsepower ) AS Min_horsepower FROM car_1.cars_data WITH (FORCESCAN) ) and t1.cylinders < 4  ",
        "qpl": "car_1 | #1 = Scan Table [ car_names ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Horsepower ] ; #3 = Aggregate [ #2 ] Output [ MIN(Horsepower) AS Min_Horsepower ] ; #4 = Scan Table [ cars_data ] Predicate [ Cylinders < 4 ] Output [ Cylinders , Horsepower , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Horsepower > #3.Min_Horsepower ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.MakeId , #1.Make ]",
        "cte": "WITH Scan_1 AS ( SELECT MakeId, Make FROM car_1.car_names ), Scan_2 AS ( SELECT Horsepower FROM car_1.cars_data ), Aggregate_3 AS ( SELECT MIN(Horsepower) AS Min_Horsepower FROM Scan_2 ), Scan_4 AS ( SELECT Cylinders, Horsepower, Id FROM car_1.cars_data WHERE Cylinders < 4 ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Horsepower > Aggregate_3.Min_Horsepower ), Join_6 AS ( SELECT Scan_1.MakeId, Scan_1.Make FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
        "clean_query": "select t2.makeid , t2.make FROM car_1.cars_data AS t1  join car_1.car_names as t2  on t1.id = t2.makeid where t1.horsepower > ( select min ( horsepower ) AS Min_horsepower FROM car_1.cars_data  ) and t1.cylinders < 4",
        "qd": "#1 = Scan the table car_names and retrieve the make ids and names of all cars ; #2 = Scan the table cars_data and retrieve the horsepower of all cars ; #3 = Find the minimum horsepower among all cars ; #4 = Scan the table cars_data and retrieve the cylinders, horsepower, and ids of all cars with less than 4 cylinders ; #5 = Join the minimum horsepower from #3 with #4 and retrieve the ids of cars that have horsepower greater than the minimum ; #6 = Join #1 and #5 based on the matching make id and retrieve the make ids and names of all cars that do not have the minimum horsepower and have less than 4 cylinders."
    },
    {
        "id": "95886c213cb2f796b359970764254b64bbe0314263e65f9fbaea1c469021457b",
        "question": "What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?",
        "query": "select max ( mpg ) AS Max_mpg FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 or year < 1980 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 OR Year < 1980 ] Output [ Year , Cylinders , MPG ] ; #2 = Aggregate [ #1 ] Output [ MAX(MPG) AS Max_MPG ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Cylinders, MPG FROM car_1.cars_data WHERE Cylinders = 8 OR Year < 1980 ), Aggregate_2 AS ( SELECT MAX(MPG) AS Max_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "select max ( mpg ) AS Max_mpg FROM car_1.cars_data  where cylinders = 8 or year < 1980",
        "qd": "#1 = Scan the table cars_data and retrieve the year, number of cylinders, and miles per gallon of all cars that have either 8 cylinders or were produced before 1980. ; #2 = Find the maximum miles per gallon among the records from #1 and identify it as the maximum miles per gallon of the car with 8 cylinders or produced before 1980."
    },
    {
        "id": "d59fc2b348e4322ab55b3c0602d3c7281523c59e6cdc25eeba00a219ed306068",
        "question": "What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980 ?",
        "query": "select max ( mpg ) AS Max_mpg FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 or year < 1980 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 OR Year < 1980 ] Output [ Year , Cylinders , MPG ] ; #2 = Aggregate [ #1 ] Output [ MAX(MPG) AS Max_MPG ]",
        "cte": "WITH Scan_1 AS ( SELECT Year, Cylinders, MPG FROM car_1.cars_data WHERE Cylinders = 8 OR Year < 1980 ), Aggregate_2 AS ( SELECT MAX(MPG) AS Max_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "select max ( mpg ) AS Max_mpg FROM car_1.cars_data  where cylinders = 8 or year < 1980",
        "qd": "#1 = Scan the table cars_data and retrieve the year, number of cylinders, and mpg of all the cars that have 8 cylinders or were produced before 1980 ; #2 = Calculate the maximum mpg from the records in #1 and return it as Max_MPG"
    },
    {
        "id": "b502c155fba512cabb54000e371ee35e6737c6de75d89889c83254465c86e8c4",
        "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?",
        "query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4 WITH (FORCESCAN) ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight < 3500 ] Output [ Weight , Id ] ; #2 = Scan Table [ car_makers ] Predicate [ FullName <> 'Ford Motor Company' ] Output [ FullName , Id ] ; #3 = Scan Table [ model_list ] Output [ Model , Maker ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.Maker ] Output [ #3.Model ] ; #5 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.MakeId , #4.Model ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.MakeId ] Distinct [ true ] Output [ #6.Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Weight, Id FROM car_1.cars_data WHERE Weight < 3500 ), Scan_2 AS ( SELECT FullName, Id FROM car_1.car_makers WHERE FullName <> 'Ford Motor Company' ), Scan_3 AS ( SELECT Model, Maker FROM car_1.model_list ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.Maker ), Scan_5 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_6 AS ( SELECT Scan_5.MakeId, Join_4.Model FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Join_6.Model FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.MakeId ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4  ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'",
        "qd": "#1 = Scan the table cars_data and retrieve the weight and IDs of all cars that are lighter than 3500 ; #2 = Scan the table car_makers and retrieve the full names and IDs of all car makers that are not the 'Ford Motor Company' ; #3 = Scan the table model_list and retrieve the models and makers of all cars ; #4 = Join #2 and #3 based on the matching IDs and retrieve the models ; #5 = Scan the table car_names and retrieve the make IDs and models of all cars ; #6 = Join #4 and #5 based on the matching models and retrieve the make IDs ; #7 = Join #1 and #6 based on the matching IDs and retrieve the models of all cars that are lighter than 3500 but not built by the 'Ford Motor Company'"
    },
    {
        "id": "16757dcf685a956d81ea88dce3aeca959bb39b0e7f5823e1d244ec45b8dc1448",
        "question": "What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?",
        "query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4 WITH (FORCESCAN) ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight < 3500 ] Output [ Weight , Id ] ; #2 = Scan Table [ car_makers ] Predicate [ FullName <> 'Ford Motor Company' ] Output [ FullName , Id ] ; #3 = Scan Table [ model_list ] Output [ Model , Maker ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.Maker ] Output [ #3.Model ] ; #5 = Scan Table [ car_names ] Output [ MakeId , Model ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.MakeId , #4.Model ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.MakeId ] Distinct [ true ] Output [ #6.Model ]",
        "cte": "WITH Scan_1 AS ( SELECT Weight, Id FROM car_1.cars_data WHERE Weight < 3500 ), Scan_2 AS ( SELECT FullName, Id FROM car_1.car_makers WHERE FullName <> 'Ford Motor Company' ), Scan_3 AS ( SELECT Model, Maker FROM car_1.model_list ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.Maker ), Scan_5 AS ( SELECT MakeId, Model FROM car_1.car_names ), Join_6 AS ( SELECT Scan_5.MakeId, Join_4.Model FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Join_6.Model FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.MakeId ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4  ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'",
        "qd": "#1 = Scan the table cars_data and retrieve the weights and IDs of cars that are lighter than 3500 ; #2 = Scan the table car_makers and retrieve the full names and IDs of car makers that are not Ford Motor Company ; #3 = Scan the table model_list and retrieve the models and makers of all car models ; #4 = Join #2 and #3 based on the matching IDs and retrieve the models of car makers that are not Ford Motor Company ; #5 = Scan the table car_names and retrieve the make IDs and models of all car names ; #6 = Join #4 and #5 based on the matching models and retrieve the make IDs of car models that were not built by Ford Motor Company ; #7 = Join #1 and #6 based on the matching IDs and retrieve the models of cars that are lighter than 3500 and were not built by Ford Motor Company"
    },
    {
        "id": "1e4db4c4de408f4f9be2225ed03040fed5bf6e86f840d6f753669492df7ee562",
        "question": "What are the name of the countries where there is not a single car maker?",
        "query": "SELECT CountryName FROM car_1.countries WITH (FORCESCAN) EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.countryId = T2.Country  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Distinct [ true ] Output [ CountryName ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.CountryName ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.CountryName = #4.CountryName ] Output [ #1.CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT CountryName FROM car_1.countries ), Scan_2 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.CountryName FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Except_5 AS ( SELECT Scan_1.CountryName FROM Scan_1 WHERE CountryName NOT IN (SELECT CountryName FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT CountryName FROM car_1.countries  EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.countryId = T2.Country",
        "qd": "#1 = Scan the table countries and retrieve the names of all countries without duplicates ; #2 = Scan the table countries and retrieve the country IDs and names of all countries ; #3 = Scan the table car_makers and retrieve the country names of all car makers ; #4 = Join #2 and #3 based on the matching country IDs and retrieve the country names ; #5 = Return the country names that are in #1 but not in #4 to find the names of the countries where there is not a single car maker"
    },
    {
        "id": "db474200659b4d04abc94f233be2174f0b5d7bad40e32821c04983268be79774",
        "question": "What are the names of the countries with no car makers?",
        "query": "SELECT CountryName FROM car_1.countries WITH (FORCESCAN) EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.countryId = T2.Country  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Distinct [ true ] Output [ CountryName ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.CountryName ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.CountryName = #4.CountryName ] Output [ #1.CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT CountryName FROM car_1.countries ), Scan_2 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.CountryName FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Except_5 AS ( SELECT Scan_1.CountryName FROM Scan_1 WHERE CountryName NOT IN (SELECT CountryName FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT CountryName FROM car_1.countries  EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.countryId = T2.Country",
        "qd": "#1 = Scan the table countries and retrieve the distinct country names ; #2 = Scan the table countries and retrieve all the country names and ids ; #3 = Scan the table car_makers and retrieve the country names where car makers exist ; #4 = Join #2 and #3 based on the matching country ids and retrieve the country names ; #5 = Return all the country names from #1 that are not present in #4 to find the names of the countries with no car makers"
    },
    {
        "id": "fefb38b1e47ce56411e8d791f7aff3e81d9c58f99f39beffa4c2b2146f8950a6",
        "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .",
        "query": "select t1.id , t1.maker FROM car_1.car_makers AS t1 WITH (FORCESCAN) join car_1.model_list as t2 WITH (FORCESCAN) on t1.id = t2.maker group by t1.id , t1.maker having count ( * ) >= 2 intersect select t1.id , t1.maker FROM car_1.car_makers AS t1 WITH (FORCESCAN) join car_1.model_list as t2 WITH (FORCESCAN) on t1.id = t2.maker join car_1.car_names as t3 WITH (FORCESCAN) on t2.model = t3.model group by t1.id , t1.maker having count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.Id , #2.Count_Star , #3.Maker ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Maker , Id ] ; #6 = Scan Table [ model_list ] Output [ Model , Maker ] ; #7 = Scan Table [ car_names ] Output [ Model ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Model = #7.Model ] Output [ #6.Maker ] ; #9 = Aggregate [ #8 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #10 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #11 = Join [ #9 , #10 ] Predicate [ #9.Maker = #10.Id ] Output [ #10.Maker , #10.Id , #9.Count_Star ] ; #12 = Filter [ #11 ] Predicate [ Count_Star > 3 ] Output [ Maker , Id ] ; #13 = Join [ #5 , #12 ] Predicate [ #5.Id = #12.Id ] Output [ #5.Maker , #5.Id ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.Id, Aggregate_2.Count_Star, Scan_3.Maker FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT Maker, Id FROM Join_4 WHERE Count_Star >= 2 ), Scan_6 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_7 AS ( SELECT Model FROM car_1.car_names ), Join_8 AS ( SELECT Scan_6.Maker FROM Scan_6 JOIN Scan_7 ON Scan_6.Model = Scan_7.Model ), Aggregate_9 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Join_8 GROUP BY Maker ), Scan_10 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_11 AS ( SELECT Scan_10.Maker, Scan_10.Id, Aggregate_9.Count_Star FROM Aggregate_9 JOIN Scan_10 ON Aggregate_9.Maker = Scan_10.Id ), Filter_12 AS ( SELECT Maker, Id FROM Join_11 WHERE Count_Star > 3 ), Join_13 AS ( SELECT Filter_5.Maker, Filter_5.Id FROM Filter_5 JOIN Filter_12 ON Filter_5.Id = Filter_12.Id ) SELECT * FROM Join_13",
        "clean_query": "select t1.id , t1.maker FROM car_1.car_makers AS t1  join car_1.model_list as t2  on t1.id = t2.maker group by t1.id , t1.maker having count ( * ) >= 2 intersect select t1.id , t1.maker FROM car_1.car_makers AS t1  join car_1.model_list as t2  on t1.id = t2.maker join car_1.car_names as t3  on t2.model = t3.model group by t1.id , t1.maker having count ( * ) > 3",
        "qd": "#1 = Scan the table model_list and retrieve the names of all car makers ; #2 = Group the car makers from #1 and aggregate the count of models produced by each car maker ; #3 = Scan the table car_makers and retrieve the ids and names of all car makers ; #4 = Join #2 and #3 based on the matching car maker names and retrieve the ids, counts, and names of car makers ; #5 = Filter the records from #4 to only include car makers with at least 2 models ; #6 = Scan the table model_list and retrieve the models and car makers ; #7 = Scan the table car_names and retrieve the models ; #8 = Join #6 and #7 based on the matching models and retrieve the car makers ; #9 = Group the car makers from #8 and aggregate the count of models produced by each car maker ; #10 = Scan the table car_makers and retrieve the ids and names of all car makers ; #11 = Join #9 and #10 based on the matching car maker names and retrieve the ids, counts, and names of car makers ; #12 = Filter the records from #11 to only include car makers with more than 3 models ; #13 = Join #5 and #12 based on the matching car maker ids and retrieve the car makers and ids"
    },
    {
        "id": "29238520da091881c4e7a017b6177cb764df61f4b23ba7e2bdb8786955bd3ad8",
        "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?",
        "query": "SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.Id , T1.Maker HAVING count ( * ) > = 2 INTERSECT SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3 WITH (FORCESCAN) ON T2.model = T3.model GROUP BY T1.Id , T1.Maker HAVING count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.Id , #2.Count_Star , #3.Maker ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Maker , Id ] ; #6 = Scan Table [ model_list ] Output [ Model , Maker ] ; #7 = Scan Table [ car_names ] Output [ Model ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Model = #7.Model ] Output [ #6.Maker ] ; #9 = Aggregate [ #8 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #10 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #11 = Join [ #9 , #10 ] Predicate [ #9.Maker = #10.Id ] Output [ #10.Maker , #10.Id , #9.Count_Star ] ; #12 = Filter [ #11 ] Predicate [ Count_Star > 3 ] Output [ Maker , Id ] ; #13 = Join [ #5 , #12 ] Predicate [ #5.Id = #12.Id ] Output [ #5.Maker , #5.Id ]",
        "cte": "WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.Id, Aggregate_2.Count_Star, Scan_3.Maker FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT Maker, Id FROM Join_4 WHERE Count_Star >= 2 ), Scan_6 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_7 AS ( SELECT Model FROM car_1.car_names ), Join_8 AS ( SELECT Scan_6.Maker FROM Scan_6 JOIN Scan_7 ON Scan_6.Model = Scan_7.Model ), Aggregate_9 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Join_8 GROUP BY Maker ), Scan_10 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_11 AS ( SELECT Scan_10.Maker, Scan_10.Id, Aggregate_9.Count_Star FROM Aggregate_9 JOIN Scan_10 ON Aggregate_9.Maker = Scan_10.Id ), Filter_12 AS ( SELECT Maker, Id FROM Join_11 WHERE Count_Star > 3 ), Join_13 AS ( SELECT Filter_5.Maker, Filter_5.Id FROM Filter_5 JOIN Filter_12 ON Filter_5.Id = Filter_12.Id ) SELECT * FROM Join_13",
        "clean_query": "SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.Id , T1.Maker HAVING count ( * ) > = 2 INTERSECT SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3  ON T2.model = T3.model GROUP BY T1.Id , T1.Maker HAVING count ( * ) > 3",
        "qd": "#1 = Scan the table model_list and retrieve the makers of all car models ; #2 = Group the records from #1 by maker and aggregate the count per maker ; #3 = Scan the table car_makers and retrieve the makers and ids of all car makers ; #4 = Join #2 and #3 based on the matching maker and id and retrieve the ids, count of models per maker, and makers ; #5 = Filter the records from #4 to include only the makers with at least 2 models ; #6 = Scan the table model_list and retrieve the models and makers of all car models ; #7 = Scan the table car_names and retrieve all the models ; #8 = Join #6 and #7 based on the matching model and retrieve the makers ; #9 = Group the records from #8 by maker and aggregate the count per maker ; #10 = Scan the table car_makers and retrieve the makers and ids of all car makers ; #11 = Join #9 and #10 based on the matching maker and id and retrieve the makers, ids, and count of cars per maker ; #12 = Filter the records from #11 to include only the makers with more than 3 cars ; #13 = Join #5 and #12 based on the matching id and retrieve the makers and ids"
    },
    {
        "id": "f23d812f404ef6bef6297f48075b5a591f9c60c9f97f36861c9b5abce2350a5f",
        "question": "What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?",
        "query": "SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country GROUP BY T1.countryId , T1.CountryName HAVING count ( * ) > 3 UNION SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country JOIN car_1.MODEL_LIST AS T3 WITH (FORCESCAN) ON T2.Id = T3.Maker WHERE T3.Model = 'fiat'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] GroupBy [ CountryId ] Output [ CountryId , countstar AS Count_Star , CountryName ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ CountryId , CountryName ] ; #6 = Scan Table [ model_list ] Predicate [ Model = 'fiat' ] Output [ Model , Maker ] ; #7 = Scan Table [ car_makers ] Output [ Country , Id ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Maker = #7.Id ] Output [ #7.Country ] ; #9 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.Country = #9.CountryId ] Output [ #9.CountryId , #9.CountryName ] ; #11 = Union [ #5 , #10 ] Output [ #5.CountryId , #5.CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT CountryId, COUNT(*) AS Count_Star, CountryName FROM Join_3 GROUP BY CountryName, CountryId ), Filter_5 AS ( SELECT CountryId, CountryName FROM Aggregate_4 WHERE Count_Star > 3 ), Scan_6 AS ( SELECT Model, Maker FROM car_1.model_list WHERE Model = 'fiat' ), Scan_7 AS ( SELECT Country, Id FROM car_1.car_makers ), Join_8 AS ( SELECT Scan_7.Country FROM Scan_6 JOIN Scan_7 ON Scan_6.Maker = Scan_7.Id ), Scan_9 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_10 AS ( SELECT Scan_9.CountryId, Scan_9.CountryName FROM Join_8 JOIN Scan_9 ON Join_8.Country = Scan_9.CountryId ), Union_11 AS ( SELECT CountryId, CountryName FROM Filter_5 UNION SELECT CountryId, CountryName FROM Join_10 ) SELECT * FROM Union_11",
        "clean_query": "SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country GROUP BY T1.countryId , T1.CountryName HAVING count ( * ) > 3 UNION SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country JOIN car_1.MODEL_LIST AS T3  ON T2.Id = T3.Maker WHERE T3.Model = 'fiat'",
        "qd": "#1 = Scan the table countries to retrieve the country IDs and names of all countries ; #2 = Scan the table car_makers to retrieve the country names of all car makers ; #3 = Join #1 and #2 based on the matching country IDs and retrieve the country IDs and names ; #4 = Group #3 by country ID and aggregate the count of records to find the number of car makers per country ; #5 = Filter the records from #4 to retrieve the country IDs and names of countries with more than 3 car makers ; #6 = Scan the table model_list and retrieve the model and maker of the 'fiat' model ; #7 = Scan the table car_makers and retrieve the country names of all car makers ; #8 = Join #6 and #7 based on the matching car maker IDs and retrieve the country names ; #9 = Scan the table countries and retrieve the country IDs and names of all countries ; #10 = Join #8 and #9 based on the matching country IDs and retrieve the country IDs and names ; #11 = Union #5 and #10 to retrieve the country IDs and names of countries with more than 3 car makers or produce the 'fiat' model"
    },
    {
        "id": "16a6e522cfd501f609c46856f658cfd95b8ef2517b7ad60ecc032807076c99ac",
        "question": "What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?",
        "query": "select t1.countryid , t1.countryname FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country group by t1.countryid , t1.countryname having count ( * ) > 3 union select t1.countryid , t1.countryname FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country join car_1.model_list as t3 WITH (FORCESCAN) on t2.id = t3.maker where t3.model = 'fiat'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "car_1 | #1 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] GroupBy [ CountryId ] Output [ CountryId , countstar AS Count_Star , CountryName ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ CountryId , CountryName ] ; #6 = Scan Table [ model_list ] Predicate [ Model = 'fiat' ] Output [ Model , Maker ] ; #7 = Scan Table [ car_makers ] Output [ Country , Id ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Maker = #7.Id ] Output [ #7.Country ] ; #9 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.Country = #9.CountryId ] Output [ #9.CountryId , #9.CountryName ] ; #11 = Union [ #5 , #10 ] Output [ #5.CountryId , #5.CountryName ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT CountryId, COUNT(*) AS Count_Star, CountryName FROM Join_3 GROUP BY CountryName, CountryId ), Filter_5 AS ( SELECT CountryId, CountryName FROM Aggregate_4 WHERE Count_Star > 3 ), Scan_6 AS ( SELECT Model, Maker FROM car_1.model_list WHERE Model = 'fiat' ), Scan_7 AS ( SELECT Country, Id FROM car_1.car_makers ), Join_8 AS ( SELECT Scan_7.Country FROM Scan_6 JOIN Scan_7 ON Scan_6.Maker = Scan_7.Id ), Scan_9 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_10 AS ( SELECT Scan_9.CountryId, Scan_9.CountryName FROM Join_8 JOIN Scan_9 ON Join_8.Country = Scan_9.CountryId ), Union_11 AS ( SELECT CountryId, CountryName FROM Filter_5 UNION SELECT CountryId, CountryName FROM Join_10 ) SELECT * FROM Union_11",
        "clean_query": "select t1.countryid , t1.countryname FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country group by t1.countryid , t1.countryname having count ( * ) > 3 union select t1.countryid , t1.countryname FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country join car_1.model_list as t3  on t2.id = t3.maker where t3.model = 'fiat'",
        "qd": "#1 = Scan the table countries and retrieve the country IDs and names of all countries. ; #2 = Scan the table car_makers and retrieve the country field. ; #3 = Join #1 and #2 based on the matching country ID and retrieve the country IDs and names. ; #4 = Group #3 by country ID and aggregate the count of records per country ID and retrieve the country IDs, count of car makers, and names. ; #5 = Filter out the records from #4 where the count of car makers is greater than 3 and retrieve the country IDs and names. ; #6 = Scan the table model_list and retrieve the models and makers where the model is 'fiat'. ; #7 = Scan the table car_makers and retrieve the country and IDs. ; #8 = Join #6 and #7 based on the matching maker and ID and retrieve the countries. ; #9 = Scan the table countries and retrieve the country IDs and names of all countries. ; #10 = Join #8 and #9 based on the matching country and country ID and retrieve the country IDs and names. ; #11 = Union #5 and #10 and retrieve the country IDs and names."
    },
    {
        "id": "36a2157fcc813e6a8d142d9e19e8471df3c97f9c4b89b1093f70b6d30255a382",
        "question": "Which country does Airline \"JetBlue Airways\" belong to?",
        "query": "SELECT Country FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Country FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Country FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'",
        "qd": "#1 = Scan the table airlines to find the country of the airline \"JetBlue Airways\"."
    },
    {
        "id": "5f4c7f4307ad324c6bd8b44a5c91d45d8fa3f854c9b23f17d5fae490193e1363",
        "question": "What country is Jetblue Airways affiliated with?",
        "query": "SELECT Country FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Country FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Country FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'",
        "qd": "#1 = Scan the table airlines and retrieve the country of the airline JetBlue Airways to find the country it is affiliated with."
    },
    {
        "id": "7f56858bb93fce00274ad7fc93c7c106d09905596af081d93d544e02731db6c4",
        "question": "What is the abbreviation of Airline \"JetBlue Airways\"?",
        "query": "SELECT Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Abbreviation ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Abbreviation FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'",
        "qd": "#1 = Scan the table airlines and retrieve the abbreviation of the airline \"JetBlue Airways\""
    },
    {
        "id": "b382a94261c2999cc724820561e70e7fc4fdab26b2e6c4e0a72ac715977e5ef4",
        "question": "Which abbreviation corresponds to Jetblue Airways?",
        "query": "SELECT Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Abbreviation ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Abbreviation FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'",
        "qd": "#1 = Scan the table airlines and retrieve the abbreviation of JetBlue Airways."
    },
    {
        "id": "f69a450ed479db5ca5b690ab618f69a33863fef823c823cb818121c200280fbd",
        "question": "List all airline names and their abbreviations in \"USA\".",
        "query": "SELECT Airline , Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Airline , Abbreviation , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Abbreviation, Country FROM flight_2.airlines WHERE Country = 'USA' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Airline , Abbreviation FROM flight_2.AIRLINES  WHERE Country = 'USA'",
        "qd": "#1 = Scan the table airlines to find all the airline names and their abbreviations in the USA."
    },
    {
        "id": "daecf9f7334ab07a6861fe88b0db2d042b3d0baf22049a3c90c953ebd630e9a0",
        "question": "What are the airline names and abbreviations for airlines in the USA?",
        "query": "SELECT Airline , Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Airline , Abbreviation , Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Abbreviation, Country FROM flight_2.airlines WHERE Country = 'USA' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Airline , Abbreviation FROM flight_2.AIRLINES  WHERE Country = 'USA'",
        "qd": "#1 = Scan the table airlines and retrieve the airline names and abbreviations for airlines in the USA"
    },
    {
        "id": "8fee41930419ed1b60bc8a03182d24c4aef408f9fe3d3042d5197c827080bfb9",
        "question": "List the airport code and name in the city of Anthony.",
        "query": "SELECT AirportCode , AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE city = 'Anthony' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Anthony' ] Output [ AirportCode , City , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City, AirportName FROM flight_2.airports WHERE City = 'Anthony' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT AirportCode , AirportName FROM flight_2.AIRPORTS  WHERE city = 'Anthony'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and names in the city of Anthony."
    },
    {
        "id": "5c334eae39a83d351071183963010a8ed84b530e462431cf43876e0ced4fed9a",
        "question": "Give the airport code and airport name corresonding to the city Anthony.",
        "query": "SELECT AirportCode , AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE city = 'Anthony' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Anthony' ] Output [ AirportCode , City , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City, AirportName FROM flight_2.airports WHERE City = 'Anthony' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT AirportCode , AirportName FROM flight_2.AIRPORTS  WHERE city = 'Anthony'",
        "qd": "#1 = Scan the table airports and retrieve the airport code and airport name of the city Anthony."
    },
    {
        "id": "369b5b7dbc8e97b2da310dc1ef97a060a3abec21242176afd9b5b8dcbcad5ff7",
        "question": "How many airlines do we have?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airlines ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES",
        "qd": "#1 = Scan the table airlines and retrieve a constant value of 1 for each record ; #2 = Aggregate the number of records from #1 to find the total count of airlines"
    },
    {
        "id": "063b8bcdd6c9ad73b186d5c9b6447dec9581ac1841a4485b9badd7e27ae84b9b",
        "question": "What is the total number of airlines?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airlines ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES",
        "qd": "#1 = Scan the table airlines and retrieve a constant value of 1 for each record ; #2 = Aggregate the records from #1 and count the number of records to find the total number of airlines"
    },
    {
        "id": "3e300a389805c802468ed78e0375595f808905a65d3a714dca27a4605afb5dde",
        "question": "How many airports do we have?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airports ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS",
        "qd": "#1 = Scan the table airports and retrieve all the records ; #2 = Aggregate the number of records from #1 to find the count of airports"
    },
    {
        "id": "4d65558cfbe559672e157d5e7ec80e6e78aebc27437ce33f926d48eb593f03c9",
        "question": "Return the number of  airports.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airports ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS",
        "qd": "#1 = Scan the table airports and retrieve the value 1 for each row ; #2 = Aggregate the number of rows in #1 to find the total number of airports"
    },
    {
        "id": "c1fd6f38135cfcb534461b08b25144826b8cbc55904aa39bf3f6cb55a584b206",
        "question": "How many flights do we have?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS",
        "qd": "#1 = Scan the table flights and retrieve a constant value of 1 for each flight ; #2 = Aggregate the number of records from #1 and retrieve the count of flights"
    },
    {
        "id": "279d2d1be85f34d2c0d188a4a33ed356a3ad63f477e61581ca597812edee5c28",
        "question": "Return the number of flights.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS",
        "qd": "#1 = Scan the table flights to retrieve all flights ; #2 = Aggregate the number of records from #1 to get the total number of flights"
    },
    {
        "id": "fad45b9bc7573cd69e8c13a9273a0663dd75d1bbfa334582e5a7ec673bf88e6d",
        "question": "Which airline has abbreviation 'UAL'?",
        "query": "SELECT Airline FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Abbreviation = 'UAL' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Abbreviation = 'UAL' ] Output [ Airline , Abbreviation ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Abbreviation = 'UAL' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Airline FROM flight_2.AIRLINES  WHERE Abbreviation = 'UAL'",
        "qd": "#1 = Scan the table airlines and retrieve the airline name and abbreviation where the abbreviation is 'UAL'."
    },
    {
        "id": "e2659b87d4a1e361b740b5e13188af89e0b4328076dd99f6a06de5b1b94b5523",
        "question": "Give the airline with abbreviation 'UAL'.",
        "query": "SELECT Airline FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Abbreviation = 'UAL' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Abbreviation = 'UAL' ] Output [ Airline , Abbreviation ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Abbreviation = 'UAL' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Airline FROM flight_2.AIRLINES  WHERE Abbreviation = 'UAL'",
        "qd": "#1 = Scan the table airlines and retrieve the name and abbreviation of the airline with the abbreviation 'UAL'."
    },
    {
        "id": "b8e73cdb60d918375ac05b729ae481ecc9d1efb4140ab54400235c695a03b096",
        "question": "How many airlines are from USA?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Country ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM flight_2.airlines WHERE Country = 'USA' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES  WHERE Country = 'USA'",
        "qd": "#1 = Scan the table airlines and retrieve the countries of all airlines ; #2 = Filter from #1 all the airlines with the country as USA and count the number of records"
    },
    {
        "id": "66b83582e021b8db08e2b4d08c135401f2b5f33950791e8cd6590d2f7ead0857",
        "question": "Return the number of airlines in the USA.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Country ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM flight_2.airlines WHERE Country = 'USA' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES  WHERE Country = 'USA'",
        "qd": "#1 = Scan the table airlines and retrieve the country of all airlines in the USA ; #2 = Aggregate the number of records of #1 and return the count of airlines in the USA"
    },
    {
        "id": "ad9d7210fdfd7165816e6492d93dd1e6f8473cf6c35e401f46ded2de93952e94",
        "question": "Which city and country is the Alton airport at?",
        "query": "SELECT City , Country FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportName = 'Alton' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportName = 'Alton' ] Output [ Country , City , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT Country, City, AirportName FROM flight_2.airports WHERE AirportName = 'Alton' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT City , Country FROM flight_2.AIRPORTS  WHERE AirportName = 'Alton'",
        "qd": "#1 = Scan the table airports and retrieve the city and country where the airport with the name \"Alton\" is located."
    },
    {
        "id": "5f82ac520562e0e693c6f75f18091b5e35fc74ee85c8bff66446e0bc61cdf85c",
        "question": "Give the city and country for the Alton airport.",
        "query": "SELECT City , Country FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportName = 'Alton' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportName = 'Alton' ] Output [ Country , City , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT Country, City, AirportName FROM flight_2.airports WHERE AirportName = 'Alton' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT City , Country FROM flight_2.AIRPORTS  WHERE AirportName = 'Alton'",
        "qd": "#1 = Scan the table airports and retrieve the country and city of the Alton airport."
    },
    {
        "id": "11e3dfccf0adfb124a6c25b1db3b111936b727842d24ab609fcd295a69fc760d",
        "question": "What is the airport name for airport 'AKO'?",
        "query": "SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportCode = 'AKO' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportCode = 'AKO' ] Output [ AirportCode , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, AirportName FROM flight_2.airports WHERE AirportCode = 'AKO' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT AirportName FROM flight_2.AIRPORTS  WHERE AirportCode = 'AKO'",
        "qd": "#1 = Scan the table airports to find the airport name for the airport with code 'AKO'"
    },
    {
        "id": "0617e10465be92424cb8e6ad6c98682473571d33e1ce56d7ccc259123ce41d1d",
        "question": "Return the name of the airport with code 'AKO'.",
        "query": "SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportCode = 'AKO' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportCode = 'AKO' ] Output [ AirportCode , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, AirportName FROM flight_2.airports WHERE AirportCode = 'AKO' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT AirportName FROM flight_2.AIRPORTS  WHERE AirportCode = 'AKO'",
        "qd": "#1 = Scan the table airports and retrieve the airport code and name of the airport with code 'AKO'."
    },
    {
        "id": "ceb36e3b14327b223ca847535d4c11f45241bc16d511bf03380079252a63b090",
        "question": "What are airport names at City 'Aberdeen'?",
        "query": "SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT City, AirportName FROM flight_2.airports WHERE City = 'Aberdeen' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT AirportName FROM flight_2.AIRPORTS  WHERE City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the airport names of all the airports in the city 'Aberdeen'."
    },
    {
        "id": "40e1f4c8aa7834d57bb2f331fb09534635a3c5fdb5ad6f142eec15b1f995b7ea",
        "question": "What are the names of airports in Aberdeen?",
        "query": "SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT City, AirportName FROM flight_2.airports WHERE City = 'Aberdeen' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT AirportName FROM flight_2.AIRPORTS  WHERE City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the city and airport name of all airports in Aberdeen."
    },
    {
        "id": "ec3405477794812934b51e5ea9d4aab5a905af1006960ad3d39101b5ccc2a6d4",
        "question": "How many flights depart from 'APG'?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'",
        "qd": "#1 = Scan the table flights and retrieve the source airport code of all flights that depart from 'APG'. ; #2 = Aggregate the count of records from #1 to find the number of flights that depart from 'APG'."
    },
    {
        "id": "5d72b16fa2cfb69617732597bc76509ba7d67eb30a250fc04d538e1c037127ec",
        "question": "Count the number of flights departing from 'APG'.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'",
        "qd": "#1 = Scan the table flights to find all flights that depart from 'APG' ; #2 = Aggregate the number of records from #1 to count the number of flights departing from 'APG'"
    },
    {
        "id": "5ebbb73a6afdbdb2974b2656c82d7299272d0e92e8831f62b3bbdbf3c4f63d21",
        "question": "How many flights have destination ATO?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'ATO' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'ATO' ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights WHERE DestAirport = 'ATO' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE DestAirport = 'ATO'",
        "qd": "#1 = Scan the table flights and find all flights with destination ATO ; #2 = Aggregate the count of all flights with destination ATO to find the total number of flights"
    },
    {
        "id": "856fdf46f76eb38b3c95693281ff5fed72655659ac9ba441d820e7ef6a1675dd",
        "question": "Count the number of flights into ATO.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'ATO' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'ATO' ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights WHERE DestAirport = 'ATO' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE DestAirport = 'ATO'",
        "qd": "#1 = Scan the table flights and retrieve the destination airports of all flights to ATO ; #2 = Aggregate the number of records from #1 to find the count of flights into ATO"
    },
    {
        "id": "4dfb9f3bd2fd30f32394562225b6b6d5eb3ec4532cc089f93fa37897071f826f",
        "question": "How many flights depart from City Aberdeen?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #1.City , #1.AirportCode ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and cities of all airports in Aberdeen ; #2 = Scan the table flights and retrieve the source airports of all flights ; #3 = Join #1 and #2 based on the matching airport code and retrieve the cities and airport codes ; #4 = Aggregate the number of records in #3 to find how many flights depart from City Aberdeen."
    },
    {
        "id": "c642fd4df84252e3f94cc6a8622ebd176aac937469bde1ca03f02bb88852b44a",
        "question": "Return the number of flights departing from Aberdeen.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #1.City , #1.AirportCode ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and city names of all airports in Aberdeen ; #2 = Scan the table flights and retrieve the source airports of all flights ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the city names and airport codes ; #4 = Aggregate the number of records in #3 to find the count of flights departing from Aberdeen"
    },
    {
        "id": "b77fa3b8526203bcd90c712fdbdee81795d22020a91667f2c3c3d49f348b347a",
        "question": "How many flights arriving in Aberdeen city?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.City , #1.AirportCode ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports to find the airport code and city of Aberdeen ; #2 = Scan the table flights to find the destination airports of all flights ; #3 = Join #1 and #2 based on the matching airport code and retrieve the city and airport code ; #4 = Aggregate the count of the records in #3 to find the number of flights arriving in Aberdeen city"
    },
    {
        "id": "596abcb0d56950837aea86f86897c9ec4d944f77fb56712c19b06aca08b5ab81",
        "question": "Return the number of flights arriving in Aberdeen.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.City , #1.AirportCode ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the airport code and city for all airports in Aberdeen. ; #2 = Scan the table flights and retrieve the destination airport for all flights. ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the city and airport code. ; #4 = Aggregate the count of records from #3 to find the number of flights arriving in Aberdeen."
    },
    {
        "id": "a86a96d3e0f4b6052d11149f8f2da48ab46dbd0cc3e8d64f456496fb96dff6f4",
        "question": "How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3 WITH (FORCESCAN) ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ airports ] Predicate [ City = 'Ashley' ] Output [ AirportCode , City ] ; #3 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.AirportCode = #3.DestAirport ] Output [ #3.SourceAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.SourceAirport ] Output [ #1.City , #1.AirportCode ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Ashley' ), Scan_3 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.SourceAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.AirportCode = Scan_3.DestAirport ), Join_5 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.SourceAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3  ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and find the airport with the city 'Aberdeen' and retrieve the airport code and city. ; #2 = Scan the table airports and find the airport with the city 'Ashley' and retrieve the airport code and city. ; #3 = Scan the table flights and retrieve the source airport and destination airport of all flights. ; #4 = Join #2 and #3 based on the matching destination airport and retrieve the source airport. ; #5 = Join #1 and #4 based on the matching airport code and retrieve the city and airport code. ; #6 = Aggregate the number of records in #5 to find how many flights depart from city 'Aberdeen' and have the destination city 'Ashley'."
    },
    {
        "id": "de87fcf74f2799bbaa79f8e759e47daa3b68377e6f8715ad9ca101b761546bed",
        "question": "How many flights fly from Aberdeen to Ashley?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3 WITH (FORCESCAN) ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ airports ] Predicate [ City = 'Ashley' ] Output [ AirportCode , City ] ; #3 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.AirportCode = #3.DestAirport ] Output [ #3.SourceAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.SourceAirport ] Output [ #1.City , #1.AirportCode ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Ashley' ), Scan_3 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.SourceAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.AirportCode = Scan_3.DestAirport ), Join_5 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.SourceAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3  ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes, cities of all airports in Aberdeen ; #2 = Scan the table airports and retrieve the airport codes, cities of all airports in Ashley ; #3 = Scan the table flights and retrieve the source airport and destination airport of all flights ; #4 = Join #2 and #3 based on the matching destination airport and retrieve the source airport ; #5 = Join #1 and #4 based on the matching airport code and retrieve the cities, airport codes of the flights from Aberdeen to Ashley ; #6 = Aggregate the count of all flights from #5"
    },
    {
        "id": "1f310f5bbbc32f27959b1948e0a2b55cc6d6ab439f95fa18d2a151873b24edf2",
        "question": "How many flights does airline 'JetBlue Airways' have?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ uid ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT uid FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'",
        "qd": "#1 = Scan the table airlines and retrieve the unique identifier of the 'JetBlue Airways' airline ; #2 = Scan the table flights and retrieve the airline of all flights ; #3 = Join #1 and #2 based on the matching unique identifier and retrieve the unique identifier of the 'JetBlue Airways' airline ; #4 = Aggregate the number of records from #3 to find the number of flights of the 'JetBlue Airways' airline"
    },
    {
        "id": "b3a92bd00df018276c532ac506f498a4aab18fc78bd5e5c233593b3d0919d6e3",
        "question": "Give the number of Jetblue Airways flights.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ uid ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT uid FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'",
        "qd": "#1 = Scan the table airlines to find the uid of JetBlue Airways ; #2 = Scan the table flights and retrieve the airline names ; #3 = Join the results from #1 and #2 based on the matching airline names, and retrieve the uids of JetBlue Airways flights ; #4 = Aggregate the count of records from #3 to find the number of JetBlue Airways flights"
    },
    {
        "id": "e5944abdcf96b6c445082d7c73904e1a558fcf3e470659bf41d44f19d8842244",
        "question": "How many 'United Airlines' flights go to Airport 'ASY'?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ DestAirport = 'ASY' ] Output [ Airline , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid , #1.Airline ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'ASY' ), Join_3 AS ( SELECT Scan_1.uid, Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'",
        "qd": "#1 = Scan the table airlines and retrieve the UID and name of all airlines with the name 'United Airlines' ; #2 = Scan the table flights and retrieve the airline and destination airport code for all flights going to airport 'ASY' ; #3 = Join #1 and #2 based on the matching UID and airline and retrieve the UID and airline name ; #4 = Aggregate the number of records in #3 to find the count of 'United Airlines' flights going to airport 'ASY'"
    },
    {
        "id": "6fcf089875e01f63af8f84cf31cc2e94508fb7a057790cb893544b2c05054445",
        "question": "Count the number of United Airlines flights arriving in ASY Airport.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ DestAirport = 'ASY' ] Output [ Airline , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid , #1.Airline ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'ASY' ), Join_3 AS ( SELECT Scan_1.uid, Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'",
        "qd": "#1 = Scan the table airlines and retrieve the airline and unique identifier of United Airlines ; #2 = Scan the table flights and retrieve the airline and destination airport of all flights arriving at ASY Airport ; #3 = Join #1 and #2 based on the matching unique identifier and airline, retrieve the unique identifier and airline of United Airlines flights arriving at ASY Airport ; #4 = Aggregate the number of records in #3 to count the number of United Airlines flights arriving at ASY Airport"
    },
    {
        "id": "d50de1020d3dcee5416196b209cf716fef84d0120bf108e9619ecbca20df62a3",
        "question": "How many 'United Airlines' flights depart from Airport 'AHD'?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid , #1.Airline ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Join_3 AS ( SELECT Scan_1.uid, Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD'",
        "qd": "#1 = Scan the table airlines and retrieve the airline and unique identifier (uid) of all United Airlines flights ; #2 = Scan the table flights and retrieve the airline and source airport of all flights departing from airport AHD ; #3 = Join #1 and #2 based on the matching uid and airline, and retrieve the unique identifier and airline name for flights departing from airport AHD ; #4 = Aggregate the count of all records from #3 to find the number of United Airlines flights that depart from airport AHD."
    },
    {
        "id": "93c0a5389ccc0e73693c2bcf4e1766badd062d038814a9442c11b9dc37fda3bc",
        "question": "Return the number of United Airlines flights leaving from AHD Airport.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid , #1.Airline ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Join_3 AS ( SELECT Scan_1.uid, Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD'",
        "qd": "#1 = Scan the table airlines to find the airline with the name 'United Airlines' ; #2 = Scan the table flights to find all flights with the source airport 'AHD' ; #3 = Join #1 and #2 based on the matching airline ID and retrieve the airline ID and airline name ; #4 = Aggregate the count of records from #3 to find the number of United Airlines flights leaving from AHD airport"
    },
    {
        "id": "fc7d50c7b91da6ea233b30b07836fcf085ac0fcc1678f271d0c50c3ccb040ab8",
        "question": "How many United Airlines flights go to City 'Aberdeen'?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3 WITH (FORCESCAN) ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #3 = Scan Table [ flights ] Output [ Airline , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.uid = #3.Airline ] Output [ #3.DestAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.DestAirport ] Output [ #1.City , #1.AirportCode ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_3 AS ( SELECT Airline, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.DestAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.uid = Scan_3.Airline ), Join_5 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.DestAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3  ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'",
        "qd": "#1 = Scan the table airports and retrieve the airport code and city of all airports in Aberdeen ; #2 = Scan the table airlines and retrieve the airline and unique ID of all United Airlines flights ; #3 = Scan the table flights and retrieve the airline and destination airport code of all flights ; #4 = Join #2 and #3 based on the matching unique ID and airline and retrieve the destination airport codes ; #5 = Join #1 and #4 based on the matching airport code and destination airport code and retrieve the cities and airport codes ; #6 = Aggregate the number of records from #5 to find the count of United Airlines flights that go to Aberdeen city"
    },
    {
        "id": "fb9f62e205b9bc6880b700da1dceb69b1975fb77e0c9ffce400ce0446e38b582",
        "question": "Count the number of United Airlines flights that arrive in Aberdeen.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3 WITH (FORCESCAN) ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #3 = Scan Table [ flights ] Output [ Airline , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.uid = #3.Airline ] Output [ #3.DestAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.DestAirport ] Output [ #1.City , #1.AirportCode ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_3 AS ( SELECT Airline, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.DestAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.uid = Scan_3.Airline ), Join_5 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.DestAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3  ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'",
        "qd": "#1 = Scan the table airports and retrieve the airport code and city of Aberdeen ; #2 = Scan the table airlines and retrieve the airline and unique identifier of United Airlines ; #3 = Scan the table flights and retrieve the airline and destination airport of all flights ; #4 = Join #2 and #3 based on the matching airline and retrieve the destination airports of United Airlines flights ; #5 = Join #1 and #4 based on the matching airport code and retrieve the city and airport code of the destinations of United Airlines flights arriving in Aberdeen ; #6 = Aggregate the number of records from #5 to count the number of United Airlines flights that arrive in Aberdeen"
    },
    {
        "id": "ff0a82c65d3f97565126fcc5ac049f4dbc79566d8ab0540c9d7d74e49940a317",
        "question": "Which city has most number of arriving flights?",
        "query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ DestAirport ] Output [ countstar AS Count_Star , DestAirport ] ; #3 = Scan Table [ airports ] Output [ AirportCode , City ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.DestAirport = #3.AirportCode ] Output [ #3.City , #2.Count_Star ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ City , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, DestAirport FROM Scan_1 GROUP BY DestAirport ), Scan_3 AS ( SELECT AirportCode, City FROM flight_2.airports ), Join_4 AS ( SELECT Scan_3.City, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.DestAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, City FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 City, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table flights and retrieve the destination airports of all flights ; #2 = Group #1 by destination airport and aggregate the count of records per destination airport ; #3 = Scan the table airports and retrieve the airport code and city of all airports ; #4 = Join #2 and #3 based on the matching destination airport and airport code and retrieve the city and count of arriving flights ; #5 = Group #4 by city and aggregate the count of arriving flights per city ; #6 = Sort the records from #5 based on the count of arriving flights in descending order, select the first record, and identify the city with the most number of arriving flights and its count of arriving flights."
    },
    {
        "id": "877a21ee7d3418d9490cef1dc4f37236ea50bc68c12059a9466e5e0e862ca059",
        "question": "Which city has the most frequent destination airport?",
        "query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ DestAirport ] Output [ countstar AS Count_Star , DestAirport ] ; #3 = Scan Table [ airports ] Output [ AirportCode , City ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.DestAirport = #3.AirportCode ] Output [ #3.City , #2.Count_Star ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ City , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, DestAirport FROM Scan_1 GROUP BY DestAirport ), Scan_3 AS ( SELECT AirportCode, City FROM flight_2.airports ), Join_4 AS ( SELECT Scan_3.City, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.DestAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, City FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 City, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table flights and retrieve the destination airports of all flights. ; #2 = Group #1 by destination airport and aggregate the count of flights to find the number of flights to each destination airport. ; #3 = Scan the table airports and retrieve the airport codes and cities of all airports. ; #4 = Join #2 and #3 based on the matching destination airport and airport code and retrieve the cities and counts. ; #5 = Group #4 by city and aggregate the count per city to find the number of flights to each city as the destination airport. ; #6 = Sort the records from #5 based on the count of flights to each city in descending order, select the first record, and identify the city that has the most frequent destination airport and its count."
    },
    {
        "id": "ccad946be7d6d75013383b0a2dcc93dfd7c97d868dcafe7309b4e97793ad9e8c",
        "question": "Which city has most number of departing flights?",
        "query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ SourceAirport ] Output [ countstar AS Count_Star , SourceAirport ] ; #3 = Scan Table [ airports ] Output [ AirportCode , City ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.SourceAirport = #3.AirportCode ] Output [ #3.City , #2.Count_Star ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ City , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, SourceAirport FROM Scan_1 GROUP BY SourceAirport ), Scan_3 AS ( SELECT AirportCode, City FROM flight_2.airports ), Join_4 AS ( SELECT Scan_3.City, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.SourceAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, City FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 City, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table flights and retrieve the source airports of all flights ; #2 = Group #1 by source airport and aggregate the count of flights per source airport ; #3 = Scan the table airports and retrieve the airport codes and cities ; #4 = Join #2 and #3 based on the matching source airport and airport code, and retrieve the cities and count of flights ; #5 = Group #4 by city and aggregate the count of flights per city ; #6 = Sort the records from #5 based on the count of flights in descending order, select the first record, and identify the city with the most number of departing flights and its count of flights."
    },
    {
        "id": "512837d29318e63bfaec1474fb6fc4170733428b7d581c634116984533d750eb",
        "question": "Which city is the most frequent source airport?",
        "query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ SourceAirport ] Output [ countstar AS Count_Star , SourceAirport ] ; #3 = Scan Table [ airports ] Output [ AirportCode , City ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.SourceAirport = #3.AirportCode ] Output [ #3.City , #2.Count_Star ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ City , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, SourceAirport FROM Scan_1 GROUP BY SourceAirport ), Scan_3 AS ( SELECT AirportCode, City FROM flight_2.airports ), Join_4 AS ( SELECT Scan_3.City, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.SourceAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, City FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 City, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table flights and retrieve the source airports of all flights.  ; #2 = Group the records from #1 by source airport and aggregate the count of flights per source airport.  ; #3 = Scan the table airports and retrieve the airport codes and cities.  ; #4 = Join #2 and #3 based on the matching airport code and retrieve the cities and the count of flights.  ; #5 = Group the records from #4 by city and aggregate the count of flights per city.  ; #6 = Sort the records from #5 based on the count of flights in descending order, select the first record, and identify the city with the most frequent source airport."
    },
    {
        "id": "d03d7fcb88ff343e5ee83769b30e5f75cf398e639d6be0a1c20fe3f0a406f9aa",
        "question": "What is the code of airport that has the highest number of flights?",
        "query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC ",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ AirportCode , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ AirportCode , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT AirportCode, COUNT(*) AS Count_Star FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 AirportCode, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table airports and retrieve all airport codes ; #2 = Scan the table flights and retrieve the source and destination airports ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the airport codes ; #4 = Group #3 by airport code and aggregate the count of flights per airport code ; #5 = Sort the records from #4 based on the count of flights in descending order, select the first record, and identify the airport code of the airport that has the highest number of flights and its count of flights."
    },
    {
        "id": "2836ab9eeb271d2e43877d422f9139f14d6978de0709568fc8068b36b8212e6f",
        "question": "What is the airport code of the airport with the most flights?",
        "query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC ",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ AirportCode , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ AirportCode , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT AirportCode, COUNT(*) AS Count_Star FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 AirportCode, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table airports and retrieve the airport codes of all airports. ; #2 = Scan the table flights and retrieve the source airports and destination airports of all flights. ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the airport codes. ; #4 = Group #3 by airport code and aggregate the count per airport code to find the number of flights for each airport. ; #5 = Sort the records from #4 based on the count of flights in descending order, select the first record, and identify the airport code of the airport with the most flights and its count of flights."
    },
    {
        "id": "0002168a04349f5ec8af3736caeba3db6f216aeec4b9c65dd78d1d1c4420b940",
        "question": "What is the code of airport that has fewest number of flights?",
        "query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) ",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ AirportCode , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ AirportCode , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT AirportCode, COUNT(*) AS Count_Star FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 AirportCode, Count_Star FROM Aggregate_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * )",
        "qd": "#1 = Scan the table airports and retrieve the airport codes of all airports ; #2 = Scan the table flights and retrieve the source and destination airports of all flights ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the airport codes ; #4 = Group #3 by airport code and aggregate the count of flights per airport code ; #5 = Sort the records from #4 based on the count of flights in ascending order, select the first record, and identify the code of the airport that has the fewest number of flights and its count."
    },
    {
        "id": "00a3390111217a03d10cdfb556125b947a46a55fc5ea5458e593007a8cfc1702",
        "question": "Give the code of the airport with the least flights.",
        "query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) ",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ AirportCode , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ AirportCode , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT AirportCode, COUNT(*) AS Count_Star FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 AirportCode, Count_Star FROM Aggregate_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * )",
        "qd": "#1 = Scan the table airports and retrieve the airport codes of all airports. ; #2 = Scan the table flights and retrieve the source and destination airports of all flights. ; #3 = Join #1 and #2 based on matching airport codes and retrieve the airport codes. ; #4 = Group #3 by airport code and aggregate the count per airport to find the number of flights for each airport. ; #5 = Sort the records from #4 based on the count of flights in ascending order, select the first record, and identify the airport code with the least number of flights and its count."
    },
    {
        "id": "aeab2749108b0a4074f867008a9cbff20796f8cfc0aa1b851851074dc8dbfa2e",
        "question": "Which airline has most number of flights?",
        "query": "SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Airline , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), TopSort_6 AS ( SELECT TOP 1 Airline, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table flights and retrieve the airline of all flights ; #2 = Group #1 by airline and aggregate the count per airline to find the number of flights for each airline ; #3 = Scan the table airlines and retrieve the airline and its unique identifier ; #4 = Join #2 and #3 based on the matching airline and unique identifier and retrieve the count of flights and the airline ; #5 = Group #4 by airline and aggregate the count per airline to find the number of flights for each airline ; #6 = Sort the records from #5 based on the count of flights in descending order, select the first record, and identify the airline with the most number of flights and its count of flights."
    },
    {
        "id": "0f7d42df7248364edf39effe13d7eba22fde164f27cd785a594e0fcd44cabce8",
        "question": "What airline serves the most flights?",
        "query": "SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Airline , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), TopSort_6 AS ( SELECT TOP 1 Airline, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table flights and retrieve the airline of all flights. ; #2 = Group #1 by airline and aggregate the count per airline to find the number of flights for each airline. ; #3 = Scan the table airlines and retrieve the airlines with their unique IDs. ; #4 = Join #2 and #3 based on the matching airline and unique ID and retrieve the count and airline. ; #5 = Group #4 by airline and aggregate the count per airline to find the number of flights for each airline. ; #6 = Sort the records from #5 based on the count of flights in descending order, select the first record, and identify the airline that serves the most flights and its count of flights."
    },
    {
        "id": "0ab456f2fbc7de30a54a57287745b5f8e8c5e3b734a5144f44b1265e347fc73e",
        "question": "Find the abbreviation and country of the airline that has fewest number of flights?",
        "query": "SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , Abbreviation , uid , Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #3.Country , #3.Abbreviation , #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Abbreviation , Country , Airline ] Output [ countstar AS Count_Star , Abbreviation , Country ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Abbreviation , Country , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, Abbreviation, uid, Country FROM flight_2.airlines ), Join_4 AS ( SELECT Scan_3.Country, Scan_3.Abbreviation, Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, Abbreviation, Country FROM Join_4 GROUP BY Abbreviation, Abbreviation , Country , Airline, Country ), TopSort_6 AS ( SELECT TOP 1 Abbreviation, Country, Count_Star FROM Aggregate_5 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * )",
        "qd": "#1 = Scan the table flights and retrieve the airline of all flights ; #2 = Group #1 by airline and count the total number of flights per airline ; #3 = Scan the table airlines and retrieve the airline, abbreviation, uid, and country information ; #4 = Join #2 and #3 based on the matching airline and uid to retrieve the abbreviation, country, count of flights, and airline ; #5 = Group #4 by abbreviation, country, and airline and count the total number of flights per abbreviation and country ; #6 = Sort the records from #5 based on the count of flights in ascending order, select the first record, and identify the abbreviation and country of the airline with the fewest number of flights."
    },
    {
        "id": "614838cd0b6d31a3440afa4fe30f7f7cbcdde3207859e06a773f1369c608adda",
        "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?",
        "query": "SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , Abbreviation , uid , Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #3.Country , #3.Abbreviation , #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Abbreviation , Country , Airline ] Output [ countstar AS Count_Star , Abbreviation , Country ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Abbreviation , Country , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, Abbreviation, uid, Country FROM flight_2.airlines ), Join_4 AS ( SELECT Scan_3.Country, Scan_3.Abbreviation, Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, Abbreviation, Country FROM Join_4 GROUP BY Abbreviation, Abbreviation , Country , Airline, Country ), TopSort_6 AS ( SELECT TOP 1 Abbreviation, Country, Count_Star FROM Aggregate_5 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * )",
        "qd": "#1 = Scan the table flights and retrieve the airline names ; #2 = Group #1 by airline and aggregate the count of flights for each airline ; #3 = Scan the table airlines and retrieve the airline names, abbreviations, and countries ; #4 = Join #2 and #3 based on the matching airline names and retrieve the countries and abbreviations ; #5 = Group #4 by abbreviation and country and aggregate the count of flights for each abbreviation and country ; #6 = Sort the records from #5 based on the count of flights in ascending order, select the first record, and identify the abbreviation of the airline with the fewest flights and the country it is in"
    },
    {
        "id": "50c40e6bc28069c3bcc0382be99a457edbe8ea4d10caa0cd645599f8e47f6379",
        "question": "What are airlines that have some flight departing from airport 'AHD'?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'",
        "qd": "#1 = Scan the table flights and retrieve the airlines and source airports of all flights departing from airport 'AHD' ; #2 = Scan the table airlines and retrieve the airlines and unique identifiers ; #3 = Join #1 and #2 based on the matching airline and unique identifier and retrieve the airline names"
    },
    {
        "id": "59494964483df233275b18143af64420c0b7863a6e168ecb92028d30acc4c823",
        "question": "Which airlines have a flight with source airport AHD?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'",
        "qd": "#1 = Scan the table flights to find all the flights with source airport AHD and retrieve the airline and the source airport ; #2 = Scan the table airlines and retrieve the airline and the unique identifier ; #3 = Join #1 and #2 based on the matching airline and unique identifier and retrieve the airline names"
    },
    {
        "id": "c3998b7c1feeb87bae4cca7d360728a072f24c52445c2355240738d9e27063b6",
        "question": "What are airlines that have flights arriving at airport 'AHD'?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'AHD' ] Output [ Airline , DestAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'",
        "qd": "#1 = Scan the table flights and retrieve the airlines and destination airports of all flights arriving at airport 'AHD' ; #2 = Scan the table airlines and retrieve the airlines and uid ; #3 = Join #1 and #2 based on the matching airline and uid and retrieve the airlines that have flights arriving at airport 'AHD'"
    },
    {
        "id": "1ccca59a2bf0612bea4c52b6b33f8bf1840d579cce726f4ad8b25b8342c718d6",
        "question": "Which airlines have a flight with destination airport AHD?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'AHD' ] Output [ Airline , DestAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'",
        "qd": "#1 = Scan the table flights and find all the flights with destination airport AHD ; #2 = Scan the table airlines and retrieve the airline and uid of all airlines ; #3 = Join #1 and #2 based on the matching airline uid and retrieve the names of the airlines that have a flight with destination airport AHD"
    },
    {
        "id": "727d962436aa6dab57de5314949a51a9e99124c9086e4e950e58f7b3b425a9d1",
        "question": "Find all airlines that have flights from both airports 'APG' and 'CVO'.",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Distinct [ true ] Output [ #2.Airline ] ; #4 = Scan Table [ airlines ] Output [ Airline , uid ] ; #5 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.uid = #5.Airline ] Output [ #4.Airline ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT DISTINCT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ), Scan_4 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_5 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_6 AS ( SELECT Scan_4.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.uid = Scan_5.Airline ), Intersect_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline IN (SELECT Airline FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO'",
        "qd": "#1 = Scan the table flights and retrieve the airlines that have flights from airport 'APG' ; #2 = Scan the table airlines and retrieve the airlines along with their unique IDs ; #3 = Join #1 and #2 based on the matching unique IDs and retrieve the airlines without duplicates ; #4 = Scan the table airlines and retrieve the airlines along with their unique IDs ; #5 = Scan the table flights and retrieve the airlines that have flights from airport 'CVO' ; #6 = Join #4 and #5 based on the matching unique IDs and retrieve the airlines without duplicates ; #7 = Intersect #3 and #6 based on the matching airlines and retrieve the airlines"
    },
    {
        "id": "698c94dd60832c69da326ce8bfa2f179b719248703b9e09aa653ebe78a3a67e6",
        "question": "Which airlines have departing flights from both APG and CVO airports?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Distinct [ true ] Output [ #2.Airline ] ; #4 = Scan Table [ airlines ] Output [ Airline , uid ] ; #5 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.uid = #5.Airline ] Output [ #4.Airline ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT DISTINCT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ), Scan_4 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_5 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_6 AS ( SELECT Scan_4.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.uid = Scan_5.Airline ), Intersect_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline IN (SELECT Airline FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO'",
        "qd": "#1 = Scan the table flights and retrieve the airlines with departing flights from APG airport. ; #2 = Scan the table airlines and retrieve all the airlines. ; #3 = Join #1 and #2 based on the matching airline IDs and retrieve the airlines. ; #4 = Scan the table airlines and retrieve all the airlines. ; #5 = Scan the table flights and retrieve the airlines with departing flights from CVO airport. ; #6 = Join #4 and #5 based on the matching airline IDs and retrieve the airlines. ; #7 = Intersect #3 and #6 based on the matching airline names and retrieve the airlines."
    },
    {
        "id": "39ceb08b1483abd2fc6eb7e0c6288d9443225a383f6d319256bd830cc714cebc",
        "question": "Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Distinct [ true ] Output [ #1.Airline ] ; #4 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #5 = Scan Table [ airlines ] Output [ Airline , uid ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Airline = #5.uid ] Output [ #5.Airline ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_3 AS ( SELECT DISTINCT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Scan_4 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_5 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_6 AS ( SELECT Scan_5.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.Airline = Scan_5.uid ), Except_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline NOT IN (SELECT Airline FROM Join_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG'",
        "qd": "#1 = Scan the table airlines and retrieve the airline names and unique IDs ; #2 = Scan the table flights and retrieve the airline names for flights from airport 'CVO' ; #3 = Join #1 and #2 based on the matching unique IDs and retrieve the airline names without duplicates ; #4 = Scan the table flights and retrieve the airline names for flights from airport 'APG' ; #5 = Scan the table airlines and retrieve the airline names and unique IDs ; #6 = Join #4 and #5 based on the matching airline IDs and retrieve the airline names ; #7 = Return all the airline names from #3 that are not in #6, meaning the airlines that have flights from airport 'CVO' but not from 'APG'"
    },
    {
        "id": "6632e3ca9157ea891f945858d65d51a7c21b4b3beac8b3d957f92610d775da20",
        "question": "Which airlines have departures from CVO but not from APG airports?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Distinct [ true ] Output [ #1.Airline ] ; #4 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #5 = Scan Table [ airlines ] Output [ Airline , uid ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Airline = #5.uid ] Output [ #5.Airline ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_3 AS ( SELECT DISTINCT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Scan_4 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_5 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_6 AS ( SELECT Scan_5.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.Airline = Scan_5.uid ), Except_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline NOT IN (SELECT Airline FROM Join_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG'",
        "qd": "#1 = Scan the table airlines and retrieve the airline names and uids of all airlines ; #2 = Scan the table flights and retrieve the airline names and source airports of all flights with CVO as the source airport ; #3 = Join #1 and #2 based on the matching uids and retrieve the unique airline names ; #4 = Scan the table flights and retrieve the airline names and source airports of all flights with APG as the source airport ; #5 = Scan the table airlines and retrieve the airline names and uids of all airlines ; #6 = Join #4 and #5 based on the matching airline names and retrieve the airline names ; #7 = Return the airline names from #3 that are not in #6, to find the airlines that have departures from CVO but not from APG airports"
    },
    {
        "id": "a9ff32fcd6bd92e2683cd5b35a991b73751f44afc13e6146cc8b4a68a61dcc1c",
        "question": "Find all airlines that have at least 10 flights.",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Output [ uid , Airline ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Airline = #1.uid ] Output [ #1.Airline ] ; #4 = Aggregate [ #3 ] GroupBy [ Airline ] Output [ countstar AS Count_Star , Airline ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 10 ] Output [ Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT uid, Airline FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_2.Airline = Scan_1.uid ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, Airline FROM Join_3 GROUP BY Airline ), Filter_5 AS ( SELECT Airline FROM Aggregate_4 WHERE Count_Star > 10 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10",
        "qd": "#1 = Scan the table airlines and retrieve the unique ID and airline name of all airlines ; #2 = Scan the table flights and retrieve the airline names of all flights ; #3 = Join #1 and #2 based on the matching airline ID and retrieve the airline names ; #4 = Group #3 by airline name and aggregate the count of flights per airline ; #5 = Filter the records from #4 to retrieve the airline names that have at least 10 flights"
    },
    {
        "id": "67367330d8de673f906ebfa5f90854abadcd59ec692acaadafbf1c0b0fcbd88b",
        "question": "Which airlines have at least 10 flights?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Output [ uid , Airline ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Airline = #1.uid ] Output [ #1.Airline ] ; #4 = Aggregate [ #3 ] GroupBy [ Airline ] Output [ countstar AS Count_Star , Airline ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 10 ] Output [ Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT uid, Airline FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_2.Airline = Scan_1.uid ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, Airline FROM Join_3 GROUP BY Airline ), Filter_5 AS ( SELECT Airline FROM Aggregate_4 WHERE Count_Star > 10 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10",
        "qd": "#1 = Scan the table airlines and retrieve the unique ID and name of all airlines ; #2 = Scan the table flights and retrieve the airline information of all flights ; #3 = Join #1 and #2 based on the matching airline ID and retrieve the airline names ; #4 = Group #3 by airline and aggregate the count of flights per airline ; #5 = Filter from #4 all the airlines with more than 10 flights and retrieve their names"
    },
    {
        "id": "14f44cbc77a573230a3ff8f32108865b84f1805f31fa964bc07357c949ae4d26",
        "question": "Find all airlines that have fewer than 200 flights.",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star < 200 ] Output [ Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), Filter_6 AS ( SELECT Airline FROM Aggregate_5 WHERE Count_Star < 200 ) SELECT * FROM Filter_6",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200",
        "qd": "#1 = Scan the table flights and retrieve the airline of all flights ; #2 = Group all flights from #1 by airline and count the number of flights per airline ; #3 = Scan the table airlines and retrieve the airline and uid ; #4 = Join #2 and #3 based on the matching airline and uid and retrieve the count of flights and airline ; #5 = Group the records from #4 by airline and count the number of flights per airline ; #6 = Filter the records from #5 to find the airlines with fewer than 200 flights and retrieve the airline names"
    },
    {
        "id": "ec2e71aef485eb1901917a50f7e013ff97e143dfd5f84f5c8c6c198f9a69106c",
        "question": "Which airlines have less than 200 flights?",
        "query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star < 200 ] Output [ Airline ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), Filter_6 AS ( SELECT Airline FROM Aggregate_5 WHERE Count_Star < 200 ) SELECT * FROM Filter_6",
        "clean_query": "SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200",
        "qd": "#1 = Scan the table flights and retrieve the airline of all flights. ; #2 = Group #1 by airline and count the number of flights per airline. ; #3 = Scan the table airlines and retrieve the airline and its unique identifier. ; #4 = Join #2 and #3 based on the matching airline and unique identifier and retrieve the count of flights and airline. ; #5 = Group #4 by airline and count the number of flights per airline. ; #6 = Filter from #5 all the airlines with less than 200 flights and retrieve the airline names."
    },
    {
        "id": "84829bc37e43487777aad24bbb1d364ae6a732e03b5d67e19ee1a9885b5ed33d",
        "question": "What are flight numbers of Airline \"United Airlines\"?",
        "query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Output [ Airline , FlightNo ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #2.FlightNo ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, FlightNo FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'",
        "qd": "#1 = Scan the table airlines and retrieve the airline and unique id of all records where the airline is \"United Airlines\" ; #2 = Scan the table flights and retrieve the airline and flight number of all flights ; #3 = Join #1 and #2 based on the matching unique id and airline, and retrieve the flight numbers of all flights by \"United Airlines\""
    },
    {
        "id": "2a3bb875beae5ee8230f21a90839bb7547486bd15cf8d6b567e659b137669342",
        "question": "Which flight numbers correspond to United Airlines flights?",
        "query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Output [ Airline , FlightNo ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #2.FlightNo ]",
        "cte": "WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, FlightNo FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'",
        "qd": "#1 = Scan the table airlines and retrieve the airline and uid for United Airlines ; #2 = Scan the table flights and retrieve the airline and flight number for all flights ; #3 = Join #1 and #2 based on the matching uid and airline to retrieve the flight numbers for United Airlines flights"
    },
    {
        "id": "8efd5f524fe11882fd054fbe9338eead2cd3fe81797f3704ed122a780f499367",
        "question": "What are flight numbers of flights departing from Airport \"APG\"?",
        "query": "SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ FlightNo , SourceAirport ]",
        "cte": "WITH Scan_1 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT FlightNo FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'",
        "qd": "#1 = Scan the table flights and retrieve the flight numbers of all flights that depart from the airport \"APG\"."
    },
    {
        "id": "2968bd140b8f572b292b72b93f380074b261e095b014111d7e34b5be584a0735",
        "question": "Give the flight numbers of flights leaving from APG.",
        "query": "SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ FlightNo , SourceAirport ]",
        "cte": "WITH Scan_1 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT FlightNo FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'",
        "qd": "#1 = Scan the table flights and retrieve the flight numbers of all flights leaving from APG."
    },
    {
        "id": "7ff01e405c8570255b3f1e0b8579237f1b2cda024aedefc247a6207d8bee48c6",
        "question": "What are flight numbers of flights arriving at Airport \"APG\"?",
        "query": "SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'APG' ] Output [ FlightNo , DestAirport ]",
        "cte": "WITH Scan_1 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights WHERE DestAirport = 'APG' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT FlightNo FROM flight_2.FLIGHTS  WHERE DestAirport = 'APG'",
        "qd": "#1 = Scan the table flights and retrieve the flight numbers of all flights that arrive at Airport \"APG\""
    },
    {
        "id": "661e9a7253223a3ccb079a380550a1278fa81e2f92a8f848c1fe944b04d916e2",
        "question": "Give the flight numbers of flights landing at APG.",
        "query": "SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'APG' ] Output [ FlightNo , DestAirport ]",
        "cte": "WITH Scan_1 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights WHERE DestAirport = 'APG' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT FlightNo FROM flight_2.FLIGHTS  WHERE DestAirport = 'APG'",
        "qd": "#1 = Scan the table flights and retrieve the flight numbers of all flights landing at APG."
    },
    {
        "id": "3e0018e4a77c7beccb7a8bd929b7232c2651929030a3b338803d131a009889a5",
        "question": "What are flight numbers of flights departing from City \"Aberdeen \"?",
        "query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ FlightNo , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #2.FlightNo ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and cities of all airports in Aberdeen ; #2 = Scan the table flights and retrieve the flight numbers and source airports of all flights ; #3 = Join #1 and #2 based on the matching airport code and source airport and retrieve the flight numbers of flights departing from Aberdeen"
    },
    {
        "id": "e13407fb59cee2490a6ebbe85e83d8aaafad8412414e1deeca3ddd50c02be181",
        "question": "Give the flight numbers of flights leaving from Aberdeen.",
        "query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ FlightNo , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #2.FlightNo ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports to find the airport code and city of all airports in Aberdeen ; #2 = Scan the table flights to find the flight numbers and source airports of all flights ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the flight numbers of flights leaving from Aberdeen"
    },
    {
        "id": "a53c60a49b1ef48137085af23de337bbc821e26eccb3bd759ba8ce5fcfc931ff",
        "question": "What are flight numbers of flights arriving at City \"Aberdeen\"?",
        "query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ FlightNo , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #2.FlightNo ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports to find the airport code and city of all airports in Aberdeen ; #2 = Scan the table flights to find the flight numbers and destination airports of all flights ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the flight numbers of flights arriving at Aberdeen"
    },
    {
        "id": "d86ceaccd1552a8dec247eb8118198684cfdf5be0ab450b672774656c4ac72a2",
        "question": "Give the flight numbers of flights arriving in Aberdeen.",
        "query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ FlightNo , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #2.FlightNo ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'",
        "qd": "#1 = Scan the table airports to find the airport code and city for all airports in Aberdeen ; #2 = Scan the table flights to find the flight numbers and destination airports for all flights ; #3 = Join #1 and #2 based on the matching airport code and destination airport to find the flight numbers of flights arriving in Aberdeen"
    },
    {
        "id": "121668ef9aa1b21c6f90356eb200c8415c68d85e24e4277a59824c5dd5f9f785",
        "question": "Find the number of flights landing in the city of Aberdeen or Abilene.",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1 WITH (FORCESCAN) JOIN flight_2.Airports AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' OR City = 'Abilene' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.City , #1.AirportCode ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' OR City = 'Abilene' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1  JOIN flight_2.Airports AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and cities where the city is either Aberdeen or Abilene. ; #2 = Scan the table flights and retrieve the destination airports. ; #3 = Join #1 and #2 based on the matching airport code and retrieve the cities and airport codes. ; #4 = Aggregate the number of records in #3 to find the number of flights landing in the city of Aberdeen or Abilene."
    },
    {
        "id": "d2374d59745c0e008a05a979d13f5c78e4b5039879a3a689dd950667f24dfdcc",
        "question": "How many flights land in Aberdeen or Abilene?",
        "query": "SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1 WITH (FORCESCAN) JOIN flight_2.Airports AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' OR City = 'Abilene' ] Output [ AirportCode , City ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.City , #1.AirportCode ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, City FROM flight_2.airports WHERE City = 'Aberdeen' OR City = 'Abilene' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.City, Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1  JOIN flight_2.Airports AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene'",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and city names of Aberdeen and Abilene. ; #2 = Scan the table flights and retrieve the destination airports. ; #3 = Join #1 and #2 based on the matching airport codes and retrieve the city names of the landing airports. ; #4 = Aggregate the count of the records from #3 to find the number of flights that land in Aberdeen or Abilene."
    },
    {
        "id": "9a73a6338b34f5e65b5cc27586bccdf5fe018eeda56c944a0b2b0b9f7e6ca09c",
        "question": "Find the name of airports which do not have any flight in and out.",
        "query": "SELECT AirportName FROM flight_2.Airports WITH (FORCESCAN) WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights WITH (FORCESCAN) UNION SELECT DestAirport FROM flight_2.Flights WITH (FORCESCAN) ) ",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode , AirportName ] ; #2 = Scan Table [ flights ] Output [ SourceAirport AS AirportCode ] ; #3 = Scan Table [ flights ] Output [ DestAirport AS AirportCode ] ; #4 = Union [ #2 , #3 ] Output [ #2.AirportCode ] ; #5 = Except [ #1 , #4 ] ExceptColumns [ #1.AirportCode ] Output [ #1.AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, AirportName FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport AS AirportCode FROM flight_2.flights ), Scan_3 AS ( SELECT DestAirport AS AirportCode FROM flight_2.flights ), Union_4 AS ( SELECT AirportCode FROM Scan_2 UNION SELECT AirportCode FROM Scan_3 ), Except_5 AS ( SELECT Scan_1.AirportName FROM Scan_1 WHERE NOT EXISTS (SELECT AirportCode FROM Union_4 WHERE Scan_1.AirportCode = Union_4.AirportCode) ) SELECT * FROM Except_5",
        "clean_query": "SELECT AirportName FROM flight_2.Airports  WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights  UNION SELECT DestAirport FROM flight_2.Flights  )",
        "qd": "#1 = Scan the table airports and retrieve the airport code and airport name of all airports ; #2 = Scan the table flights and retrieve the source airport code of all flights ; #3 = Scan the table flights and retrieve the destination airport code of all flights ; #4 = Union the source airport codes from #2 and the destination airport codes from #3 to find all the airport codes that have flights in and out ; #5 = Return the airport names from #1 that are not in the list of airport codes from #4 to find the airports that do not have any flights in and out"
    },
    {
        "id": "63bfffa86de5ddf9518ff92a308340dbf0884a3e273892bfb044d3f7c7fbe2a3",
        "question": "Which airports do not have departing or arriving flights?",
        "query": "SELECT AirportName FROM flight_2.Airports WITH (FORCESCAN) WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights WITH (FORCESCAN) UNION SELECT DestAirport FROM flight_2.Flights WITH (FORCESCAN) ) ",
        "qpl": "flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode , AirportName ] ; #2 = Scan Table [ flights ] Output [ SourceAirport AS AirportCode ] ; #3 = Scan Table [ flights ] Output [ DestAirport AS AirportCode ] ; #4 = Union [ #2 , #3 ] Output [ #2.AirportCode ] ; #5 = Except [ #1 , #4 ] ExceptColumns [ #1.AirportCode ] Output [ #1.AirportName ]",
        "cte": "WITH Scan_1 AS ( SELECT AirportCode, AirportName FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport AS AirportCode FROM flight_2.flights ), Scan_3 AS ( SELECT DestAirport AS AirportCode FROM flight_2.flights ), Union_4 AS ( SELECT AirportCode FROM Scan_2 UNION SELECT AirportCode FROM Scan_3 ), Except_5 AS ( SELECT Scan_1.AirportName FROM Scan_1 WHERE NOT EXISTS (SELECT AirportCode FROM Union_4 WHERE Scan_1.AirportCode = Union_4.AirportCode) ) SELECT * FROM Except_5",
        "clean_query": "SELECT AirportName FROM flight_2.Airports  WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights  UNION SELECT DestAirport FROM flight_2.Flights  )",
        "qd": "#1 = Scan the table airports and retrieve the airport codes and names of all airports ; #2 = Scan the table flights and retrieve the source airports ; #3 = Scan the table flights and retrieve the destination airports ; #4 = Union #2 and #3 and retrieve the airport codes ; #5 = return all the airport names that are not in #4 to find the airports that do not have any departing or arriving flights"
    },
    {
        "id": "554a0b7814c3f16586c821c590d72c85fb6cd567bdaed14279d59e072644ed1f",
        "question": "How many employees are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee",
        "qd": "#1 = Scan the table employee and retrieve a constant value of 1 for each employee ; #2 = Aggregate the count of all records in #1 to find the total number of employees"
    },
    {
        "id": "b7ce7e96288841eb3415b871eb6a39d8aadabecb1b37a15b91b8309111d50ed1",
        "question": "Count the number of employees",
        "query": "SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee",
        "qd": "#1 = Scan the table employee and retrieve a constant value of 1 for each employee ; #2 = Aggregate the count of the constant value from #1 to count the number of employees"
    },
    {
        "id": "638f6f2ec73a8fdd72296c056dbd30a739b9d387584c4b01c28c97f413f3675c",
        "question": "Sort employee names by their age in ascending order.",
        "query": "SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM employee_hire_evaluation.employee ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
        "clean_query": "SELECT name FROM employee_hire_evaluation.employee  ORDER BY age",
        "qd": "#1 = Scan the table employee and retrieve the names and ages of all employees. ; #2 = Sort the records from #1 based on the age in ascending order and retrieve the names and ages of employees."
    },
    {
        "id": "187a9dfd630ef2d10c685b291d0f05840d8d172803e5dede4b1dfcd226fa7f5e",
        "question": "List the names of employees and sort in ascending order of age.",
        "query": "SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM employee_hire_evaluation.employee ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
        "clean_query": "SELECT name FROM employee_hire_evaluation.employee  ORDER BY age",
        "qd": "#1 = Scan the table employee and retrieve the names and ages of all employees ; #2 = Sort the records from #1 based on the age in ascending order and retrieve the names and ages"
    },
    {
        "id": "3e0c05f363776d11348e6153e66cd5edbe0ef5a51c3a812ec2633d44e47352ee",
        "question": "What is the number of employees from each city?",
        "query": "SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee WITH (FORCESCAN) GROUP BY city OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ City ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ]",
        "cte": "WITH Scan_1 AS ( SELECT City FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, City FROM Scan_1 GROUP BY City ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee  GROUP BY city",
        "qd": "#1 = Scan the table Employee and retrieve the city of each employee ; #2 = Group the records from #1 based on the city and aggregate the count per city to find the number of employees from each city"
    },
    {
        "id": "e81d18bcec18f6d352f79d2f159af0c55a5dc378dca8d9aa19e6d1a9d78f5a9e",
        "question": "Count the number of employees for each city.",
        "query": "SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee WITH (FORCESCAN) GROUP BY city OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ City ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ]",
        "cte": "WITH Scan_1 AS ( SELECT City FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, City FROM Scan_1 GROUP BY City ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee  GROUP BY city",
        "qd": "#1 = Scan the table employee and retrieve the city of each employee ; #2 = Group #1 by city and count the number of employees in each city"
    },
    {
        "id": "f290992f9d25245881047abb0c5a8fa75425fa9fa94cedc433334874825ed374",
        "question": "Which cities do more than one employee under age 30 come from?",
        "query": "SELECT city FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE age < 30 GROUP BY city HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Predicate [ Age < 30 ] Output [ City , Age ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ City ]",
        "cte": "WITH Scan_1 AS ( SELECT City, Age FROM employee_hire_evaluation.employee WHERE Age < 30 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, City FROM Scan_1 GROUP BY City ), Filter_3 AS ( SELECT City FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT city FROM employee_hire_evaluation.employee  WHERE age < 30 GROUP BY city HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table employee and retrieve the cities and ages of all employees under age 30 ; #2 = Group #1 by city and aggregate the count of employees per city ; #3 = Filter from #2 the cities that have more than one employee under age 30 and retrieve the cities"
    },
    {
        "id": "335feb174905f95c58ecd6591d17c573f3b40baf343333f6bbeed83c02516e79",
        "question": "Find the cities that have more than one employee under age 30.",
        "query": "SELECT city FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE age < 30 GROUP BY city HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Predicate [ Age < 30 ] Output [ City , Age ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ countstar AS Count_Star , City ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ City ]",
        "cte": "WITH Scan_1 AS ( SELECT City, Age FROM employee_hire_evaluation.employee WHERE Age < 30 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, City FROM Scan_1 GROUP BY City ), Filter_3 AS ( SELECT City FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT city FROM employee_hire_evaluation.employee  WHERE age < 30 GROUP BY city HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table employee and retrieve the cities and ages of all employees under the age of 30 ; #2 = Group #1 by city and aggregate the count of employees per city ; #3 = Filter from #2 all the cities that have more than one employee under the age of 30 and retrieve the cities"
    },
    {
        "id": "a4b73ee60e1ed8de6d08edba00c1d94f1aed84d6660302a5970865956fdbdf1c",
        "question": "Find the number of shops in each location.",
        "query": "SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) GROUP BY LOCATION OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Location ] ; #2 = Aggregate [ #1 ] GroupBy [ Location ] Output [ countstar AS Count_Star , Location ]",
        "cte": "WITH Scan_1 AS ( SELECT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Location FROM Scan_1 GROUP BY Location ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop  GROUP BY LOCATION",
        "qd": "#1 = Scan the table shop and retrieve the location of all the shops ; #2 = Group the records from #1 by location and aggregate the count of shops in each location to find the number of shops in each location."
    },
    {
        "id": "0d4fb20a6fb3ba654d1369ba25a6a2a37e5ff5c8fdd5227b2a6e28aa7436fa5e",
        "question": "How many shops are there in each location?",
        "query": "SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) GROUP BY LOCATION OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Location ] ; #2 = Aggregate [ #1 ] GroupBy [ Location ] Output [ countstar AS Count_Star , Location ]",
        "cte": "WITH Scan_1 AS ( SELECT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Location FROM Scan_1 GROUP BY Location ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop  GROUP BY LOCATION",
        "qd": "#1 = Scan the table shop and retrieve the locations of all the shops ; #2 = Group the records from #1 by location and aggregate the count per location to find the number of shops in each location"
    },
    {
        "id": "4e203440b0f9a0aedc9e463d02382c9f59aab4bf42372c1411307a998ac33150",
        "question": "Find the manager name and district of the shop whose number of products is the largest.",
        "query": "SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products , Manager_name , District ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Number_products DESC ] Output [ Number_products , Manager_name , District ]",
        "cte": "WITH Scan_1 AS ( SELECT Number_products, Manager_name, District FROM employee_hire_evaluation.shop ), TopSort_2 AS ( SELECT TOP 1 Number_products, Manager_name, District FROM Scan_1 ORDER BY Number_products DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC",
        "qd": "#1 = Scan the table shop and retrieve the number of products, manager name, and district of all shops ; #2 = Sort the records from #1 based on the number of products in descending order, select the first record, and identify the manager name and district of the shop with the largest number of products."
    },
    {
        "id": "7c4fa321a90c7351e476975b181c798ce83282484ff08fa81936504345c58670",
        "question": "What are the manager name and district of the shop that sells the largest number of products?",
        "query": "SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products , Manager_name , District ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Number_products DESC ] Output [ Number_products , Manager_name , District ]",
        "cte": "WITH Scan_1 AS ( SELECT Number_products, Manager_name, District FROM employee_hire_evaluation.shop ), TopSort_2 AS ( SELECT TOP 1 Number_products, Manager_name, District FROM Scan_1 ORDER BY Number_products DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC",
        "qd": "#1 = Scan the table shop and retrieve the number of products, manager name, and district of all shops ; #2 = Sort the records from #1 based on the number of products in descending order, select the first record, and retrieve the manager name and district of the shop that sells the largest number of products"
    },
    {
        "id": "6ae399e06f0727c2e17b66033a479df7c995fb6126ac67372fe9c15c6a115c23",
        "question": "find the minimum and maximum number of products of all stores.",
        "query": "SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ MAX(Number_products) AS Max_Number_products , MIN(Number_products) AS Min_Number_products ]",
        "cte": "WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT MAX(Number_products) AS Max_Number_products, MIN(Number_products) AS Min_Number_products FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop",
        "qd": "#1 = Scan the table shop and retrieve the number of products of all stores. ; #2 = Aggregate the maximum and minimum values of the number of products to find the minimum and maximum number of products of all stores."
    },
    {
        "id": "9e1d5ef6745da75269f01f2394f4be8f88a36f0f2f1760c4d6dd46ebc23dec81",
        "question": "What are the minimum and maximum number of products across all the shops?",
        "query": "SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ MAX(Number_products) AS Max_Number_products , MIN(Number_products) AS Min_Number_products ]",
        "cte": "WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT MAX(Number_products) AS Max_Number_products, MIN(Number_products) AS Min_Number_products FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop",
        "qd": "#1 = Scan the table shop and retrieve the number of products for each shop ; #2 = Calculate the maximum and minimum number of products across all the shops"
    },
    {
        "id": "f8a3282285f9259ebf76f900a07aac1703877f2df99a0034fa27e72907327cb5",
        "question": "Return the name, location and district of all shops in descending order of number of products.",
        "query": "SELECT name , LOCATION , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , Number_products , Location , District ] ; #2 = Sort [ #1 ] OrderBy [ Number_products DESC ] Output [ Name , Number_products , Location , District ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Number_products, Location, District FROM employee_hire_evaluation.shop ) SELECT Name, Number_products, Location, District FROM Scan_1 ORDER BY Number_products DESC",
        "clean_query": "SELECT name , LOCATION , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC",
        "qd": "#1 = Scan the table shop and retrieve the names, number of products, locations, and districts of all shops ; #2 = Sort the records from #1 based on the number of products in descending order and retrieve the names, number of products, locations, and districts"
    },
    {
        "id": "b69843ef90777876c4360c78bd23ba71beb1e392bbf2540345f6709eb354d205",
        "question": "Sort all the shops by number products in descending order, and return the name, location and district of each shop.",
        "query": "SELECT name , LOCATION , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , Number_products , Location , District ] ; #2 = Sort [ #1 ] OrderBy [ Number_products DESC ] Output [ Name , Number_products , Location , District ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Number_products, Location, District FROM employee_hire_evaluation.shop ) SELECT Name, Number_products, Location, District FROM Scan_1 ORDER BY Number_products DESC",
        "clean_query": "SELECT name , LOCATION , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC",
        "qd": "#1 = Scan the table shop and retrieve the name, number of products, location, and district of each shop ; #2 = Sort the records from #1 based on the number of products in descending order and retrieve the name, number of products, location, and district of each shop"
    },
    {
        "id": "c7b79dc46ba1d29aaab498484888e38ee860e274eca99a6919829c054daf7d81",
        "question": "Find the names of stores whose number products is more than the average number of products.",
        "query": "SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) ) ",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ AVG(Number_products) AS Avg_Number_products ] ; #3 = Scan Table [ shop ] Output [ Name , Number_products ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Number_products > #2.Avg_Number_products ] Output [ #3.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT AVG(Number_products) AS Avg_Number_products FROM Scan_1 ), Scan_3 AS ( SELECT Name, Number_products FROM employee_hire_evaluation.shop ), Join_4 AS ( SELECT Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Number_products > Aggregate_2.Avg_Number_products ) SELECT * FROM Join_4",
        "clean_query": "SELECT name FROM employee_hire_evaluation.shop  WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop  )",
        "qd": "#1 = Scan the table shop and retrieve the number of products for each store ; #2 = Calculate the average number of products across all stores ; #3 = Scan the table shop and retrieve the names and number of products for each store ; #4 = Join the average number of products from #2 with the names and number of products from #3 to retrieve the names of stores whose number of products is more than the average number of products."
    },
    {
        "id": "6ea998f796ec30bffa8e18b93df295017492f935422901936d3cd25d3d8cb4b4",
        "question": "Which shops' number products is above the average? Give me the shop names.",
        "query": "SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) ) ",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ AVG(Number_products) AS Avg_Number_products ] ; #3 = Scan Table [ shop ] Output [ Name , Number_products ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Number_products > #2.Avg_Number_products ] Output [ #3.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT AVG(Number_products) AS Avg_Number_products FROM Scan_1 ), Scan_3 AS ( SELECT Name, Number_products FROM employee_hire_evaluation.shop ), Join_4 AS ( SELECT Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Number_products > Aggregate_2.Avg_Number_products ) SELECT * FROM Join_4",
        "clean_query": "SELECT name FROM employee_hire_evaluation.shop  WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop  )",
        "qd": "#1 = Scan the table shop and retrieve the number of products of each shop ; #2 = Calculate the average number of products among all shops ; #3 = Scan the table shop and retrieve the names and number of products of each shop ; #4 = Join #2 and #3 based on the condition that the number of products of a shop is greater than the average number of products and retrieve the names of the shops"
    },
    {
        "id": "0049599bd964edec86a7cd9e34a482b47430b2f6f3b2376013f90f446d7b20e0",
        "question": "find the name of employee who was awarded the most times in the evaluation.",
        "query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Employee_ID ] Output [ countstar AS Count_Star , Employee_ID ] ; #3 = Scan Table [ employee ] Output [ Name , Employee_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Employee_ID = #3.Employee_ID ] Output [ #3.Name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Employee_ID FROM Scan_1 GROUP BY Employee_ID ), Scan_3 AS ( SELECT Name, Employee_ID FROM employee_hire_evaluation.employee ), Join_4 AS ( SELECT Scan_3.Name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Employee_ID = Scan_3.Employee_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table evaluation and retrieve the employee IDs of all evaluations ; #2 = Group #1 by employee ID and aggregate the count of evaluations per employee ; #3 = Scan the table employee and retrieve the names and employee IDs of all employees ; #4 = Join #2 and #3 based on the matching employee IDs and retrieve the names and counts of evaluations ; #5 = Sort the records from #4 based on the count of evaluations in descending order, select the first record, and identify the employee name with the highest number of awards in the evaluations and the count of awards."
    },
    {
        "id": "93b7ac35d94bcc7afc58e37c1555d4cd63f189511d09f623994cfda40291923d",
        "question": "Which employee received the most awards in evaluations? Give me the employee name.",
        "query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Employee_ID ] Output [ countstar AS Count_Star , Employee_ID ] ; #3 = Scan Table [ employee ] Output [ Name , Employee_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Employee_ID = #3.Employee_ID ] Output [ #3.Name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Employee_ID FROM Scan_1 GROUP BY Employee_ID ), Scan_3 AS ( SELECT Name, Employee_ID FROM employee_hire_evaluation.employee ), Join_4 AS ( SELECT Scan_3.Name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Employee_ID = Scan_3.Employee_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table evaluation and retrieve the employee IDs of all evaluations ; #2 = Group #1 by employee ID and aggregate the count of evaluations per employee ; #3 = Scan the table employee and retrieve the names and employee IDs of all employees ; #4 = Join #2 and #3 based on the matching employee IDs and retrieve the names and count of evaluations ; #5 = Sort the records from #4 based on the count of evaluations in descending order, select the first record, and identify the name of the employee who received the most awards in evaluations and the count of awards received."
    },
    {
        "id": "3139aeb80c8cefdaf39826e2d00b9d3cd210caeef5fb2ead36207817e06f956c",
        "question": "Find the name of the employee who got the highest one time bonus.",
        "query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID , Bonus ] ; #2 = Scan Table [ employee ] Output [ Name , Employee_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Employee_ID = #2.Employee_ID ] Output [ #1.Bonus , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Bonus DESC ] Output [ Name , Bonus ]",
        "cte": "WITH Scan_1 AS ( SELECT Employee_ID, Bonus FROM employee_hire_evaluation.evaluation ), Scan_2 AS ( SELECT Name, Employee_ID FROM employee_hire_evaluation.employee ), Join_3 AS ( SELECT Scan_1.Bonus, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Employee_ID = Scan_2.Employee_ID ), TopSort_4 AS ( SELECT TOP 1 Name, Bonus FROM Join_3 ORDER BY Bonus DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC",
        "qd": "#1 = Scan the table evaluation and retrieve the employee IDs and bonuses awarded ; #2 = Scan the table employee and retrieve the names and employee IDs of all employees ; #3 = Join #1 and #2 based on the matching employee IDs and retrieve the names and bonuses ; #4 = Sort the records from #3 based on the bonus in descending order, select the first record, and identify the name of the employee who got the highest one-time bonus and the amount of the bonus."
    },
    {
        "id": "944f0b4d6ff267f7af127233f544a13a26d78eac3fd23869c146f15b97c3279f",
        "question": "Which employee received the biggest bonus? Give me the employee name.",
        "query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID , Bonus ] ; #2 = Scan Table [ employee ] Output [ Name , Employee_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Employee_ID = #2.Employee_ID ] Output [ #1.Bonus , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Bonus DESC ] Output [ Name , Bonus ]",
        "cte": "WITH Scan_1 AS ( SELECT Employee_ID, Bonus FROM employee_hire_evaluation.evaluation ), Scan_2 AS ( SELECT Name, Employee_ID FROM employee_hire_evaluation.employee ), Join_3 AS ( SELECT Scan_1.Bonus, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Employee_ID = Scan_2.Employee_ID ), TopSort_4 AS ( SELECT TOP 1 Name, Bonus FROM Join_3 ORDER BY Bonus DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC",
        "qd": "#1 = Scan the table evaluation and retrieve the employee IDs and bonuses awarded ; #2 = Scan the table employee and retrieve the names and employee IDs of all employees ; #3 = Join #1 and #2 based on the matching employee IDs and retrieve the names and bonuses ; #4 = Sort the records from #3 based on the bonus amount in descending order, select the first record, and identify the name of the employee who received the biggest bonus"
    },
    {
        "id": "c850bd4e8300b6e5ba35a342efc45a3c8f2d8ed8a4ce4e92e01bc12f5688331c",
        "question": "Find the names of employees who never won any award in the evaluation.",
        "query": "SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Name , Employee_ID ] ; #2 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Employee_ID ] Output [ Employee_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Employee_ID = #1.Employee_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Employee_ID FROM employee_hire_evaluation.employee ), Scan_2 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_3 AS ( SELECT Employee_ID FROM Scan_2 GROUP BY Employee_ID ), Except_4 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Employee_ID NOT IN (SELECT Employee_ID FROM Aggregate_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT name FROM employee_hire_evaluation.employee  WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation  )",
        "qd": "#1 = Scan the table employee and retrieve the names and employee IDs of all employees ; #2 = Scan the table evaluation and retrieve the employee IDs ; #3 = Group #2 by employee ID to find all the employees who won awards in the evaluation ; #4 = Return the names of employees from #1 who are not in #3 to find the names of employees who never won any award in the evaluation"
    },
    {
        "id": "85aeac6085a45b42a3cb13e9a51a1238d1d7659f549c5d296e0bd0b85977b67f",
        "question": "What are the names of the employees who never received any evaluation?",
        "query": "SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Name , Employee_ID ] ; #2 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Employee_ID ] Output [ Employee_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Employee_ID = #1.Employee_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Employee_ID FROM employee_hire_evaluation.employee ), Scan_2 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_3 AS ( SELECT Employee_ID FROM Scan_2 GROUP BY Employee_ID ), Except_4 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Employee_ID NOT IN (SELECT Employee_ID FROM Aggregate_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT name FROM employee_hire_evaluation.employee  WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation  )",
        "qd": "#1 = Scan the table Employee and retrieve the names and employee IDs of all employees ; #2 = Scan the table Evaluation and retrieve the employee IDs ; #3 = Group #2 by Employee and retrieve the employee IDs ; #4 = Return the names of the employees from #1 that are not in #3 to find the names of the employees who never received any evaluation"
    },
    {
        "id": "9c652b3b6b8008aeefd32407accb5c92e8b77e33db8255bf73373095371f09ac",
        "question": "What is the name of the shop that is hiring the largest number of employees?",
        "query": "SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #1.Shop_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Shop_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_1.Shop_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Shop_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table hiring to find the IDs of all the shops that are currently hiring employees. ; #2 = Scan the table shop to find the names and IDs of all the shops. ; #3 = Join #1 and #2 based on the matching shop IDs and retrieve the shop IDs and names. ; #4 = Group #3 by shop ID and aggregate the count of records per shop ID to find the number of employees being hired by each shop. ; #5 = Sort the records from #4 based on the count of employees being hired in descending order, select the first record, and identify the name of the shop that is hiring the largest number of employees and its count of employees."
    },
    {
        "id": "6a735b312c65119564c18fa7ea1b10ecb2e74b7449a429e88e93ecf303f8eeb5",
        "question": "Which shop has the most employees? Give me the shop name.",
        "query": "SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #1.Shop_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Shop_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_1.Shop_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Shop_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Hiring and retrieve the shop IDs of all the employees ; #2 = Scan the table Shop and retrieve the names and shop IDs of all the shops ; #3 = Join #1 and #2 based on the matching Shop IDs and retrieve the shop IDs and names ; #4 = Group #3 by shop ID and aggregate the count per shop ID to find the number of employees in each shop ; #5 = Sort the records from #4 based on the count of employees in descending order, select the first record, and identify the name of the shop with the most employees and its employee count."
    },
    {
        "id": "72cb3e5d56ab334b4eb7dbfbb1e6d8cac17ea9531d988f83da4a411ca5ed89a6",
        "question": "Find the name of the shops that do not hire any employee.",
        "query": "SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring WITH (FORCESCAN) ) ",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #2 = Scan Table [ hiring ] Output [ Shop_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Shop_ID IS NULL OR #1.Shop_ID = #2.Shop_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Scan_2 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Shop_ID NOT IN (SELECT Shop_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT name FROM employee_hire_evaluation.shop  WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring  )",
        "qd": "#1 = Scan the table shop and retrieve the names and IDs of all shops ; #2 = Scan the table hiring and retrieve the shop IDs of all shops that hire employees ; #3 = Return the names of the shops that are in #1 but not in #2, which are the shops that do not hire any employee."
    },
    {
        "id": "d080be18c27371378e9624a6372e8ba0e7e9f9cde4f841e863a6a2a3aa5ea890",
        "question": "Which shops run with no employees? Find the shop names",
        "query": "SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring WITH (FORCESCAN) ) ",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #2 = Scan Table [ hiring ] Output [ Shop_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Shop_ID IS NULL OR #1.Shop_ID = #2.Shop_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Scan_2 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Shop_ID NOT IN (SELECT Shop_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT name FROM employee_hire_evaluation.shop  WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring  )",
        "qd": "#1 = Scan the table shop and retrieve the names and IDs of all shops. ; #2 = Scan the table hiring and retrieve the shop IDs of all the shops that have employees. ; #3 = Find the shops with no employees by excluding the shop IDs from #2 and retrieve their names from #1."
    },
    {
        "id": "c645e766e0f936794bee7762b6bf8105d088753264597fd96793c738dd10dd91",
        "question": "Find the number of employees hired in each shop; show the shop name as well.",
        "query": "SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name",
        "qd": "#1 = Scan the table hiring and retrieve the shop IDs of all employees who were hired ; #2 = Scan the table shop and retrieve the names and shop IDs of all shops ; #3 = Join #1 and #2 based on the matching Shop IDs and retrieve the names of the shops ; #4 = Group #3 by name and aggregate the count of shop names to find the number of employees hired in each shop; show the shop name as well."
    },
    {
        "id": "d4a90c1eaa15edba9a6d3920f3e16b7bfa906ace797d675ad139dd1f1982ae08",
        "question": "For each shop, return the number of employees working there and the name of the shop.",
        "query": "SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name",
        "qd": "#1 = Scan the table hiring and retrieve all the shop IDs ; #2 = Scan the table shop and retrieve the names and shop IDs of all shops ; #3 = Join #1 and #2 based on the matching Shop IDs and retrieve the names of the shops ; #4 = Group #3 by name and aggregate the count of records per shop to find the number of employees working at each shop and the name of the shop."
    },
    {
        "id": "9d6035ad0ad42b2d785b043e82035e314bdf85d3fa4ae7d8d22cb7a8980c2c5b",
        "question": "What is total bonus given in all evaluations?",
        "query": "SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Bonus ] ; #2 = Aggregate [ #1 ] Output [ SUM(Bonus) AS Sum_Bonus ]",
        "cte": "WITH Scan_1 AS ( SELECT Bonus FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT SUM(Bonus) AS Sum_Bonus FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation",
        "qd": "#1 = Scan the table evaluation and retrieve the bonus of all evaluations ; #2 = Aggregate the sum of all bonuses to find the total bonus given in all evaluations"
    },
    {
        "id": "542cbe30d5c93dbde2e5d22089c6766789949c24e1098ec81ef7fb28853ae1ff",
        "question": "Find the total amount of bonus given in all the evaluations.",
        "query": "SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Bonus ] ; #2 = Aggregate [ #1 ] Output [ SUM(Bonus) AS Sum_Bonus ]",
        "cte": "WITH Scan_1 AS ( SELECT Bonus FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT SUM(Bonus) AS Sum_Bonus FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation",
        "qd": "#1 = Scan the table evaluation and retrieve the bonus amount from all evaluations ; #2 = Aggregate the sum of all the bonus amounts to find the total amount of bonus given in all the evaluations"
    },
    {
        "id": "5c0de2f93c0a4a04d5e485de311035b20abd380bf6580f29e898c84ac4a90fc1",
        "question": "Give me all the information about hiring.",
        "query": "SELECT * FROM employee_hire_evaluation.hiring WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Start_from , Shop_ID , Employee_ID , Is_full_time ]",
        "cte": "WITH Scan_1 AS ( SELECT Start_from, Shop_ID, Employee_ID, Is_full_time FROM employee_hire_evaluation.hiring ) SELECT * FROM Scan_1",
        "clean_query": "SELECT * FROM employee_hire_evaluation.hiring",
        "qd": "#1 = Scan the table hiring and retrieve the start date, shop ID, employee ID, and full-time status of all hirings."
    },
    {
        "id": "9a5c03af4b83ba7b55e93a138b9c8711e265ee47ca1a1ffa85059523cee22920",
        "question": "What is all the information about hiring?",
        "query": "SELECT * FROM employee_hire_evaluation.hiring WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Start_from , Shop_ID , Employee_ID , Is_full_time ]",
        "cte": "WITH Scan_1 AS ( SELECT Start_from, Shop_ID, Employee_ID, Is_full_time FROM employee_hire_evaluation.hiring ) SELECT * FROM Scan_1",
        "clean_query": "SELECT * FROM employee_hire_evaluation.hiring",
        "qd": "#1 = Scan the table hiring and retrieve the start date, shop ID, employee ID, and whether the employee is hired full-time or not for all hiring information."
    },
    {
        "id": "41ac9ea02212af7c1d4afef475a1a3e7678709ec843720d39156c36445ceb7ae",
        "question": "Which district has both stores with less than 3000 products and stores with more than 10000 products?",
        "query": "SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products > 10000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Predicate [ Number_products < 3000 ] Distinct [ true ] Output [ Number_products , District ] ; #2 = Scan Table [ shop ] Predicate [ Number_products > 10000 ] Output [ Number_products , District ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.District = #2.District ] Output [ #1.District ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Number_products, District FROM employee_hire_evaluation.shop WHERE Number_products < 3000 ), Scan_2 AS ( SELECT Number_products, District FROM employee_hire_evaluation.shop WHERE Number_products > 10000 ), Intersect_3 AS ( SELECT Scan_1.District FROM Scan_1 WHERE District IN (SELECT District FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products > 10000",
        "qd": "#1 = Scan the table shop and retrieve the number of products and district of all the stores with less than 3000 products without duplicates ; #2 = Scan the table shop and retrieve the number of products and district of all the stores with more than 10000 products ; #3 = Intersect #1 and #2 based on the matching districts and retrieve the districts"
    },
    {
        "id": "e0677381f837d83064d2983f6482252b89c6d6f8f0f60cad1d6fabe5917d5ec1",
        "question": "Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
        "query": "SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products > 10000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Predicate [ Number_products < 3000 ] Distinct [ true ] Output [ Number_products , District ] ; #2 = Scan Table [ shop ] Predicate [ Number_products > 10000 ] Output [ Number_products , District ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.District = #2.District ] Output [ #1.District ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Number_products, District FROM employee_hire_evaluation.shop WHERE Number_products < 3000 ), Scan_2 AS ( SELECT Number_products, District FROM employee_hire_evaluation.shop WHERE Number_products > 10000 ), Intersect_3 AS ( SELECT Scan_1.District FROM Scan_1 WHERE District IN (SELECT District FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products > 10000",
        "qd": "#1 = Scan the table shop and retrieve the number of products and the district of all shops selling less than 3000 products without duplicates ; #2 = Scan the table shop and retrieve the number of products and the district of all shops selling more than 10000 products ; #3 = Intersect #1 and #2 based on the matching district and retrieve the districts"
    },
    {
        "id": "8f2fa5fd0ef79053cfaef4c8c5f35c04f052a81db289cbdc839fcf8309c7201c",
        "question": "How many different store locations are there?",
        "query": "SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Distinct [ true ] Output [ Location ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Location) AS Count_Dist_Location ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Location) AS Count_Dist_Location FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop",
        "qd": "#1 = Scan the table shop and retrieve all the store locations without duplicates ; #2 = Aggregate the count of distinct store locations to find the number of different store locations"
    },
    {
        "id": "819c2643bf90842bf8740422b759e856df9364f70dfae3b568f5dac7506e4c90",
        "question": "Count the number of distinct store locations.",
        "query": "SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "employee_hire_evaluation | #1 = Scan Table [ shop ] Distinct [ true ] Output [ Location ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Location) AS Count_Dist_Location ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Location) AS Count_Dist_Location FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop",
        "qd": "#1 = Scan the table shop and retrieve all distinct store locations ; #2 = Aggregate the count of distinct store locations to find the number of distinct store locations"
    },
    {
        "id": "eab7bb94e7abc6a9e24b9ce9ebd085bd7718b6149dae5227d4158b83dc38b80a",
        "question": "How many documents do we have?",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Documents and retrieve a constant value of 1 for each record ; #2 = Aggregate the number of records from #1 and retrieve the total count of documents"
    },
    {
        "id": "79abb4aa8ede602463ad0c23ef7d323059fd0942a2c077791c8902fa8a6b3c84",
        "question": "Count the number of documents.",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Documents and retrieve the value 1 for each document ; #2 = Aggregate the number of records from #1 to count the total number of documents"
    },
    {
        "id": "fce8efd12aefcfdc3f2e9ca07f4444e7f1865fffdd2bc1fc7ec53c0727a02f6a",
        "question": "List document IDs, document names, and document descriptions for all documents.",
        "query": "SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Document_Name , Document_ID , Document_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID, Document_Description FROM cre_Doc_Template_Mgt.Documents ) SELECT * FROM Scan_1",
        "clean_query": "SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Documents and retrieve the document IDs, document names, and document descriptions for all documents."
    },
    {
        "id": "adf96d93299f5428237c3f5812145f2761590bac2baec91d082aa82d0d2b0b84",
        "question": "What are the ids, names, and descriptions for all documents?",
        "query": "SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Document_Name , Document_ID , Document_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID, Document_Description FROM cre_Doc_Template_Mgt.Documents ) SELECT * FROM Scan_1",
        "clean_query": "SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Documents and retrieve the document name, document ID, and document description for all documents."
    },
    {
        "id": "7cfeeba3a17801aa0e5e8907ae3de3f7117164f2eac9624d4f86b7caed7ae112",
        "question": "What is the document name and template id for document with description with the letter 'w' in it?",
        "query": "SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE Document_Description LIKE '%w%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Description like '%w%' ] Output [ Document_Name , Document_Description , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_Description, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Description like '%w%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents  WHERE Document_Description LIKE '%w%'",
        "qd": "#1 = Scan the table Documents to find all the documents with a description that contains the letter 'w' in it and retrieve the document name and template ID."
    },
    {
        "id": "18df0d6d89d729ddddb63ab14a7b51091dcdaa8a024eb30d6fc2483580187d04",
        "question": "Return the names and template ids for documents that contain the letter w in their description.",
        "query": "SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE Document_Description LIKE '%w%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Description like '%w%' ] Output [ Document_Name , Document_Description , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_Description, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Description like '%w%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents  WHERE Document_Description LIKE '%w%'",
        "qd": "#1 = Scan the table Documents and retrieve the document names and template ids for all documents that contain the letter w in their description."
    },
    {
        "id": "de7fe93e9fc34cbb4e48313cb3c9d1a8b89df8398f23bf0ed08a5dca217c31d4",
        "question": "What is the document id, template id and description for document named \"Robbin CV\"?",
        "query": "SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE document_name = 'Robbin CV' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Robbin CV' ] Output [ Document_Name , Document_ID , Document_Description , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID, Document_Description, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Robbin CV' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents  WHERE document_name = 'Robbin CV'",
        "qd": "#1 = Scan the table Documents to find the document with the name \"Robbin CV\" and retrieve its document ID, template ID, and description."
    },
    {
        "id": "7571db72eb5bba0f37d0be25e316684fb2c1e9f8c7b68a7a4d919a83bb7e09fa",
        "question": "Return the document id, template id, and description for the document with the name Robbin CV.",
        "query": "SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE document_name = 'Robbin CV' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Robbin CV' ] Output [ Document_Name , Document_ID , Document_Description , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID, Document_Description, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Robbin CV' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents  WHERE document_name = 'Robbin CV'",
        "qd": "#1 = Scan the table Documents and retrieve the document name, document ID, document description, and template ID for the document with the name \"Robbin CV\"."
    },
    {
        "id": "725a0a1fc36a2853a3b3653227520372024a5dba8ae7bed03e06066dc689001d",
        "question": "How many different templates do all document use?",
        "query": "SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Distinct [ true ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Documents and retrieve all the distinct Template IDs used by all documents ; #2 = Aggregate the count of distinct Template IDs to find the number of different templates used by all documents"
    },
    {
        "id": "0fe435ff996ce5bd596ecf192de9539d0b672b65c46ad5ac0b30f3ae4de14179",
        "question": "Count the number of different templates used for documents.",
        "query": "SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Distinct [ true ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Documents and retrieve the distinct Template IDs of all documents. ; #2 = Aggregate the count of distinct Template IDs from #1 to find the number of different templates used for documents."
    },
    {
        "id": "3d42cc6f33bbde3a7435930ec8087870981f004e3da7c98cf437a6de0a7d8d7a",
        "question": "How many documents are using the template with type code 'PPT'?",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #1.Template_ID , #1.Template_Type_Code ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PPT' ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_1.Template_ID, Scan_1.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT'",
        "qd": "#1 = Scan the table Templates to find all the template IDs with type code 'PPT' ; #2 = Scan the table Documents to find all the template IDs used in documents ; #3 = Join #1 and #2 based on the matching template ID and retrieve the template IDs and type codes ; #4 = Aggregate the number of records from #3 to find how many documents are using the template with type code 'PPT'"
    },
    {
        "id": "577492e72abb4721384a009437ef90d0efd51c4d0a2fac6c92e9cceed7781094",
        "question": "Count the number of documents that use the PPT template type.",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #1.Template_ID , #1.Template_Type_Code ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PPT' ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_1.Template_ID, Scan_1.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT'",
        "qd": "#1 = Scan the table Templates to find all the templates with PPT template type and retrieve the template type code and template ID. ; #2 = Scan the table Documents and retrieve all the template IDs. ; #3 = Join #1 and #2 based on the matching template IDs and retrieve the template IDs and template type codes. ; #4 = Aggregate the number of records in #3 to count the number of documents that use the PPT template type."
    },
    {
        "id": "c6bc5150c9983a750e71d9667f462c05d034560988d775220ae3b526e8e64abd",
        "question": "Show all template ids and number of documents using each template.",
        "query": "SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ countstar AS Count_Star , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Template_ID FROM Scan_1 GROUP BY Template_ID ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all documents. ; #2 = Group #1 by template ID and aggregate the count of records per template ID to find the number of documents using each template."
    },
    {
        "id": "21a326c50fe17acbb83d3c76d8ef9b391937207f1540f33c05c37f28ca6a7b67",
        "question": "What are all different template ids used for documents, and how many times were each of them used?",
        "query": "SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ countstar AS Count_Star , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Template_ID FROM Scan_1 GROUP BY Template_ID ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id",
        "qd": "#1 = Scan the table Documents and retrieve all the template IDs used for the documents ; #2 = Group the records from #1 by the template ID and aggregate the count of records per template ID to find how many times each template ID was used for the documents"
    },
    {
        "id": "c3ef543a45f6e5e4f66daf47c8a178b75e697130dea996d32edb01489e7f2b0c",
        "question": "What is the id and type code for the template used by the most documents?",
        "query": "SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ countstar AS Count_Star , Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #2.Count_Star , #3.Template_Type_Code , #2.Template_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Template_Type_Code , Template_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Template_ID FROM Scan_1 GROUP BY Template_ID ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Template_Type_Code, Aggregate_2.Template_ID FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Template_ID = Scan_3.Template_ID ), TopSort_5 AS ( SELECT TOP 1 Template_Type_Code, Template_ID, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all the documents ; #2 = Group #1 by template ID and aggregate the count of each template ID to find which template is used by the most documents ; #3 = Scan the table Templates and retrieve the template type code and template ID ; #4 = Join #2 and #3 based on the matching template ID and retrieve the count of documents, template type code, and template ID ; #5 = Sort the records from #4 based on the count of documents in descending order, select the first record, and retrieve the template type code and template ID for the template used by the most documents"
    },
    {
        "id": "66c3f98482a14280727e245d4aa8fb05ff84ec2ea3d5c2fc79ecd29f068dc541",
        "question": "Return the id and type code of the template that is used for the greatest number of documents.",
        "query": "SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ countstar AS Count_Star , Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #2.Count_Star , #3.Template_Type_Code , #2.Template_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Template_Type_Code , Template_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Template_ID FROM Scan_1 GROUP BY Template_ID ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Template_Type_Code, Aggregate_2.Template_ID FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Template_ID = Scan_3.Template_ID ), TopSort_5 AS ( SELECT TOP 1 Template_Type_Code, Template_ID, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all the documents ; #2 = Group #1 by template ID and count the number of documents per template ID ; #3 = Scan the table Templates and retrieve the template type code and template ID ; #4 = Join #2 and #3 based on the matching template ID and retrieve the count of documents, template type code, and template ID ; #5 = Sort the records from #4 based on the count of documents in descending order, select the first record, and identify the template ID and template type code of the template that is used for the greatest number of documents."
    },
    {
        "id": "4af5f846a2c00cc1660bb52df528a97d9532d57a5546a57a7d2989a3df6518c8",
        "question": "Show ids for all templates that are used by more than one document.",
        "query": "SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ countstar AS Count_Star , Template_ID ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Template_ID FROM Scan_1 GROUP BY Template_ID ), Filter_3 AS ( SELECT Template_ID FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT template_id FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all documents ; #2 = Group #1 by Template_ID and aggregate the count per template ID ; #3 = Filter from #2 all the records with a count greater than 1 and retrieve the template ID"
    },
    {
        "id": "e449e6f942e8de3c7125b40721a8e17af0e967438dc82614ca4da0cc044227c3",
        "question": "What are the template ids of any templates used in more than a single document?",
        "query": "SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ countstar AS Count_Star , Template_ID ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Template_ID FROM Scan_1 GROUP BY Template_ID ), Filter_3 AS ( SELECT Template_ID FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT template_id FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all the documents ; #2 = Group the records from #1 by the template ID and aggregate the count of records per template ID ; #3 = Filter the records from #2 and retrieve the template IDs of templates used in more than a single document"
    },
    {
        "id": "90709a58f713a9b610f22a044e73dd9540902fee65a49244b062b9344b9e1493",
        "question": "Show ids for all templates not used by any document.",
        "query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Template_ID = #1.Template_ID ] Output [ #1.Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Except_3 AS ( SELECT Scan_1.Template_ID FROM Scan_1 WHERE Template_ID NOT IN (SELECT Template_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Templates and retrieve the template IDs of all templates ; #2 = Scan the table Documents and retrieve the template IDs of all documents ; #3 = Return the template IDs from #1 that are not present in #2 to find the IDs of all templates not used by any document"
    },
    {
        "id": "653a2932fa46003787be8119d8beaab1ef997a5cf04809f7712481e7ffdecd2d",
        "question": "What are the ids for templates that are not used in any documents?",
        "query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Template_ID = #1.Template_ID ] Output [ #1.Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Except_3 AS ( SELECT Scan_1.Template_ID FROM Scan_1 WHERE Template_ID NOT IN (SELECT Template_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents",
        "qd": "#1 = Scan the table Templates and retrieve the template IDs of all templates ; #2 = Scan the table Documents and retrieve the template IDs of all documents ; #3 = Return the template IDs from #1 that are not in #2 to find the IDs for templates that are not used in any documents"
    },
    {
        "id": "2d9d0cf37702e5dc6bca104899f8e9e4118cca15f96b64c53fa9158e1aec75f7",
        "question": "How many templates do we have?",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates",
        "qd": "#1 = Scan the table Templates and retrieve a column with constant value 1 for all records ; #2 = Aggregate the number of records in #1 to find the total count of templates we have"
    },
    {
        "id": "ba118082f2f696e0f2bc26b33b647f0029b62f4d0e51713ae5858279f600f595",
        "question": "Count the number of templates.",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates",
        "qd": "#1 = Scan the table Templates and retrieve the value 1 for each template ; #2 = Aggregate the number of records in #1 to find the count of templates."
    },
    {
        "id": "ba3f56f03b1943de5b7ddbd446cd90be44d8e731880028b4f9de9e873e1a5457",
        "question": "Show template ids, version numbers, and template type codes for all templates.",
        "query": "SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID , Version_Number ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID, Version_Number FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates",
        "qd": "#1 = Scan the table Templates and retrieve the template type code, template id, and version number for all templates."
    },
    {
        "id": "64d97831731936fc8fa76d5d897530503fe24df345357db9599440a78381e569",
        "question": "What are the ids, version numbers, and type codes for each template?",
        "query": "SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID , Version_Number ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID, Version_Number FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates",
        "qd": "#1 = Scan the table Templates and retrieve the template type code, template ID, and version number for each template."
    },
    {
        "id": "bdc760b10e114287a082d9d26269eaba08a7116ab333ba86922c908eee77b475",
        "question": "Show all distinct template type codes for all templates.",
        "query": "SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates",
        "qd": "#1 = Scan the table Templates and retrieve all the distinct template type codes used in the templates."
    },
    {
        "id": "5233ddd186d5ebb3489169e89600027c8bd742e7e796b95faebfacd2c2a6b3ea",
        "question": "What are the different template type codes?",
        "query": "SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates",
        "qd": "#1 = Scan the table Templates and retrieve the distinct template type codes"
    },
    {
        "id": "bee611719acb4d7633d62ac694f134c781ebbc780185efb12abf4c9f7ab521e9",
        "question": "What are the ids of templates with template type code PP or PPT?",
        "query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'PP' OR template_type_code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'PP' OR template_type_code = 'PPT'",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes and template IDs of all templates with the template type code PP or PPT"
    },
    {
        "id": "c8b3aede5aace8a4d0ece8d034f406ef98bd0e2a5d513ececdba72e3acb31d3e",
        "question": "Return the ids of templates that have the code PP or PPT.",
        "query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'PP' OR template_type_code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_id FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'PP' OR template_type_code = 'PPT'",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes and template IDs of all templates with the code PP or PPT."
    },
    {
        "id": "7677207c536eff1811ff521af6a0b89899e3c67b81b8c0af18b1a7ded10277b8",
        "question": "How many templates have template type code CV?",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'CV' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'CV' ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'CV' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'CV'",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes of all templates with template type code 'CV' ; #2 = Aggregate the count of records in #1"
    },
    {
        "id": "2889806e9f7d6a3170472334db0059bddb62f3b27c327d85fcbe1953a3a5bb12",
        "question": "Count the number of templates of the type CV.",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'CV' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'CV' ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'CV' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'CV'",
        "qd": "#1 = Scan the table Templates and retrieve the template type code of all templates of the type CV. ; #2 = Aggregate the number of records in #1 to count the number of templates of the type CV."
    },
    {
        "id": "23f904d4bb657c2244387cda5a52f79e36b9bb5a5edd4ce0dc973805fe3d3e58",
        "question": "What is the version number and template type code for the template with version number later than 5?",
        "query": "SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE version_number > 5 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Version_Number > 5 ] Output [ Template_Type_Code , Version_Number ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates WHERE Version_Number > 5 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates  WHERE version_number > 5",
        "qd": "#1 = Scan the table Templates and retrieve the template type code and version number of the templates with version number later than 5"
    },
    {
        "id": "35116c37e2ee06bd187013cda7d51a7b1c1c96f3da8bba25d01a181000644bbc",
        "question": "Return the version numbers and template type codes of templates with a version number greater than 5.",
        "query": "SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE version_number > 5 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Version_Number > 5 ] Output [ Template_Type_Code , Version_Number ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates WHERE Version_Number > 5 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates  WHERE version_number > 5",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes and version numbers of all templates with a version number greater than 5."
    },
    {
        "id": "fd82a9f09b508e811cd8d7220707f1309008b4ff5a1aa9ad7873e7b2d54c7195",
        "question": "Show all template type codes and number of templates for each.",
        "query": "SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes of all templates ; #2 = Group #1 by template type code and aggregate the count of templates for each template type code. Show the template type code and the count."
    },
    {
        "id": "3fad8c40ea6e872d9085dc84fbff9347ef1135d054e5f0ce599cb367400f65e7",
        "question": "What are the different template type codes, and how many templates correspond to each?",
        "query": "SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes of all templates ; #2 = Group the records from #1 by template type code and aggregate the count of templates for each template type code"
    },
    {
        "id": "f94680095338fe6d4fa0872710695fc16a03ebdefc4828a7282775e6eb1b5a6d",
        "question": "Which template type code has most number of templates?",
        "query": "SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Template_Type_Code , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), TopSort_3 AS ( SELECT TOP 1 Template_Type_Code, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Templates and retrieve all the template type codes ; #2 = Group #1 by template type code and aggregate the count of templates per template type code ; #3 = Sort the records from #2 based on the count of templates in descending order, select the first record, and identify the template type code that has the most number of templates and its count of templates."
    },
    {
        "id": "d3f58202801fed06a5f97b5ad10641054333545fa7d15effc5c7fcc10bd721cb",
        "question": "Return the type code of the template type that the most templates belong to.",
        "query": "SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Template_Type_Code , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), TopSort_3 AS ( SELECT TOP 1 Template_Type_Code, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Templates and retrieve the template type code of all templates. ; #2 = Group #1 by template type code and aggregate the count of templates per template type. ; #3 = Sort the records from #2 based on the count of templates in descending order, select the first record, and identify the template type code that the most templates belong to and its count of templates."
    },
    {
        "id": "e90ca10d3b801905b62e731b28f241b782967b8d2548e1057d546192c2a51a80",
        "question": "Show all template type codes with less than three templates.",
        "query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code HAVING count ( * ) < 3 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star < 3 ] Output [ Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), Filter_3 AS ( SELECT Template_Type_Code FROM Aggregate_2 WHERE Count_Star < 3 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code HAVING count ( * ) < 3",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes of all templates. ; #2 = Group #1 by template type code and aggregate the count of templates for each template type. ; #3 = Filter from #2 all the template type codes with a count of templates less than 3."
    },
    {
        "id": "80efc9528d926cc2970eaa5a22f5f4d008fa1a94b6050d71ae100ab15bca8ef7",
        "question": "What are the codes of template types that have fewer than 3 templates?",
        "query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code HAVING count ( * ) < 3 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star < 3 ] Output [ Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), Filter_3 AS ( SELECT Template_Type_Code FROM Aggregate_2 WHERE Count_Star < 3 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code HAVING count ( * ) < 3",
        "qd": "#1 = Scan the table Templates and retrieve the template type codes of all templates ; #2 = Group #1 by template type code and aggregate the count of templates per type code ; #3 = Filter from #2 the template type codes that have a count of templates less than 3 and retrieve the template type codes"
    },
    {
        "id": "035659c5c5e07d718124ae4a3b4635423b78d35990d7ce6a1447c312966c2d8d",
        "question": "What the smallest version number and its template type code?",
        "query": "SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , MIN(Version_Number) AS Min_Version_Number ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, MIN(Version_Number) AS Min_Version_Number FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code",
        "qd": "#1 = Scan the table Templates and retrieve the template type code and version number of all templates ; #2 = Group #1 by template type code and find the minimum version number for each template type code"
    },
    {
        "id": "cce310591b81b5c42d2388e7d5f7462d4d15db56b4ec47479ff05f4b43ad2cfa",
        "question": "Return the lowest version number, along with its corresponding template type code.",
        "query": "SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , MIN(Version_Number) AS Min_Version_Number ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, MIN(Version_Number) AS Min_Version_Number FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code",
        "qd": "#1 = Scan the table Templates and retrieve the template type code and version number of all templates ; #2 = Group #1 by template type code and find the minimum version number for each template type code, retrieve the template type code and its corresponding lowest version number"
    },
    {
        "id": "24951b727022323b841fa4837a8f3c39e5b669a8458b03cfc4f009b4d71d98b1",
        "question": "What is the template type code of the template used by document with the name \"Data base\"?",
        "query": "SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Data base' ] Output [ Document_Name , Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Data base' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base'",
        "qd": "#1 = Scan the table Documents and retrieve the document name and template ID of the document with the name \"Data base\" ; #2 = Scan the table Templates and retrieve the template type code and template ID of all templates ; #3 = Join #1 and #2 based on the matching template IDs and retrieve the template type code of the template used by the document with the name \"Data base\""
    },
    {
        "id": "7d4d00e09ba1ba6a1e7656c6ce0d5484581e271467b204aa8afa2c37ac010302",
        "question": "Return the template type code of the template that is used by a document named Data base.",
        "query": "SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Data base' ] Output [ Document_Name , Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Data base' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base'",
        "qd": "#1 = Scan the table Documents to find the document with the name \"Data base\" and retrieve its document name and template ID. ; #2 = Scan the table Templates to retrieve the template type code and template ID of all templates. ; #3 = Join #1 and #2 based on the matching template ID and retrieve the template type code of the template used by the document with the name \"Data base\"."
    },
    {
        "id": "aa8f4dc719d2148591f8ac649686e938d8fca15a61e0473dba4cde677c04eb35",
        "question": "Show all document names using templates with template type code BK.",
        "query": "SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'BK' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Document_Name , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Document_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'BK' ), Scan_2 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_2.Document_Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK'",
        "qd": "#1 = Scan the table Templates and retrieve the template type code and template ID of all templates with template type code BK. ; #2 = Scan the table Documents and retrieve the document name and template ID of all documents. ; #3 = Join #1 and #2 based on the matching template IDs and retrieve the document names."
    },
    {
        "id": "298d870bec392fa19b20b8832552e950629a8a216a48964ca01db204efba7167",
        "question": "What are the names of documents that use templates with the code BK?",
        "query": "SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'BK' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Document_Name , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Document_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'BK' ), Scan_2 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_2.Document_Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK'",
        "qd": "#1 = Scan the table Templates and retrieve the template type code and template ID of all templates with code BK ; #2 = Scan the table Documents and retrieve the document name and template ID of all documents ; #3 = Join #1 and #2 based on the matching template ID and retrieve the document names that use templates with the code BK"
    },
    {
        "id": "ba9ec7f64a81c18e5612e3c60bd1335237118276d50004d9341e44428f26a6b6",
        "question": "Show all template type codes and the number of documents using each type.",
        "query": "SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all documents ; #2 = Scan the table Templates and retrieve the template type codes and template IDs of all templates ; #3 = Join #1 and #2 based on the matching template IDs and retrieve the template type codes ; #4 = Group #3 by template type code and aggregate the count of each template type code to find the number of documents using each type"
    },
    {
        "id": "021957d7439054583c88614742c82045301c5c4676dc72aef66e2b98ed986b63",
        "question": "What are the different template type codes, and how many documents use each type?",
        "query": "SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all the documents ; #2 = Scan the table Templates and retrieve the template type codes and template IDs ; #3 = Join #1 and #2 based on the matching template ID and retrieve the template type codes ; #4 = Group #3 by template type code and aggregate the count of records to find the number of documents that use each template type code"
    },
    {
        "id": "4ef7c7e7cdfb5f345e3af0a619b2fb55d98588777a38c541dd047cdcc5f39cde",
        "question": "Which template type code is used by most number of documents?",
        "query": "SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Template_Type_Code , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ), TopSort_5 AS ( SELECT TOP 1 Template_Type_Code, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Documents to retrieve the template IDs of all documents ; #2 = Scan the table Templates to retrieve the template type codes and template IDs ; #3 = Join #1 and #2 based on the matching template IDs and retrieve the template type codes ; #4 = Group #3 by template type code and aggregate the count per template type code to find the number of documents for each template type code ; #5 = Sort the records from #4 based on the count of documents in descending order, select the first record, and identify the template type code that is used by the most number of documents and its count of documents."
    },
    {
        "id": "847022cb66cc94760f125822895688d689431d8dd110319a78dea3ac54d8e390",
        "question": "Return the code of the template type that is most commonly used in documents.",
        "query": "SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Template_Type_Code , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ), TopSort_5 AS ( SELECT TOP 1 Template_Type_Code, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Documents and retrieve the template IDs of all documents ; #2 = Scan the table Templates and retrieve the template type codes and template IDs ; #3 = Join #1 and #2 based on the matching template IDs and retrieve the template type codes ; #4 = Group #3 by template type code and aggregate the count per template type code to find the number of occurrences of each template type code ; #5 = Sort the records from #4 based on the count of occurrences in descending order, select the first record, and identify the template type code that is most commonly used in documents and its count of occurrences"
    },
    {
        "id": "d22f2ff3f365ceb1b3d8479abfc5a1b892b0c5d4f31164f40f8a348e01319bb4",
        "question": "Show all template type codes that are not used by any document.",
        "query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Output [ #1.Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Except_5 AS ( SELECT Scan_1.Template_Type_Code FROM Scan_1 WHERE Template_Type_Code NOT IN (SELECT Template_Type_Code FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id",
        "qd": "#1 = Scan the table Templates and retrieve all distinct template type codes ; #2 = Scan the table Documents and retrieve all template IDs ; #3 = Scan the table Templates and retrieve the template type codes and template IDs ; #4 = Join #2 and #3 based on the matching template IDs and retrieve the template type codes ; #5 = Return all the template type codes from #1 that are not present in #4, to find all the template type codes that are not used by any document."
    },
    {
        "id": "16c8b2f4d9463070faff9317b19b1c0ccb8c1c214ccc3d71f8e08fef7bb61dac",
        "question": "What are the codes of template types that are not used for any document?",
        "query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Output [ #1.Template_Type_Code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Except_5 AS ( SELECT Scan_1.Template_Type_Code FROM Scan_1 WHERE Template_Type_Code NOT IN (SELECT Template_Type_Code FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id",
        "qd": "#1 = Scan the table Templates and retrieve the distinct template type codes ; #2 = Scan the table Documents and retrieve all the template IDs ; #3 = Scan the table Templates and retrieve the template type codes and template IDs ; #4 = Join #2 and #3 based on the matching template IDs and retrieve the template type codes ; #5 = Return all the template type codes from #1 that do not exist in #4, which are the template types that are not used for any document."
    },
    {
        "id": "a07879731338a04cef67baf9770bf287adb98fcd9c64d0ac6e36ecd3427e69ad",
        "question": "Show all template type codes and descriptions.",
        "query": "SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type codes and descriptions."
    },
    {
        "id": "293ca51746fc9d32a1dd66c427eca16fb5c854a5a331c121a91808f0c9fb49a7",
        "question": "What are the type codes and descriptions for all template types?",
        "query": "SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type codes and descriptions."
    },
    {
        "id": "f8570300943103954805da5211d88f9110b2dfd81e138e50b0a6fa6285117742",
        "question": "What is the template type descriptions for template type code \"AD\".",
        "query": "SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_code = 'AD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Code = 'AD' ] Output [ Template_Type_Code , Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Code = 'AD' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_code = 'AD'",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type descriptions for the template type code \"AD\"."
    },
    {
        "id": "53552c392e22e333152e2693ed0474d4840881992fc15562e483b439b6782b5d",
        "question": "Return the template type description of the template type with the code AD.",
        "query": "SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_code = 'AD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Code = 'AD' ] Output [ Template_Type_Code , Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Code = 'AD' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_code = 'AD'",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type code and description for the template type with the code AD."
    },
    {
        "id": "f2835d4663242f441aa3f03c81b9ec20269ac042793a9eca922c9cca3f737d5a",
        "question": "What is the template type code for template type description \"Book\".",
        "query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_description = 'Book' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Book' ] Output [ Template_Type_Code , Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Book' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_description = 'Book'",
        "qd": "#1 = Scan the table Ref_Template_Types to find the template type code for the template type description \"Book\"."
    },
    {
        "id": "79080aff1d071f0394c8b61de5cf2fff5f294694291ca094959f8b8e56a97e01",
        "question": "Return the type code of the template type with the description \"Book\".",
        "query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_description = 'Book' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Book' ] Output [ Template_Type_Code , Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Book' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_description = 'Book'",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type code for the template type with the description \"Book\""
    },
    {
        "id": "a5c6e42a1d24d3732f7b16dcde9891a5195f390875ae1f489359f2d7dccfb7a6",
        "question": "What are the distinct template type descriptions for the templates ever used by any document?",
        "query": "SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3 WITH (FORCESCAN) ON T2.Template_ID = T3.template_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Distinct [ true ] Output [ #1.Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Join_5 AS ( SELECT DISTINCT Scan_1.Template_Type_Description FROM Scan_1 JOIN Join_4 ON Scan_1.Template_Type_Code = Join_4.Template_Type_Code ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3  ON T2.Template_ID = T3.template_ID",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type codes and descriptions of all template types ; #2 = Scan the table Documents and retrieve the template IDs of all documents ; #3 = Scan the table Templates and retrieve the template type codes and IDs of all templates ; #4 = Join #2 and #3 based on the matching template IDs and retrieve the template type codes ; #5 = Join #1 and #4 based on the matching template type codes, remove duplicates, and retrieve the template type descriptions"
    },
    {
        "id": "ae0670f297cf9b8c324a52dc99fc74755fa27bb442814673d6e095611d79886f",
        "question": "Return the different descriptions for templates that have been used in a document.",
        "query": "SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3 WITH (FORCESCAN) ON T2.Template_ID = T3.template_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Distinct [ true ] Output [ #1.Template_Type_Description ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Join_5 AS ( SELECT DISTINCT Scan_1.Template_Type_Description FROM Scan_1 JOIN Join_4 ON Scan_1.Template_Type_Code = Join_4.Template_Type_Code ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3  ON T2.Template_ID = T3.template_ID",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type codes and descriptions for all templates ; #2 = Scan the table Documents and retrieve the template IDs of all documents ; #3 = Scan the table Templates and retrieve the template type codes and template IDs ; #4 = Join #2 and #3 based on the matching template IDs and retrieve the template type codes ; #5 = Join #1 and #4 based on the matching template type codes and retrieve the distinct template descriptions"
    },
    {
        "id": "db21dc13f516c2d21d6b03dd40a463b7e9d28a54dd4951c763ef689c9ac77fb9",
        "question": "What are the template ids with template type description \"Presentation\".",
        "query": "SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Presentation' ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_Type_Code = #2.Template_Type_Code ] Output [ #2.Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Presentation' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_Type_Code = Scan_2.Template_Type_Code ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation'",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type code and description of all templates ; #2 = Scan the table Templates and retrieve the template type code and template ID of all templates ; #3 = Join #1 and #2 based on the matching template type code and retrieve the template IDs of templates with the template type description \"Presentation\""
    },
    {
        "id": "a1c640433ac0aa6246e93a4cb6c53dd0dfd6ea14e7528d4c9080d31beb9bc5db",
        "question": "Return the ids corresponding to templates with the description 'Presentation'.",
        "query": "SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Presentation' ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_Type_Code = #2.Template_Type_Code ] Output [ #2.Template_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Presentation' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_Type_Code = Scan_2.Template_Type_Code ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation'",
        "qd": "#1 = Scan the table Ref_Template_Types and retrieve the template type code and description of all templates ; #2 = Scan the table Templates and retrieve the template type code and template ID of all templates ; #3 = Join #1 and #2 based on the matching template type code and retrieve the template IDs of templates with the description 'Presentation'"
    },
    {
        "id": "14759693b8e6ccb3b5373b3635e7c8d5e0763f8e3fd96765eeaf0cd318627e24",
        "question": "How many paragraphs in total?",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs",
        "qd": "#1 = Scan the table Paragraphs and retrieve all the paragraphs ; #2 = Aggregate the count of all paragraphs to find the total number of paragraphs"
    },
    {
        "id": "c68377e24e04a97ee2cb8d163fb6be38ae5e40a2f50c26dc500eeb8432ff76db",
        "question": "Count the number of paragraphs.",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs",
        "qd": "#1 = Scan the table Paragraphs and retrieve each paragraph ; #2 = Aggregate the number of paragraphs to count the total number of paragraphs"
    },
    {
        "id": "25606457dfeb99c81a178c71cf5dbdd5bc475297eaae4baba83c0b3f28a8b5d5",
        "question": "How many paragraphs for the document with name 'Summer Show'?",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Summer Show' ] Output [ Document_Name , Document_ID ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_Name , #1.Document_ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Summer Show' ), Scan_2 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_1.Document_Name, Scan_1.Document_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show'",
        "qd": "#1 = Scan the table Documents to find the document with the name 'Summer Show' and retrieve the document name and ID ; #2 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #3 = Join #1 and #2 based on the matching document ID and retrieve the document name and ID ; #4 = Aggregate the count of all records from #3 to find the number of paragraphs for the document with the name 'Summer Show'"
    },
    {
        "id": "48d4d88081a41b0892197a3c9aa93eac81e0a2158d60ea3843a175b0f2b053c0",
        "question": "Count the number of paragraphs in the document named 'Summer Show'.",
        "query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Summer Show' ] Output [ Document_Name , Document_ID ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_Name , #1.Document_ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Summer Show' ), Scan_2 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_1.Document_Name, Scan_1.Document_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show'",
        "qd": "#1 = Scan the table Documents and retrieve the document name and ID of the document named 'Summer Show' ; #2 = Scan the table Paragraphs and retrieve the document ID of all paragraphs ; #3 = Join #1 and #2 based on the matching Document ID and retrieve the document name and ID of the document named 'Summer Show' ; #4 = Aggregate the number of records in #3 to find the count of paragraphs in the document named 'Summer Show'"
    },
    {
        "id": "d2502ee559df2f596143a49e800b73f835360ae66c3ddae79b9c43c55315a820",
        "question": "Show paragraph details for paragraph with text 'Korea ' .",
        "query": "select other_details FROM cre_Doc_Template_Mgt.paragraphs WITH (FORCESCAN) where paragraph_text like 'korea' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text like 'korea' ] Output [ Paragraph_Text , Other_Details ]",
        "cte": "WITH Scan_1 AS ( SELECT Paragraph_Text, Other_Details FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text like 'korea' ) SELECT * FROM Scan_1",
        "clean_query": "select other_details FROM cre_Doc_Template_Mgt.paragraphs  where paragraph_text like 'korea'",
        "qd": "#1 = Scan the table Paragraphs to find paragraphs with the text 'Korea' and retrieve their paragraph text and other details."
    },
    {
        "id": "121311c3b8547bc02036a7ee997148efc6a18552e09213becf9d418b8b66bdec",
        "question": "What are the details for the paragraph that includes the text 'Korea ' ?",
        "query": "select other_details FROM cre_Doc_Template_Mgt.paragraphs WITH (FORCESCAN) where paragraph_text like 'korea' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text like 'korea' ] Output [ Paragraph_Text , Other_Details ]",
        "cte": "WITH Scan_1 AS ( SELECT Paragraph_Text, Other_Details FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text like 'korea' ) SELECT * FROM Scan_1",
        "clean_query": "select other_details FROM cre_Doc_Template_Mgt.paragraphs  where paragraph_text like 'korea'",
        "qd": "#1 = Scan the table Paragraphs and retrieve the paragraph text and other details for all paragraphs that include the text 'Korea'"
    },
    {
        "id": "5c853eed095b6baf4df9f2f0070d754fac01d936f3136ee93d9295666ec32afc",
        "question": "Show all paragraph ids and texts for the document with name 'Welcome to NY'.",
        "query": "SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Welcome to NY' ] Output [ Document_Name , Document_ID ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text , Paragraph_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_ID , #2.Paragraph_Text ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Welcome to NY' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text, Paragraph_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_ID, Scan_2.Paragraph_Text FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY'",
        "qd": "#1 = Scan the table Documents and retrieve the document ID of the document with the name 'Welcome to NY' ; #2 = Scan the table Paragraphs and retrieve the document ID, paragraph text, and paragraph ID of all paragraphs ; #3 = Join #1 and #2 based on the matching document ID and retrieve the paragraph ID and paragraph text"
    },
    {
        "id": "3d3eca8148eb50a89b259e7e52852f0bc74562a78e97347bc1fabc4ccd9f2592",
        "question": "What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?",
        "query": "SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Welcome to NY' ] Output [ Document_Name , Document_ID ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text , Paragraph_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_ID , #2.Paragraph_Text ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Welcome to NY' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text, Paragraph_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_ID, Scan_2.Paragraph_Text FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY'",
        "qd": "#1 = Scan the table Documents and retrieve the document name and ID of the document titled 'Welcome to NY' ; #2 = Scan the table Paragraphs and retrieve the document ID, paragraph text, and paragraph ID of all paragraphs ; #3 = Join #1 and #2 based on the matching document ID and retrieve the paragraph ID and text of the paragraphs in the document titled 'Welcome to NY'"
    },
    {
        "id": "7b011cefaa29c94bcd921f109c6aba92f00feeee515a5c416047c8829261c99a",
        "question": "Show all paragraph texts for the document \"Customer reviews\".",
        "query": "SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Customer reviews' ] Output [ Document_Name , Document_ID ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Customer reviews' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_Text FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews'",
        "qd": "#1 = Scan the table Documents and retrieve the document ID and name of the document with the name \"Customer reviews\". ; #2 = Scan the table Paragraphs and retrieve the document ID and paragraph text of all paragraphs. ; #3 = Join #1 and #2 based on the matching document ID and retrieve the paragraph text of all paragraphs from the document \"Customer reviews\"."
    },
    {
        "id": "7d29cad1b4024d12284567661ef0e6588258cde70692d06347b87dcde5d31d9b",
        "question": "What are the paragraph texts for the document with the name 'Customer reviews'?",
        "query": "SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Customer reviews' ] Output [ Document_Name , Document_ID ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Customer reviews' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_Text FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews'",
        "qd": "#1 = Scan the table Documents to find the document with the name 'Customer reviews' and retrieve its name and ID. ; #2 = Scan the table Paragraphs and retrieve the document ID and paragraph text of all paragraphs. ; #3 = Join #1 and #2 based on the matching document ID and retrieve the paragraph texts for the document with the name 'Customer reviews'."
    },
    {
        "id": "a2cf4e35c9235fe7fe8b7f23cd46ecbf8798764d9afd5799468de4112f0a8b3d",
        "question": "Show all document ids and the number of paragraphs in each document. Order by document id.",
        "query": "SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY document_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Document_ID ] Output [ Document_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ) SELECT Document_ID, Count_Star FROM Aggregate_2 ORDER BY Document_ID",
        "clean_query": "SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY document_id",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group #1 by document ID and aggregate the count of paragraphs per document ; #3 = Sort the records from #2 based on the document ID in ascending order and retrieve the document ID and the count of paragraphs for each document"
    },
    {
        "id": "8b9d043a303b43c1a782650d2ce723fe3dcd74a534ba49ee19d1b194d80acc7b",
        "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.",
        "query": "SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY document_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Document_ID ] Output [ Document_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ) SELECT Document_ID, Count_Star FROM Aggregate_2 ORDER BY Document_ID",
        "clean_query": "SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY document_id",
        "qd": "#1 = Scan the table Paragraphs and retrieve the Document IDs of all the paragraphs.  ; #2 = Group #1 by Document ID and aggregate the count of paragraphs per Document ID to find the number of paragraphs corresponding to each document.  ; #3 = Sort the records from #2 based on the Document ID in ascending order and retrieve the Document ID along with the corresponding count of paragraphs."
    },
    {
        "id": "5ad21a316fc1e48c6d44ed5198b1070d3760ce48bfd31f752d8ed9e39bd2f980",
        "question": "Show all document ids, names and the number of paragraphs in each document.",
        "query": "SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_Name , Document_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ) SELECT * FROM Join_4",
        "clean_query": "SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs ; #2 = Group the records from #1 by document ID and count the number of paragraphs in each document ; #3 = Scan the table Documents and retrieve the document name and document ID ; #4 = Join #2 and #3 based on the matching document ID and retrieve the count of paragraphs, document ID, and document name for each document"
    },
    {
        "id": "a7a22869d73d48865b3babbf4cd9a658bca2148ab089e5178ccbfef3547536fb",
        "question": "What are the ids and names of each document, as well as the number of paragraphs in each?",
        "query": "SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_Name , Document_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ) SELECT * FROM Join_4",
        "clean_query": "SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group #1 by document ID and aggregate the count of paragraphs to find the number of paragraphs in each document ; #3 = Scan the table Documents and retrieve the document names and IDs of all documents ; #4 = Join #2 and #3 based on the matching document IDs and retrieve the count of paragraphs, document IDs, and document names"
    },
    {
        "id": "00d2bfa30e9d1a0eeec54a5722b019f8d9c849abe3f18da1fd96dcc51e8ab2e6",
        "question": "List all document ids with at least two paragraphs.",
        "query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Document_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Paragraphs and retrieve the Document IDs of all paragraphs. ; #2 = Group the records from #1 by Document IDs and aggregate the count of paragraphs for each Document ID. ; #3 = Filter the records from #2 and retrieve the Document IDs that have at least two paragraphs."
    },
    {
        "id": "18b61f884d9b62c0631faab968c6bb3a753aafc3b726e3b5dbb62a9efe12b1b4",
        "question": "What are the ids of documents that have 2 or more paragraphs?",
        "query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Document_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group #1 by document ID and aggregate the count per document ID to find the number of paragraphs in each document ; #3 = Filter from #2 all the records with a count of paragraphs that is greater than or equal to 2 and retrieve the document IDs"
    },
    {
        "id": "298a9f020337263ed5acf9bcfad40d6801fc573097ccc09cf57b97caf658b304",
        "question": "What is the document id and name with greatest number of paragraphs?",
        "query": "SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_Name , Document_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Document_Name , Document_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ), TopSort_5 AS ( SELECT TOP 1 Document_Name, Document_ID, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group #1 by document ID and count the number of paragraphs per document ; #3 = Scan the table Documents and retrieve the document name and ID ; #4 = Join #2 and #3 based on the matching document ID and retrieve the count of paragraphs, document ID, and document name ; #5 = Sort the records from #4 based on the count of paragraphs in descending order, select the first record, and identify the document ID and name with the greatest number of paragraphs"
    },
    {
        "id": "b3fbd3fffe1bdb198cce71e819e0cf49319e836a0ded36d695ce29110d2b43d3",
        "question": "Return the id and name of the document with the most paragraphs.",
        "query": "SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_Name , Document_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Document_Name , Document_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_Name, Document_ID FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ), TopSort_5 AS ( SELECT TOP 1 Document_Name, Document_ID, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group #1 by document ID and count the number of paragraphs per document ; #3 = Scan the table Documents and retrieve the document name and ID of all documents ; #4 = Join #2 and #3 based on the matching document ID and retrieve the count of paragraphs and the document name ; #5 = Sort the records from #4 based on the count of paragraphs in descending order, select the first record, and retrieve the document name and ID of the document with the most paragraphs."
    },
    {
        "id": "e4f3f3933094ccad96397a211a67ef8bd7f0009aa568a942929d5e84304ff8e5",
        "question": "What is the document id with least number of paragraphs?",
        "query": "SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY count ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Document_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), TopSort_3 AS ( SELECT TOP 1 Document_ID, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY count ( * ) ASC",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group #1 by document ID and aggregate the count of paragraphs per document ID ; #3 = Sort the records from #2 based on the count of paragraphs in ascending order, select the first record, and identify the document ID with the least number of paragraphs and its count of paragraphs."
    },
    {
        "id": "8e3aad50097526966d284fe425eed6f8ffe01c3dca9060ccd62b3d3ff562e4b9",
        "question": "Return the id of the document with the fewest paragraphs.",
        "query": "SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY count ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Document_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), TopSort_3 AS ( SELECT TOP 1 Document_ID, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY count ( * ) ASC",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs. ; #2 = Group #1 by document ID and count the number of paragraphs per document. ; #3 = Sort the records from #2 based on the count of paragraphs in ascending order, select the first record, and retrieve the document ID and the count of paragraphs."
    },
    {
        "id": "111b103537318355b92ca659ac7eb2d1145d8a72756a47d2355826c9c51c0998",
        "question": "What is the document id with 1 to 2 paragraphs?",
        "query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 1 AND Count_Star <= 2 ] Output [ Document_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 1 AND Count_Star <= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Group the records from #1 by Document ID and aggregate the count of paragraphs per document ; #3 = Filter from #2 all the records with the count of paragraphs between 1 and 2, and retrieve the document IDs"
    },
    {
        "id": "593b02f02ed6283fc7f6f920d4f2c675dd951433acf861995146b5c3a0e90968",
        "question": "Give the ids of documents that have between one and two paragraphs.",
        "query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 1 AND Count_Star <= 2 ] Output [ Document_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 1 AND Count_Star <= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs ; #2 = Aggregate the document IDs from #1 by document ID and count the number of paragraphs per document ; #3 = Filter the records from #2 to find the document IDs that have between 1 and 2 paragraphs"
    },
    {
        "id": "12d76df65c31c361eba089ea8e44faefd069c74214a2ba2d4a8b0f5dc7ed7e26",
        "question": "Show the document id with paragraph text 'Brazil' and 'Ireland'.",
        "query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Ireland' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Brazil' ] Distinct [ true ] Output [ Document_ID , Paragraph_Text ] ; #2 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Ireland' ] Output [ Document_ID , Paragraph_Text ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Brazil' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Ireland' ), Intersect_3 AS ( SELECT Scan_1.Document_ID FROM Scan_1 WHERE Document_ID IN (SELECT Document_ID FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Ireland'",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs that have the paragraph text 'Brazil' without duplicates ; #2 = Scan the table Paragraphs and retrieve the document IDs that have the paragraph text 'Ireland' ; #3 = Intersect the document IDs from #1 and #2 based on matching document IDs and retrieve the document IDs that have both 'Brazil' and 'Ireland' paragraph text"
    },
    {
        "id": "527a89df62df5b27b7fecaaec5caaac757cd54ef07aacbae2576450a55d385b0",
        "question": "What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
        "query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Ireland' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Brazil' ] Distinct [ true ] Output [ Document_ID , Paragraph_Text ] ; #2 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Ireland' ] Output [ Document_ID , Paragraph_Text ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Brazil' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Ireland' ), Intersect_3 AS ( SELECT Scan_1.Document_ID FROM Scan_1 WHERE Document_ID IN (SELECT Document_ID FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Ireland'",
        "qd": "#1 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs that contain the text 'Brazil' (without duplicates) ; #2 = Scan the table Paragraphs and retrieve the document IDs of all paragraphs that contain the text 'Ireland' ; #3 = Intersect #1 and #2 based on the matching document IDs and retrieve the document IDs that contain both the texts 'Brazil' and 'Ireland'"
    },
    {
        "id": "7bcee666dc61c24ef33d8f9dc8c2ce0f1d9fcc88e028a8ae269ea5507f2555d6",
        "question": "How many teachers are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM course_teach.teacher",
        "qd": "#1 = Scan the table teacher and retrieve any value (1) for each record ; #2 = Aggregate the number of records from #1 to count the total number of teachers"
    },
    {
        "id": "623537054e505047ae01d4aa98e12d75a8df926e1d7b3f51b1846adcd1990150",
        "question": "What is the total count of teachers?",
        "query": "SELECT count ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM course_teach.teacher",
        "qd": "#1 = Scan the table teacher and retrieve a constant value of 1 for each teacher ; #2 = Aggregate the number of records in #1 to find the total count of teachers"
    },
    {
        "id": "c14783a0953c100a8cdf5562d085bafac95385ffda14252282e3a01b1d41244d",
        "question": "List the names of teachers in ascending order of age.",
        "query": "SELECT Name FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
        "clean_query": "SELECT Name FROM course_teach.teacher  ORDER BY Age ASC",
        "qd": "#1 = Scan the table teacher and retrieve the names and ages of all teachers ; #2 = Sort the records from #1 based on the age in ascending order and retrieve the names and ages"
    },
    {
        "id": "58cef4c0076830335440dd933356d6eec64df763d1e4b8b8da20e69b4b7fb390",
        "question": "What are the names of the teachers ordered by ascending age?",
        "query": "SELECT Name FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
        "clean_query": "SELECT Name FROM course_teach.teacher  ORDER BY Age ASC",
        "qd": "#1 = Scan the table teacher and retrieve the names and ages of all teachers ; #2 = Sort the records from #1 based on the age in ascending order and retrieve the names and ages of all teachers, ordered by ascending age."
    },
    {
        "id": "58b54f5a3d2293d6e55a40e44757181a2c3aed9fb41e5bb4961202045ca48c6e",
        "question": "What are the age and hometown of teachers?",
        "query": "SELECT Age , Hometown FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Age , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Age, Hometown FROM course_teach.teacher ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Age , Hometown FROM course_teach.teacher",
        "qd": "#1 = Scan the table teacher and retrieve the age and hometown of all the teachers."
    },
    {
        "id": "5fd9ccaae0c96c0dbd181367f13e8533d804eda56bffe6c9cf52d2aa5bf2997c",
        "question": "What is the age and hometown of every teacher?",
        "query": "SELECT Age , Hometown FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Age , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Age, Hometown FROM course_teach.teacher ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Age , Hometown FROM course_teach.teacher",
        "qd": "#1 = Scan the table Teacher and retrieve the age and hometown of every teacher."
    },
    {
        "id": "68a7c7be81a8bd9b48f9750cfc34bfa65110ac9eacce30055ad944d8300f8166",
        "question": "List the name of teachers whose hometown is not `` Little Lever Urban District '' .",
        "query": "select name FROM course_teach.teacher WITH (FORCESCAN) where hometown != 'little lever urban district' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Predicate [ Hometown <> 'little lever urban district' ] Output [ Name , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Hometown FROM course_teach.teacher WHERE Hometown <> 'little lever urban district' ) SELECT * FROM Scan_1",
        "clean_query": "select name FROM course_teach.teacher  where hometown != 'little lever urban district'",
        "qd": "#1 = Scan the table teacher and retrieve the names of teachers whose hometown is not \"Little Lever Urban District\"."
    },
    {
        "id": "0af2de205b31198e6eca3d7b0b73802ad3764080025941cb66a392eda65a9e13",
        "question": "What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?",
        "query": "select name FROM course_teach.teacher WITH (FORCESCAN) where hometown != 'little lever urban district' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Predicate [ Hometown <> 'little lever urban district' ] Output [ Name , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Hometown FROM course_teach.teacher WHERE Hometown <> 'little lever urban district' ) SELECT * FROM Scan_1",
        "clean_query": "select name FROM course_teach.teacher  where hometown != 'little lever urban district'",
        "qd": "#1 = Scan the table teacher and retrieve the names of the teachers whose hometown is not \"Little Lever Urban District\"."
    },
    {
        "id": "874d7f27668df1183762770b3c6571180db780700251069053ba4401174165ef",
        "question": "Show the name of teachers aged either 32 or 33?",
        "query": "SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Age = 32 OR Age = 33 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Predicate [ Age = 32 OR Age = 33 ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher WHERE Age = 32 OR Age = 33 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM course_teach.teacher  WHERE Age = 32 OR Age = 33",
        "qd": "#1 = Scan the table teacher and retrieve the names of all teachers with age 32 or 33"
    },
    {
        "id": "37c6344d0991afd89c9c159fc6a00dd71a4e656faeb14892c43cb3a1d63c0848",
        "question": "What are the names of the teachers who are aged either 32 or 33?",
        "query": "SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Age = 32 OR Age = 33 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Predicate [ Age = 32 OR Age = 33 ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher WHERE Age = 32 OR Age = 33 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM course_teach.teacher  WHERE Age = 32 OR Age = 33",
        "qd": "#1 = Scan the table teacher and retrieve the names of the teachers who are either 32 or 33 years old."
    },
    {
        "id": "81ea1ebcc988a1d5cfb2f5eed7737cbd6d17b0cb15f16a9d08837af696997f07",
        "question": "What is the hometown of the youngest teacher?",
        "query": "SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Age , Hometown ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Age , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Age, Hometown FROM course_teach.teacher ), TopSort_2 AS ( SELECT TOP 1 Age, Hometown FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Hometown FROM course_teach.teacher  ORDER BY Age ASC",
        "qd": "#1 = Scan the table Teacher and retrieve the age and hometown of all teachers. ; #2 = Sort the records from #1 based on the age of the teachers in ascending order, select the first record, and identify the hometown of the youngest teacher."
    },
    {
        "id": "3a98eaad53fc81c47f32a49cd7ec2e73520ec75e0536d99059050386a10ee590",
        "question": "Where is the youngest teacher from?",
        "query": "SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Age , Hometown ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Age , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Age, Hometown FROM course_teach.teacher ), TopSort_2 AS ( SELECT TOP 1 Age, Hometown FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Hometown FROM course_teach.teacher  ORDER BY Age ASC",
        "qd": "#1 = Scan the table teacher and retrieve the age and hometown of all teachers ; #2 = Sort the records from #1 based on the age in ascending order, select the first record, and identify the hometown of the youngest teacher"
    },
    {
        "id": "603bc70182ffde705ac9eac27f319a5aba32804cf32d8fb791f32b264dd03922",
        "question": "Show different hometown of teachers and the number of teachers from each hometown.",
        "query": "SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ countstar AS Count_Star , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Hometown FROM Scan_1 GROUP BY Hometown ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher  GROUP BY Hometown",
        "qd": "#1 = Scan the table teacher and retrieve the hometown of all the teachers. ; #2 = Group #1 by hometown and aggregate the count per hometown to find the number of teachers from each hometown. Return the count of teachers and the hometown."
    },
    {
        "id": "e2b8750d45f4e92cca02f5e87e2becaf9a4b4744049c22ccedd4cfd3a3d0dfd7",
        "question": "For each hometown, how many teachers are there?",
        "query": "SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ countstar AS Count_Star , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Hometown FROM Scan_1 GROUP BY Hometown ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher  GROUP BY Hometown",
        "qd": "#1 = Scan the table teacher and retrieve the hometown of each teacher ; #2 = Group #1 by hometown and aggregate the count of teachers per hometown to find the number of teachers in each hometown"
    },
    {
        "id": "6b47ad0390ba5a23811643ceb795c832310e9b535c05f9d935d83a9fe79d8f85",
        "question": "List the most common hometown of teachers.",
        "query": "SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ countstar AS Count_Star , Hometown ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Hometown FROM Scan_1 GROUP BY Hometown ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Hometown FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Hometown FROM course_teach.teacher  GROUP BY Hometown ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table teacher and retrieve the hometown of all teachers. ; #2 = Group #1 by hometown and aggregate the count of teachers per hometown. ; #3 = Sort the records from #2 based on the count of teachers in descending order, select the first record, and identify the hometown that is the most common among teachers."
    },
    {
        "id": "4611a9d09e6d3dd627d95b6c315e97d00104bed81aa905e8c242ca35c0671678",
        "question": "What is the most commmon hometowns for teachers?",
        "query": "SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ countstar AS Count_Star , Hometown ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Hometown FROM Scan_1 GROUP BY Hometown ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Hometown FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Hometown FROM course_teach.teacher  GROUP BY Hometown ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table teacher and retrieve the hometowns of all teachers. ; #2 = Group the records from #1 by hometown and aggregate the count of teachers per hometown. ; #3 = Sort the records from #2 based on the count of teachers in descending order, select the first record, and identify the most common hometown for teachers and its count."
    },
    {
        "id": "6b280b59c701284ea7d360487270d2cdccc7b55f90b65e9d7e7484f4be0a3e78",
        "question": "Show the hometowns shared by at least two teachers.",
        "query": "SELECT Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ countstar AS Count_Star , Hometown ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Hometown FROM Scan_1 GROUP BY Hometown ), Filter_3 AS ( SELECT Hometown FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT Hometown FROM course_teach.teacher  GROUP BY Hometown HAVING COUNT ( * ) > = 2",
        "qd": "#1 = Scan the table teacher and retrieve the hometowns of all teachers. ; #2 = Group the records from #1 by hometown and aggregate the count of teachers per hometown. ; #3 = Filter the records from #2 to only include the hometowns that have a count of at least 2 teachers and retrieve the hometowns."
    },
    {
        "id": "0e79c74a5610e5c303a789fad6b46b6a88e4328a1f400bf558be69eaac43af46",
        "question": "What are the towns from which at least two teachers come from?",
        "query": "SELECT Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ countstar AS Count_Star , Hometown ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Hometown ]",
        "cte": "WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Hometown FROM Scan_1 GROUP BY Hometown ), Filter_3 AS ( SELECT Hometown FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT Hometown FROM course_teach.teacher  GROUP BY Hometown HAVING COUNT ( * ) > = 2",
        "qd": "#1 = Scan the table teacher and retrieve the hometown of all teachers ; #2 = Group #1 by hometown and aggregate the count of teachers per hometown ; #3 = Filter #2 and return the hometowns where the count of teachers is greater than or equal to 2"
    },
    {
        "id": "8bdd139d26705091a90878940a67335d43bde42567b0dbcd021c9dd118a84d20",
        "question": "Show names of teachers and the courses they are arranged to teach.",
        "query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name , #3.Course ]",
        "cte": "WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name, Join_3.Course FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID",
        "qd": "#1 = Scan the table course_arrange and retrieve the course IDs and teacher IDs of all the course arrangements ; #2 = Scan the table course and retrieve the course IDs and courses of all the courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the courses and teacher IDs ; #4 = Scan the table teacher and retrieve the names and teacher IDs of all the teachers ; #5 = Join #3 and #4 based on the matching teacher IDs and retrieve the names of the teachers and the courses they are arranged to teach"
    },
    {
        "id": "e39c8aa6302e480ebe544ab36de4875b9b45d00eee51f4cc97c46be201830fa9",
        "question": "What is the name of each teacher and what course they teach?",
        "query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name , #3.Course ]",
        "cte": "WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name, Join_3.Course FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID",
        "qd": "#1 = Scan the table course_arrange and retrieve the course IDs and teacher IDs of all course arrangements ; #2 = Scan the table course and retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names and teacher IDs ; #4 = Scan the table teacher and retrieve the names and teacher IDs of all teachers ; #5 = Join #3 and #4 based on the matching teacher IDs and retrieve the names of each teacher and the course they teach"
    },
    {
        "id": "9ae78bb93870f4f5e609eea4e7be9e17d17f90eedf2b3f5d801460325259aff7",
        "question": "Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.",
        "query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name , #3.Course ] ; #6 = Sort [ #5 ] OrderBy [ Name ASC ] Output [ Name , Course ]",
        "cte": "WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name, Join_3.Course FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT Name, Course FROM Join_5 ORDER BY Name ASC",
        "clean_query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name",
        "qd": "#1 = Scan the table course_arrange to retrieve the course IDs and teacher IDs of all course arrangements ; #2 = Scan the table course to retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names and teacher IDs ; #4 = Scan the table teacher to retrieve the names and teacher IDs of all teachers ; #5 = Join #3 and #4 based on the matching teacher IDs and retrieve the names and course names ; #6 = Sort the records from #5 based on the teacher's name in ascending order and retrieve the names of the teachers and the courses they are arranged to teach"
    },
    {
        "id": "02c89bd982dfca591b480780bb255fb46d9d7c0a268f6bb76ecdce5f1f7f6bf2",
        "question": "What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?",
        "query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name , #3.Course ] ; #6 = Sort [ #5 ] OrderBy [ Name ASC ] Output [ Name , Course ]",
        "cte": "WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name, Join_3.Course FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT Name, Course FROM Join_5 ORDER BY Name ASC",
        "clean_query": "SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name",
        "qd": "#1 = Scan the table course_arrange and retrieve the course IDs and teacher IDs of all course arrangements ; #2 = Scan the table course and retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the names of the courses and the teacher IDs ; #4 = Scan the table teacher and retrieve the names and teacher IDs of all teachers ; #5 = Join #3 and #4 based on the matching teacher IDs and retrieve the names of the teachers and the courses they teach ; #6 = Sort the records from #5 based on the name of the teacher in ascending alphabetical order and retrieve the names of the teachers and the courses they teach"
    },
    {
        "id": "2e8baf9e453be42a11b71337dbfa3196ce81ab88196a3965e5d9eaef85ff4a28",
        "question": "Show the name of the teacher for the math course.",
        "query": "SELECT T3.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course ] Predicate [ Course = 'Math' ] Output [ Course_ID , Course ] ; #2 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Course_ID, Course FROM course_teach.course WHERE Course = 'Math' ), Scan_2 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Join_3 AS ( SELECT Scan_2.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T3.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math'",
        "qd": "#1 = Scan the table course and retrieve the course ID and name of the math course ; #2 = Scan the table course_arrange and retrieve the course ID and teacher ID of all courses ; #3 = Join #1 and #2 based on the matching course ID and retrieve the teacher ID ; #4 = Scan the table teacher and retrieve the name and teacher ID of all teachers ; #5 = Join #3 and #4 based on the matching teacher ID and retrieve the name of the teacher for the math course"
    },
    {
        "id": "3bd79e8079339ca598e74c333c4128f10638b4de9de645b52185fcd23d3115a4",
        "question": "What are the names of the people who teach math courses?",
        "query": "SELECT T3.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course ] Predicate [ Course = 'Math' ] Output [ Course_ID , Course ] ; #2 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Course_ID, Course FROM course_teach.course WHERE Course = 'Math' ), Scan_2 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Join_3 AS ( SELECT Scan_2.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T3.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math'",
        "qd": "#1 = Scan the table course and retrieve the course IDs and names of all math courses ; #2 = Scan the table course_arrange and retrieve the course IDs and teacher IDs of all course arrangements ; #3 = Join #1 and #2 based on the matching course ID and retrieve the teacher IDs ; #4 = Scan the table teacher and retrieve the names and teacher IDs of all teachers ; #5 = Join #3 and #4 based on the matching teacher ID and retrieve the names of the people who teach math courses"
    },
    {
        "id": "6b56664c45bbe45ade08c28a7892035d10283d0f493698f906bdc3a78a9ca431",
        "question": "Show names of teachers and the number of courses they teach.",
        "query": "SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name",
        "qd": "#1 = Scan the table course_arrange and retrieve the teacher IDs of all the course arrangements ; #2 = Scan the table teacher and retrieve the names and teacher IDs of all teachers ; #3 = Join #1 and #2 based on the matching teacher IDs and retrieve the names of the teachers ; #4 = Group #3 by name and aggregate the count per name to find the number of courses taught by each teacher"
    },
    {
        "id": "287c13b7cc426c370cd220879683109522739aad32877db06c470639a03a973a",
        "question": "What are the names of the teachers and how many courses do they teach?",
        "query": "SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name",
        "qd": "#1 = Scan the table course_arrange and retrieve the teacher IDs of all course arrangements ; #2 = Scan the table teacher and retrieve the names and teacher IDs of all teachers ; #3 = Join #1 and #2 based on the matching teacher IDs and retrieve the names of the teachers ; #4 = Group #3 by name and aggregate the count per name to find how many courses each teacher teaches"
    },
    {
        "id": "5a00e81d064799fc71f61f7eddc83f1fcad00988da1b787b02501bb425797671",
        "question": "Show names of teachers that teach at least two courses.",
        "query": "SELECT T2.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2",
        "qd": "#1 = Scan the table course_arrange and retrieve the teacher IDs of all course arrangements ; #2 = Scan the table teacher and retrieve the names and teacher IDs of all teachers ; #3 = Join #1 and #2 based on the matching teacher IDs and retrieve the names of the teachers ; #4 = Group #3 by name and aggregate the count per name to find the number of courses taught by each teacher ; #5 = Filter from #4 all the teachers with at least 2 courses and retrieve their names."
    },
    {
        "id": "402c83aa7e9857cd245b007d9858090ddba77f61656583eb61ff34afc92fa7b2",
        "question": "What are the names of the teachers who teach at least two courses?",
        "query": "SELECT T2.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2",
        "qd": "#1 = Scan the table course_arrange and retrieve the teacher IDs of all the courses that are arranged ; #2 = Scan the table teacher and retrieve the names and teacher IDs of all the teachers ; #3 = Join #1 and #2 based on the matching teacher IDs and retrieve the names of the teachers ; #4 = Group #3 by name and aggregate the count per name to find the number of courses taught by each teacher ; #5 = Filter from #4 all the teachers with at least 2 courses taught and retrieve their names"
    },
    {
        "id": "caa8cc9af95a5c1b20b0bf682fe3c0c874b0f7df744592b557c3a30bbd608e52",
        "question": "List the names of teachers who have not been arranged to teach courses.",
        "query": "SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #2 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Teacher_ID = #1.Teacher_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Scan_2 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Name FROM course_teach.teacher  WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange  )",
        "qd": "#1 = Scan the table teacher and retrieve the names and IDs of all teachers ; #2 = Scan the table course_arrange and retrieve the IDs of all teachers who have been arranged to teach courses ; #3 = Return the names of the teachers from #1 who have not been arranged to teach any courses"
    },
    {
        "id": "ef3355a7fe3ce05cbe2e30e7a414c19cd64cc838a7d6cdb2e91aaea1f1811886",
        "question": "What are the names of the teachers whose courses have not been arranged?",
        "query": "SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "course_teach | #1 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #2 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Teacher_ID = #1.Teacher_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Scan_2 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Name FROM course_teach.teacher  WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange  )",
        "qd": "#1 = Scan the table teacher and retrieve the names and IDs of all teachers ; #2 = Scan the table course_arrange and retrieve the IDs of teachers for whom courses have been arranged ; #3 = Return the names of the teachers from #1 whose courses have not been arranged, based on the matching teacher IDs between #1 and #2"
    },
    {
        "id": "ccf0a1234580e327589862c55c99a5568deaaa030d338a8f77d11c02036eab31",
        "question": "How many visitors below age 30 are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM museum_visit.visitor WITH (FORCESCAN) WHERE age < 30 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visitor ] Predicate [ Age < 30 ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Age FROM museum_visit.visitor WHERE Age < 30 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM museum_visit.visitor  WHERE age < 30",
        "qd": "#1 = Scan the table Visitor and retrieve the age of all visitors below 30 years old ; #2 = Aggregate the number of records from #1 and retrieve the count of visitors below age 30"
    },
    {
        "id": "2b4311470404464d3aceb7aa1ee3fe0b8a84f764405a2eec8a7224e91344cc85",
        "question": "Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.",
        "query": "SELECT name FROM museum_visit.visitor WITH (FORCESCAN) WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership > 4 ] Output [ Name , Level_of_membership ] ; #2 = Sort [ #1 ] OrderBy [ Level_of_membership DESC ] Output [ Name , Level_of_membership ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Level_of_membership FROM museum_visit.visitor WHERE Level_of_membership > 4 ) SELECT Name, Level_of_membership FROM Scan_1 ORDER BY Level_of_membership DESC",
        "clean_query": "SELECT name FROM museum_visit.visitor  WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC",
        "qd": "#1 = Scan the table Visitor to find the names and membership levels of all visitors with a membership level higher than 4 ; #2 = Sort the records from #1 based on the membership level in descending order and retrieve the names and membership levels"
    },
    {
        "id": "e55c321fe2277cb22a4cdb52e32820d830e29d08212b93e1f6ed54a5c0f64e43",
        "question": "What is the average age of the visitors whose membership level is not higher than 4?",
        "query": "SELECT avg ( age ) AS Avg_age FROM museum_visit.visitor WITH (FORCESCAN) WHERE Level_of_membership < = 4 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership <= 4 ] Output [ Level_of_membership , Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Level_of_membership, Age FROM museum_visit.visitor WHERE Level_of_membership <= 4 ), Aggregate_2 AS ( SELECT AVG(Age) AS Avg_Age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( age ) AS Avg_age FROM museum_visit.visitor  WHERE Level_of_membership < = 4",
        "qd": "#1 = Scan the table Visitor to find who are the visitors with membership level not higher than 4 ; #2 = Aggregate the average age of the visitors from #1 to find the average age of the visitors whose membership level is not higher than 4"
    },
    {
        "id": "c3bc8027a1635183c2a5ab079b6bd0b8d12076ab770b908c0ea6bfc617303969",
        "question": "Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.",
        "query": "SELECT name , Level_of_membership FROM museum_visit.visitor WITH (FORCESCAN) WHERE Level_of_membership > 4 ORDER BY age DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership > 4 ] Output [ Name , Level_of_membership , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Level_of_membership , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Level_of_membership, Age FROM museum_visit.visitor WHERE Level_of_membership > 4 ) SELECT Name, Level_of_membership, Age FROM Scan_1 ORDER BY Age DESC",
        "clean_query": "SELECT name , Level_of_membership FROM museum_visit.visitor  WHERE Level_of_membership > 4 ORDER BY age DESC",
        "qd": "#1 = Scan the table visitor and retrieve the names and membership levels of all visitors whose membership level is higher than 4. ; #2 = Sort the records from #1 based on the age of visitors in descending order and retrieve the names and membership levels."
    },
    {
        "id": "60e9a83821454bd3ff7a90d11440f1e090c22d5ce2e40674a210dd1189f47522",
        "question": "Find the id and name of the museum that has the most staff members?",
        "query": "SELECT TOP 1 museum_id , name FROM museum_visit.museum WITH (FORCESCAN) ORDER BY num_of_staff DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Output [ Name , Num_of_Staff , Museum_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Num_of_Staff DESC ] Output [ Name , Num_of_Staff , Museum_ID ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Num_of_Staff, Museum_ID FROM museum_visit.museum ), TopSort_2 AS ( SELECT TOP 1 Name, Num_of_Staff, Museum_ID FROM Scan_1 ORDER BY Num_of_Staff DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 museum_id , name FROM museum_visit.museum  ORDER BY num_of_staff DESC",
        "qd": "#1 = Scan the table museum and retrieve the names, number of staff members, and museum IDs of all museums ; #2 = Sort the records from #1 based on the number of staff members in descending order, select the first record, and retrieve the name and ID of the museum with the most staff members"
    },
    {
        "id": "5c3c8a98e8d4b701ff4536883ed85090028f3f9d26cd21f026fd0d2664bc61c8",
        "question": "Find the average number of staff working for the museums that were open before 2009.",
        "query": "SELECT avg ( num_of_staff ) AS Avg_num_of_staff FROM museum_visit.museum WITH (FORCESCAN) WHERE open_year < 2009 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year < 2009 ] Output [ Num_of_Staff , Open_Year ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_of_Staff) AS Avg_Num_of_Staff ]",
        "cte": "WITH Scan_1 AS ( SELECT Num_of_Staff, Open_Year FROM museum_visit.museum WHERE Open_Year < 2009 ), Aggregate_2 AS ( SELECT AVG(Num_of_Staff) AS Avg_Num_of_Staff FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( num_of_staff ) AS Avg_num_of_staff FROM museum_visit.museum  WHERE open_year < 2009",
        "qd": "#1 = Scan the table museum and retrieve the number of staff and open year of all museums that were opened before 2009. ; #2 = Calculate the average number of staff from #1 to find the average number of staff working for the museums that were open before 2009."
    },
    {
        "id": "de129d84d27db6a0fb572077f40706c07205c6e5de0feaa6dda6ccf452c57217",
        "question": "What are the opening year and staff number of the museum named Plaza Museum?",
        "query": "SELECT Num_of_Staff , Open_Year FROM museum_visit.museum WITH (FORCESCAN) WHERE name = 'Plaza Museum' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Predicate [ Name = 'Plaza Museum' ] Output [ Name , Num_of_Staff , Open_Year ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Num_of_Staff, Open_Year FROM museum_visit.museum WHERE Name = 'Plaza Museum' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Num_of_Staff , Open_Year FROM museum_visit.museum  WHERE name = 'Plaza Museum'",
        "qd": "#1 = Scan the table museum and retrieve the name, staff number, and opening year of the museum named Plaza Museum"
    },
    {
        "id": "179c60a2a7a0834d0afcd9c0c07b9051c8adb59bea2837c5aef588b199ee14dd",
        "question": "find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.",
        "query": "SELECT name FROM museum_visit.museum WITH (FORCESCAN) WHERE num_of_staff > ( SELECT min ( num_of_staff ) AS Min_num_of_staff FROM museum_visit.museum WITH (FORCESCAN) WHERE open_year > 2010 ) ",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year > 2010 ] Output [ Num_of_Staff , Open_Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Num_of_Staff) AS Min_Num_of_Staff ] ; #3 = Scan Table [ museum ] Output [ Name , Num_of_Staff ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Num_of_Staff > #2.Min_Num_of_Staff ] Output [ #3.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Num_of_Staff, Open_Year FROM museum_visit.museum WHERE Open_Year > 2010 ), Aggregate_2 AS ( SELECT MIN(Num_of_Staff) AS Min_Num_of_Staff FROM Scan_1 ), Scan_3 AS ( SELECT Name, Num_of_Staff FROM museum_visit.museum ), Join_4 AS ( SELECT Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Num_of_Staff > Aggregate_2.Min_Num_of_Staff ) SELECT * FROM Join_4",
        "clean_query": "SELECT name FROM museum_visit.museum  WHERE num_of_staff > ( SELECT min ( num_of_staff ) AS Min_num_of_staff FROM museum_visit.museum  WHERE open_year > 2010 )",
        "qd": "#1 = Scan the table museum and retrieve the number of staff and opening year of all museums opened after 2010 ; #2 = Aggregate #1 and find the minimum number of staff as Min_Num_of_Staff ; #3 = Scan the table museum and retrieve the names and number of staff of all museums ; #4 = Join #2 and #3 based on the condition that the number of staff in #3 is greater than the minimum number of staff in #2 and retrieve the names of museums with more staff than the minimum staff number of all museums opened after 2010"
    },
    {
        "id": "0a0317dc30dddb0490383d219a1b1f2002d1ff2a27e96ed69090c468a73e9bcb",
        "question": "find the id, name and age for visitors who visited some museums more than once.",
        "query": "SELECT t1.id , t1.name , t1.age FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id GROUP BY t1.id , t1.name , t1.age HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visit ] Output [ visitor_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ visitor_ID ] Output [ visitor_ID , countstar AS Count_Star ] ; #3 = Scan Table [ visitor ] Output [ Name , ID , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.visitor_ID = #3.ID ] Output [ #3.Name , #2.Count_Star , #3.ID , #3.Age ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name , ID , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT visitor_ID FROM museum_visit.visit ), Aggregate_2 AS ( SELECT visitor_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY visitor_ID ), Scan_3 AS ( SELECT Name, ID, Age FROM museum_visit.visitor ), Join_4 AS ( SELECT Scan_3.Name, Aggregate_2.Count_Star, Scan_3.ID, Scan_3.Age FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.visitor_ID = Scan_3.ID ), Filter_5 AS ( SELECT Name, ID, Age FROM Join_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT t1.id , t1.name , t1.age FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id GROUP BY t1.id , t1.name , t1.age HAVING count ( * ) > 1",
        "qd": "#1 = Scan the table Visit and retrieve the visitor IDs of all visits ; #2 = Group #1 by visitor ID and aggregate the count per visitor ID to find the number of visits made by each visitor ; #3 = Scan the table Visitor and retrieve the names, IDs, and ages of all visitors ; #4 = Join #2 and #3 based on the matching visitor IDs and retrieve the names, IDs, ages, and visit counts ; #5 = Filter from #4 the visitors who have visited museums more than once and retrieve their names, IDs, and ages"
    },
    {
        "id": "35123af8dc9b9ee62fb89c900e54cbc078224381186a88392dae10e50a7427b8",
        "question": "What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?",
        "query": "SELECT TOP 1 t2.visitor_id , t1.name , t1.Level_of_membership FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id GROUP BY t2.visitor_id , t1.name , t1.Level_of_membership ORDER BY sum ( t2.Total_spent ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visit ] Output [ visitor_ID , Total_spent ] ; #2 = Aggregate [ #1 ] GroupBy [ visitor_ID ] Output [ visitor_ID , SUM(Total_spent) AS Sum_Total_spent ] ; #3 = Scan Table [ visitor ] Output [ Name , Level_of_membership , ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.visitor_ID = #3.ID ] Output [ #2.Sum_Total_spent , #3.Name , #2.visitor_ID , #3.Level_of_membership ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_Total_spent DESC ] Output [ Name , Level_of_membership , visitor_ID , Sum_Total_spent ]",
        "cte": "WITH Scan_1 AS ( SELECT visitor_ID, Total_spent FROM museum_visit.visit ), Aggregate_2 AS ( SELECT visitor_ID, SUM(Total_spent) AS Sum_Total_spent FROM Scan_1 GROUP BY visitor_ID ), Scan_3 AS ( SELECT Name, Level_of_membership, ID FROM museum_visit.visitor ), Join_4 AS ( SELECT Aggregate_2.Sum_Total_spent, Scan_3.Name, Aggregate_2.visitor_ID, Scan_3.Level_of_membership FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.visitor_ID = Scan_3.ID ), TopSort_5 AS ( SELECT TOP 1 Name, Level_of_membership, visitor_ID, Sum_Total_spent FROM Join_4 ORDER BY Sum_Total_spent DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 t2.visitor_id , t1.name , t1.Level_of_membership FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id GROUP BY t2.visitor_id , t1.name , t1.Level_of_membership ORDER BY sum ( t2.Total_spent ) DESC",
        "qd": "#1 = Scan the table visit and retrieve the visitor IDs and total spent amount for all visits to museums ; #2 = Group #1 by visitor ID and aggregate the sum of total spent amount for each visitor ; #3 = Scan the table visitor and retrieve the names, membership levels, and IDs of all visitors ; #4 = Join #2 and #3 based on the matching visitor ID and retrieve the total spent amount, names, membership levels, and visitor IDs ; #5 = Sort the records from #4 based on the sum of total spent amount in descending order, select the first record, and retrieve the name, membership level, visitor ID, and the total spent amount of the visitor who has spent the largest amount of money in total in all museum tickets"
    },
    {
        "id": "9904b062c563102b86314357314958e0648753b448df996620cdf9be065e0f0e",
        "question": "What are the id and name of the museum visited most times?",
        "query": "SELECT TOP 1 t2.Museum_ID , t1.name FROM museum_visit.museum AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.Museum_ID = t2.Museum_ID GROUP BY t2.Museum_ID , t1.name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visit ] Output [ Museum_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Museum_ID ] Output [ countstar AS Count_Star , Museum_ID ] ; #3 = Scan Table [ museum ] Output [ Name , Museum_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Museum_ID = #3.Museum_ID ] Output [ #3.Name , #2.Count_Star , #2.Museum_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Museum_ID , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Museum_ID FROM museum_visit.visit ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Museum_ID FROM Scan_1 GROUP BY Museum_ID ), Scan_3 AS ( SELECT Name, Museum_ID FROM museum_visit.museum ), Join_4 AS ( SELECT Scan_3.Name, Aggregate_2.Count_Star, Aggregate_2.Museum_ID FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Museum_ID = Scan_3.Museum_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Museum_ID, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 t2.Museum_ID , t1.name FROM museum_visit.museum AS t1  JOIN museum_visit.visit AS t2  ON t1.Museum_ID = t2.Museum_ID GROUP BY t2.Museum_ID , t1.name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Visit to retrieve the museum IDs of all visits ; #2 = Group #1 by Museum ID and count the number of visits per museum ; #3 = Scan the table Museum to retrieve the names and museum IDs of all museums ; #4 = Join #2 and #3 based on the matching museum ID and retrieve the museum names, visit counts, and museum IDs ; #5 = Sort the records from #4 based on the visit count in descending order, select the first record, and retrieve the museum name and ID that has been visited the most times."
    },
    {
        "id": "8ae2a94a239d725b450e3f2319fccfc633f24c3e2b702c94b1e3933c301ff2ea",
        "question": "What is the name of the museum that had no visitor yet?",
        "query": "SELECT name FROM museum_visit.museum WITH (FORCESCAN) WHERE Museum_ID NOT IN ( SELECT museum_id FROM museum_visit.visit WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Output [ Name , Museum_ID ] ; #2 = Scan Table [ visit ] Output [ Museum_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Museum_ID ] Output [ Museum_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Museum_ID = #1.Museum_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Museum_ID FROM museum_visit.museum ), Scan_2 AS ( SELECT Museum_ID FROM museum_visit.visit ), Aggregate_3 AS ( SELECT Museum_ID FROM Scan_2 GROUP BY Museum_ID ), Except_4 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Museum_ID NOT IN (SELECT Museum_ID FROM Aggregate_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT name FROM museum_visit.museum  WHERE Museum_ID NOT IN ( SELECT museum_id FROM museum_visit.visit  )",
        "qd": "#1 = Scan the table museum and retrieve the names and IDs of all museums ; #2 = Scan the table visit and retrieve the museum IDs ; #3 = Group the records from #2 by museum ID to find the museums that had at least one visitor ; #4 = return the names of the museums from #1 that are not in #3 to find the museums that had no visitor yet"
    },
    {
        "id": "f00fb87bd37e2b2945ed497ba5ea69eac0f7d33f744a55657896bdbfc31dd036",
        "question": "Find the name and age of the visitor who bought the most tickets at once.",
        "query": "SELECT TOP 1 t1.name , t1.age FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id ORDER BY t2.num_of_ticket DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visit ] Output [ visitor_ID , Num_of_Ticket ] ; #2 = Scan Table [ visitor ] Output [ Name , ID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.visitor_ID = #2.ID ] Output [ #2.Age , #2.Name , #1.Num_of_Ticket ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Num_of_Ticket DESC ] Output [ Name , Num_of_Ticket , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT visitor_ID, Num_of_Ticket FROM museum_visit.visit ), Scan_2 AS ( SELECT Name, ID, Age FROM museum_visit.visitor ), Join_3 AS ( SELECT Scan_2.Age, Scan_2.Name, Scan_1.Num_of_Ticket FROM Scan_1 JOIN Scan_2 ON Scan_1.visitor_ID = Scan_2.ID ), TopSort_4 AS ( SELECT TOP 1 Name, Num_of_Ticket, Age FROM Join_3 ORDER BY Num_of_Ticket DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 t1.name , t1.age FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id ORDER BY t2.num_of_ticket DESC",
        "qd": "#1 = Scan the table visit and retrieve the visitor IDs and the number of tickets bought by each visitor ; #2 = Scan the table visitor and retrieve the names, IDs, and ages of all visitors ; #3 = Join #1 and #2 based on the matching visitor ID and retrieve the names, ages, and number of tickets bought at once by each visitor ; #4 = Sort the records from #3 based on the number of tickets bought at once in descending order, select the first record, and identify the name and age of the visitor who bought the most tickets at once."
    },
    {
        "id": "50a9673efed62eae22b4c202df67633cef3c1493a63dcfa415e75c65c29580f2",
        "question": "What are the average and maximum number of tickets bought in all visits?",
        "query": "SELECT avg ( num_of_ticket ) AS Avg_num_of_ticket , max ( num_of_ticket ) AS Max_num_of_ticket FROM museum_visit.visit WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visit ] Output [ Num_of_Ticket ] ; #2 = Aggregate [ #1 ] Output [ MAX(Num_of_Ticket) AS Max_Num_of_Ticket , AVG(Num_of_Ticket) AS Avg_Num_of_Ticket ]",
        "cte": "WITH Scan_1 AS ( SELECT Num_of_Ticket FROM museum_visit.visit ), Aggregate_2 AS ( SELECT MAX(Num_of_Ticket) AS Max_Num_of_Ticket, AVG(Num_of_Ticket) AS Avg_Num_of_Ticket FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( num_of_ticket ) AS Avg_num_of_ticket , max ( num_of_ticket ) AS Max_num_of_ticket FROM museum_visit.visit",
        "qd": "#1 = Scan the table visit and retrieve the number of tickets bought in all visits ; #2 = Aggregate the maximum and average number of tickets from #1 to find the maximum and average number of tickets bought in all visits"
    },
    {
        "id": "61bb655bcee5c11242e7ae7ad2bb18245dcaaad4ade6d8d621789af648b98cd6",
        "question": "What is the total ticket expense of the visitors whose membership level is 1?",
        "query": "SELECT sum ( t2.Total_spent ) AS Sum_Total_spent FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id WHERE t1.Level_of_membership = 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership = 1 ] Output [ Level_of_membership , ID ] ; #2 = Scan Table [ visit ] Output [ visitor_ID , Total_spent ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.visitor_ID ] Output [ #2.Total_spent ] ; #4 = Aggregate [ #3 ] Output [ SUM(Total_spent) AS Sum_Total_spent ]",
        "cte": "WITH Scan_1 AS ( SELECT Level_of_membership, ID FROM museum_visit.visitor WHERE Level_of_membership = 1 ), Scan_2 AS ( SELECT visitor_ID, Total_spent FROM museum_visit.visit ), Join_3 AS ( SELECT Scan_2.Total_spent FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.visitor_ID ), Aggregate_4 AS ( SELECT SUM(Total_spent) AS Sum_Total_spent FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT sum ( t2.Total_spent ) AS Sum_Total_spent FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id WHERE t1.Level_of_membership = 1",
        "qd": "#1 = Scan the table Visitor to find who are the visitors with membership level 1 ; #2 = Scan the table Visit to find what is the total spent by visitors during their visits ; #3 = Join #1 and #2 to find what is the total spent by each visitor with membership level 1 during their visits ; #4 = Calculate the sum of the total spent from #3 to find the total ticket expense of the visitors whose membership level is 1"
    },
    {
        "id": "524c108e3bf0acdbbb82209403f005db8b11506bdae75cbd4850a8235c714cf5",
        "question": "What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
        "query": "SELECT t1.name FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3 WITH (FORCESCAN) ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year < 2009 INTERSECT SELECT t1.name FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3 WITH (FORCESCAN) ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year > 2011 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year < 2009 ] Output [ Open_Year , Museum_ID ] ; #2 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Museum_ID = #2.Museum_ID ] Output [ #2.visitor_ID ] ; #4 = Scan Table [ visitor ] Output [ Name , ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.visitor_ID = #4.ID ] Distinct [ true ] Output [ #4.Name ] ; #6 = Scan Table [ museum ] Predicate [ Open_Year > 2011 ] Output [ Open_Year , Museum_ID ] ; #7 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Museum_ID = #7.Museum_ID ] Output [ #7.visitor_ID ] ; #9 = Scan Table [ visitor ] Output [ Name , ID ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.visitor_ID = #9.ID ] Output [ #9.Name ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Name = #10.Name ] Output [ #5.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Open_Year, Museum_ID FROM museum_visit.museum WHERE Open_Year < 2009 ), Scan_2 AS ( SELECT visitor_ID, Museum_ID FROM museum_visit.visit ), Join_3 AS ( SELECT Scan_2.visitor_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Museum_ID = Scan_2.Museum_ID ), Scan_4 AS ( SELECT Name, ID FROM museum_visit.visitor ), Join_5 AS ( SELECT DISTINCT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.visitor_ID = Scan_4.ID ), Scan_6 AS ( SELECT Open_Year, Museum_ID FROM museum_visit.museum WHERE Open_Year > 2011 ), Scan_7 AS ( SELECT visitor_ID, Museum_ID FROM museum_visit.visit ), Join_8 AS ( SELECT Scan_7.visitor_ID FROM Scan_6 JOIN Scan_7 ON Scan_6.Museum_ID = Scan_7.Museum_ID ), Scan_9 AS ( SELECT Name, ID FROM museum_visit.visitor ), Join_10 AS ( SELECT Scan_9.Name FROM Join_8 JOIN Scan_9 ON Join_8.visitor_ID = Scan_9.ID ), Intersect_11 AS ( SELECT Join_5.Name FROM Join_5 WHERE Name IN (SELECT Name FROM Join_10) ) SELECT * FROM Intersect_11",
        "clean_query": "SELECT t1.name FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3  ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year < 2009 INTERSECT SELECT t1.name FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3  ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year > 2011",
        "qd": "#1 = Scan the table museum and retrieve the open year and museum ID of all museums opened before 2009 ; #2 = Scan the table visit and retrieve the visitor ID and museum ID of all visits ; #3 = Join #1 and #2 based on the matching museum ID and retrieve the visitor IDs ; #4 = Scan the table visitor and retrieve the names and IDs of all visitors ; #5 = Join #3 and #4 based on the matching visitor ID and retrieve the names ; #6 = Scan the table museum and retrieve the open year and museum ID of all museums opened after 2011 ; #7 = Scan the table visit and retrieve the visitor ID and museum ID of all visits ; #8 = Join #6 and #7 based on the matching museum ID and retrieve the visitor IDs ; #9 = Scan the table visitor and retrieve the names and IDs of all visitors ; #10 = Join #8 and #9 based on the matching visitor ID and retrieve the names ; #11 = Intersect #5 and #10 based on the matching names to find the names of the visitors who visited both a museum opened before 2009 and a museum opened after 2011"
    },
    {
        "id": "ae181dcca46228f38a78aa5acf558f35f920c5e4bdb8b56ce47a9945cfb18458",
        "question": "Find the number of visitors who did not visit any museum opened after 2010.",
        "query": "SELECT count ( * ) AS Count_Star FROM museum_visit.visitor WITH (FORCESCAN) WHERE id NOT IN ( SELECT t2.visitor_id FROM museum_visit.museum AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.Museum_ID = t2.Museum_ID WHERE t1.open_year > 2010 ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ visitor ] Output [ ID ] ; #2 = Scan Table [ museum ] Predicate [ Open_Year > 2010 ] Output [ Open_Year , Museum_ID ] ; #3 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Museum_ID = #3.Museum_ID ] Output [ #3.visitor_ID ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.visitor_ID = #1.ID ] Output [ 1 AS One ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT ID FROM museum_visit.visitor ), Scan_2 AS ( SELECT Open_Year, Museum_ID FROM museum_visit.museum WHERE Open_Year > 2010 ), Scan_3 AS ( SELECT visitor_ID, Museum_ID FROM museum_visit.visit ), Join_4 AS ( SELECT Scan_3.visitor_ID FROM Scan_2 JOIN Scan_3 ON Scan_2.Museum_ID = Scan_3.Museum_ID ), Except_5 AS ( SELECT 1 AS One FROM Scan_1 WHERE ID NOT IN (SELECT visitor_ID FROM Join_4) ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Except_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM museum_visit.visitor  WHERE id NOT IN ( SELECT t2.visitor_id FROM museum_visit.museum AS t1  JOIN museum_visit.visit AS t2  ON t1.Museum_ID = t2.Museum_ID WHERE t1.open_year > 2010 )",
        "qd": "#1 = Scan the table visitor to find who are the visitors ; #2 = Scan the table museum to find all the museums that opened after 2010 ; #3 = Scan the table visit and retrieve the visitor IDs and museum IDs of all visits ; #4 = Join #2 and #3 based on the matching museum ID and retrieve all the visitor IDs ; #5 = Return all the visitor IDs from #1 that are not in #4 to find the visitors who did not visit any museum opened after 2010 ; #6 = Aggregate the count of all the visitors in #5 to find the number of visitors who did not visit any museum opened after 2010"
    },
    {
        "id": "ea13f16bad44cab1f5519ae833248e98e84d09409acf52956eae0675e9cf159e",
        "question": "How many museums were opened after 2013 or before 2008?",
        "query": "SELECT count ( * ) AS Count_Star FROM museum_visit.museum WITH (FORCESCAN) WHERE open_year > 2013 OR open_year < 2008 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year > 2013 OR Open_Year < 2008 ] Output [ Open_Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Open_Year FROM museum_visit.museum WHERE Open_Year > 2013 OR Open_Year < 2008 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM museum_visit.museum  WHERE open_year > 2013 OR open_year < 2008",
        "qd": "#1 = Scan the table museum and retrieve the open years of all museums opened after 2013 or before 2008 ; #2 = Aggregate the number of records from #1 to find the count of museums that were opened after 2013 or before 2008."
    },
    {
        "id": "4631e248fadb782ac6922779f4289d6c953b3c5d345b58dc7b86b67be4b17b1f",
        "question": "Find the total number of players.",
        "query": "SELECT count ( * ) AS Count_Star FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM wta_1.players",
        "qd": "#1 = Scan the table players and retrieve a constant value of 1 for each player. ; #2 = Aggregate the records from #1 and count the total number of players."
    },
    {
        "id": "b89f7b5db1f8857f0713223621e84ae4f40ed97b45e2b2ba79a26641c096d8ed",
        "question": "How many players are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM wta_1.players",
        "qd": "#1 = Scan the table players and retrieve a constant value of 1 for each player ; #2 = Aggregate the records from #1 and count the total number of players"
    },
    {
        "id": "a138de21c6fb3c215e42c91746c2e9841522ae6a2bf1e80bde7978850e711477",
        "question": "Find the total number of matches.",
        "query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve a constant value of 1 for each match ; #2 = Aggregate the number of constant values from #1 to find the total number of matches"
    },
    {
        "id": "2d1ff3bdc9e4e167beb08971a10a8d8d149cc138b1bf5491f2dfdeb69f47e4d2",
        "question": "Count the number of matches.",
        "query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve a constant value of 1 for each match ; #2 = Aggregate the records from #1 and calculate the count of matches"
    },
    {
        "id": "d612319015bf64e8590a72838cdd91e35aaaaaa0b6c436634cc43acf73848f15",
        "question": "List the first name and birth date of all players from the country with code USA.",
        "query": "SELECT first_name , birth_date FROM wta_1.players WITH (FORCESCAN) WHERE country_code = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Predicate [ country_code = 'USA' ] Output [ first_name , birth_date , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, birth_date, country_code FROM wta_1.players WHERE country_code = 'USA' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT first_name , birth_date FROM wta_1.players  WHERE country_code = 'USA'",
        "qd": "#1 = Scan the table players and retrieve the first name and birth date of all players from the country with the code 'USA'."
    },
    {
        "id": "c6eaf80201ad8d7f85db0df294c33fed7080cd547a81a9a164d9c2ef59b662e3",
        "question": "What are the first names and birth dates of players from the USA?",
        "query": "SELECT first_name , birth_date FROM wta_1.players WITH (FORCESCAN) WHERE country_code = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Predicate [ country_code = 'USA' ] Output [ first_name , birth_date , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, birth_date, country_code FROM wta_1.players WHERE country_code = 'USA' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT first_name , birth_date FROM wta_1.players  WHERE country_code = 'USA'",
        "qd": "#1 = Scan the table players and retrieve the first names and birth dates of players from the USA"
    },
    {
        "id": "2ae1a5a8d079e1ddb3c830c69f555e616cc82ca7a5d386879eb5085591970c7c",
        "question": "Find the average age of losers and winners of all matches.",
        "query": "SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_age , loser_age ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_age) AS Avg_winner_age , AVG(loser_age) AS Avg_loser_age ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_age, loser_age FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_age) AS Avg_winner_age, AVG(loser_age) AS Avg_loser_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the ages of both winners and losers ; #2 = Calculate the average age of the winners and the average age of the losers"
    },
    {
        "id": "b3db64365a68c90a44de3089b599cbb27ffa0e6a1d83bc09344beac1c5cfaa6b",
        "question": "What are the average ages of losers and winners across matches?",
        "query": "SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_age , loser_age ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_age) AS Avg_winner_age , AVG(loser_age) AS Avg_loser_age ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_age, loser_age FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_age) AS Avg_winner_age, AVG(loser_age) AS Avg_loser_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the ages of winners and losers for all matches ; #2 = Aggregate the average age of winners as Avg_winner_age, and the average age of losers as Avg_loser_age"
    },
    {
        "id": "139fe90e20205c170d6167b71f0e43f1bc29925a7d457c55605f62f830b59678",
        "question": "Find the average rank of winners in all matches.",
        "query": "SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_rank) AS Avg_winner_rank ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_rank) AS Avg_winner_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the rank of all winners in all matches ; #2 = Aggregate the average rank of all winners and retrieve the average rank of winners in all matches"
    },
    {
        "id": "d6d0dc5db8b689d4c0ac7ea1f9baae2fc6d0363c22531ceab894610838fbd534",
        "question": "What is the average rank for winners in all matches?",
        "query": "SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_rank) AS Avg_winner_rank ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_rank) AS Avg_winner_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the ranks of all the winners ; #2 = Calculate the average of the winner ranks to find the average rank for winners in all matches"
    },
    {
        "id": "a64d6f482d2ebdc30710080c6687dabf2623b14791148768a43369e54265ec45",
        "question": "Find the highest rank of losers in all matches.",
        "query": "SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ loser_rank ] ; #2 = Aggregate [ #1 ] Output [ MIN(loser_rank) AS Min_loser_rank ]",
        "cte": "WITH Scan_1 AS ( SELECT loser_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT MIN(loser_rank) AS Min_loser_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the rank of all losers in the matches ; #2 = Aggregate the minimum rank from #1 to find the highest rank among all the losers in the matches."
    },
    {
        "id": "a17adb01c205ee4acecf59e8282753026f4bcbfac86be64aba1ac37290f2415c",
        "question": "What is the best rank of losers across all matches?",
        "query": "SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ loser_rank ] ; #2 = Aggregate [ #1 ] Output [ MIN(loser_rank) AS Min_loser_rank ]",
        "cte": "WITH Scan_1 AS ( SELECT loser_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT MIN(loser_rank) AS Min_loser_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the rank of all losers ; #2 = Aggregate the minimum rank of losers across all matches to find the best rank of losers"
    },
    {
        "id": "8376e9086290a914bac06f17b3d831a833daedaa3449dbcbb5c6881a573673e1",
        "question": "find the number of distinct country codes of all players.",
        "query": "SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Distinct [ true ] Output [ country_code ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT country_code) AS Count_Dist_country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(DISTINCT country_code) AS Count_Dist_country_code FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players",
        "qd": "#1 = Scan the table players and retrieve all the distinct country codes of all players ; #2 = Aggregate the count of distinct country codes to find the number of distinct country codes of all players."
    },
    {
        "id": "7d0952affa592f943383d85f82a3cdbae6b653e87a16d0198cd69070d06cd9ab",
        "question": "How many distinct countries do players come from?",
        "query": "SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Distinct [ true ] Output [ country_code ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT country_code) AS Count_Dist_country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(DISTINCT country_code) AS Count_Dist_country_code FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players",
        "qd": "#1 = Scan the table players and retrieve all the distinct country codes of players ; #2 = Aggregate the count of distinct country codes to find the number of distinct countries that players come from"
    },
    {
        "id": "456cfce7f4f9a1bf5059801519fd02ec3ef4b74df8dd9289c623633591d50cce",
        "question": "Find the number of distinct name of losers.",
        "query": "SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ loser_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT loser_name) AS Count_Dist_loser_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT loser_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(DISTINCT loser_name) AS Count_Dist_loser_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve the distinct names of all the losers ; #2 = Aggregate the count of distinct loser names to find the number of distinct names of the losers"
    },
    {
        "id": "180b86428841fc7e75e3b1a8d8a95e2bf8b8b3b4b445be82d19fc0c34bf51e2f",
        "question": "How many different loser names are there?",
        "query": "SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ loser_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT loser_name) AS Count_Dist_loser_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT loser_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(DISTINCT loser_name) AS Count_Dist_loser_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches",
        "qd": "#1 = Scan the table matches and retrieve all distinct loser names ; #2 = Aggregate the count of distinct loser names to find the number of different loser names"
    },
    {
        "id": "f0a3396077268cb93b9b22bee78d31feaf8e636a88216d5d2f568ffd491ea915",
        "question": "Find the name of tourney that has more than 10 matches.",
        "query": "SELECT tourney_name FROM wta_1.matches WITH (FORCESCAN) GROUP BY tourney_name HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ tourney_name ] ; #2 = Aggregate [ #1 ] GroupBy [ tourney_name ] Output [ tourney_name , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 10 ] Output [ tourney_name ]",
        "cte": "WITH Scan_1 AS ( SELECT tourney_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT tourney_name, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY tourney_name ), Filter_3 AS ( SELECT tourney_name FROM Aggregate_2 WHERE Count_Star > 10 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT tourney_name FROM wta_1.matches  GROUP BY tourney_name HAVING count ( * ) > 10",
        "qd": "#1 = Scan the table matches and retrieve the tourney names of all matches ; #2 = Group #1 by tourney name and aggregate the count of matches per tourney name ; #3 = Filter from #2 all the tourney names that have a count of matches greater than 10 and retrieve the tourney names"
    },
    {
        "id": "6c2fcf353449efb9231d6c798d779d0168d424c399c9c362f5a6da5654716338",
        "question": "What are the names of tournaments that have more than 10 matches?",
        "query": "SELECT tourney_name FROM wta_1.matches WITH (FORCESCAN) GROUP BY tourney_name HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ tourney_name ] ; #2 = Aggregate [ #1 ] GroupBy [ tourney_name ] Output [ tourney_name , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 10 ] Output [ tourney_name ]",
        "cte": "WITH Scan_1 AS ( SELECT tourney_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT tourney_name, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY tourney_name ), Filter_3 AS ( SELECT tourney_name FROM Aggregate_2 WHERE Count_Star > 10 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT tourney_name FROM wta_1.matches  GROUP BY tourney_name HAVING count ( * ) > 10",
        "qd": "#1 = Scan the table matches and retrieve the tournament names of all matches ; #2 = Group #1 by tournament name and aggregate the count of matches per tournament ; #3 = Filter from #2 all the tournaments with more than 10 matches and retrieve the tournament names"
    },
    {
        "id": "e173f111341c71e2a837c8c0f18342105c3339de0e08e545b831d9f159845ed3",
        "question": "List the names of all winners who played in both 2013 and 2016.",
        "query": "SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 ] Distinct [ true ] Output [ year , winner_name ] ; #2 = Scan Table [ matches ] Predicate [ year = 2016 ] Output [ year , winner_name ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.winner_name = #2.winner_name ] Output [ #1.winner_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT year, winner_name FROM wta_1.matches WHERE year = 2013 ), Scan_2 AS ( SELECT year, winner_name FROM wta_1.matches WHERE year = 2016 ), Intersect_3 AS ( SELECT Scan_1.winner_name FROM Scan_1 WHERE winner_name IN (SELECT winner_name FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2016",
        "qd": "#1 = Scan the table matches and retrieve the years and names of all winners who played in 2013 without duplicates ; #2 = Scan the table matches and retrieve the years and names of all winners who played in 2016 ; #3 = Intersect the records from #1 and #2 based on the matching names and retrieve the names of all winners who played in both 2013 and 2016."
    },
    {
        "id": "ed32d95c06b758a201d5b6a501e55481c633acf085ca4187edd64f37741a20c1",
        "question": "What are the names of players who won in both 2013 and 2016?",
        "query": "SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 ] Distinct [ true ] Output [ year , winner_name ] ; #2 = Scan Table [ matches ] Predicate [ year = 2016 ] Output [ year , winner_name ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.winner_name = #2.winner_name ] Output [ #1.winner_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT year, winner_name FROM wta_1.matches WHERE year = 2013 ), Scan_2 AS ( SELECT year, winner_name FROM wta_1.matches WHERE year = 2016 ), Intersect_3 AS ( SELECT Scan_1.winner_name FROM Scan_1 WHERE winner_name IN (SELECT winner_name FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2016",
        "qd": "#1 = Scan the table matches and retrieve the years and names of all the winners in 2013 without duplicates ; #2 = Scan the table matches and retrieve the years and names of all the winners in 2016 ; #3 = Intersect #1 and #2 based on the matching names and retrieve the names of the players who won in both 2013 and 2016"
    },
    {
        "id": "560524f03cef0b0c2248599274a33d9621b0f01f721c71d46382408e6c0e6f56",
        "question": "List the number of all matches who played in years of 2013 or 2016.",
        "query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 OR YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 OR year = 2016 ] Output [ year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT year FROM wta_1.matches WHERE year = 2013 OR year = 2016 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches  WHERE YEAR = 2013 OR YEAR = 2016",
        "qd": "#1 = Scan the table matches and retrieve the years of all matches played in 2013 or 2016 ; #2 = Aggregate the count of all records from #1 to find the number of matches played in years 2013 or 2016"
    },
    {
        "id": "0e52fbec4158ca7c3cfba053e57807319098341d3583da7d1076f728ea86df2b",
        "question": "How many matches were played in 2013 or 2016?",
        "query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 OR YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 OR year = 2016 ] Output [ year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT year FROM wta_1.matches WHERE year = 2013 OR year = 2016 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM wta_1.matches  WHERE YEAR = 2013 OR YEAR = 2016",
        "qd": "#1 = Scan the table matches and retrieve the year of all matches played in 2013 or 2016 ; #2 = Aggregate the number of records of #1 and retrieve the count of matches that were played in 2013 or 2016"
    },
    {
        "id": "4e761a9127f36296f20021c44a8cadca031a57c3bb317ef82e3f9b28cfc2fee5",
        "question": "What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
        "query": "SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' ] Output [ tourney_name , winner_id ] ; #2 = Scan Table [ players ] Output [ first_name , player_id , country_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Distinct [ true ] Output [ #2.country_code , #2.first_name ] ; #4 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ tourney_name , winner_id ] ; #5 = Scan Table [ players ] Output [ first_name , player_id , country_code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.winner_id = #5.player_id ] Output [ #5.first_name , #5.country_code ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.country_code = #6.country_code ] Output [ #3.first_name , #3.country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT tourney_name, winner_id FROM wta_1.matches WHERE tourney_name = 'WTA Championships' ), Scan_2 AS ( SELECT first_name, player_id, country_code FROM wta_1.players ), Join_3 AS ( SELECT DISTINCT Scan_2.country_code, Scan_2.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), Scan_4 AS ( SELECT tourney_name, winner_id FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), Scan_5 AS ( SELECT first_name, player_id, country_code FROM wta_1.players ), Join_6 AS ( SELECT Scan_5.first_name, Scan_5.country_code FROM Scan_4 JOIN Scan_5 ON Scan_4.winner_id = Scan_5.player_id ), Intersect_7 AS ( SELECT Join_3.first_name, Join_3.country_code FROM Join_3 WHERE country_code IN (SELECT country_code FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open'",
        "qd": "#1 = Scan the matches table and retrieve the tourney name and winner IDs of all matches in the WTA Championships ; #2 = Scan the players table and retrieve the first names, player IDs, and country codes of all players ; #3 = Join #1 and #2 based on the matching winner IDs and retrieve the country codes and first names ; #4 = Scan the matches table and retrieve the tourney name and winner IDs of all matches in the Australian Open ; #5 = Scan the players table and retrieve the first names, player IDs, and country codes of all players ; #6 = Join #4 and #5 based on the matching winner IDs and retrieve the first names and country codes ; #7 = Intersect #3 and #6 based on the matching country codes and retrieve the first names and country codes"
    },
    {
        "id": "2a4a5e75c0774a24355f23685b6e1e35bf529fbe6c142f94efbf6a9f24a57f6d",
        "question": "What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
        "query": "SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' ] Output [ tourney_name , winner_id ] ; #2 = Scan Table [ players ] Output [ first_name , player_id , country_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Distinct [ true ] Output [ #2.country_code , #2.first_name ] ; #4 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ tourney_name , winner_id ] ; #5 = Scan Table [ players ] Output [ first_name , player_id , country_code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.winner_id = #5.player_id ] Output [ #5.first_name , #5.country_code ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.country_code = #6.country_code ] Output [ #3.first_name , #3.country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT tourney_name, winner_id FROM wta_1.matches WHERE tourney_name = 'WTA Championships' ), Scan_2 AS ( SELECT first_name, player_id, country_code FROM wta_1.players ), Join_3 AS ( SELECT DISTINCT Scan_2.country_code, Scan_2.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), Scan_4 AS ( SELECT tourney_name, winner_id FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), Scan_5 AS ( SELECT first_name, player_id, country_code FROM wta_1.players ), Join_6 AS ( SELECT Scan_5.first_name, Scan_5.country_code FROM Scan_4 JOIN Scan_5 ON Scan_4.winner_id = Scan_5.player_id ), Intersect_7 AS ( SELECT Join_3.first_name, Join_3.country_code FROM Join_3 WHERE country_code IN (SELECT country_code FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open'",
        "qd": "#1 = Scan the table matches and retrieve the tournament name and winner IDs for all matches in the WTA Championships ; #2 = Scan the table players and retrieve the first names and player IDs for all players ; #3 = Join #1 and #2 based on the matching winner IDs and retrieve the first names and country codes ; #4 = Scan the table matches and retrieve the tournament name and winner IDs for all matches in the Australian Open ; #5 = Scan the table players and retrieve the first names and player IDs for all players ; #6 = Join #4 and #5 based on the matching winner IDs and retrieve the first names and country codes ; #7 = Intersect #3 and #6 based on the matching country codes and retrieve the first names and country codes"
    },
    {
        "id": "d48e7fe6972cb8e21a3c6394d53980bdf7e37fc28a78f91f9fb7230c24136dae",
        "question": "Find the first name and country code of the oldest player.",
        "query": "SELECT TOP 1 first_name , country_code FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ first_name , birth_date , country_code ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, birth_date, country_code FROM wta_1.players ), TopSort_2 AS ( SELECT TOP 1 first_name, birth_date, country_code FROM Scan_1 ORDER BY birth_date ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 first_name , country_code FROM wta_1.players  ORDER BY birth_date",
        "qd": "#1 = Scan the table players and retrieve the first name, birth date, and country code of all players ; #2 = Sort the records from #1 based on the birth date in ascending order, select the first record, and retrieve the first name and country code of the oldest player"
    },
    {
        "id": "baa9a1483242a0a237f97714d50d97a1b5a523b10b592594eae08f5e9e0280e6",
        "question": "What is the first name and country code of the oldest player?",
        "query": "SELECT TOP 1 first_name , country_code FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ first_name , birth_date , country_code ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, birth_date, country_code FROM wta_1.players ), TopSort_2 AS ( SELECT TOP 1 first_name, birth_date, country_code FROM Scan_1 ORDER BY birth_date ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 first_name , country_code FROM wta_1.players  ORDER BY birth_date",
        "qd": "#1 = Scan the table players and retrieve the first names, birth dates, and country codes of all players ; #2 = Sort the records from #1 based on the birth date in ascending order, select the first record, and identify the first name and country code of the oldest player"
    },
    {
        "id": "6e5a3955c039c7de8941e2b20560eb004bf6273531145bbe4f9433d229b66a37",
        "question": "List the first and last name of all players in the order of birth date.",
        "query": "SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ first_name , last_name , birth_date ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , last_name , birth_date ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, last_name, birth_date FROM wta_1.players ) SELECT first_name, last_name, birth_date FROM Scan_1 ORDER BY birth_date ASC",
        "clean_query": "SELECT first_name , last_name FROM wta_1.players  ORDER BY birth_date",
        "qd": "#1 = Scan the table players and retrieve the first name, last name, and birth date of all players. ; #2 = Sort the records from #1 based on the birth date in ascending order and retrieve the first name and last name."
    },
    {
        "id": "2cccadad4927cf8f0d910ca98ba5bd58effcdffa734554dc162d4da321a9f158",
        "question": "What are the full names of all players, sorted by birth date?",
        "query": "SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ first_name , last_name , birth_date ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , last_name , birth_date ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, last_name, birth_date FROM wta_1.players ) SELECT first_name, last_name, birth_date FROM Scan_1 ORDER BY birth_date ASC",
        "clean_query": "SELECT first_name , last_name FROM wta_1.players  ORDER BY birth_date",
        "qd": "#1 = Scan the table players and retrieve the first names, last names, and birth dates of all players ; #2 = Sort the records from #1 based on the birth date in ascending order and retrieve the full names (first name and last name)"
    },
    {
        "id": "da1dbbcc0a1c8a817f65ae6ee6fce3dabc45b38d66111fc4c7bee9adec5000cb",
        "question": "List the first and last name of all players who are left / L hand in the order of birth date.",
        "query": "SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) WHERE hand = 'L' ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Predicate [ hand = 'L' ] Output [ hand , first_name , last_name , birth_date ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , last_name , birth_date ]",
        "cte": "WITH Scan_1 AS ( SELECT hand, first_name, last_name, birth_date FROM wta_1.players WHERE hand = 'L' ) SELECT first_name, last_name, birth_date FROM Scan_1 ORDER BY birth_date ASC",
        "clean_query": "SELECT first_name , last_name FROM wta_1.players  WHERE hand = 'L' ORDER BY birth_date",
        "qd": "#1 = Scan the table players to find all the players who are left-handed and retrieve their hand, first name, last name, and birth date. ; #2 = Sort the records from #1 based on the birth date in ascending order and retrieve the first name and last name of all players who are left-handed."
    },
    {
        "id": "295988b244a1dd78a84417dd6e2054e99798ab87f1f153e3cae281c302e1c32e",
        "question": "What are the full names of all left handed players, in order of birth date?",
        "query": "SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) WHERE hand = 'L' ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Predicate [ hand = 'L' ] Output [ hand , first_name , last_name , birth_date ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , last_name , birth_date ]",
        "cte": "WITH Scan_1 AS ( SELECT hand, first_name, last_name, birth_date FROM wta_1.players WHERE hand = 'L' ) SELECT first_name, last_name, birth_date FROM Scan_1 ORDER BY birth_date ASC",
        "clean_query": "SELECT first_name , last_name FROM wta_1.players  WHERE hand = 'L' ORDER BY birth_date",
        "qd": "#1 = Scan the table players and retrieve the hand, first name, last name, and birth date of all left-handed players ; #2 = Sort the records from #1 based on the birth date in ascending order and retrieve the full names (first name and last name)"
    },
    {
        "id": "8a97b1f2dce33f93402760747b78c771827c6f87f26cd8b79c78e074a69bf916",
        "question": "Find the first name and country code of the player who did the most number of tours.",
        "query": "SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id ORDER BY T2.tours DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ first_name , player_id , country_code ] ; #2 = Scan Table [ rankings ] Output [ tours , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.tours , #1.country_code , #1.first_name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ tours DESC ] Output [ tours , first_name , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, player_id, country_code FROM wta_1.players ), Scan_2 AS ( SELECT tours, player_id FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.tours, Scan_1.country_code, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 tours, first_name, country_code FROM Join_3 ORDER BY tours DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id ORDER BY T2.tours DESC",
        "qd": "#1 = Scan the table players and retrieve the first name and country code of all players. ; #2 = Scan the table rankings and retrieve the number of tours and player IDs. ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the number of tours, first name, and country code. ; #4 = Sort the records from #3 based on the number of tours in descending order, select the first record, and identify the first name and country code of the player who did the most number of tours."
    },
    {
        "id": "108ae9411be5efb3b8c13a863ccd27c25db8bb6f388e077086e5a293dfcddf27",
        "question": "What is the first name and country code of the player with the most tours?",
        "query": "SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id ORDER BY T2.tours DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ first_name , player_id , country_code ] ; #2 = Scan Table [ rankings ] Output [ tours , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.tours , #1.country_code , #1.first_name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ tours DESC ] Output [ tours , first_name , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, player_id, country_code FROM wta_1.players ), Scan_2 AS ( SELECT tours, player_id FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.tours, Scan_1.country_code, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 tours, first_name, country_code FROM Join_3 ORDER BY tours DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id ORDER BY T2.tours DESC",
        "qd": "#1 = Scan the table players and retrieve the first name and country code of all players ; #2 = Scan the table rankings and retrieve the number of tours and player IDs ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the number of tours, country code, and first name ; #4 = Sort the records from #3 based on the number of tours in descending order, select the first record, and identify the first name and country code of the player with the most tours."
    },
    {
        "id": "72e0cde1414ecaa5cdc66b35b9cd074f48422ec83080c25ee226bf95fe4a35d4",
        "question": "Find the year that has the most number of matches.",
        "query": "SELECT TOP 1 YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ countstar AS Count_Star , year ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ year , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, year FROM Scan_1 GROUP BY year ), TopSort_3 AS ( SELECT TOP 1 year, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 YEAR FROM wta_1.matches  GROUP BY YEAR ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table matches to retrieve the year of all matches ; #2 = Group #1 by year and aggregate the count of matches per year ; #3 = Sort the records from #2 based on the count of matches in descending order, select the first record, and identify the year that has the most number of matches and its count"
    },
    {
        "id": "ea75910ba3afc10a0d59dae128d0c75acb7487d6b9222ffa99e6fdc28fa60845",
        "question": "Which year had the most matches?",
        "query": "SELECT TOP 1 YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ countstar AS Count_Star , year ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ year , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, year FROM Scan_1 GROUP BY year ), TopSort_3 AS ( SELECT TOP 1 year, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 YEAR FROM wta_1.matches  GROUP BY YEAR ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table matches and retrieve the year of all matches ; #2 = Group #1 by year and aggregate the count of matches per year ; #3 = Sort the records from #2 based on the count of matches in descending order, select the first record, and identify the year that had the most matches and its count of matches."
    },
    {
        "id": "141841cbe0cbd647aee9c2aafc35639203dbf2df3604e6c80a0c387bb04ceae0",
        "question": "Find the name and rank points of the winner who won the most times.",
        "query": "SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches WITH (FORCESCAN) GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank_points , winner_name ] ; #2 = Aggregate [ #1 ] GroupBy [ winner_rank_points , winner_name ] Output [ winner_rank_points , countstar AS Count_Star , winner_name ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ winner_rank_points , winner_name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank_points, winner_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT winner_rank_points, COUNT(*) AS Count_Star, winner_name FROM Scan_1 GROUP BY winner_name, winner_rank_points, winner_rank_points , winner_name ), TopSort_3 AS ( SELECT TOP 1 winner_rank_points, winner_name, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches  GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table matches and retrieve the winner's rank points and name for all matches ; #2 = Group the records from #1 by the winner's rank points and name, and aggregate the count of matches won by each winner ; #3 = Sort the records from #2 based on the count of matches won in descending order, select the first record, and retrieve the winner's rank points, name, and the count of matches won."
    },
    {
        "id": "ee837d790c1052adcb9de495cfc9af05e217e5ad8839eeddf75d4cadfbd199fd",
        "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?",
        "query": "SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches WITH (FORCESCAN) GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank_points , winner_name ] ; #2 = Aggregate [ #1 ] GroupBy [ winner_rank_points , winner_name ] Output [ winner_rank_points , countstar AS Count_Star , winner_name ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ winner_rank_points , winner_name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank_points, winner_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT winner_rank_points, COUNT(*) AS Count_Star, winner_name FROM Scan_1 GROUP BY winner_name, winner_rank_points, winner_rank_points , winner_name ), TopSort_3 AS ( SELECT TOP 1 winner_rank_points, winner_name, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches  GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table matches and retrieve the rank points and names of all the winners ; #2 = Group #1 by the rank points and names of the winners and aggregate the count of matches won by each player ; #3 = Sort the records from #2 based on the count of matches won in descending order, select the first record, and identify the name of the winner with the most matches won and their rank points."
    },
    {
        "id": "c501736c887bf86ce56b90e4db34439faacb5416059971b688fd5830afa86a07",
        "question": "Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.",
        "query": "SELECT TOP 1 winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ winner_rank_points , tourney_name , winner_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , winner_name ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank_points, tourney_name, winner_name FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), TopSort_2 AS ( SELECT TOP 1 winner_rank_points, winner_name FROM Scan_1 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 winner_name FROM wta_1.matches  WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC",
        "qd": "#1 = Scan the table matches and retrieve the winner's rank points and name for all matches in the Australian Open tournament ; #2 = Sort the records from #1 based on the winner's rank points in descending order, select the first record, and identify the name of the winner with the highest rank points and participated in the Australian Open tournament."
    },
    {
        "id": "d8dfc34cdbedc21a0d90ad298cde344397edb67285973cccaf4929b8f06682d8",
        "question": "What is the name of the winner with the most rank points who participated in the Australian Open tournament?",
        "query": "SELECT TOP 1 winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ winner_rank_points , tourney_name , winner_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , winner_name ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank_points, tourney_name, winner_name FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), TopSort_2 AS ( SELECT TOP 1 winner_rank_points, winner_name FROM Scan_1 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 winner_name FROM wta_1.matches  WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC",
        "qd": "#1 = Scan the table matches and retrieve the rank points, tournament name, and winner name of all matches in the Australian Open tournament. ; #2 = Sort the records from #1 based on the rank points of the winners in descending order, select the first record, and identify the name of the winner with the most rank points who participated in the Australian Open tournament."
    },
    {
        "id": "1a52ea66e61e79d0c7556af1d81db30038d734dc4d84fcc7157edcb76b0e0f84",
        "question": "find the names of loser and winner who played in the match with greatest number of minutes.",
        "query": "SELECT TOP 1 winner_name , loser_name FROM wta_1.matches WITH (FORCESCAN) ORDER BY minutes DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_name , minutes , loser_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ minutes DESC ] Output [ winner_name , minutes , loser_name ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_name, minutes, loser_name FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 1 winner_name, minutes, loser_name FROM Scan_1 ORDER BY minutes DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 winner_name , loser_name FROM wta_1.matches  ORDER BY minutes DESC",
        "qd": "#1 = Scan the table matches and retrieve the winner name, minutes, and loser name of all matches ; #2 = Sort the records from #1 based on the number of minutes in descending order, select the first record, and identify the names of the winner and loser who played in the match with the greatest number of minutes."
    },
    {
        "id": "f1c050489e77aa36a4a6916315d9101c4fc31dd87f4c21d1a86f6de09e54aa1b",
        "question": "What are the names of the winner and loser who played in the longest match?",
        "query": "SELECT TOP 1 winner_name , loser_name FROM wta_1.matches WITH (FORCESCAN) ORDER BY minutes DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_name , minutes , loser_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ minutes DESC ] Output [ winner_name , minutes , loser_name ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_name, minutes, loser_name FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 1 winner_name, minutes, loser_name FROM Scan_1 ORDER BY minutes DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 winner_name , loser_name FROM wta_1.matches  ORDER BY minutes DESC",
        "qd": "#1 = Scan the table matches and retrieve the names of the winners and losers, and the duration of each match ; #2 = Sort the records from #1 based on the duration of the matches in descending order, select the longest match, and retrieve the names of the winner and loser"
    },
    {
        "id": "086087399d35549efbe7ca776ed64b5eb84b62ea11f7dc4585b96c2c26eb7d5a",
        "question": "Find the average ranking for each player and their first name.",
        "query": "SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ AVG(ranking) AS Avg_ranking , first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT AVG(ranking) AS Avg_ranking, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name",
        "qd": "#1 = Scan the table players and retrieve the player ID and first name of all players. ; #2 = Scan the table rankings and retrieve the player ID and ranking of all players. ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the rankings and first names. ; #4 = Group #3 by first name and aggregate the average ranking per player to find the average ranking for each player and their first name."
    },
    {
        "id": "c21404f628622b0b31a04806e09664651daff826371944fb1be63ecf5b1627a7",
        "question": "What are the first names of all players, and their average rankings?",
        "query": "SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ AVG(ranking) AS Avg_ranking , first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT AVG(ranking) AS Avg_ranking, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name",
        "qd": "#1 = Scan the table players and retrieve the player IDs and first names of all players ; #2 = Scan the table rankings and retrieve the player IDs and rankings of all players ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the rankings and first names ; #4 = Group #3 by first name and aggregate the average ranking per first name to find the average ranking of all players with their first names"
    },
    {
        "id": "fc6edbd3e37d50acc7d2b3f1a3c6d66eccec37a36afcf02f8f6a14bfc7f951bc",
        "question": "Find the total ranking points for each player and their first name.",
        "query": "SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking_points ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking_points , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ SUM(ranking_points) AS Sum_ranking_points , first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking_points FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking_points, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT SUM(ranking_points) AS Sum_ranking_points, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name",
        "qd": "#1 = Scan the table players and retrieve the player IDs and first names of all players. ; #2 = Scan the table rankings and retrieve the player IDs and ranking points of all players. ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the ranking points and first names. ; #4 = Group #3 by first name and aggregate the sum of ranking points for each player to find the total ranking points for each player and their first name."
    },
    {
        "id": "78180afbb85c0ff5153d14edb5060ddbd3cc213bd221da87adef21a8d4c73e41",
        "question": "What are the first names of all players, and their total ranking points?",
        "query": "SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking_points ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking_points , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ SUM(ranking_points) AS Sum_ranking_points , first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking_points FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking_points, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT SUM(ranking_points) AS Sum_ranking_points, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name",
        "qd": "#1 = Scan the table players and retrieve the player IDs and first names of all players ; #2 = Scan the table rankings and retrieve the player IDs and ranking points of all players ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the ranking points and first names ; #4 = Group #3 by first name and aggregate the sum of ranking points to find the total ranking points for each player, also retrieve their first names"
    },
    {
        "id": "277b5c8f864f36802e3bf5a4fdb43007f4b02f4575e48575970786bce9af05ee",
        "question": "find the number of players for each country.",
        "query": "SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ countstar AS Count_Star , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country_code FROM Scan_1 GROUP BY country_code ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players  GROUP BY country_code",
        "qd": "#1 = Scan the table players and retrieve the country codes of all players ; #2 = Group #1 by country code and aggregate the count of players for each country"
    },
    {
        "id": "e14b091525b0605611e8ca7329ecc05141580545c11b68d81e0d40d9b9eed55f",
        "question": "How many players are from each country?",
        "query": "SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ countstar AS Count_Star , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country_code FROM Scan_1 GROUP BY country_code ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players  GROUP BY country_code",
        "qd": "#1 = Scan the table players and retrieve the country codes of all players ; #2 = Group #1 by country code and aggregate the count of players per country"
    },
    {
        "id": "01647ae7e0cf6d752409dfd6fdd41d79bc9a878d51fe2a086123887c87b38554",
        "question": "find the code of the country where has the greatest number of players.",
        "query": "SELECT TOP 1 country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ countstar AS Count_Star , country_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country_code FROM Scan_1 GROUP BY country_code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, country_code FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 country_code FROM wta_1.players  GROUP BY country_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table players and retrieve the country codes of all players ; #2 = Group #1 by country code and aggregate the count of records per country code ; #3 = Sort the records from #2 based on the count of players in descending order, select the first record, and identify the country code that has the greatest number of players and its count"
    },
    {
        "id": "bf536a5accf17fc5f50fe4a88831ffb0eddf2c053cfd010f4e496faec5a26fbc",
        "question": "What is the code of the country with the most players?",
        "query": "SELECT TOP 1 country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ countstar AS Count_Star , country_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country_code FROM Scan_1 GROUP BY country_code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, country_code FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 country_code FROM wta_1.players  GROUP BY country_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table players and retrieve the country code of all players ; #2 = Group #1 by country code and aggregate the count of players per country code ; #3 = Sort the records from #2 based on the count of players in descending order, select the first record, and identify the country code with the most players"
    },
    {
        "id": "425bff2bfebdbee3e9137540cf2239f10e3986898173aa49e7bbbba2d55064a9",
        "question": "Find the codes of countries that have more than 50 players.",
        "query": "SELECT country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code HAVING count ( * ) > 50 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ countstar AS Count_Star , country_code ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 50 ] Output [ country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country_code FROM Scan_1 GROUP BY country_code ), Filter_3 AS ( SELECT country_code FROM Aggregate_2 WHERE Count_Star > 50 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT country_code FROM wta_1.players  GROUP BY country_code HAVING count ( * ) > 50",
        "qd": "#1 = Scan the table players and retrieve the country codes of all players ; #2 = Group #1 by country code and aggregate the count of players per country code ; #3 = Filter from #2 all the records where the count of players is greater than 50 and retrieve the country codes"
    },
    {
        "id": "5322a644022dbc15036fe0c0099125fa375687c8e4eeb4917d45d70c1b33f836",
        "question": "What are the codes of countries with more than 50 players?",
        "query": "SELECT country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code HAVING count ( * ) > 50 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ countstar AS Count_Star , country_code ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 50 ] Output [ country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country_code FROM Scan_1 GROUP BY country_code ), Filter_3 AS ( SELECT country_code FROM Aggregate_2 WHERE Count_Star > 50 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT country_code FROM wta_1.players  GROUP BY country_code HAVING count ( * ) > 50",
        "qd": "#1 = Scan the table players and retrieve the country codes of all players. ; #2 = Group #1 by country code and aggregate the count of players per country. ; #3 = Filter from #2 all the countries with more than 50 players and retrieve their country codes."
    },
    {
        "id": "4defbf0359c1037bfe89c5403c7cdb8c67b0f82ae96d81d003691e8e0500a564",
        "question": "Find the total number of tours for each ranking date.",
        "query": "SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings WITH (FORCESCAN) GROUP BY ranking_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ rankings ] Output [ tours , ranking_date ] ; #2 = Aggregate [ #1 ] GroupBy [ ranking_date ] Output [ SUM(tours) AS Sum_tours , ranking_date ]",
        "cte": "WITH Scan_1 AS ( SELECT tours, ranking_date FROM wta_1.rankings ), Aggregate_2 AS ( SELECT SUM(tours) AS Sum_tours, ranking_date FROM Scan_1 GROUP BY ranking_date ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings  GROUP BY ranking_date",
        "qd": "#1 = Scan the table rankings and retrieve the number of tours and ranking date for each record ; #2 = Aggregate the number of tours from #1 and group them by ranking date to find the total number of tours for each ranking date."
    },
    {
        "id": "1355c0cdad34ed6843f0c7be4c8311e7c04c5e47498de15c69206fb41203297b",
        "question": "How many total tours were there for each ranking date?",
        "query": "SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings WITH (FORCESCAN) GROUP BY ranking_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ rankings ] Output [ tours , ranking_date ] ; #2 = Aggregate [ #1 ] GroupBy [ ranking_date ] Output [ SUM(tours) AS Sum_tours , ranking_date ]",
        "cte": "WITH Scan_1 AS ( SELECT tours, ranking_date FROM wta_1.rankings ), Aggregate_2 AS ( SELECT SUM(tours) AS Sum_tours, ranking_date FROM Scan_1 GROUP BY ranking_date ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings  GROUP BY ranking_date",
        "qd": "#1 = Scan the table rankings and retrieve the number of tours and ranking date for each record ; #2 = Group #1 by ranking date and aggregate the sum of tours to calculate the total number of tours for each ranking date"
    },
    {
        "id": "620308662187c344a0e108bb40e62440d3db5e674d02984ac1edc18328782d6e",
        "question": "Find the number of matches happened in each year.",
        "query": "SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ countstar AS Count_Star , year ]",
        "cte": "WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, year FROM Scan_1 GROUP BY year ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches  GROUP BY YEAR",
        "qd": "#1 = Scan the table matches and retrieve the year of all matches ; #2 = Group #1 by year and aggregate the count of matches per year to find the number of matches happened in each year"
    },
    {
        "id": "14d7ca6040f3fd88253dc36d52a5dc3f8c9fddca5527843daae9a68e3513cdfd",
        "question": "How many matches were played in each year?",
        "query": "SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ countstar AS Count_Star , year ]",
        "cte": "WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, year FROM Scan_1 GROUP BY year ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches  GROUP BY YEAR",
        "qd": "#1 = Scan the table matches and retrieve the year of each match played ; #2 = Group #1 by year and aggregate the count of matches played in each year"
    },
    {
        "id": "5f825d0ca7aab228d5c0ae6793b47a6d6044a166df89612088071c3bbdf4a22e",
        "question": "Find the name and rank of the 3 youngest winners across all matches.",
        "query": "SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches WITH (FORCESCAN) ORDER BY winner_age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ winner_rank , winner_name , winner_age ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ winner_age , winner_name , winner_rank ] Output [ winner_rank , winner_name , winner_age ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT winner_rank, winner_name, winner_age FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 3 winner_rank, winner_name, winner_age FROM Scan_1 ORDER BY winner_age , winner_name , winner_rank ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches  ORDER BY winner_age",
        "qd": "#1 = Scan the table matches to retrieve the distinct records including the winner's rank, name, and age in all matches ; #2 = Sort the records from #1 based on the winner's age, name, and rank, select the top 3 youngest winners, and retrieve their rank, name, and age."
    },
    {
        "id": "1d475eb098ce0ad96f35972c2d26c617cfcc6e15efde805ae7ee5dbca0616181",
        "question": "What are the names and ranks of the three youngest winners across all matches?",
        "query": "SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches WITH (FORCESCAN) ORDER BY winner_age OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ winner_rank , winner_name , winner_age ] ; #2 = Top [ #1 ] Rows [ 3 ] OrderBy [ winner_age , winner_name , winner_rank ] Output [ winner_rank , winner_name , winner_age ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT winner_rank, winner_name, winner_age FROM wta_1.matches ), Top_2 AS ( SELECT TOP 3 winner_rank, winner_name, winner_age FROM Scan_1 ORDER BY winner_age , winner_name , winner_rank ) SELECT * FROM Top_2",
        "clean_query": "SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches  ORDER BY winner_age",
        "qd": "#1 = Scan the table matches and retrieve the distinct records of winner rank, winner name, and winner age ; #2 = Select the top 3 records from #1 based on the youngest winners and retrieve the winner rank, winner name, and winner age"
    },
    {
        "id": "1b4a7a6a4a6edbd99f288bea34b33440647837c357c6aaea4af04799805c576e",
        "question": "How many different winners both participated in the WTA Championships and were left handed?",
        "query": "SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' AND winner_hand = 'L' ] Distinct [ true ] Output [ tourney_name , winner_hand , winner_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT winner_name) AS Count_Dist_winner_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT tourney_name, winner_hand, winner_name FROM wta_1.matches WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' ), Aggregate_2 AS ( SELECT COUNT(DISTINCT winner_name) AS Count_Dist_winner_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches  WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L'",
        "qd": "#1 = Scan the table matches to find all the matches that were part of the WTA Championships and the winners who were left handed. ; #2 = Aggregate the count of distinct winner names from #1 to find the number of different winners who both participated in the WTA Championships and were left handed."
    },
    {
        "id": "08b917ef83c5cde81cdece7e98cfef78e82f1bd17c0dc8b77e8759f9fa88485a",
        "question": "Find the number of left handed winners who participated in the WTA Championships.",
        "query": "SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' AND winner_hand = 'L' ] Distinct [ true ] Output [ tourney_name , winner_hand , winner_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT winner_name) AS Count_Dist_winner_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT tourney_name, winner_hand, winner_name FROM wta_1.matches WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' ), Aggregate_2 AS ( SELECT COUNT(DISTINCT winner_name) AS Count_Dist_winner_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches  WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L'",
        "qd": "#1 = Scan the table matches and retrieve the tournament name, hand of the winner, and name of the winner for all matches in the WTA Championships where the winner is left-handed ; #2 = Aggregate the distinct count of winner names from #1 to find the number of left-handed winners who participated in the WTA Championships."
    },
    {
        "id": "867cde5170a26741ae4655d22fca0ab3bb8617a3498fc46fe257463dea794d20",
        "question": "Find the first name, country code and birth date of the winner who has the highest rank points in all matches.",
        "query": "SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank_points , winner_id ] ; #2 = Scan Table [ players ] Output [ first_name , player_id , birth_date , country_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Output [ #2.country_code , #2.birth_date , #2.first_name , #1.winner_rank_points ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , first_name , birth_date , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank_points, winner_id FROM wta_1.matches ), Scan_2 AS ( SELECT first_name, player_id, birth_date, country_code FROM wta_1.players ), Join_3 AS ( SELECT Scan_2.country_code, Scan_2.birth_date, Scan_2.first_name, Scan_1.winner_rank_points FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 winner_rank_points, first_name, birth_date, country_code FROM Join_3 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC",
        "qd": "#1 = Scan the table matches and retrieve the winner's rank points and ID for all matches ; #2 = Scan the table players and retrieve the first name, player ID, birth date, and country code for all players ; #3 = Join #1 and #2 based on the matching winner ID and player ID and retrieve the country code, birth date, first name, and winner rank points ; #4 = Sort the records from #3 based on the winner rank points in descending order, select the first record, and retrieve the winner rank points, first name, birth date, and country code"
    },
    {
        "id": "1a6d7284f609f767a7d2bbc05f7e125020d7b13ecf4c7f2f2de8e63338e8f6fe",
        "question": "What is the first name, country code, and birth date of the player with the most winner rank points across all matches?",
        "query": "SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank_points , winner_id ] ; #2 = Scan Table [ players ] Output [ first_name , player_id , birth_date , country_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Output [ #2.country_code , #2.birth_date , #2.first_name , #1.winner_rank_points ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , first_name , birth_date , country_code ]",
        "cte": "WITH Scan_1 AS ( SELECT winner_rank_points, winner_id FROM wta_1.matches ), Scan_2 AS ( SELECT first_name, player_id, birth_date, country_code FROM wta_1.players ), Join_3 AS ( SELECT Scan_2.country_code, Scan_2.birth_date, Scan_2.first_name, Scan_1.winner_rank_points FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 winner_rank_points, first_name, birth_date, country_code FROM Join_3 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC",
        "qd": "#1 = Scan the table matches and retrieve the winner rank points and player ID of all matches ; #2 = Scan the table players and retrieve the first name, player ID, birth date, and country code of all players ; #3 = Join #1 and #2 based on the matching player ID and retrieve the country code, birth date, first name, and winner rank points ; #4 = Sort the records from #3 based on the winner rank points in descending order, select the first record, and identify the first name, country code, and birth date of the player with the most winner rank points across all matches."
    },
    {
        "id": "e5bb7493553ebb3687bf1cdb55d5edfc06663219cc39e255956981437ab3d826",
        "question": "Find the number of players for each hand type.",
        "query": "SELECT count ( * ) AS Count_Star , hand FROM wta_1.players WITH (FORCESCAN) GROUP BY hand OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ hand ] ; #2 = Aggregate [ #1 ] GroupBy [ hand ] Output [ hand , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT hand FROM wta_1.players ), Aggregate_2 AS ( SELECT hand, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY hand ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , hand FROM wta_1.players  GROUP BY hand",
        "qd": "#1 = Scan the table players and retrieve the hand type of all players ; #2 = Group #1 by hand type and count the number of players for each hand type"
    },
    {
        "id": "fcffebd3ff6c929d806e7b4ea91b3ad91aa2d65799cc8b9af47caed7c6fb1f68",
        "question": "How many players are there for each hand type?",
        "query": "SELECT count ( * ) AS Count_Star , hand FROM wta_1.players WITH (FORCESCAN) GROUP BY hand OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "wta_1 | #1 = Scan Table [ players ] Output [ hand ] ; #2 = Aggregate [ #1 ] GroupBy [ hand ] Output [ hand , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT hand FROM wta_1.players ), Aggregate_2 AS ( SELECT hand, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY hand ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , hand FROM wta_1.players  GROUP BY hand",
        "qd": "#1 = Scan the table players and retrieve the hand type of all players ; #2 = Group #1 by hand type and aggregate the count of players for each hand type"
    },
    {
        "id": "65eeff6ba62debfd324c1369719ec178496b3f06a7b1df6fc9760d2bd4d00bc0",
        "question": "How many ships ended up being 'Captured'?",
        "query": "SELECT count ( * ) AS Count_Star FROM battle_death.ship WITH (FORCESCAN) WHERE disposition_of_ship = 'Captured' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ ship ] Predicate [ disposition_of_ship = 'Captured' ] Output [ disposition_of_ship ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT disposition_of_ship FROM battle_death.ship WHERE disposition_of_ship = 'Captured' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM battle_death.ship  WHERE disposition_of_ship = 'Captured'",
        "qd": "#1 = Scan the table ship and retrieve the ships with the disposition of 'Captured' ; #2 = Count the number of records in #1 to find how many ships ended up being 'Captured'"
    },
    {
        "id": "2ccd32ac0d180b828be858b0bf0735ce6f91ee1507751a8ac74b2614fb9dda0e",
        "question": "List the name and tonnage ordered by in descending alphaetical order for the names.",
        "query": "SELECT name , tonnage FROM battle_death.ship WITH (FORCESCAN) ORDER BY name DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ ship ] Output [ tonnage , name ] ; #2 = Sort [ #1 ] OrderBy [ name DESC ] Output [ tonnage , name ]",
        "cte": "WITH Scan_1 AS ( SELECT tonnage, name FROM battle_death.ship ) SELECT tonnage, name FROM Scan_1 ORDER BY name DESC",
        "clean_query": "SELECT name , tonnage FROM battle_death.ship  ORDER BY name DESC",
        "qd": "#1 = Scan the table ship and retrieve the tonnage and names of all ships ; #2 = Sort the records from #1 based on the ship names in descending alphabetical order and retrieve the tonnage and names"
    },
    {
        "id": "3356268778a1d181ee966ca9d917f094aa438755a17a6c70463309f229a4dcff",
        "question": "List the name, date and result of each battle.",
        "query": "SELECT name , date FROM battle_death.battle WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Output [ name , date ]",
        "cte": "WITH Scan_1 AS ( SELECT name, date FROM battle_death.battle ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , date FROM battle_death.battle",
        "qd": "#1 = Scan the table battle and retrieve the name and date of each battle"
    },
    {
        "id": "efc3d6b583061fdac5b1192e6644f9c76d5ae824ba2e041fabcadee05b13cb63",
        "question": "What is maximum and minimum death toll caused each time?",
        "query": "SELECT max ( killed ) AS Max_killed , min ( killed ) AS Min_killed FROM battle_death.death WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ death ] Output [ killed ] ; #2 = Aggregate [ #1 ] Output [ MAX(killed) AS Max_killed , MIN(killed) AS Min_killed ]",
        "cte": "WITH Scan_1 AS ( SELECT killed FROM battle_death.death ), Aggregate_2 AS ( SELECT MAX(killed) AS Max_killed, MIN(killed) AS Min_killed FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( killed ) AS Max_killed , min ( killed ) AS Min_killed FROM battle_death.death",
        "qd": "#1 = Scan the table death and retrieve the number of people killed each time ; #2 = Find the maximum and minimum death toll caused each time by aggregating the maximum and minimum values of the killed column from #1"
    },
    {
        "id": "0ee950e67cdbf2bef9cf54225445cebf182b136e6592005c3991f6b2a08a2d9e",
        "question": "What is the average number of injuries caused each time?",
        "query": "SELECT avg ( injured ) AS Avg_injured FROM battle_death.death WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ death ] Output [ injured ] ; #2 = Aggregate [ #1 ] Output [ AVG(injured) AS Avg_injured ]",
        "cte": "WITH Scan_1 AS ( SELECT injured FROM battle_death.death ), Aggregate_2 AS ( SELECT AVG(injured) AS Avg_injured FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( injured ) AS Avg_injured FROM battle_death.death",
        "qd": "#1 = Scan the table Death and retrieve the number of injuries caused each time ; #2 = Aggregate the average of injuries from #1 and calculate the average number of injuries caused each time."
    },
    {
        "id": "b1386d93c89b01508f84c2462d3dcc0f4f8ecec266f8b78d947bbe90436733a8",
        "question": "What are the death and injury situations caused by the ship with tonnage 't'?",
        "query": "SELECT T1.killed , T1.injured FROM battle_death.death AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS t2 WITH (FORCESCAN) ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ ship ] Predicate [ tonnage = 't' ] Output [ id , tonnage ] ; #2 = Scan Table [ death ] Output [ injured , caused_by_ship_id , killed ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.caused_by_ship_id ] Output [ #2.injured , #2.killed ]",
        "cte": "WITH Scan_1 AS ( SELECT id, tonnage FROM battle_death.ship WHERE tonnage = 't' ), Scan_2 AS ( SELECT injured, caused_by_ship_id, killed FROM battle_death.death ), Join_3 AS ( SELECT Scan_2.injured, Scan_2.killed FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.caused_by_ship_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.killed , T1.injured FROM battle_death.death AS T1  JOIN battle_death.ship AS t2  ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'",
        "qd": "#1 = Scan the table ship and retrieve the ship IDs and tonnage of all ships with tonnage 't' ; #2 = Scan the table death and retrieve the number of injured and killed, and the ship IDs that caused the deaths/injuries ; #3 = Join #1 and #2 based on the matching ship IDs and retrieve the number of injured and killed caused by the ship with tonnage 't'"
    },
    {
        "id": "55ed9a583e8099eef15899b28809eab0db5d06e127a724e4cc65ad722df4beed",
        "question": "What are the name and results of the battles when the bulgarian commander is not 'Boril'",
        "query": "SELECT name , RESULT FROM battle_death.battle WITH (FORCESCAN) WHERE bulgarian_commander ! = 'Boril' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Predicate [ bulgarian_commander <> 'Boril' ] Output [ bulgarian_commander , result , name ]",
        "cte": "WITH Scan_1 AS ( SELECT bulgarian_commander, result, name FROM battle_death.battle WHERE bulgarian_commander <> 'Boril' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , RESULT FROM battle_death.battle  WHERE bulgarian_commander ! = 'Boril'",
        "qd": "#1 = Scan the table Battle and retrieve the names and results of all battles where the Bulgarian commander is not 'Boril'."
    },
    {
        "id": "3f394f24a9ffba65e83de378069abbc3c6dc21d0e6858fd28bcaf8a4c44c069c",
        "question": "What are the different ids and names of the battles that lost any 'Brig' type shipes?",
        "query": "SELECT DISTINCT T1.id , T1.name FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.ship_type = 'Brig' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Output [ id , name ] ; #2 = Scan Table [ ship ] Predicate [ ship_type = 'Brig' ] Output [ lost_in_battle , ship_type ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.lost_in_battle = #1.id ] Output [ #1.id , #1.name ]",
        "cte": "WITH Scan_1 AS ( SELECT id, name FROM battle_death.battle ), Scan_2 AS ( SELECT lost_in_battle, ship_type FROM battle_death.ship WHERE ship_type = 'Brig' ), Intersect_3 AS ( SELECT Scan_1.id, Scan_1.name FROM Scan_1 WHERE id IN (SELECT lost_in_battle FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT DISTINCT T1.id , T1.name FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.ship_type = 'Brig'",
        "qd": "#1 = Scan the table battle and retrieve the ids and names of all battles ; #2 = Scan the table ship and retrieve the lost_in_battle and ship_type of all 'Brig' type ships ; #3 = Intersect the records from #1 and #2 based on the matching lost_in_battle and id, and retrieve the ids and names of the battles that lost any 'Brig' type ships"
    },
    {
        "id": "c08c23e7cc708242ee88a3d2b2b77fcc6eba87f51093769a204df2c410d443ae",
        "question": "What are the ids and names of the battles that led to more than 10 people killed in total.",
        "query": "SELECT T1.id , T1.name FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle JOIN battle_death.death AS T3 WITH (FORCESCAN) ON T2.id = T3.caused_by_ship_id GROUP BY T1.id , T1.name HAVING sum ( T3.killed ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ ship ] Output [ lost_in_battle , id ] ; #2 = Scan Table [ battle ] Output [ name , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.lost_in_battle = #2.id ] Output [ #2.id , #2.name ] ; #4 = Scan Table [ death ] Output [ caused_by_ship_id , killed ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.id = #4.caused_by_ship_id ] Output [ #3.id , #3.name , #4.killed ] ; #6 = Aggregate [ #5 ] GroupBy [ id ] Output [ SUM(killed) AS Sum_killed , name , id ] ; #7 = Filter [ #6 ] Predicate [ Sum_killed > 10 ] Output [ name , id ]",
        "cte": "WITH Scan_1 AS ( SELECT lost_in_battle, id FROM battle_death.ship ), Scan_2 AS ( SELECT name, id FROM battle_death.battle ), Join_3 AS ( SELECT Scan_2.id, Scan_2.name, Scan_1.id as ship_id FROM Scan_1 JOIN Scan_2 ON Scan_1.lost_in_battle = Scan_2.id ), Scan_4 AS ( SELECT caused_by_ship_id, killed FROM battle_death.death ), Join_5 AS ( SELECT Join_3.id, Join_3.name, Scan_4.killed FROM Join_3 JOIN Scan_4 ON Join_3.ship_id = Scan_4.caused_by_ship_id ), Aggregate_6 AS ( SELECT SUM(killed) AS Sum_killed, name, id FROM Join_5 GROUP BY name, id ), Filter_7 AS ( SELECT name, id FROM Aggregate_6 WHERE Sum_killed > 10 ) SELECT * FROM Filter_7",
        "clean_query": "SELECT T1.id , T1.name FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle JOIN battle_death.death AS T3  ON T2.id = T3.caused_by_ship_id GROUP BY T1.id , T1.name HAVING sum ( T3.killed ) > 10",
        "qd": "#1 = Scan the table ship and retrieve the battles in which ships were lost and their corresponding battle ids ; #2 = Scan the table battle and retrieve the names and ids of all battles ; #3 = Join #1 and #2 based on the matching battle ids and retrieve the names and ids of battles that led to ships being lost ; #4 = Scan the table death and retrieve the ship ids and number of people killed ; #5 = Join #3 and #4 based on the matching battle ids and ship ids and retrieve the names, ids, and number of people killed in each battle ; #6 = Group #5 by battle id and aggregate the sum of people killed for each battle ; #7 = Filter from #6 the battles with a total number of people killed greater than 10 and retrieve their names and ids"
    },
    {
        "id": "1d303a4c9be0e889f0579981273206eb3953935055b14be901616cc6fc92ba5f",
        "question": "What is the ship id and name that caused most total injuries?",
        "query": "SELECT TOP 1 T2.id , T2.name FROM battle_death.death AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS t2 WITH (FORCESCAN) ON T1.caused_by_ship_id = T2.id GROUP BY T2.id , T2.name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ death ] Output [ caused_by_ship_id ] ; #2 = Aggregate [ #1 ] GroupBy [ caused_by_ship_id ] Output [ countstar AS Count_Star , caused_by_ship_id ] ; #3 = Scan Table [ ship ] Output [ id , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.caused_by_ship_id = #3.id ] Output [ #3.id , #2.Count_Star , #3.name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ id , Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT caused_by_ship_id FROM battle_death.death ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, caused_by_ship_id FROM Scan_1 GROUP BY caused_by_ship_id ), Scan_3 AS ( SELECT id, name FROM battle_death.ship ), Join_4 AS ( SELECT Scan_3.id, Aggregate_2.Count_Star, Scan_3.name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.caused_by_ship_id = Scan_3.id ), TopSort_5 AS ( SELECT TOP 1 id, Count_Star, name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.id , T2.name FROM battle_death.death AS T1  JOIN battle_death.ship AS t2  ON T1.caused_by_ship_id = T2.id GROUP BY T2.id , T2.name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table death and retrieve the ship IDs of all the deaths caused by ships ; #2 = Group #1 by ship ID and aggregate the count per ship ID to find the total number of injuries caused by each ship ; #3 = Scan the table ship and retrieve the ship IDs and names of all the ships ; #4 = Join #2 and #3 based on the matching ship ID and retrieve the ship IDs, count of injuries, and the ship names ; #5 = Sort the records from #4 based on the count of injuries in descending order, select the first record, and identify the ship ID and name that caused the most total injuries"
    },
    {
        "id": "03a299a92f3839f2c0bb5e82bfe834b731538003186dcd06f7dea307ba81cee7",
        "question": "What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?",
        "query": "SELECT name FROM battle_death.battle WITH (FORCESCAN) WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Predicate [ bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' ] Output [ latin_commander , bulgarian_commander , name ]",
        "cte": "WITH Scan_1 AS ( SELECT latin_commander, bulgarian_commander, name FROM battle_death.battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name FROM battle_death.battle  WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'",
        "qd": "#1 = Scan the table battle and retrieve the names of the battles where the Bulgarian commander is 'Kaloyan' and the Latin commander is 'Baldwin I'."
    },
    {
        "id": "fe556df1566300f7d867bf85a0acea81c1ec223b682d1513e1b388040c727efe",
        "question": "How many different results are there for the battles?",
        "query": "SELECT count ( DISTINCT RESULT ) AS Count_Dist_RESULT FROM battle_death.battle WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Distinct [ true ] Output [ result ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT result) AS Count_Dist_result ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT result FROM battle_death.battle ), Aggregate_2 AS ( SELECT COUNT(DISTINCT result) AS Count_Dist_result FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT RESULT ) AS Count_Dist_RESULT FROM battle_death.battle",
        "qd": "#1 = Scan the table battle and retrieve all the distinct results of the battles ; #2 = Aggregate the count of distinct results from #1 to find how many different results are there for the battles"
    },
    {
        "id": "efc2abfda824f8537f7433476f8c634f1afe5c44f1e47895e62966073e995993",
        "question": "How many battles did not lose any ship with tonnage '225'?",
        "query": "SELECT count ( * ) AS Count_Star FROM battle_death.battle WITH (FORCESCAN) WHERE id NOT IN ( SELECT lost_in_battle FROM battle_death.ship WITH (FORCESCAN) WHERE tonnage = '225' )  ",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Output [ id ] ; #2 = Scan Table [ ship ] Predicate [ tonnage = '225' ] Output [ tonnage , lost_in_battle ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.lost_in_battle IS NULL OR #1.id = #2.lost_in_battle ] Output [ #1.id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT id FROM battle_death.battle ), Scan_2 AS ( SELECT tonnage, lost_in_battle FROM battle_death.ship WHERE tonnage = '225' ), Except_3 AS ( SELECT Scan_1.id FROM Scan_1 WHERE id NOT IN (SELECT lost_in_battle FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM battle_death.battle  WHERE id NOT IN ( SELECT lost_in_battle FROM battle_death.ship  WHERE tonnage = '225' )",
        "qd": "#1 = Scan the table battle and retrieve the IDs of all battles ; #2 = Scan the table ship and retrieve the tonnage and IDs of all ships with tonnage '225' ; #3 = return all the IDs from #1 that are not in #2 or where the ships were not lost in battle ; #4 = Aggregate the number of records from #3 to find the count of battles that did not lose any ship with tonnage '225'"
    },
    {
        "id": "bd21f664a846bc1fe7d88e638adb44527375b28722a48eb0c8675360b6696489",
        "question": "List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'",
        "query": "SELECT T1.name , T1.date FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.name = 'Lettice' INTERSECT SELECT T1.name , T1.date FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.name = 'HMS Atalanta' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ ship ] Predicate [ name = 'Lettice' ] Output [ name , lost_in_battle ] ; #2 = Scan Table [ battle ] Output [ id , name , date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.lost_in_battle = #2.id ] Distinct [ true ] Output [ #2.date , #2.name ] ; #4 = Scan Table [ ship ] Predicate [ name = 'HMS Atalanta' ] Output [ name , lost_in_battle ] ; #5 = Scan Table [ battle ] Output [ id , name , date ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.lost_in_battle = #5.id ] Output [ #5.name , #5.date ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.date , #3.name ]",
        "cte": "WITH Scan_1 AS ( SELECT name, lost_in_battle FROM battle_death.ship WHERE name = 'Lettice' ), Scan_2 AS ( SELECT id, name, date FROM battle_death.battle ), Join_3 AS ( SELECT DISTINCT Scan_2.date, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.lost_in_battle = Scan_2.id ), Scan_4 AS ( SELECT name, lost_in_battle FROM battle_death.ship WHERE name = 'HMS Atalanta' ), Scan_5 AS ( SELECT id, name, date FROM battle_death.battle ), Join_6 AS ( SELECT Scan_5.name, Scan_5.date FROM Scan_4 JOIN Scan_5 ON Scan_4.lost_in_battle = Scan_5.id ), Intersect_7 AS ( SELECT Join_3.date, Join_3.name FROM Join_3 WHERE name IN (SELECT name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.name , T1.date FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.name = 'Lettice' INTERSECT SELECT T1.name , T1.date FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.name = 'HMS Atalanta'",
        "qd": "#1 = Scan the table ship and retrieve the name and battle ID of the ship named 'Lettice' that was lost in battle ; #2 = Scan the table battle and retrieve the battle IDs, names, and dates of all battles ; #3 = Join #1 and #2 based on the matching battle ID and retrieve the names and dates of battles where the ship named 'Lettice' was lost ; #4 = Scan the table ship and retrieve the name and battle ID of the ship named 'HMS Atalanta' that was lost in battle ; #5 = Scan the table battle and retrieve the battle IDs, names, and dates of all battles ; #6 = Join #4 and #5 based on the matching battle ID and retrieve the names and dates of battles where the ship named 'HMS Atalanta' was lost ; #7 = Intersect #3 and #6 based on the matching names and retrieve the names and dates"
    },
    {
        "id": "2ff92e902d385f0d3c7c7ac8839232b8f21877f00a5e4efad288d1204c1383cd",
        "question": "Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.",
        "query": "SELECT name , RESULT , bulgarian_commander FROM battle_death.battle WITH (FORCESCAN) EXCEPT SELECT T1.name , T1.result , T1.bulgarian_commander FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.location = 'English Channel' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ battle ] Distinct [ true ] Output [ bulgarian_commander , name , result ] ; #2 = Scan Table [ ship ] Predicate [ location = 'English Channel' ] Output [ location , lost_in_battle ] ; #3 = Scan Table [ battle ] Output [ id , bulgarian_commander , name , result ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.lost_in_battle = #3.id ] Output [ #3.result , #3.name , #3.bulgarian_commander ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.result , #1.bulgarian_commander , #1.name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT bulgarian_commander, name, result FROM battle_death.battle ), Scan_2 AS ( SELECT location, lost_in_battle FROM battle_death.ship WHERE location = 'English Channel' ), Scan_3 AS ( SELECT id, bulgarian_commander, name, result FROM battle_death.battle ), Join_4 AS ( SELECT Scan_3.result, Scan_3.name, Scan_3.bulgarian_commander FROM Scan_2 JOIN Scan_3 ON Scan_2.lost_in_battle = Scan_3.id ), Except_5 AS ( SELECT Scan_1.result, Scan_1.bulgarian_commander, Scan_1.name FROM Scan_1 WHERE name NOT IN (SELECT name FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT name , RESULT , bulgarian_commander FROM battle_death.battle  EXCEPT SELECT T1.name , T1.result , T1.bulgarian_commander FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.location = 'English Channel'",
        "qd": "#1 = Scan the table battle and retrieve the distinct bulgarian commanders, names and results of all battles ; #2 = Scan the table ship and retrieve the location and lost in battle status of all ships in the English Channel ; #3 = Scan the table battle and retrieve the IDs, bulgarian commanders, names and results of all battles ; #4 = Join #2 and #3 based on the matching lost in battle and battle IDs and retrieve the results, names and bulgarian commanders ; #5 = Return the battles from #1 that do not have a matching record in #4 based on the battle names and retrieve the results and bulgarian commanders"
    },
    {
        "id": "1b35f7d7b149e16fedff1f5ae56a8bb5a21a6a4e93ab8f12af0f265c757d44bd",
        "question": "What are the notes of the death events which has substring 'East'?",
        "query": "SELECT note FROM battle_death.death WITH (FORCESCAN) WHERE note LIKE '%East%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "battle_death | #1 = Scan Table [ death ] Predicate [ note like '%East%' ] Output [ note ]",
        "cte": "WITH Scan_1 AS ( SELECT note FROM battle_death.death WHERE note like '%East%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT note FROM battle_death.death  WHERE note LIKE '%East%'",
        "qd": "#1 = Scan the table death and retrieve the notes of all death events that have the substring 'East' in them."
    },
    {
        "id": "2ac1015ed0642af90685a98b50fb7c5ab2fd9c6dc918f84b974bfc879d519cfe",
        "question": "what are all the addresses including line 1 and line 2?",
        "query": "SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ line_2 , line_1 ]",
        "cte": "WITH Scan_1 AS ( SELECT line_2, line_1 FROM student_transcripts_tracking.Addresses ) SELECT * FROM Scan_1",
        "clean_query": "SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses",
        "qd": "#1 = Scan the table Addresses and retrieve the line 1 and line 2 of all addresses."
    },
    {
        "id": "db4fbaa64e0ce68cfcc60c590b0bb1bff812a2a61390293307fba0d9cf1d1be2",
        "question": "What is the first and second line for all addresses?",
        "query": "SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ line_2 , line_1 ]",
        "cte": "WITH Scan_1 AS ( SELECT line_2, line_1 FROM student_transcripts_tracking.Addresses ) SELECT * FROM Scan_1",
        "clean_query": "SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses",
        "qd": "#1 = Scan the table Addresses and retrieve the second line and first line for all addresses."
    },
    {
        "id": "c54e9172bd8c8469719531b90d2bcd9a3ae3a106a373164fcaa4f4b968821e42",
        "question": "How many courses in total are listed?",
        "query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Courses ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Courses ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses",
        "qd": "#1 = Scan the table Courses and retrieve a constant value of 1 for each course ; #2 = Aggregate the number of records from #1 to find the total count of courses listed"
    },
    {
        "id": "b53627579d8711d98990593ed80847023e92dbca50b1ca0ac0b92653554ca0c9",
        "question": "How many courses are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Courses ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Courses ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses",
        "qd": "#1 = Scan the table Courses and output a value of 1 for each row ; #2 = Aggregate the records from #1 and count the total number of records to find the number of courses"
    },
    {
        "id": "c799c2d3a69ce74de70092294fcae7075d54975ef156b0e53763fecc34b61ff3",
        "question": "How is the math course described?",
        "query": "SELECT course_description FROM student_transcripts_tracking.Courses WITH (FORCESCAN) WHERE course_name = 'math' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Courses ] Predicate [ course_name = 'math' ] Output [ course_description , course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_description, course_name FROM student_transcripts_tracking.Courses WHERE course_name = 'math' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT course_description FROM student_transcripts_tracking.Courses  WHERE course_name = 'math'",
        "qd": "#1 = Scan the table Courses and retrieve the course description and name of the math course."
    },
    {
        "id": "e5bc7ae30bf83fb8eed96dab217d730ef7479ca2974ab899b2c5de3a57b5d83f",
        "question": "What are the descriptions for all the math courses?",
        "query": "SELECT course_description FROM student_transcripts_tracking.Courses WITH (FORCESCAN) WHERE course_name = 'math' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Courses ] Predicate [ course_name = 'math' ] Output [ course_description , course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_description, course_name FROM student_transcripts_tracking.Courses WHERE course_name = 'math' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT course_description FROM student_transcripts_tracking.Courses  WHERE course_name = 'math'",
        "qd": "#1 = Scan the table Courses and retrieve the course descriptions and names for all courses with the name \"math\""
    },
    {
        "id": "a96906121bf8107ed5d7287ea51641686047ef0e777391884145b07db87baad4",
        "question": "What is the zip code of the address in the city Port Chelsea?",
        "query": "SELECT zip_postcode FROM student_transcripts_tracking.Addresses WITH (FORCESCAN) WHERE city = 'Port Chelsea' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ city = 'Port Chelsea' ] Output [ zip_postcode , city ]",
        "cte": "WITH Scan_1 AS ( SELECT zip_postcode, city FROM student_transcripts_tracking.Addresses WHERE city = 'Port Chelsea' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT zip_postcode FROM student_transcripts_tracking.Addresses  WHERE city = 'Port Chelsea'",
        "qd": "#1 = Scan the table Addresses and retrieve the zip code and city of the address in the city Port Chelsea"
    },
    {
        "id": "99902bf465647b9de71fa5b3a255675bf1cf550f6095bced50a1103e60932e10",
        "question": "What is the zip code for Port Chelsea?",
        "query": "SELECT zip_postcode FROM student_transcripts_tracking.Addresses WITH (FORCESCAN) WHERE city = 'Port Chelsea' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ city = 'Port Chelsea' ] Output [ zip_postcode , city ]",
        "cte": "WITH Scan_1 AS ( SELECT zip_postcode, city FROM student_transcripts_tracking.Addresses WHERE city = 'Port Chelsea' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT zip_postcode FROM student_transcripts_tracking.Addresses  WHERE city = 'Port Chelsea'",
        "qd": "#1 = Scan the table Addresses and retrieve the zip code and city for all addresses in Port Chelsea."
    },
    {
        "id": "594047a3f87d0aa4e97ebf98f5d3e84a42a74422b787725d5ca6a6f0d75c94fb",
        "question": "Which department offers the most number of degrees? List department name and id.",
        "query": "SELECT TOP 1 T2.department_name , T1.department_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Departments AS T2 WITH (FORCESCAN) ON T1.department_id = T2.department_id GROUP BY T2.department_name , T1.department_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #2 = Aggregate [ #1 ] GroupBy [ department_id ] Output [ department_id , countstar AS Count_Star ] ; #3 = Scan Table [ Departments ] Output [ department_id , department_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.department_id = #3.department_id ] Output [ #2.Count_Star , #2.department_id , #3.department_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ department_id , Count_Star , department_name ]",
        "cte": "WITH Scan_1 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT department_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY department_id ), Scan_3 AS ( SELECT department_id, department_name FROM student_transcripts_tracking.Departments ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.department_id, Scan_3.department_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.department_id = Scan_3.department_id ), TopSort_5 AS ( SELECT TOP 1 department_id, Count_Star, department_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.department_name , T1.department_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Departments AS T2  ON T1.department_id = T2.department_id GROUP BY T2.department_name , T1.department_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the department IDs of all degree programs ; #2 = Group the records from #1 by department ID and count the number of records per department ID ; #3 = Scan the table Departments and retrieve the department IDs and names of all departments ; #4 = Join #2 and #3 based on the matching department IDs and retrieve the count of degrees, department IDs, and department names ; #5 = Sort the records from #4 based on the count of degrees in descending order, select the first record, and identify the department that offers the most number of degrees by providing the department ID and name"
    },
    {
        "id": "b81b808b3e493817e0147dc7b225dd4243187c2fcb355ad2bced48ea5131cc90",
        "question": "What is the name and id of the department with the most number of degrees ?",
        "query": "select TOP 1 t2.department_name , t1.department_id FROM student_transcripts_tracking.degree_programs AS t1 WITH (FORCESCAN) join student_transcripts_tracking.departments as t2 WITH (FORCESCAN) on t1.department_id = t2.department_id group by t2.department_name , t1.department_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #2 = Aggregate [ #1 ] GroupBy [ department_id ] Output [ department_id , countstar AS Count_Star ] ; #3 = Scan Table [ Departments ] Output [ department_id , department_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.department_id = #3.department_id ] Output [ #2.Count_Star , #2.department_id , #3.department_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ department_id , Count_Star , department_name ]",
        "cte": "WITH Scan_1 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT department_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY department_id ), Scan_3 AS ( SELECT department_id, department_name FROM student_transcripts_tracking.Departments ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.department_id, Scan_3.department_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.department_id = Scan_3.department_id ), TopSort_5 AS ( SELECT TOP 1 department_id, Count_Star, department_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 t2.department_name , t1.department_id FROM student_transcripts_tracking.degree_programs AS t1  join student_transcripts_tracking.departments as t2  on t1.department_id = t2.department_id group by t2.department_name , t1.department_id order by count ( * ) desc",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the department IDs of all degree programs. ; #2 = Group #1 by department ID and aggregate the count per department ID to find the number of degrees in each department. ; #3 = Scan the table Departments and retrieve the department IDs and names of all departments. ; #4 = Join #2 and #3 based on the matching department ID and retrieve the count of degrees, department ID, and department name. ; #5 = Sort the records from #4 based on the count of degrees in descending order, select the first record, and identify the department with the most number of degrees by its ID and name."
    },
    {
        "id": "8dd28dfa3877846461c9ca5ff24f1cf529cd5aa35599c46a87fbe88ad5a40e83",
        "question": "How many departments offer any degree?",
        "query": "SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ department_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs",
        "qd": "#1 = Scan the table Degree_Programs and retrieve all distinct department IDs ; #2 = Aggregate the number of distinct department IDs obtained from #1 to find the count of departments that offer any degree"
    },
    {
        "id": "6b818bfc5b7ecb4ae741d03d4ff61323fd33d7453db6ca50c0b0a72664470020",
        "question": "How many different departments offer degrees?",
        "query": "SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ department_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the distinct department IDs ; #2 = Aggregate the number of distinct department IDs from #1 to find the number of different departments that offer degrees."
    },
    {
        "id": "40bb6ce78af5916e027bb54942e97bb6cf361c0fd77103510be85af50772caa2",
        "question": "How many different degree names are offered?",
        "query": "SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ degree_summary_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs",
        "qd": "#1 = Scan the table Degree_Programs and retrieve all the distinct degree names offered ; #2 = Aggregate the count of distinct degree names from #1 to find the total number of different degree names offered."
    },
    {
        "id": "898c347eb5c12469a2246087c9e41c6d25d26c018c7d1456e41bcc557448867e",
        "question": "How many different degrees are offered?",
        "query": "SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ degree_summary_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the distinct degree summary names of all degree programs ; #2 = Aggregate the count of distinct degree summary names from #1 to find the number of different degrees offered."
    },
    {
        "id": "e2a8016205c76a65594123511298f5a3b3c80cdcda2a34b2d5958b3b76357407",
        "question": "How many degrees does the engineering department offer?",
        "query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Degree_Programs AS T2 WITH (FORCESCAN) ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name = 'engineer' ] Output [ department_id , department_name ] ; #2 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.department_id = #2.department_id ] Output [ #1.department_id , #1.department_name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT department_id, department_name FROM student_transcripts_tracking.Departments WHERE department_name = 'engineer' ), Scan_2 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_1.department_id, Scan_1.department_name FROM Scan_1 JOIN Scan_2 ON Scan_1.department_id = Scan_2.department_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1  JOIN student_transcripts_tracking.Degree_Programs AS T2  ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer'",
        "qd": "#1 = Scan the table Departments and retrieve the department ID and name of the engineering department ; #2 = Scan the table Degree_Programs and retrieve the department IDs of all degree programs ; #3 = Join #1 and #2 based on the matching department ID and retrieve the department ID and name of the engineering department ; #4 = Aggregate the number of records in #3 to find the total number of degrees offered by the engineering department"
    },
    {
        "id": "6c0f1803add8e16276df518874b943504f46798a505b30fcd496ca3f2a5ef9e3",
        "question": "How many degrees does the engineering department have?",
        "query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Degree_Programs AS T2 WITH (FORCESCAN) ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name = 'engineer' ] Output [ department_id , department_name ] ; #2 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.department_id = #2.department_id ] Output [ #1.department_id , #1.department_name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT department_id, department_name FROM student_transcripts_tracking.Departments WHERE department_name = 'engineer' ), Scan_2 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_1.department_id, Scan_1.department_name FROM Scan_1 JOIN Scan_2 ON Scan_1.department_id = Scan_2.department_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1  JOIN student_transcripts_tracking.Degree_Programs AS T2  ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer'",
        "qd": "#1 = Scan the table Departments to find the department with the name 'engineering' ; #2 = Scan the table Degree_Programs to find all the degree programs associated with the department ; #3 = Join #1 and #2 based on the matching department ID and retrieve the department ID and department name ; #4 = Aggregate the number of records from #3 to find the count of degrees in the engineering department"
    },
    {
        "id": "9dfedf1ed380083968565ef5a9823ced768e51cfdfa1f398b7cfde5337d6a06d",
        "question": "What are the names and descriptions of all the sections?",
        "query": "SELECT section_name , section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_description , section_name ]",
        "cte": "WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections ) SELECT * FROM Scan_1",
        "clean_query": "SELECT section_name , section_description FROM student_transcripts_tracking.Sections",
        "qd": "#1 = Scan the table Sections and retrieve the section descriptions and names of all the sections."
    },
    {
        "id": "4a4ef13b7b975976a31902cf7be1396d6d291bb928fecc469235c9d646f33b5d",
        "question": "What are the names and descriptions for all the sections?",
        "query": "SELECT section_name , section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_description , section_name ]",
        "cte": "WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections ) SELECT * FROM Scan_1",
        "clean_query": "SELECT section_name , section_description FROM student_transcripts_tracking.Sections",
        "qd": "#1 = Scan the table Sections and retrieve the section descriptions and names for all the sections."
    },
    {
        "id": "57a37b0501428222f4c8034672ee226bc3ec6d001972e5e1b7a7218189e3276c",
        "question": "What are the names and id of courses having at most 2 sections?",
        "query": "SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Sections AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name , #2.course_id ] ; #4 = Aggregate [ #3 ] GroupBy [ course_id ] Output [ countstar AS Count_Star , course_id , course_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star <= 2 ] Output [ course_id , course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Sections ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name, Scan_2.course_id FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, course_id, course_name FROM Join_3 GROUP BY course_name, course_id ), Filter_5 AS ( SELECT course_id, course_name FROM Aggregate_4 WHERE Count_Star <= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Sections AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2",
        "qd": "#1 = Scan the table Sections and retrieve the course IDs of all sections ; #2 = Scan the table Courses and retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names and IDs ; #4 = Group #3 by course ID and aggregate the count of sections per course ID and retrieve the count, course ID, and course name ; #5 = Filter from #4 all the records with a count of sections that is at most 2 and retrieve the course ID and name"
    },
    {
        "id": "3941c44dd86826e64780268e4986fd9beabdcb24cc002665fe4249303f2d9fd1",
        "question": "What are the names and ids of every course with less than 2 sections?",
        "query": "SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Sections AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name , #2.course_id ] ; #4 = Aggregate [ #3 ] GroupBy [ course_id ] Output [ countstar AS Count_Star , course_id , course_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star <= 2 ] Output [ course_id , course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Sections ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name, Scan_2.course_id FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, course_id, course_name FROM Join_3 GROUP BY course_name, course_id ), Filter_5 AS ( SELECT course_id, course_name FROM Aggregate_4 WHERE Count_Star <= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Sections AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2",
        "qd": "#1 = Scan the table Sections and retrieve the course IDs of all sections ; #2 = Scan the table Courses and retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the names and IDs ; #4 = Group #3 by course ID and aggregate the count of sections per course ; #5 = Filter from #4 all the courses with a count of sections less than or equal to 2, and retrieve the course IDs and names"
    },
    {
        "id": "0d4d196cc026090096873dca60f9f9112235e305878c0d7bab7b6fd404e4a148",
        "question": "List the section_name in reversed lexicographical order.",
        "query": "SELECT section_name FROM student_transcripts_tracking.Sections WITH (FORCESCAN) ORDER BY section_name DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_name ] ; #2 = Sort [ #1 ] OrderBy [ section_name DESC ] Output [ section_name ]",
        "cte": "WITH Scan_1 AS ( SELECT section_name FROM student_transcripts_tracking.Sections ) SELECT section_name FROM Scan_1 ORDER BY section_name DESC",
        "clean_query": "SELECT section_name FROM student_transcripts_tracking.Sections  ORDER BY section_name DESC",
        "qd": "#1 = Scan the table Sections and retrieve the section names ; #2 = Sort the section names from #1 in reversed lexicographical order and retrieve the section names"
    },
    {
        "id": "84e29240b001575ac46e8f3eebcf206cf49d7fc7fb2a26cca0199b1123c01bdd",
        "question": "What are the names of the sections in reverse alphabetical order?",
        "query": "SELECT section_name FROM student_transcripts_tracking.Sections WITH (FORCESCAN) ORDER BY section_name DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_name ] ; #2 = Sort [ #1 ] OrderBy [ section_name DESC ] Output [ section_name ]",
        "cte": "WITH Scan_1 AS ( SELECT section_name FROM student_transcripts_tracking.Sections ) SELECT section_name FROM Scan_1 ORDER BY section_name DESC",
        "clean_query": "SELECT section_name FROM student_transcripts_tracking.Sections  ORDER BY section_name DESC",
        "qd": "#1 = Scan the table Sections and retrieve the names of all sections ; #2 = Sort the records from #1 based on the section name in reverse alphabetical order and retrieve the section names"
    },
    {
        "id": "4ee8e06d6ea0494afddda0a73ba51a5f3c93bfded92d39d8fef5436b57c0689b",
        "question": "What is the semester which most student registered in? Show both the name and the id.",
        "query": "SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #2 = Aggregate [ #1 ] GroupBy [ semester_id ] Output [ countstar AS Count_Star , semester_id ] ; #3 = Scan Table [ Semesters ] Output [ semester_name , semester_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.semester_id = #3.semester_id ] Output [ #2.Count_Star , #3.semester_name , #3.semester_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ semester_name , Count_Star , semester_id ]",
        "cte": "WITH Scan_1 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, semester_id FROM Scan_1 GROUP BY semester_id ), Scan_3 AS ( SELECT semester_name, semester_id FROM student_transcripts_tracking.Semesters ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.semester_name, Scan_3.semester_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.semester_id = Scan_3.semester_id ), TopSort_5 AS ( SELECT TOP 1 semester_name, Count_Star, semester_id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the semester IDs of all student enrolments ; #2 = Group #1 by semester ID and aggregate the count of enrolments for each semester ; #3 = Scan the table Semesters and retrieve the semester names and IDs ; #4 = Join #2 and #3 based on the matching semester ID and retrieve the count of enrolments, semester name, and semester ID ; #5 = Sort the records from #4 based on the count of enrolments in descending order, select the first record, and identify the semester with the most student registrations by retrieving the semester name and ID"
    },
    {
        "id": "fd3ab86c1726ff82dfae3f950d230250d8b8d89f8ebb0146cad28b2fb7ba5ecb",
        "question": "For each semester, what is the name and id of the one with the most students registered?",
        "query": "SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #2 = Aggregate [ #1 ] GroupBy [ semester_id ] Output [ countstar AS Count_Star , semester_id ] ; #3 = Scan Table [ Semesters ] Output [ semester_name , semester_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.semester_id = #3.semester_id ] Output [ #2.Count_Star , #3.semester_name , #3.semester_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ semester_name , Count_Star , semester_id ]",
        "cte": "WITH Scan_1 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, semester_id FROM Scan_1 GROUP BY semester_id ), Scan_3 AS ( SELECT semester_name, semester_id FROM student_transcripts_tracking.Semesters ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.semester_name, Scan_3.semester_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.semester_id = Scan_3.semester_id ), TopSort_5 AS ( SELECT TOP 1 semester_name, Count_Star, semester_id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the semester IDs of all student enrolments ; #2 = Group #1 by semester ID and aggregate the count of enrolments per semester to find the number of students registered in each semester ; #3 = Scan the table Semesters and retrieve the semester names and IDs of all semesters ; #4 = Join #2 and #3 based on the matching semester IDs and retrieve the count of students registered, semester names, and semester IDs ; #5 = Sort the records from #4 based on the count of students registered in descending order, select the first record, and identify the name and ID of the semester with the most students registered."
    },
    {
        "id": "e213cd4fec20daef85edf43f959e494d49e9cfc209bf8d906ddc0e163d0b7736",
        "question": "What is the description of the department whose name has the substring the computer?",
        "query": "SELECT department_description FROM student_transcripts_tracking.Departments WITH (FORCESCAN) WHERE department_name LIKE '%computer%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name like '%computer%' ] Output [ department_description , department_name ]",
        "cte": "WITH Scan_1 AS ( SELECT department_description, department_name FROM student_transcripts_tracking.Departments WHERE department_name like '%computer%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT department_description FROM student_transcripts_tracking.Departments  WHERE department_name LIKE '%computer%'",
        "qd": "#1 = Scan the table Departments and retrieve the department description and department name of all departments whose name contains the substring \"computer\"."
    },
    {
        "id": "edd55d4ed905a820d6ca16947655a80dec3a03568e863d01d3c67c42ddaac344",
        "question": "What is the department description for the one whose name has the word computer?",
        "query": "SELECT department_description FROM student_transcripts_tracking.Departments WITH (FORCESCAN) WHERE department_name LIKE '%computer%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name like '%computer%' ] Output [ department_description , department_name ]",
        "cte": "WITH Scan_1 AS ( SELECT department_description, department_name FROM student_transcripts_tracking.Departments WHERE department_name like '%computer%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT department_description FROM student_transcripts_tracking.Departments  WHERE department_name LIKE '%computer%'",
        "qd": "#1 = Scan the table Departments and retrieve the department description and name for the department whose name contains the word \"computer\""
    },
    {
        "id": "728498cf775875068b9bab8aa842056887ff0d7f89672525110cc65529a4fbef",
        "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.",
        "query": "SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ] ; #3 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.first_name , #3.middle_name , #3.last_name , #3.student_id , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 2 ] Output [ middle_name , first_name , last_name , student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT middle_name, first_name, last_name, student_id FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.first_name, Scan_3.middle_name, Scan_3.last_name, Scan_3.student_id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), Filter_5 AS ( SELECT middle_name, first_name, last_name, student_id FROM Join_4 WHERE Count_Star = 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the student IDs of all enrolled students ; #2 = Group #1 by student ID and count the number of enrollments per student ; #3 = Scan the table Students and retrieve the middle name, first name, last name, and student ID of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the first name, middle name, last name, student ID, and the count of enrollments ; #5 = Filter from #4 all the students with a count of enrollments equals to 2 and retrieve the middle name, first name, last name, and student ID"
    },
    {
        "id": "f85c2f09f4eae3cc1aaf881656ac6d56ca396023118851906c9efa64f26e905d",
        "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?",
        "query": "SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ] ; #3 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.first_name , #3.middle_name , #3.last_name , #3.student_id , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 2 ] Output [ middle_name , first_name , last_name , student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT middle_name, first_name, last_name, student_id FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.first_name, Scan_3.middle_name, Scan_3.last_name, Scan_3.student_id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), Filter_5 AS ( SELECT middle_name, first_name, last_name, student_id FROM Join_4 WHERE Count_Star = 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2",
        "qd": "#1 = Scan the table Student_Enrolment to retrieve the student IDs of all students who enrolled in degree programs ; #2 = Group #1 by student ID and aggregate the count of records per student ID ; #3 = Scan the table Students and retrieve the middle name, first name, last name, and student ID of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the first name, middle name, last name, student ID, and the count of degree programs enrolled by each student ; #5 = Filter from #4 the records where the count of degree programs enrolled is equal to 2 and retrieve the middle name, first name, last name, and student ID of these students"
    },
    {
        "id": "154ade6ec7a46682d047b9181ae3c0a84374232035fcf506874a2219cdd09599",
        "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
        "query": "SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3 WITH (FORCESCAN) ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_summary_name , degree_program_id ] ; #2 = Scan Table [ Student_Enrolment ] Output [ student_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.student_id ] ; #4 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , student_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.student_id = #4.student_id ] Distinct [ true ] Output [ #4.middle_name , #4.first_name , #4.last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_2 AS ( SELECT student_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT middle_name, first_name, last_name, student_id FROM student_transcripts_tracking.Students ), Join_5 AS ( SELECT DISTINCT Scan_4.middle_name, Scan_4.first_name, Scan_4.last_name FROM Join_3 JOIN Scan_4 ON Join_3.student_id = Scan_4.student_id ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3  ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the degree program IDs of all Bachelor degree programs ; #2 = Scan the table Student_Enrolment and retrieve the student IDs of all students enrolled in a degree program ; #3 = Join #1 and #2 based on the matching degree program IDs and retrieve the student IDs ; #4 = Scan the table Students and retrieve the middle name, first name, last name, and student IDs of all students ; #5 = Join #3 and #4 based on the matching student IDs without duplicates and retrieve the middle name, first name, last name of all students enrolled in a Bachelor degree program"
    },
    {
        "id": "2302a1b8bb2111d71497b49f79a57e7db73f1de39aa54c60c1bab8fae0217a10",
        "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?",
        "query": "SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3 WITH (FORCESCAN) ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_summary_name , degree_program_id ] ; #2 = Scan Table [ Student_Enrolment ] Output [ student_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.student_id ] ; #4 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , student_id ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.student_id = #4.student_id ] Distinct [ true ] Output [ #4.middle_name , #4.first_name , #4.last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_2 AS ( SELECT student_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT middle_name, first_name, last_name, student_id FROM student_transcripts_tracking.Students ), Join_5 AS ( SELECT DISTINCT Scan_4.middle_name, Scan_4.first_name, Scan_4.last_name FROM Join_3 JOIN Scan_4 ON Join_3.student_id = Scan_4.student_id ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3  ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the degree program IDs of all Bachelor programs ; #2 = Scan the table Student_Enrolment and retrieve the student IDs and degree program IDs of all student enrollments ; #3 = Join #1 and #2 based on the matching degree program IDs and retrieve the student IDs ; #4 = Scan the table Students and retrieve the middle names, first names, last names, and student IDs of all students ; #5 = Join #3 and #4 based on the matching student IDs, remove any duplicate records, and retrieve the middle names, first names, last names of all students enrolled in a Bachelor program"
    },
    {
        "id": "a10ef1dc84070e92c63477211ea1738d364aca09cd140fdcb5d8d7685285a26d",
        "question": "Find the kind of program which most number of students are enrolled in?",
        "query": "SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ degree_summary_name , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.degree_summary_name ] ; #4 = Aggregate [ #3 ] GroupBy [ degree_summary_name ] Output [ countstar AS Count_Star , degree_summary_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ degree_summary_name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_2 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_2.degree_summary_name FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, degree_summary_name FROM Join_3 GROUP BY degree_summary_name ), TopSort_5 AS ( SELECT TOP 1 degree_summary_name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the degree program IDs of all students enrolled ; #2 = Scan the table Degree_Programs and retrieve the degree program names and IDs ; #3 = Join #1 and #2 based on the matching degree program ID and retrieve the degree program names ; #4 = Group #3 by degree program name and aggregate the count per degree program to find the number of students enrolled in each program ; #5 = Sort the records from #4 based on the count of students enrolled in each program in descending order, select the first record, and identify the program with the most number of students and its count of students."
    },
    {
        "id": "d25d036afc69baf9a3904e24917c7343ef491033d06727dec986ad7c1acc8f97",
        "question": "What is the degree summary name that has the most number of students enrolled?",
        "query": "SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ degree_summary_name , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.degree_summary_name ] ; #4 = Aggregate [ #3 ] GroupBy [ degree_summary_name ] Output [ countstar AS Count_Star , degree_summary_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ degree_summary_name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_2 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_2.degree_summary_name FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, degree_summary_name FROM Join_3 GROUP BY degree_summary_name ), TopSort_5 AS ( SELECT TOP 1 degree_summary_name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the degree program IDs of all student enrollments ; #2 = Scan the table Degree_Programs and retrieve the degree summary names and degree program IDs ; #3 = Join #1 and #2 based on the matching degree program IDs and retrieve the degree summary names ; #4 = Group #3 by degree summary name and aggregate the count per degree summary name to find the number of students enrolled in each degree program ; #5 = Sort the records from #4 based on the count of students enrolled in descending order, select the first record, and identify the degree summary name of the degree program with the most number of students enrolled and its count of students."
    },
    {
        "id": "d0a296f1837c86b98749f120148d725826c46b39b052aeb796e95d08240be359",
        "question": "Find the program which most number of students are enrolled in. List both the id and the summary.",
        "query": "SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Aggregate [ #1 ] GroupBy [ degree_program_id ] Output [ countstar AS Count_Star , degree_program_id ] ; #3 = Scan Table [ Degree_Programs ] Output [ degree_summary_name , degree_program_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.degree_program_id = #3.degree_program_id ] Output [ #2.Count_Star , #3.degree_summary_name , #3.degree_program_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ degree_summary_name , Count_Star , degree_program_id ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, degree_program_id FROM Scan_1 GROUP BY degree_program_id ), Scan_3 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.degree_summary_name, Scan_3.degree_program_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.degree_program_id = Scan_3.degree_program_id ), TopSort_5 AS ( SELECT TOP 1 degree_summary_name, Count_Star, degree_program_id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the degree program IDs of all student enrollments ; #2 = Group #1 by degree program ID and aggregate the count of enrollments per degree program ; #3 = Scan the table Degree_Programs and retrieve the degree program summary names and IDs ; #4 = Join #2 and #3 based on the matching degree program IDs and retrieve the enrollment count and program summary name and ID ; #5 = Sort the records from #4 based on the enrollment count in descending order, select the first record, and identify the degree program with the most number of students enrolled, including its summary and program ID."
    },
    {
        "id": "34572d6690f52e3ae8b1930d673e5bb162d889950786a5123cf119a1dab9cc1e",
        "question": "What is the program id and the summary of the degree that has the most students enrolled?",
        "query": "SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Aggregate [ #1 ] GroupBy [ degree_program_id ] Output [ countstar AS Count_Star , degree_program_id ] ; #3 = Scan Table [ Degree_Programs ] Output [ degree_summary_name , degree_program_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.degree_program_id = #3.degree_program_id ] Output [ #2.Count_Star , #3.degree_summary_name , #3.degree_program_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ degree_summary_name , Count_Star , degree_program_id ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, degree_program_id FROM Scan_1 GROUP BY degree_program_id ), Scan_3 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.degree_summary_name, Scan_3.degree_program_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.degree_program_id = Scan_3.degree_program_id ), TopSort_5 AS ( SELECT TOP 1 degree_summary_name, Count_Star, degree_program_id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the degree program IDs of all student enrolments. ; #2 = Group #1 by degree program ID and aggregate the count of enrolments per degree program. ; #3 = Scan the table Degree_Programs and retrieve the degree summary names and associated degree program IDs. ; #4 = Join #2 and #3 based on the matching degree program IDs and retrieve the count of enrolments and degree summary names. ; #5 = Sort the records from #4 based on the count of enrolments in descending order, select the first record, and identify the degree summary and associated degree program ID that has the most students enrolled."
    },
    {
        "id": "25e6219ead2bf27a2598b9113dc3d3af8c1960671ba08542f364e3d1cf519404",
        "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.",
        "query": "SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ] ; #3 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.first_name , #3.middle_name , #3.last_name , #3.student_id , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , student_id , middle_name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT middle_name, first_name, last_name, student_id FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.first_name, Scan_3.middle_name, Scan_3.last_name, Scan_3.student_id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), TopSort_5 AS ( SELECT TOP 1 first_name, last_name, student_id, middle_name, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the student IDs of all enrolments ; #2 = Group #1 by student ID and aggregate the count of enrolments per student ; #3 = Scan the table Students and retrieve the middle name, first name, last name, and student ID of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the first name, middle name, last name, student ID, and the count of enrolments ; #5 = Sort the records from #4 based on the count of enrolments in descending order, select the first record, and identify the student who has enrolled the most times in any program. Retrieve their ID, first name, middle name, last name, and the number of enrollments."
    },
    {
        "id": "24a2b7acc32937966d07d1265d8dc136e4be76b7cfe7bf73b2ac90793d0c310b",
        "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?",
        "query": "SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ] ; #3 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.first_name , #3.middle_name , #3.last_name , #3.student_id , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , student_id , middle_name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT middle_name, first_name, last_name, student_id FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.first_name, Scan_3.middle_name, Scan_3.last_name, Scan_3.student_id, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), TopSort_5 AS ( SELECT TOP 1 first_name, last_name, student_id, middle_name, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment and retrieve the student IDs of all enrollments ; #2 = Group #1 by student ID and aggregate the count of enrollments per student ; #3 = Scan the table Students and retrieve the middle name, first name, last name, and student ID of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the first name, middle name, last name, student ID, and the count of enrollments ; #5 = Sort the records from #4 based on the count of enrollments in descending order, select the first record, and identify the first name, middle name, last name, student ID, and the count of enrollments for the student who enrolled the most in any program."
    },
    {
        "id": "8f8dd95299a63e06a826543a636d943555a7b97b7b1a3fae24cebc48ce2f8de4",
        "question": "Which semesters do not have any student enrolled? List the semester name.",
        "query": "SELECT semester_name FROM student_transcripts_tracking.Semesters WITH (FORCESCAN) WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Semesters ] Output [ semester_name , semester_id ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.semester_id = #1.semester_id ] Output [ #1.semester_name ]",
        "cte": "WITH Scan_1 AS ( SELECT semester_name, semester_id FROM student_transcripts_tracking.Semesters ), Scan_2 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Except_3 AS ( SELECT Scan_1.semester_name FROM Scan_1 WHERE semester_id NOT IN (SELECT semester_id FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT semester_name FROM student_transcripts_tracking.Semesters  WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment  )",
        "qd": "#1 = Scan the table Semesters and retrieve the semester names and IDs of all semesters ; #2 = Scan the table Student_Enrolment and retrieve the semester IDs of all student enrolments ; #3 = Return all the semester names from #1 that do not have any student enrolled, based on the matching semester IDs in #2"
    },
    {
        "id": "9fd7819b14bde9ee74ec0e3209b223ce84e293f99d29e2ac8a51f4ac4e6a787c",
        "question": "What is the name of the semester with no students enrolled?",
        "query": "SELECT semester_name FROM student_transcripts_tracking.Semesters WITH (FORCESCAN) WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Semesters ] Output [ semester_name , semester_id ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.semester_id = #1.semester_id ] Output [ #1.semester_name ]",
        "cte": "WITH Scan_1 AS ( SELECT semester_name, semester_id FROM student_transcripts_tracking.Semesters ), Scan_2 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Except_3 AS ( SELECT Scan_1.semester_name FROM Scan_1 WHERE semester_id NOT IN (SELECT semester_id FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT semester_name FROM student_transcripts_tracking.Semesters  WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment  )",
        "qd": "#1 = Scan the table Semesters to retrieve the names and IDs of all semesters. ; #2 = Scan the table Student_Enrollment to retrieve the semester IDs of all enrollments. ; #3 = Return the semester names from #1 that are not in #2 to find the names of semesters with no students enrolled."
    },
    {
        "id": "ca275588e6a1888e3ee9ac925a1f679efdc98638946b70168e6eb08bd0b42247",
        "question": "What are all the course names of the courses which ever have students enrolled in?",
        "query": "SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Distinct [ true ] Output [ #2.course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT DISTINCT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id",
        "qd": "#1 = Scan the table Student_Enrolment_Courses and retrieve the course IDs of all the courses that have students enrolled ; #2 = Scan the table Courses and retrieve the course IDs and course names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names without duplicates"
    },
    {
        "id": "c3c0c78ed6a2f30afcfd3f309300640fd3f03dc8619ee2ab43d1b39f24566e90",
        "question": "What are the names of all courses that have some students enrolled?",
        "query": "SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Distinct [ true ] Output [ #2.course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT DISTINCT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id",
        "qd": "#1 = Scan the table Student_Enrolment_Courses and retrieve the course IDs of all enrolled courses ; #2 = Scan the table Courses and retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names without duplicates"
    },
    {
        "id": "1bd94e2f18aa0acb7fb193440870a60c58d392889f7f5282908b639d56d1d35e",
        "question": "What's the name of the course with most number of enrollments?",
        "query": "SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name ] ; #4 = Aggregate [ #3 ] GroupBy [ course_name ] Output [ countstar AS Count_Star , course_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, course_name FROM Join_3 GROUP BY course_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, course_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment_Courses to retrieve all course IDs of students' enrollments ; #2 = Scan the table Courses to retrieve the course IDs and course names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names ; #4 = Group #3 by course name and aggregate the count of records per course name ; #5 = Sort the records from #4 based on the count of enrollments in descending order, select the first record, and identify the name of the course with the most number of enrollments"
    },
    {
        "id": "8d8d7be0915ab938d82fc0dc6b68687fa8a87c94b363531168932afc2034e978",
        "question": "What is the name of the course with the most students enrolled?",
        "query": "SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name ] ; #4 = Aggregate [ #3 ] GroupBy [ course_name ] Output [ countstar AS Count_Star , course_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , course_name ]",
        "cte": "WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, course_name FROM Join_3 GROUP BY course_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, course_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Student_Enrolment_Courses and retrieve the course IDs of all enrolled courses ; #2 = Scan the table Courses and retrieve the course IDs and names of all courses ; #3 = Join #1 and #2 based on the matching course IDs and retrieve the course names ; #4 = Group #3 by course name and aggregate the count per course name to find the number of students enrolled in each course ; #5 = Sort the records from #4 based on the count of students enrolled in descending order, select the first record, and identify the name of the course with the most students enrolled and its count of enrolled students."
    },
    {
        "id": "90fe37982799391287e4f0d346699f1b44e07bfa60c82d7570607cd1983a3094",
        "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
        "query": "SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Addresses AS T2 WITH (FORCESCAN) ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T4 WITH (FORCESCAN) ON T3.student_id = T4.student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ state_province_county = 'NorthCarolina' ] Output [ address_id , state_province_county ] ; #2 = Scan Table [ Students ] Output [ current_address_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.address_id = #2.current_address_id ] Distinct [ true ] Output [ #2.last_name ] ; #4 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #5 = Scan Table [ Students ] Output [ last_name , student_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.student_id = #5.student_id ] Distinct [ true ] Output [ #5.last_name ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.last_name = #6.last_name ] Output [ #3.last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT address_id, state_province_county FROM student_transcripts_tracking.Addresses WHERE state_province_county = 'NorthCarolina' ), Scan_2 AS ( SELECT current_address_id, last_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT DISTINCT Scan_2.last_name FROM Scan_1 JOIN Scan_2 ON Scan_1.address_id = Scan_2.current_address_id ), Scan_4 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_5 AS ( SELECT last_name, student_id FROM student_transcripts_tracking.Students ), Join_6 AS ( SELECT DISTINCT Scan_5.last_name FROM Scan_4 JOIN Scan_5 ON Scan_4.student_id = Scan_5.student_id ), Except_7 AS ( SELECT Join_3.last_name FROM Join_3 WHERE last_name NOT IN (SELECT last_name FROM Join_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Addresses AS T2  ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3  JOIN student_transcripts_tracking.Student_Enrolment AS T4  ON T3.student_id = T4.student_id",
        "qd": "#1 = Scan the table Addresses to find the address IDs and state of all addresses in the state of North Carolina. ; #2 = Scan the table Students and retrieve the current address IDs and last names of all students. ; #3 = Join #1 and #2 based on the matching address IDs and retrieve the last names of the students. ; #4 = Scan the table Student_Enrolment and retrieve the student IDs of all enrolled students. ; #5 = Scan the table Students and retrieve the last names and student IDs of all students. ; #6 = Join #4 and #5 based on the matching student IDs and retrieve the last names of the enrolled students. ; #7 = Return the last names from #3 that are not in #6 to find the last names of the students who currently live in North Carolina but have not registered in any degree program."
    },
    {
        "id": "c0a96b9f9d0925f4b25d2753c394e50199efd3b2e713af2553e63e9a993cd92f",
        "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
        "query": "SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Addresses AS T2 WITH (FORCESCAN) ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T4 WITH (FORCESCAN) ON T3.student_id = T4.student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ state_province_county = 'NorthCarolina' ] Output [ address_id , state_province_county ] ; #2 = Scan Table [ Students ] Output [ current_address_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.address_id = #2.current_address_id ] Distinct [ true ] Output [ #2.last_name ] ; #4 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #5 = Scan Table [ Students ] Output [ last_name , student_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.student_id = #5.student_id ] Distinct [ true ] Output [ #5.last_name ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.last_name = #6.last_name ] Output [ #3.last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT address_id, state_province_county FROM student_transcripts_tracking.Addresses WHERE state_province_county = 'NorthCarolina' ), Scan_2 AS ( SELECT current_address_id, last_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT DISTINCT Scan_2.last_name FROM Scan_1 JOIN Scan_2 ON Scan_1.address_id = Scan_2.current_address_id ), Scan_4 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_5 AS ( SELECT last_name, student_id FROM student_transcripts_tracking.Students ), Join_6 AS ( SELECT DISTINCT Scan_5.last_name FROM Scan_4 JOIN Scan_5 ON Scan_4.student_id = Scan_5.student_id ), Except_7 AS ( SELECT Join_3.last_name FROM Join_3 WHERE last_name NOT IN (SELECT last_name FROM Join_6) ) SELECT * FROM Except_7",
        "clean_query": "SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Addresses AS T2  ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3  JOIN student_transcripts_tracking.Student_Enrolment AS T4  ON T3.student_id = T4.student_id",
        "qd": "#1 = Scan the table Addresses to find the address IDs and state/province/county of all students who live in North Carolina. ; #2 = Scan the table Students to retrieve the current address IDs and last names of all students. ; #3 = Join #1 and #2 based on the matching address ID and retrieve the last names of the students who live in North Carolina. ; #4 = Scan the table Student_Enrolment to retrieve the IDs of all students enrolled in degree programs. ; #5 = Scan the table Students to retrieve the last names and IDs of all students. ; #6 = Join #4 and #5 based on the matching student ID and retrieve the last names of the students enrolled in degree programs. ; #7 = Return the last names from #3 that are not in #6 to find the last names of the students who live in North Carolina but have not registered in any degree programs."
    },
    {
        "id": "681cf03b6d36068143ee1116a534b9ea3ea9ab0b38428280e350f80987598ba7",
        "question": "Show the date and id of the transcript with at least 2 course results.",
        "query": "SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Transcripts AS T2 WITH (FORCESCAN) ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #2 = Aggregate [ #1 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #3 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.transcript_id = #3.transcript_id ] Output [ #2.transcript_id , #2.Count_Star , #3.transcript_date ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ transcript_id , transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, transcript_id FROM Scan_1 GROUP BY transcript_id ), Scan_3 AS ( SELECT transcript_id, transcript_date FROM student_transcripts_tracking.Transcripts ), Join_4 AS ( SELECT Aggregate_2.transcript_id, Aggregate_2.Count_Star, Scan_3.transcript_date FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.transcript_id = Scan_3.transcript_id ), Filter_5 AS ( SELECT transcript_id, transcript_date FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  JOIN student_transcripts_tracking.Transcripts AS T2  ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table transcript contents and retrieve all the transcript IDs ; #2 = Group #1 by transcript ID and count the number of course results in each transcript ; #3 = Scan the table transcripts and retrieve the transcript IDs and dates ; #4 = Join #2 and #3 based on the matching transcript IDs and retrieve the transcript IDs, course result counts, and dates ; #5 = Filter #4 to only include records with count of course results greater than or equal to 2, and retrieve the transcript IDs and dates of transcripts with at least 2 course results."
    },
    {
        "id": "f354038a754fe4726aab53423b47fd7259de7b16d4e90b949c9f3f0fe7c097a5",
        "question": "What is the date and id of the transcript with at least 2 courses listed?",
        "query": "SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Transcripts AS T2 WITH (FORCESCAN) ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #2 = Aggregate [ #1 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #3 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.transcript_id = #3.transcript_id ] Output [ #2.transcript_id , #2.Count_Star , #3.transcript_date ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ transcript_id , transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, transcript_id FROM Scan_1 GROUP BY transcript_id ), Scan_3 AS ( SELECT transcript_id, transcript_date FROM student_transcripts_tracking.Transcripts ), Join_4 AS ( SELECT Aggregate_2.transcript_id, Aggregate_2.Count_Star, Scan_3.transcript_date FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.transcript_id = Scan_3.transcript_id ), Filter_5 AS ( SELECT transcript_id, transcript_date FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  JOIN student_transcripts_tracking.Transcripts AS T2  ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Transcript_Contents to retrieve the transcript IDs of all the courses listed in the transcripts ; #2 = Group the records from #1 by transcript ID and aggregate the count of records per ID ; #3 = Scan the table Transcripts to retrieve the transcript IDs and dates of all transcripts ; #4 = Join #2 and #3 based on the matching transcript ID and retrieve the transcript IDs, count of courses, and dates ; #5 = Filter from #4 all the records with a count of courses greater than or equal to 2 and retrieve the transcript IDs and dates"
    },
    {
        "id": "12f83d872b4996b26a5511d6910db085bcd48e6656dcaef27eb62b3424a06ca9",
        "question": "What is the phone number of the man with the first name Timmothy and the last name Ward?",
        "query": "SELECT cell_mobile_number FROM student_transcripts_tracking.Students WITH (FORCESCAN) WHERE first_name = 'Timmothy' AND last_name = 'Ward' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ first_name = 'Timmothy' AND last_name = 'Ward' ] Output [ first_name , last_name , cell_mobile_number ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, last_name, cell_mobile_number FROM student_transcripts_tracking.Students WHERE first_name = 'Timmothy' AND last_name = 'Ward' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT cell_mobile_number FROM student_transcripts_tracking.Students  WHERE first_name = 'Timmothy' AND last_name = 'Ward'",
        "qd": "#1 = Scan the table Students and retrieve the first name, last name, and cell/mobile number of the man with the first name Timmothy and the last name Ward."
    },
    {
        "id": "6e07e3442e971836451c6b5d8270702979d958da915172bf10e273487e3e254d",
        "question": "What is the mobile phone number of the student named Timmothy Ward ?",
        "query": "select cell_mobile_number FROM student_transcripts_tracking.students WITH (FORCESCAN) where first_name = 'timmothy' and last_name = 'ward' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ first_name = 'timmothy' AND last_name = 'ward' ] Output [ first_name , last_name , cell_mobile_number ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, last_name, cell_mobile_number FROM student_transcripts_tracking.Students WHERE first_name = 'timmothy' AND last_name = 'ward' ) SELECT * FROM Scan_1",
        "clean_query": "select cell_mobile_number FROM student_transcripts_tracking.students  where first_name = 'timmothy' and last_name = 'ward'",
        "qd": "#1 = Scan the table Students and retrieve the mobile phone number of the student named Timmothy Ward"
    },
    {
        "id": "13402275c28ea205994823c1db8e3dc7acb229431deaad3cb2954b8df3778978",
        "question": "Who is the first student to register? List the first name, middle name and last name.",
        "query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_first_registered ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , date_first_registered ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_first_registered ASC ] Output [ middle_name , first_name , last_name , date_first_registered ]",
        "cte": "WITH Scan_1 AS ( SELECT middle_name, first_name, last_name, date_first_registered FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 middle_name, first_name, last_name, date_first_registered FROM Scan_1 ORDER BY date_first_registered ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_first_registered ASC",
        "qd": "#1 = Scan the table Students and retrieve the middle name, first name, last name, and date of first registration of all students ; #2 = Sort the records from #1 based on the date of first registration in ascending order, select the first record, and retrieve the middle name, first name, and last name of the first student who registered"
    },
    {
        "id": "c072e76619b9b9ee950cec35cf5f953243537d799f59ec4fca100dcca366c081",
        "question": "What is the first, middle, and last name of the first student to register?",
        "query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_first_registered ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ middle_name , first_name , last_name , date_first_registered ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_first_registered ASC ] Output [ middle_name , first_name , last_name , date_first_registered ]",
        "cte": "WITH Scan_1 AS ( SELECT middle_name, first_name, last_name, date_first_registered FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 middle_name, first_name, last_name, date_first_registered FROM Scan_1 ORDER BY date_first_registered ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_first_registered ASC",
        "qd": "#1 = Scan the table Students and retrieve the middle name, first name, last name, and registration date of all students ; #2 = Sort the records from #1 based on the registration date in ascending order, select the first record, and identify the first student to register with their first name, middle name, and last name."
    },
    {
        "id": "e7e55a8fa3c545c49218fac804bb17a8f183588046d59a33f56a1e69d025ff83",
        "question": "Who is the earliest graduate of the school? List the first name, middle name and last name.",
        "query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_left ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ middle_name , date_left , first_name , last_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_left ASC ] Output [ middle_name , date_left , first_name , last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT middle_name, date_left, first_name, last_name FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 middle_name, date_left, first_name, last_name FROM Scan_1 ORDER BY date_left ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_left ASC",
        "qd": "#1 = Scan the table Students and retrieve the middle name, date left, first name, and last name of all students ; #2 = Sort the records from #1 based on the date left in ascending order, select the first record, and retrieve the middle name, date left, first name, and last name of the earliest graduate of the school."
    },
    {
        "id": "9eb49aca2584d05d0366be17ba34ccfb07f238dffed751db48a4e86346eb6789",
        "question": "What is the first, middle, and last name of the earliest school graduate?",
        "query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_left ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ middle_name , date_left , first_name , last_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_left ASC ] Output [ middle_name , date_left , first_name , last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT middle_name, date_left, first_name, last_name FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 middle_name, date_left, first_name, last_name FROM Scan_1 ORDER BY date_left ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_left ASC",
        "qd": "#1 = Scan the table Students and retrieve the middle name, date left, first name, and last name of all students ; #2 = Sort the records from #1 based on the date left in ascending order, select the first record, and retrieve the middle name, date left, first name, and last name of the earliest school graduate"
    },
    {
        "id": "621f50d37306c6e356a4de3df6e3793856ee7f9d9ab9b053e9890cfa5db56c89",
        "question": "Whose permanent address is different from his or her current address? List his or her first name.",
        "query": "SELECT first_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) WHERE current_address_id ! = permanent_address_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ current_address_id <> permanent_address_id ] Output [ permanent_address_id , current_address_id , first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT permanent_address_id, current_address_id, first_name FROM student_transcripts_tracking.Students WHERE current_address_id <> permanent_address_id ) SELECT * FROM Scan_1",
        "clean_query": "SELECT first_name FROM student_transcripts_tracking.Students  WHERE current_address_id ! = permanent_address_id",
        "qd": "#1 = Scan the table Students and retrieve the permanent address IDs, current address IDs, and first names of all students whose permanent address is different from their current address."
    },
    {
        "id": "73c8b1da8ff7be1c1d0af01653242378ba5b079a8bde31662382b9a99834ae05",
        "question": "What is the first name of the student whose permanent address is different from his or her current one?",
        "query": "SELECT first_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) WHERE current_address_id ! = permanent_address_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ current_address_id <> permanent_address_id ] Output [ permanent_address_id , current_address_id , first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT permanent_address_id, current_address_id, first_name FROM student_transcripts_tracking.Students WHERE current_address_id <> permanent_address_id ) SELECT * FROM Scan_1",
        "clean_query": "SELECT first_name FROM student_transcripts_tracking.Students  WHERE current_address_id ! = permanent_address_id",
        "qd": "#1 = Scan the table Students and retrieve the permanent address ID, current address ID, and first name of all students whose permanent address is different from their current address."
    },
    {
        "id": "5a1add434252fa8ef88afe242d0e6f6da6ebe21eab7ebb70940db2d4060acb6e",
        "question": "Which address holds the most number of students currently? List the address id and all lines.",
        "query": "SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Students AS T2 WITH (FORCESCAN) ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] GroupBy [ current_address_id ] Output [ countstar AS Count_Star , current_address_id ] ; #3 = Scan Table [ Addresses ] Output [ address_id , line_2 , line_1 ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.current_address_id = #3.address_id ] Output [ #2.Count_Star , #3.line_2 , #3.address_id , #3.line_1 ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ address_id , line_2 , Count_Star , line_1 ]",
        "cte": "WITH Scan_1 AS ( SELECT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, current_address_id FROM Scan_1 GROUP BY current_address_id ), Scan_3 AS ( SELECT address_id, line_2, line_1 FROM student_transcripts_tracking.Addresses ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.line_2, Scan_3.address_id, Scan_3.line_1 FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.current_address_id = Scan_3.address_id ), TopSort_5 AS ( SELECT TOP 1 address_id, line_2, Count_Star, line_1 FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1  JOIN student_transcripts_tracking.Students AS T2  ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Students and retrieve the current address IDs of all students ; #2 = Group #1 by current address ID and aggregate the count of records per current address ID to find the number of students in each address ; #3 = Scan the table Addresses and retrieve the address ID and address lines ; #4 = Join #2 and #3 based on the matching current address ID and retrieve the count of students and address lines ; #5 = Sort the records from #4 based on the count of students in descending order, select the first record, and identify the address ID and lines of the address that holds the most number of students currently"
    },
    {
        "id": "c61132133c0884369b3656e64742fefba5bafb269a5d2e9604eed2bd4d7792f7",
        "question": "What is the id, line 1, and line 2 of the address with the most students?",
        "query": "SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Students AS T2 WITH (FORCESCAN) ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] GroupBy [ current_address_id ] Output [ countstar AS Count_Star , current_address_id ] ; #3 = Scan Table [ Addresses ] Output [ address_id , line_2 , line_1 ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.current_address_id = #3.address_id ] Output [ #2.Count_Star , #3.line_2 , #3.address_id , #3.line_1 ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ address_id , line_2 , Count_Star , line_1 ]",
        "cte": "WITH Scan_1 AS ( SELECT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, current_address_id FROM Scan_1 GROUP BY current_address_id ), Scan_3 AS ( SELECT address_id, line_2, line_1 FROM student_transcripts_tracking.Addresses ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.line_2, Scan_3.address_id, Scan_3.line_1 FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.current_address_id = Scan_3.address_id ), TopSort_5 AS ( SELECT TOP 1 address_id, line_2, Count_Star, line_1 FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1  JOIN student_transcripts_tracking.Students AS T2  ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Students and retrieve the current address IDs of all students ; #2 = Group #1 by current address ID and aggregate the count of students per address ; #3 = Scan the table Addresses and retrieve the address ID, line 2, and line 1 of all addresses ; #4 = Join #2 and #3 based on the matching current address ID and retrieve the count of students, line 2, address ID, and line 1 ; #5 = Sort the records from #4 based on the count of students in descending order, select the first record, and identify the address ID, line 2, and line 1 of the address with the most students."
    },
    {
        "id": "8671937b8fca85e18cd7d84da33377f4105cc302be5b0d30e884478c99e61450",
        "question": "On average, when were the transcripts printed?",
        "query": "SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = Aggregate [ #1 ] Output [ AVG(transcript_date) AS Avg_transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT AVG(transcript_date) AS Avg_transcript_date FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts",
        "qd": "#1 = Scan the table Transcripts and retrieve the transcript dates of all transcripts ; #2 = Aggregate the average transcript date from #1 to find when the transcripts were printed on average"
    },
    {
        "id": "c3597c57608e6709f8aa5590f37792720cf006026f950415914855999b49a2dc",
        "question": "What is the average transcript date?",
        "query": "SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = Aggregate [ #1 ] Output [ AVG(transcript_date) AS Avg_transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT AVG(transcript_date) AS Avg_transcript_date FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts",
        "qd": "#1 = Scan the table Transcripts and retrieve all the transcript dates ; #2 = Calculate the average of all transcript dates to find the average transcript date"
    },
    {
        "id": "d381b46013f0591ed9f55bae1c24b89d012b6cca147b787e06954fb2f9f1d091",
        "question": "When is the first transcript released? List the date and details.",
        "query": "SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ other_details , transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date ASC ] Output [ other_details , transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT other_details, transcript_date FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 other_details, transcript_date FROM Scan_1 ORDER BY transcript_date ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date ASC",
        "qd": "#1 = Scan the table Transcripts and retrieve the details and transcript dates of all transcripts ; #2 = Sort the records from #1 based on the transcript date in ascending order, select the first record, and retrieve the details and transcript date of the first transcript released."
    },
    {
        "id": "f120ceebe63b91cf7d8ec2153a05da63c2f6a2cb3b1402da0f1772c73a21307e",
        "question": "What is the earliest date of a transcript release, and what details can you tell me?",
        "query": "SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ other_details , transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date ASC ] Output [ other_details , transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT other_details, transcript_date FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 other_details, transcript_date FROM Scan_1 ORDER BY transcript_date ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date ASC",
        "qd": "#1 = Scan the table Transcripts and retrieve all the transcript details and release dates ; #2 = Sort the records from #1 based on the transcript release date in ascending order, select the first record, and retrieve the transcript details and earliest release date"
    },
    {
        "id": "4d616fdb35747a6d6392a417df2d25850f46e59e5970a943e380befec0675e3a",
        "question": "How many transcripts are released?",
        "query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts",
        "qd": "#1 = Scan the table Transcripts and add a constant value of 1 for each record ; #2 = Aggregate the number of records in #1 and retrieve the count as the number of transcripts released"
    },
    {
        "id": "523fbe361abc1311f6b3f07e9edf236519a70dbd66130b8dce011bcb8d76bd5e",
        "question": "How many transcripts are listed?",
        "query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts",
        "qd": "#1 = Scan the table Transcripts and retrieve the value 1 for each transcript ; #2 = Aggregate the number of records in #1 and retrieve the count of transcripts listed"
    },
    {
        "id": "ce82a2bc66cd458fd38b1b6325e2c841b5eb71ebe89e613ef8d2356e65d99a3b",
        "question": "What is the last transcript release date?",
        "query": "SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date DESC ] Output [ transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 transcript_date FROM Scan_1 ORDER BY transcript_date DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date DESC",
        "qd": "#1 = Scan the table Transcripts and retrieve all the transcript release dates ; #2 = Sort the records from #1 based on the transcript release date in descending order, select the first record, and retrieve the last transcript release date"
    },
    {
        "id": "e3cd6248e6e7f1dba56b3d1440d38872d8d0c60b3c205be143bf0e682bee3268",
        "question": "When was the last transcript released?",
        "query": "SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date DESC ] Output [ transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 transcript_date FROM Scan_1 ORDER BY transcript_date DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date DESC",
        "qd": "#1 = Scan the table Transcripts and retrieve the transcript dates of all transcripts ; #2 = Sort the records from #1 based on the transcript date in descending order, select the first record, and identify the date of the last transcript released"
    },
    {
        "id": "73eb7b4c3f37bf11cedc8f329393c4d8a8e8cfe20fd3345a5a445897b86fa329",
        "question": "How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.",
        "query": "SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents WITH (FORCESCAN) GROUP BY student_course_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ student_course_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_course_id ] Output [ student_course_id , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ student_course_id , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT student_course_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT student_course_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_course_id ), TopSort_3 AS ( SELECT TOP 1 student_course_id, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents  GROUP BY student_course_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Transcript_Contents and retrieve the student course IDs of all course enrollment results recorded in the transcripts ; #2 = Group #1 by student course ID and aggregate the count of occurrences per student course ID to find the maximum number of times a course enrollment result can show in different transcripts ; #3 = Sort the records from #2 based on the count of occurrences in descending order, select the first record, and retrieve the student course ID and the count of occurrences to find the maximum number of times a course enrollment result can show in different transcripts and display the corresponding course enrollment ID."
    },
    {
        "id": "3a3c210329f066c16ae725a134bcf591f4cb70fa224a580ef0a2c17a0f9f0c2a",
        "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?",
        "query": "SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents WITH (FORCESCAN) GROUP BY student_course_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ student_course_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_course_id ] Output [ student_course_id , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ student_course_id , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT student_course_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT student_course_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_course_id ), TopSort_3 AS ( SELECT TOP 1 student_course_id, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents  GROUP BY student_course_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Transcript_Contents and retrieve all the student_course_ids ; #2 = Group #1 by student_course_id and aggregate the count of occurrences per student_course_id to find the maximum number of times a course shows up in different transcripts ; #3 = Sort the records from #2 based on the count of occurrences in descending order, select the first record, and retrieve the student_course_id and count of occurrences as the maximum number of times a course shows up in different transcripts and its enrollment id."
    },
    {
        "id": "bd844dd1bbe595ee1aa0d5da9010030323680dc2b4a5b47d15a2dd2bd4796d8b",
        "question": "Show the date of the transcript which shows the least number of results, also list the id.",
        "query": "select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) join student_transcripts_tracking.transcripts as t2 WITH (FORCESCAN) ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #2 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #3 = Aggregate [ #2 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.transcript_id = #1.transcript_id ] Output [ #1.transcript_date , Count_Star , #3.transcript_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ transcript_id , transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_id, transcript_date FROM student_transcripts_tracking.Transcripts ), Scan_2 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star, transcript_id FROM Scan_2 GROUP BY transcript_id ), Join_4 AS ( SELECT Scan_1.transcript_date, Count_Star, Aggregate_3.transcript_id FROM Scan_1 JOIN Aggregate_3 ON Aggregate_3.transcript_id = Scan_1.transcript_id ), TopSort_5 AS ( SELECT TOP 1 WITH TIES transcript_id, transcript_date FROM Join_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  join student_transcripts_tracking.transcripts as t2  ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc",
        "qd": "#1 = Scan the table Transcripts and retrieve the transcript IDs and dates of all transcripts ; #2 = Scan the table Transcript_Contents and retrieve all transcript IDs ; #3 = Group and aggregate the count of records per transcript ID to find the number of results for each transcript ; #4 = Join #1 and #3 based on the matching transcript IDs and retrieve the transcript dates, count of results, and transcript IDs ; #5 = Sort the records from #4 based on the count of results in ascending order, select the first record with ties, and retrieve the transcript ID and date of the transcript with the least number of results"
    },
    {
        "id": "b4b4ae10d25e46d7369817827ed4141e9c701e7046aefa27d6f88b73baff0a32",
        "question": "What is the date and id of the transcript with the least number of results?",
        "query": "select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) join student_transcripts_tracking.transcripts as t2 WITH (FORCESCAN) ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #2 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #3 = Aggregate [ #2 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.transcript_id = #1.transcript_id ] Output [ #1.transcript_date , Count_Star , #3.transcript_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ transcript_id , transcript_date ]",
        "cte": "WITH Scan_1 AS ( SELECT transcript_id, transcript_date FROM student_transcripts_tracking.Transcripts ), Scan_2 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star, transcript_id FROM Scan_2 GROUP BY transcript_id ), Join_4 AS ( SELECT Scan_1.transcript_date, Count_Star, Aggregate_3.transcript_id FROM Scan_1 JOIN Aggregate_3 ON Aggregate_3.transcript_id = Scan_1.transcript_id ), TopSort_5 AS ( SELECT TOP 1 WITH TIES transcript_id, transcript_date FROM Join_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  join student_transcripts_tracking.transcripts as t2  ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc",
        "qd": "#1 = Scan the table Transcripts and retrieve the transcript ID and date of all transcripts ; #2 = Scan the table Transcript_Contents and retrieve the transcript IDs ; #3 = Group #2 by transcript ID and aggregate the count of records per transcript ID ; #4 = Join #1 and #3 based on the matching transcript IDs and retrieve the transcript date, count of records, and transcript ID ; #5 = Sort the records from #4 based on the count of records in ascending order and select the first record with the least number of results, retrieve the transcript ID and date"
    },
    {
        "id": "ab348f161bbbba695ed592adb3a2971ae4a97acac0250ed0130c2c730c9403f5",
        "question": "Find the semester when both Master students and Bachelor students got enrolled in.",
        "query": "SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Master' ] Output [ degree_summary_name , degree_program_id ] ; #2 = Scan Table [ Student_Enrolment ] Output [ degree_program_id , semester_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Distinct [ true ] Output [ #2.semester_id ] ; #4 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_summary_name , degree_program_id ] ; #5 = Scan Table [ Student_Enrolment ] Output [ degree_program_id , semester_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.degree_program_id = #5.degree_program_id ] Distinct [ true ] Output [ #5.semester_id ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.semester_id = #6.semester_id ] Distinct [ true ] Output [ #3.semester_id ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Master' ), Scan_2 AS ( SELECT degree_program_id, semester_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT DISTINCT Scan_2.semester_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_5 AS ( SELECT degree_program_id, semester_id FROM student_transcripts_tracking.Student_Enrolment ), Join_6 AS ( SELECT DISTINCT Scan_5.semester_id FROM Scan_4 JOIN Scan_5 ON Scan_4.degree_program_id = Scan_5.degree_program_id ), Join_7 AS ( SELECT DISTINCT Join_3.semester_id FROM Join_3 JOIN Join_6 ON Join_3.semester_id = Join_6.semester_id ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor'",
        "qd": "#1 = Scan the table Degree_Programs to find the degree programs with the name 'Master' and retrieve the degree program IDs ; #2 = Scan the table Student_Enrolment to retrieve the degree program IDs and semester IDs of all enrolments ; #3 = Join #1 and #2 based on the matching degree program IDs and retrieve the semester IDs without duplicates for Master students ; #4 = Scan the table Degree_Programs to find the degree programs with the name 'Bachelor' and retrieve the degree program IDs ; #5 = Scan the table Student_Enrolment to retrieve the degree program IDs and semester IDs of all enrolments ; #6 = Join #4 and #5 based on the matching degree program IDs and retrieve the semester IDs without duplicates for Bachelor students ; #7 = Join #3 and #6 based on the matching semester IDs and retrieve the semester IDs when both Master students and Bachelor students got enrolled in"
    },
    {
        "id": "51f9a9d3a8314bf9ecb1b1a87c9575af07e01bf2c3ca056692feb0849a94c29f",
        "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?",
        "query": "SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Master' ] Output [ degree_summary_name , degree_program_id ] ; #2 = Scan Table [ Student_Enrolment ] Output [ degree_program_id , semester_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Distinct [ true ] Output [ #2.semester_id ] ; #4 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_summary_name , degree_program_id ] ; #5 = Scan Table [ Student_Enrolment ] Output [ degree_program_id , semester_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.degree_program_id = #5.degree_program_id ] Distinct [ true ] Output [ #5.semester_id ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.semester_id = #6.semester_id ] Distinct [ true ] Output [ #3.semester_id ]",
        "cte": "WITH Scan_1 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Master' ), Scan_2 AS ( SELECT degree_program_id, semester_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT DISTINCT Scan_2.semester_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT degree_summary_name, degree_program_id FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_5 AS ( SELECT degree_program_id, semester_id FROM student_transcripts_tracking.Student_Enrolment ), Join_6 AS ( SELECT DISTINCT Scan_5.semester_id FROM Scan_4 JOIN Scan_5 ON Scan_4.degree_program_id = Scan_5.degree_program_id ), Join_7 AS ( SELECT DISTINCT Join_3.semester_id FROM Join_3 JOIN Join_6 ON Join_3.semester_id = Join_6.semester_id ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor'",
        "qd": "#1 = Scan the table Degree_Programs and retrieve the degree program IDs for all Masters programs ; #2 = Scan the table Student_Enrolment and retrieve the degree program IDs and semester IDs for all enrollments ; #3 = Join #1 and #2 based on the matching degree program IDs and retrieve the semester IDs without duplicates ; #4 = Scan the table Degree_Programs and retrieve the degree program IDs for all Bachelors programs ; #5 = Scan the table Student_Enrolment and retrieve the degree program IDs and semester IDs for all enrollments ; #6 = Join #4 and #5 based on the matching degree program IDs and retrieve the semester IDs without duplicates ; #7 = Join #3 and #6 based on the matching semester IDs and retrieve the semester IDs without duplicates ;  ; "
    },
    {
        "id": "6269b3c79bb884695b183d76877a2391ef7ff843fd60ae69ef86d1a04074438f",
        "question": "How many different addresses do the students currently live?",
        "query": "SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Distinct [ true ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students",
        "qd": "#1 = Scan the table Students and retrieve all the current address IDs without duplicates ; #2 = Aggregate the number of different current addresses in #1"
    },
    {
        "id": "94c692894c8dd9304581db7b6d26ff3423973cb28e3474fb0a4dc1d552bbfe43",
        "question": "What are the different addresses that have students living there?",
        "query": "SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Distinct [ true ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students",
        "qd": "#1 = Scan the table Students and retrieve the distinct current address IDs ; #2 = Aggregate the count of distinct current address IDs to find the number of different addresses that have students living there."
    },
    {
        "id": "57ea74cc58d20b8ed0db92d1be3dd10e1fe48807fd6ec9ac1060e4fd1c7553be",
        "question": "List all the student details in reversed lexicographical order.",
        "query": "SELECT other_student_details FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY other_student_details DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ other_student_details ] ; #2 = Sort [ #1 ] OrderBy [ other_student_details DESC ] Output [ other_student_details ]",
        "cte": "WITH Scan_1 AS ( SELECT other_student_details FROM student_transcripts_tracking.Students ) SELECT other_student_details FROM Scan_1 ORDER BY other_student_details DESC",
        "clean_query": "SELECT other_student_details FROM student_transcripts_tracking.Students  ORDER BY other_student_details DESC",
        "qd": "#1 = Scan the table Students and retrieve all the student details ; #2 = Sort the records from #1 based on the student details in reversed lexicographical order and retrieve the student details"
    },
    {
        "id": "dbbfb1513b82391695d42babdf470c3cde68b3f2eb3e972fc216e917ea6f1c48",
        "question": "What other details can you tell me about students in reverse alphabetical order?",
        "query": "SELECT other_student_details FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY other_student_details DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ other_student_details ] ; #2 = Sort [ #1 ] OrderBy [ other_student_details DESC ] Output [ other_student_details ]",
        "cte": "WITH Scan_1 AS ( SELECT other_student_details FROM student_transcripts_tracking.Students ) SELECT other_student_details FROM Scan_1 ORDER BY other_student_details DESC",
        "clean_query": "SELECT other_student_details FROM student_transcripts_tracking.Students  ORDER BY other_student_details DESC",
        "qd": "#1 = Scan the table Students and retrieve the other details of all students ; #2 = Sort the records from #1 based on the other student details in reverse alphabetical order and retrieve the other student details"
    },
    {
        "id": "b969e259f189aeb41d02cf9f2331af01a76604299a70247de3c91c3b863f3aa9",
        "question": "Describe the section h.",
        "query": "SELECT section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) WHERE section_name = 'h' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Predicate [ section_name = 'h' ] Output [ section_description , section_name ]",
        "cte": "WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections WHERE section_name = 'h' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT section_description FROM student_transcripts_tracking.Sections  WHERE section_name = 'h'",
        "qd": "#1 = Scan the table Sections and retrieve the description and name of the section with the name 'h'."
    },
    {
        "id": "e8521737692fde7573e1b72b45538c2b1f7ff3b663744abb8012787667193b91",
        "question": "What is the description for the section named h?",
        "query": "SELECT section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) WHERE section_name = 'h' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Sections ] Predicate [ section_name = 'h' ] Output [ section_description , section_name ]",
        "cte": "WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections WHERE section_name = 'h' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT section_description FROM student_transcripts_tracking.Sections  WHERE section_name = 'h'",
        "qd": "#1 = Scan the table Sections and retrieve the description and name of the section with the name 'h'"
    },
    {
        "id": "a6c5ac5f34c3767df7ecfa7d8e8fa26d6aa081e9ae9a06b31887b21badbbe39f",
        "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .",
        "query": "select t1.first_name FROM student_transcripts_tracking.students AS t1 WITH (FORCESCAN) join student_transcripts_tracking.addresses as t2 WITH (FORCESCAN) on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ address_id , country ] ; #2 = Scan Table [ Students ] Output [ cell_mobile_number , permanent_address_id , first_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.permanent_address_id = #1.address_id ] Output [ #2.first_name , #2.cell_mobile_number , #1.country ] ; #4 = Filter [ #3 ] Predicate [ country = 'haiti' OR cell_mobile_number = '09700166582' ] Output [ first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT address_id, country FROM student_transcripts_tracking.Addresses ), Scan_2 AS ( SELECT cell_mobile_number, permanent_address_id, first_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT Scan_2.first_name, Scan_2.cell_mobile_number, Scan_1.country FROM Scan_1 JOIN Scan_2 ON Scan_2.permanent_address_id = Scan_1.address_id ), Filter_4 AS ( SELECT first_name FROM Join_3 WHERE country = 'haiti' OR cell_mobile_number = '09700166582' ) SELECT * FROM Filter_4",
        "clean_query": "select t1.first_name FROM student_transcripts_tracking.students AS t1  join student_transcripts_tracking.addresses as t2  on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582'",
        "qd": "#1 = Scan the table Addresses and retrieve the address IDs and countries of all addresses ; #2 = Scan the table Students and retrieve the cell/mobile numbers, permanent address IDs, and first names of all students ; #3 = Join #1 and #2 based on the matching permanent address IDs and retrieve the first names and cell/mobile numbers ; #4 = Filter from #3 all the records with the country 'Haiti' or cell/mobile number '09700166582' and retrieve the first names"
    },
    {
        "id": "d405cd0b531fc7126168977471c87d89140774601d8b1779ff31df5e3fee25af",
        "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?",
        "query": "select t1.first_name FROM student_transcripts_tracking.students AS t1 WITH (FORCESCAN) join student_transcripts_tracking.addresses as t2 WITH (FORCESCAN) on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ address_id , country ] ; #2 = Scan Table [ Students ] Output [ cell_mobile_number , permanent_address_id , first_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.permanent_address_id = #1.address_id ] Output [ #2.first_name , #2.cell_mobile_number , #1.country ] ; #4 = Filter [ #3 ] Predicate [ country = 'haiti' OR cell_mobile_number = '09700166582' ] Output [ first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT address_id, country FROM student_transcripts_tracking.Addresses ), Scan_2 AS ( SELECT cell_mobile_number, permanent_address_id, first_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT Scan_2.first_name, Scan_2.cell_mobile_number, Scan_1.country FROM Scan_1 JOIN Scan_2 ON Scan_2.permanent_address_id = Scan_1.address_id ), Filter_4 AS ( SELECT first_name FROM Join_3 WHERE country = 'haiti' OR cell_mobile_number = '09700166582' ) SELECT * FROM Filter_4",
        "clean_query": "select t1.first_name FROM student_transcripts_tracking.students AS t1  join student_transcripts_tracking.addresses as t2  on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582'",
        "qd": "#1 = Scan the table Addresses and retrieve the address IDs and countries of all addresses ; #2 = Scan the table Students and retrieve the cell phone numbers, permanent address IDs, and first names of all students ; #3 = Join #1 and #2 based on the matching permanent address IDs and retrieve the first names and cell phone numbers ; #4 = Filter from #3 all the records where the country is 'Haiti' or the cell phone number is '09700166582' and retrieve the first names"
    },
    {
        "id": "83393630216ab26b6fab91f2a2babda82dc85c460b21671995a86dfb3b40b45c",
        "question": "List the title of all cartoons in alphabetical order.",
        "query": "SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY title OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Title ] ; #2 = Sort [ #1 ] OrderBy [ Title ASC ] Output [ Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Title FROM tvshow.Cartoon ) SELECT Title FROM Scan_1 ORDER BY Title ASC",
        "clean_query": "SELECT Title FROM tvshow.Cartoon  ORDER BY title",
        "qd": "#1 = Scan the table Cartoon and retrieve the titles of all cartoons ; #2 = Sort the records from #1 based on the title in alphabetical order and retrieve the titles"
    },
    {
        "id": "a43b9140724231649b4ddbab7229b1aa922a38418117b56994c953b9d5eaa96c",
        "question": "What are the titles of the cartoons sorted alphabetically?",
        "query": "SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY title OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Title ] ; #2 = Sort [ #1 ] OrderBy [ Title ASC ] Output [ Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Title FROM tvshow.Cartoon ) SELECT Title FROM Scan_1 ORDER BY Title ASC",
        "clean_query": "SELECT Title FROM tvshow.Cartoon  ORDER BY title",
        "qd": "#1 = Scan the table Cartoon and retrieve the titles of all cartoons. ; #2 = Sort the records from #1 based on the title in ascending order and retrieve the titles of the cartoons."
    },
    {
        "id": "dbbbe82c51d0aeb8bf96cdb30d579d6edc0ac34004b3f04fcea2e9b6f8fdb3c1",
        "question": "List all cartoon directed by \"Ben Jones\".",
        "query": "SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Title FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones'",
        "qd": "#1 = Scan the table Cartoon and retrieve all the cartoons directed by \"Ben Jones\" and their titles."
    },
    {
        "id": "bc01be7fce4867f664d6814ae240bfc097023a0d8bcc6196449757b046ef01a3",
        "question": "What are the names of all cartoons directed by Ben Jones?",
        "query": "SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Title FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones'",
        "qd": "#1 = Scan the table Cartoon and retrieve the titles of all cartoons directed by Ben Jones."
    },
    {
        "id": "916a509f0948cff8af77cf3a8a8905ca4e5a6dafdc6ddb386cc27f529e15253e",
        "question": "How many cartoons were written by \"Joseph Kuhr\"?",
        "query": "SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Written_by = 'Joseph Kuhr'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Joseph Kuhr' ] Output [ Written_by ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Written_by FROM tvshow.Cartoon WHERE Written_by = 'Joseph Kuhr' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon  WHERE Written_by = 'Joseph Kuhr'",
        "qd": "#1 = Scan the table Cartoon and retrieve all the cartoons that were written by \"Joseph Kuhr\" ; #2 = Aggregate the count of records in #1 to find how many cartoons were written by \"Joseph Kuhr\""
    },
    {
        "id": "4fc046eaa05a69a8810508b57112267cd85a6423220b08115f978f1ece9484c9",
        "question": "What is the number of cartoones written by Joseph Kuhr?",
        "query": "SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Written_by = 'Joseph Kuhr'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Joseph Kuhr' ] Output [ Written_by ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Written_by FROM tvshow.Cartoon WHERE Written_by = 'Joseph Kuhr' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon  WHERE Written_by = 'Joseph Kuhr'",
        "qd": "#1 = Scan the table Cartoon and retrieve the records where the cartoon is written by Joseph Kuhr ; #2 = Aggregate the number of records from #1 to find the count of cartoons written by Joseph Kuhr"
    },
    {
        "id": "7a5f7faeae28debe426151c8e824472857dbcfafd49de540e5824d750266034f",
        "question": "list all cartoon titles and their directors ordered by their air date",
        "query": "SELECT title , Directed_by FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY Original_air_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Directed_by , Original_air_date , Title ] ; #2 = Sort [ #1 ] OrderBy [ Original_air_date ASC ] Output [ Directed_by , Original_air_date , Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Original_air_date, Title FROM tvshow.Cartoon ) SELECT Directed_by, Original_air_date, Title FROM Scan_1 ORDER BY Original_air_date ASC",
        "clean_query": "SELECT title , Directed_by FROM tvshow.Cartoon  ORDER BY Original_air_date",
        "qd": "#1 = Scan the table Cartoon and retrieve the titles and directors of all cartoons ; #2 = Sort the records from #1 based on the air date in ascending order and retrieve the directors and titles of the cartoons"
    },
    {
        "id": "fb9cbfdceb6a3362120b75015476a3bdc879639245debb86984e0edc8b39b35e",
        "question": "What is the name and directors of all the cartoons that are ordered by air date?",
        "query": "SELECT title , Directed_by FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY Original_air_date OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Directed_by , Original_air_date , Title ] ; #2 = Sort [ #1 ] OrderBy [ Original_air_date ASC ] Output [ Directed_by , Original_air_date , Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Original_air_date, Title FROM tvshow.Cartoon ) SELECT Directed_by, Original_air_date, Title FROM Scan_1 ORDER BY Original_air_date ASC",
        "clean_query": "SELECT title , Directed_by FROM tvshow.Cartoon  ORDER BY Original_air_date",
        "qd": "#1 = Scan the table Cartoon and retrieve the directors, original air dates, and titles of all the cartoons ; #2 = Sort the records from #1 based on the original air date in ascending order and retrieve the directors, original air dates, and titles"
    },
    {
        "id": "8c22247b347d4e3a016d6cf1c8b13a1bf4dc34f953f590d860f9f4901eaf98fd",
        "question": "List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\".",
        "query": "SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ] Output [ Directed_by , Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Title FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'",
        "qd": "#1 = Scan the table Cartoon to find all the cartoons directed by either \"Ben Jones\" or \"Brandon Vietti\" and retrieve their titles."
    },
    {
        "id": "845de45b965c3b3970089c390863ec33e835ecd3505b2b6734403f82f9483f47",
        "question": "What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?",
        "query": "SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ] Output [ Directed_by , Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Title FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'",
        "qd": "#1 = Scan the table Cartoon and retrieve the titles of all cartoons directed by Ben Jones or Brandon Vietti."
    },
    {
        "id": "da8cd4bbfc74b3388a037e8ca179f7adc6b22bbe197285d40fb33fa0f18b6fb2",
        "question": "Which country has the most of TV Channels? List the country and number of TV Channels it has.",
        "query": "SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY Country ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Country , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), TopSort_3 AS ( SELECT TOP 1 Country, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY Country ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table TV_Channel and retrieve the country of all TV channels ; #2 = Group #1 by country and aggregate the count of TV channels per country ; #3 = Sort the records from #2 based on the count of TV channels in descending order, select the first record, and identify the country with the most TV channels and the number of TV channels it has."
    },
    {
        "id": "95a64f969855e9817719f0ec18278eba85b5e86a4c520343b59cce05a0f425e1",
        "question": "What is the country with the most number of TV Channels and how many does it have?",
        "query": "SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY Country ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ countstar AS Count_Star , Country ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Country , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Country FROM Scan_1 GROUP BY Country ), TopSort_3 AS ( SELECT TOP 1 Country, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY Country ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table TV_Channel and retrieve the countries of all the TV Channels. ; #2 = Group #1 by country and aggregate the count of TV Channels per country. ; #3 = Sort the records from #2 based on the count of TV Channels in descending order, select the first record, and identify the country with the most number of TV Channels and its count of TV Channels."
    },
    {
        "id": "48aba4e97ed55fd23a7b7f378e185c1043acaaacc7cc04191774930eac1a2559",
        "question": "List the number of different series names and contents in the TV Channel table.",
        "query": "SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel WITH (FORCESCAN)  ",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ series_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT series_name) AS Count_Dist_series_name ] ; #3 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Content ] ; #4 = Aggregate [ #3 ] Output [ COUNT(DISTINCT Content) AS Count_Dist_Content ] ; #5 = Join [ #2 , #4 ] Output [ #2.Count_Dist_series_name , #4.Count_Dist_Content ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT series_name FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(DISTINCT series_name) AS Count_Dist_series_name FROM Scan_1 ), Scan_3 AS ( SELECT DISTINCT Content FROM tvshow.TV_Channel ), Aggregate_4 AS ( SELECT COUNT(DISTINCT Content) AS Count_Dist_Content FROM Scan_3 ), Join_5 AS ( SELECT Aggregate_2.Count_Dist_series_name, Aggregate_4.Count_Dist_Content FROM Aggregate_2 CROSS JOIN Aggregate_4 ) SELECT * FROM Join_5",
        "clean_query": "SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel",
        "qd": "#1 = Scan the table TV_Channel and retrieve all the distinct series names ; #2 = Aggregate the number of distinct series names to find the count of different series names ; #3 = Scan the table TV_Channel and retrieve all the distinct contents ; #4 = Aggregate the number of distinct contents to find the count of different contents ; #5 = Join the counts of different series names and different contents to list the number of different series names and contents in the TV Channel table."
    },
    {
        "id": "083277424cc72b24b52d3e290a538f559469a57cd0a48ed24160555273b717de",
        "question": "How many different series and contents are listed in the TV Channel table?",
        "query": "SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel WITH (FORCESCAN)  ",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ series_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT series_name) AS Count_Dist_series_name ] ; #3 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Content ] ; #4 = Aggregate [ #3 ] Output [ COUNT(DISTINCT Content) AS Count_Dist_Content ] ; #5 = Join [ #2 , #4 ] Output [ #2.Count_Dist_series_name , #4.Count_Dist_Content ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT series_name FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(DISTINCT series_name) AS Count_Dist_series_name FROM Scan_1 ), Scan_3 AS ( SELECT DISTINCT Content FROM tvshow.TV_Channel ), Aggregate_4 AS ( SELECT COUNT(DISTINCT Content) AS Count_Dist_Content FROM Scan_3 ), Join_5 AS ( SELECT Aggregate_2.Count_Dist_series_name, Aggregate_4.Count_Dist_Content FROM Aggregate_2 CROSS JOIN Aggregate_4 ) SELECT * FROM Join_5",
        "clean_query": "SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel",
        "qd": "#1 = Scan the table TV_Channel and retrieve all distinct series names ; #2 = Count the number of distinct series names from #1 to find the total number of different series listed in the TV Channel table ; #3 = Scan the table TV_Channel and retrieve all distinct content names ; #4 = Count the number of distinct content names from #3 to find the total number of different contents listed in the TV Channel table ; #5 = Join the results of #2 and #4 to retrieve the count of distinct series names and distinct content names"
    },
    {
        "id": "2ecd289b6fa8307e7eaee7f29ec9f80701fd8cde59870b09aa00e307ff7ad0f0",
        "question": "What is the content of TV Channel with serial name \"Sky Radio\"?",
        "query": "SELECT Content FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ series_name , Content ]",
        "cte": "WITH Scan_1 AS ( SELECT series_name, Content FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Content FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the content of the TV Channel with the serial name \"Sky Radio\""
    },
    {
        "id": "d0c1275920417bc3e083a6ffa3814d5dbd98e9791189c35e9c83e797092aa2c2",
        "question": "What is the content of the series Sky Radio?",
        "query": "SELECT Content FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ series_name , Content ]",
        "cte": "WITH Scan_1 AS ( SELECT series_name, Content FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Content FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel to find the series with the name 'Sky Radio' and retrieve the content of the series."
    },
    {
        "id": "c88891737613a4d053e155f72e36d99af9f1e6c24735c66f1070319dacf69229",
        "question": "What is the Package Option of TV Channel with serial name \"Sky Radio\"?",
        "query": "SELECT Package_Option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ series_name , Package_Option ]",
        "cte": "WITH Scan_1 AS ( SELECT series_name, Package_Option FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Package_Option FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the package option of the TV Channel with the serial name \"Sky Radio\"."
    },
    {
        "id": "5cc42c682b5f85b204d17a77cab55f313f590e22ca5b0bdcd9e04dc092cfa830",
        "question": "What are the Package Options of the TV Channels whose series names are Sky Radio?",
        "query": "SELECT Package_Option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ series_name , Package_Option ]",
        "cte": "WITH Scan_1 AS ( SELECT series_name, Package_Option FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Package_Option FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the package options of the TV Channels whose series names are Sky Radio."
    },
    {
        "id": "42c58734b7b2117d31f7c8ae5a8fcb3ee80e9712f2b48d534c7896cc0edf9681",
        "question": "How many TV Channel using language English?",
        "query": "SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE LANGUAGE = 'English'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language = 'English' ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel WHERE Language = 'English' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel  WHERE LANGUAGE = 'English'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the language of all TV channels ; #2 = Group #1 by language and aggregate the count of records to find the number of TV channels using the English language"
    },
    {
        "id": "a44b097d3f024e039d7a10d6b30bd8c5732316000159a260fef28e3ea1b0471c",
        "question": "How many TV Channels use the English language?",
        "query": "SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE LANGUAGE = 'English'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language = 'English' ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel WHERE Language = 'English' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel  WHERE LANGUAGE = 'English'",
        "qd": "#1 = Scan the table TV_Channel to find all TV Channels that use the English language. ; #2 = Aggregate the count of TV Channels from #1 to determine the number of TV Channels that use the English language."
    },
    {
        "id": "37e62b783f69df48aa3ec8d6e649c65292819d95b61eac824d791d914bc56cf0",
        "question": "List the language used least number of TV Channel. List language and number of TV Channel.",
        "query": "SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) ASC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Language , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Language, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE ORDER BY count ( * ) ASC",
        "qd": "#1 = Scan the table TV_Channel and retrieve the language of all TV Channels. ; #2 = Group the records from #1 by language and aggregate the count of TV Channels for each language. ; #3 = Sort the records from #2 based on the count of TV Channels in ascending order, select the first record, and retrieve the language and the count of TV Channels for the language used least number of TV Channels."
    },
    {
        "id": "b4bf1579616f30d8191511ad0538c28b203ba0c36abbed3cf7d6fb7af1590c25",
        "question": "What are the languages used by the least number of TV Channels and how many channels use it?",
        "query": "SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) ASC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Language , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Language, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE ORDER BY count ( * ) ASC",
        "qd": "#1 = Scan the table TV_Channel and retrieve the languages used by all TV Channels. ; #2 = Group the records from #1 by language and aggregate the count of channels per language to find the number of channels using each language. ; #3 = Sort the records from #2 based on the count of channels in ascending order, select the first record, and identify the language used by the least number of TV Channels and the count of channels using it."
    },
    {
        "id": "3020ddb5623bc3540cb9939da3f22bd066bc0e6679425deaf65e0faadfecbd31",
        "question": "List each language and the number of TV Channels using it.",
        "query": "SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE",
        "qd": "#1 = Scan the table TV_Channel and retrieve the languages used by all TV Channels ; #2 = Group the records from #1 by language and aggregate the count of TV Channels using each language. List the language and the count of TV Channels using it."
    },
    {
        "id": "ab86e3891f95a394dbe0237a414d25eb65194fc3e353b440873e332010727c71",
        "question": "For each language, list the number of TV Channels that use it.",
        "query": "SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE",
        "qd": "#1 = Scan the table TV_Channel and retrieve the language used by each TV Channel ; #2 = Group the records from #1 by language and aggregate the count of TV Channels that use each language, and list the language along with the count"
    },
    {
        "id": "312ecca6914f2c420ffd5f838287d2bd37e5588d4adca8b138affdbf865a7f5c",
        "question": "What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.",
        "query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Title = 'The Rise of the Blue Beetle!' ] Output [ Channel , Title ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
        "cte": "WITH Scan_1 AS ( SELECT Channel, Title FROM tvshow.Cartoon WHERE Title = 'The Rise of the Blue Beetle!' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'",
        "qd": "#1 = Scan the table Cartoon to find the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\" ; #2 = Scan the table TV_Channel and retrieve the IDs and series names of all TV channels ; #3 = Join #1 and #2 based on the matching TV Channel ID and retrieve the series names of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\""
    },
    {
        "id": "cbabb0f4acf5348df82086edafeb33e346d67ddb5ecf5f10dedfd657044434a3",
        "question": "What is the series name of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle\"?",
        "query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Title = 'The Rise of the Blue Beetle!' ] Output [ Channel , Title ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
        "cte": "WITH Scan_1 AS ( SELECT Channel, Title FROM tvshow.Cartoon WHERE Title = 'The Rise of the Blue Beetle!' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'",
        "qd": "#1 = Scan the table Cartoon and retrieve the channel and title of the cartoon \"The Rise of the Blue Beetle\" ; #2 = Scan the table TV_Channel and retrieve the IDs and series names of all TV channels ; #3 = Join #1 and #2 based on the matching channel ID and retrieve the series name of the TV channel that shows the cartoon \"The Rise of the Blue Beetle\""
    },
    {
        "id": "67ad6ffc709d3e44ff5f84c9af0a4d2e16a89919d6c6f723b770165a6314e930",
        "question": "List the title of all  Cartoons showed on TV Channel with series name \"Sky Radio\".",
        "query": "SELECT T2.Title FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ Cartoon ] Output [ Channel , Title ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Title ]",
        "cte": "WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Channel, Title FROM tvshow.Cartoon ), Join_3 AS ( SELECT Scan_2.Title FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.Title FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel to find the channel with series name \"Sky Radio\" ; #2 = Scan the table Cartoon and retrieve the channel and title of all cartoons ; #3 = Join #1 and #2 based on the matching channel ID and retrieve the title of all cartoons showed on the TV Channel with series name \"Sky Radio\""
    },
    {
        "id": "cc65ca5065252da2020bf5040dd74af587bed02d69e4980d862e8216f0a767b3",
        "question": "What is the title of all the cartools that are on the TV Channel with the series name \"Sky Radio\"?",
        "query": "SELECT T2.Title FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ Cartoon ] Output [ Channel , Title ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Title ]",
        "cte": "WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Channel, Title FROM tvshow.Cartoon ), Join_3 AS ( SELECT Scan_2.Title FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.Title FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the IDs and series names of the TV Channels with the series name \"Sky Radio\" ; #2 = Scan the table Cartoon and retrieve the Channel and Title of all the Cartoons ; #3 = Join #1 and #2 based on the matching IDs and retrieve the Titles of all the Cartoons on the TV Channel with the series name \"Sky Radio\""
    },
    {
        "id": "4af53503bdc21b5142677ed8df8d47ab8618267cae7b31f47a0953918d948d2a",
        "question": "List the Episode of all TV series sorted by rating.",
        "query": "SELECT Episode FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY rating OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = Sort [ #1 ] OrderBy [ Rating ASC ] Output [ Rating , Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ) SELECT Rating, Episode FROM Scan_1 ORDER BY Rating ASC",
        "clean_query": "SELECT Episode FROM tvshow.TV_series  ORDER BY rating",
        "qd": "#1 = Scan the table TV_series and retrieve the ratings and episodes of all TV series. ; #2 = Sort the records from #1 based on the rating in ascending order and retrieve the ratings and episodes."
    },
    {
        "id": "4b0a022ab96f7a4a516115996f72cb33a909184ac542d5a74415bce23b7c24a8",
        "question": "What are all of the episodes ordered by ratings?",
        "query": "SELECT Episode FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY rating OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = Sort [ #1 ] OrderBy [ Rating ASC ] Output [ Rating , Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ) SELECT Rating, Episode FROM Scan_1 ORDER BY Rating ASC",
        "clean_query": "SELECT Episode FROM tvshow.TV_series  ORDER BY rating",
        "qd": "#1 = Scan the table TV_series and retrieve the ratings and episodes of all episodes ; #2 = Sort the records from #1 based on the rating in ascending order and retrieve the ratings and episodes of all episodes"
    },
    {
        "id": "3b9f0f36bbd855cfee9bb2d646369dc4a8280d0621cd411f99915cdaaac6739a",
        "question": "List top 3 highest Rating  TV series. List the TV series's Episode and Rating.",
        "query": "SELECT TOP 3 Episode , Rating FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY Rating DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Rating DESC ] Output [ Rating , Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ), TopSort_2 AS ( SELECT TOP 3 Rating, Episode FROM Scan_1 ORDER BY Rating DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 3 Episode , Rating FROM tvshow.TV_series  ORDER BY Rating DESC",
        "qd": "#1 = Scan the table TV_series and retrieve the rating and episode of all TV series. ; #2 = Sort the records from #1 based on the rating in descending order, select the top 3 records, and retrieve the rating and episode of the TV series with the highest rating."
    },
    {
        "id": "680ba48e48448ad6bc596a4098af77b8f44684a2676f89ea8faf15035aa7e516",
        "question": "What are 3 most highly rated episodes in the TV series table and what were those ratings?",
        "query": "SELECT TOP 3 Episode , Rating FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY Rating DESC  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Rating DESC ] Output [ Rating , Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ), TopSort_2 AS ( SELECT TOP 3 Rating, Episode FROM Scan_1 ORDER BY Rating DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 3 Episode , Rating FROM tvshow.TV_series  ORDER BY Rating DESC",
        "qd": "#1 = Scan the table TV_series and retrieve the ratings and episodes of all episodes ; #2 = Sort the records from #1 based on the ratings in descending order, select the top 3 records, and retrieve the ratings and episodes of the 3 most highly rated episodes in the TV series table."
    },
    {
        "id": "2e383ebce0c62942782b4210e6a1afa87716bc51cd92d0f5cdb21c1209ef2847",
        "question": "What is minimum and maximum share of TV series?",
        "query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Output [ Share ] ; #2 = Aggregate [ #1 ] Output [ MAX(Share) AS Max_Share , MIN(Share) AS Min_Share ]",
        "cte": "WITH Scan_1 AS ( SELECT Share FROM tvshow.TV_series ), Aggregate_2 AS ( SELECT MAX(Share) AS Max_Share, MIN(Share) AS Min_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series",
        "qd": "#1 = Scan the table TV_series to retrieve the share of all TV series ; #2 = Aggregate the maximum and minimum share values from #1 to find the minimum and maximum share of TV series"
    },
    {
        "id": "0d0142deb8de8f5219172ede8c642c91ddae82dd31bf4d779468a6fd3c876d10",
        "question": "What is the maximum and minimum share for the TV series?",
        "query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Output [ Share ] ; #2 = Aggregate [ #1 ] Output [ MAX(Share) AS Max_Share , MIN(Share) AS Min_Share ]",
        "cte": "WITH Scan_1 AS ( SELECT Share FROM tvshow.TV_series ), Aggregate_2 AS ( SELECT MAX(Share) AS Max_Share, MIN(Share) AS Min_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series",
        "qd": "#1 = Scan the table TV_series and retrieve the share of all TV series ; #2 = Aggregate the maximum and minimum share from #1 and identify the maximum and minimum share for the TV series"
    },
    {
        "id": "3c6d87c1ae7bbff92689d133bff4b619478545457a0610d9ed0e01a8819082c3",
        "question": "What is the air date of TV series with Episode \"A Love of a Lifetime\"?",
        "query": "SELECT Air_Date FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Air_Date , Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT Air_Date, Episode FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Air_Date FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'",
        "qd": "#1 = Scan the table TV_series and retrieve the air date of the TV series with episode \"A Love of a Lifetime\""
    },
    {
        "id": "e76fdac7b3d43bfbb98970b3914f8afa9705c4d943431cbb16e627f0c60ee527",
        "question": "When did the episode \"A Love of a Lifetime\" air?",
        "query": "SELECT Air_Date FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Air_Date , Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT Air_Date, Episode FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Air_Date FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'",
        "qd": "#1 = Scan the table TV_series and retrieve the air date of the episode \"A Love of a Lifetime\""
    },
    {
        "id": "e0000e04d7b1f0b4787cee1a9cad5012af99c9d21b96a02abe5b69467345fa8b",
        "question": "What is Weekly Rank of TV series with Episode \"A Love of a Lifetime\"?",
        "query": "SELECT Weekly_Rank FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Weekly_Rank ]",
        "cte": "WITH Scan_1 AS ( SELECT Episode, Weekly_Rank FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Weekly_Rank FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'",
        "qd": "#1 = Scan the table TV_series and retrieve the Weekly Rank of the TV series with the Episode \"A Love of a Lifetime\""
    },
    {
        "id": "73165e09ea1c7c3e8c2058b4d3ae9211344a042bda319db31c06871c272683e2",
        "question": "What is the weekly rank for the episode \"A Love of a Lifetime\"?",
        "query": "SELECT Weekly_Rank FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Weekly_Rank ]",
        "cte": "WITH Scan_1 AS ( SELECT Episode, Weekly_Rank FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Weekly_Rank FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'",
        "qd": "#1 = Scan the table TV_series and retrieve the weekly rank for the episode \"A Love of a Lifetime\""
    },
    {
        "id": "c8b3f1ae55f0334741eb68f99155ba70466e54b6e14fdf47419475fbf841cada",
        "question": "What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.",
        "query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
        "cte": "WITH Scan_1 AS ( SELECT Episode, Channel FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'",
        "qd": "#1 = Scan the table TV_series and retrieve the channel and episode of the TV series with the episode \"A Love of a Lifetime\" ; #2 = Scan the table TV_Channel and retrieve the IDs and series names of all TV channels ; #3 = Join #1 and #2 based on the matching channel ID and retrieve the series names of the TV channels that aired the TV series \"A Love of a Lifetime\""
    },
    {
        "id": "dce5580fa604cef1b7013efde88ea414c1480828f0c15e0c53b05b4ef6ff025b",
        "question": "What is the name of the series that has the episode \"A Love of a Lifetime\"?",
        "query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
        "cte": "WITH Scan_1 AS ( SELECT Episode, Channel FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'",
        "qd": "#1 = Scan the table TV_series and retrieve the series with the episode \"A Love of a Lifetime\" ; #2 = Scan the table TV_Channel and retrieve the series IDs and names ; #3 = Join #1 and #2 based on the matching channel ID and retrieve the series name of the series with the episode \"A Love of a Lifetime\""
    },
    {
        "id": "e75fca8acdfc313eda670c300d1d3931ee4ab7bc8f3ae5fd929fe9f48b3b1e4e",
        "question": "List the Episode of all  TV series showed on TV Channel with series name \"Sky Radio\".",
        "query": "SELECT T2.Episode FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ TV_series ] Output [ Channel , Episode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Channel, Episode FROM tvshow.TV_series ), Join_3 AS ( SELECT Scan_2.Episode FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.Episode FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel to find the ID and series name of the TV Channel with series name \"Sky Radio\" ; #2 = Scan the table TV_series to retrieve the channel and episode of all TV series ; #3 = Join #1 and #2 based on the matching ID and channel to find the episodes of all TV series shown on the TV Channel with series name \"Sky Radio\""
    },
    {
        "id": "61b6eaccc94d6d2900ca8a1d8163d9c358c6a9d2034e1abc1e0f04df540300a6",
        "question": "What is the episode for the TV series named \"Sky Radio\"?",
        "query": "SELECT T2.Episode FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ TV_series ] Output [ Channel , Episode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Episode ]",
        "cte": "WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Channel, Episode FROM tvshow.TV_series ), Join_3 AS ( SELECT Scan_2.Episode FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.Episode FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the ID and series name of the TV series named \"Sky Radio\" ; #2 = Scan the table TV_series and retrieve the channel and episode of all TV series ; #3 = Join #1 and #2 based on the matching ID and channel, and retrieve the episode for the TV series named \"Sky Radio\""
    },
    {
        "id": "4ab4d8bcc47a07a29ea3496adc3b48879e72fe4cfc5f8a0a2d496c8918645efc",
        "question": "Find the number of cartoons directed by each of the listed directors.",
        "query": "SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon WITH (FORCESCAN) GROUP BY Directed_by OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Directed_by ] ; #2 = Aggregate [ #1 ] GroupBy [ Directed_by ] Output [ Directed_by , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by FROM tvshow.Cartoon ), Aggregate_2 AS ( SELECT Directed_by, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Directed_by ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon  GROUP BY Directed_by",
        "qd": "#1 = Scan the table Cartoon and retrieve the names of all directors ; #2 = Group #1 by director and aggregate the count per director to find the number of cartoons directed by each director"
    },
    {
        "id": "e835c56211f4c9c6c4b47bb293e2ebc043d28551a4456f405a8473f234ffbbfa",
        "question": "How many cartoons did each director create?",
        "query": "SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon WITH (FORCESCAN) GROUP BY Directed_by OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Directed_by ] ; #2 = Aggregate [ #1 ] GroupBy [ Directed_by ] Output [ Directed_by , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by FROM tvshow.Cartoon ), Aggregate_2 AS ( SELECT Directed_by, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Directed_by ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon  GROUP BY Directed_by",
        "qd": "#1 = Scan the table Cartoon and retrieve the names of all directors ; #2 = Group the records from #1 by the director and aggregate the count of cartoons each director created"
    },
    {
        "id": "6cb24d73bd9d6854c0c145accf850e49e98a77696072a3e9f52e58a90d56a1ae",
        "question": "Find the production code and channel of the most recently aired cartoon .",
        "query": "select TOP 1 production_code , channel FROM tvshow.cartoon WITH (FORCESCAN) order by original_air_date desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Original_air_date , Production_code , Channel ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Original_air_date DESC ] Output [ Original_air_date , Production_code , Channel ]",
        "cte": "WITH Scan_1 AS ( SELECT Original_air_date, Production_code, Channel FROM tvshow.Cartoon ), TopSort_2 AS ( SELECT TOP 1 Original_air_date, Production_code, Channel FROM Scan_1 ORDER BY Original_air_date DESC ) SELECT * FROM TopSort_2",
        "clean_query": "select TOP 1 production_code , channel FROM tvshow.cartoon  order by original_air_date desc",
        "qd": "#1 = Scan the table Cartoon and retrieve the original air date, production code, and channel of all cartoons. ; #2 = Sort the records from #1 based on the original air date in descending order, select the first record, and identify the production code and channel of the most recently aired cartoon."
    },
    {
        "id": "bd73120de1d8750d59209a5ddee60a05cb1e802dcf56822cc36df4a5c48897a2",
        "question": "What is the produdction code and channel of the most recent cartoon ?",
        "query": "select TOP 1 production_code , channel FROM tvshow.cartoon WITH (FORCESCAN) order by original_air_date desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Output [ Original_air_date , Production_code , Channel ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Original_air_date DESC ] Output [ Original_air_date , Production_code , Channel ]",
        "cte": "WITH Scan_1 AS ( SELECT Original_air_date, Production_code, Channel FROM tvshow.Cartoon ), TopSort_2 AS ( SELECT TOP 1 Original_air_date, Production_code, Channel FROM Scan_1 ORDER BY Original_air_date DESC ) SELECT * FROM TopSort_2",
        "clean_query": "select TOP 1 production_code , channel FROM tvshow.cartoon  order by original_air_date desc",
        "qd": "#1 = Scan the table Cartoon and retrieve the original air date, production code, and channel for all cartoons. ; #2 = Sort the records from #1 based on the original air date in descending order, select the first record, and retrieve the production code and channel of the most recent cartoon."
    },
    {
        "id": "bf9ddbd285a985059dab1d4b5e14d0f1eb5b056a7d8547bf2194f977af1ee913",
        "question": "Find the package choice and series name of the TV channel that has high definition TV.",
        "query": "SELECT package_option , series_name FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE hight_definition_TV = 'yes' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Hight_definition_TV = 'yes' ] Output [ series_name , Package_Option , Hight_definition_TV ]",
        "cte": "WITH Scan_1 AS ( SELECT series_name, Package_Option, Hight_definition_TV FROM tvshow.TV_Channel WHERE Hight_definition_TV = 'yes' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT package_option , series_name FROM tvshow.TV_Channel  WHERE hight_definition_TV = 'yes'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the series name and package option of the TV channel that has high definition TV."
    },
    {
        "id": "f0e91e76e174c126de5c9c0d6245a9120aaa03ae0ff59b30f94247798be5350f",
        "question": "What are the package options and the name of the series for the TV Channel that supports high definition TV?",
        "query": "SELECT package_option , series_name FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE hight_definition_TV = 'yes' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Hight_definition_TV = 'yes' ] Output [ series_name , Package_Option , Hight_definition_TV ]",
        "cte": "WITH Scan_1 AS ( SELECT series_name, Package_Option, Hight_definition_TV FROM tvshow.TV_Channel WHERE Hight_definition_TV = 'yes' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT package_option , series_name FROM tvshow.TV_Channel  WHERE hight_definition_TV = 'yes'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the series name and package option of the TV Channels that support high definition TV."
    },
    {
        "id": "64753597dc7d6d2a32db6eda3baa31e7ee2d2fb6ecd4b920fe5b970040457805",
        "question": "which countries' tv channels are playing some cartoon written by Todd Casey?",
        "query": "SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_2 AS ( SELECT id, Country FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.Country FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'",
        "qd": "#1 = Scan the table Cartoon and find out which cartoons are written by Todd Casey and retrieve the channels they are aired on ; #2 = Scan the table TV_Channel and retrieve the IDs and countries of all TV channels ; #3 = Join #1 and #2 based on the matching channel ID and retrieve the countries of the TV channels that are playing some cartoon written by Todd Casey"
    },
    {
        "id": "0c75ccfe4d4b0ec47c5677e32113c1b28aaf51d4a93834a03fe8f1674d1f650d",
        "question": "What are the countries that have cartoons on TV that were written by Todd Casey?",
        "query": "SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.Country ]",
        "cte": "WITH Scan_1 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_2 AS ( SELECT id, Country FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.Country FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'",
        "qd": "#1 = Scan the table Cartoon and retrieve the records where the cartoons were written by Todd Casey and the corresponding channels ; #2 = Scan the table TV_Channel and retrieve the channel IDs and countries ; #3 = Join #1 and #2 based on the matching channel IDs and retrieve the countries"
    },
    {
        "id": "dc9fa93cafe7bbc0200c3ea1a4db537478df1395d50ebeb37cca2c2cf91f79c6",
        "question": "which countries' tv channels are not playing any cartoon written by Todd Casey?",
        "query": "SELECT country FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Country ] ; #2 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #3 = Scan Table [ TV_Channel ] Output [ id , Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Channel = #3.id ] Output [ #3.Country ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Country = #4.Country ] Output [ #1.Country ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Country FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_3 AS ( SELECT id, Country FROM tvshow.TV_Channel ), Join_4 AS ( SELECT Scan_3.Country FROM Scan_2 JOIN Scan_3 ON Scan_2.Channel = Scan_3.id ), Except_5 AS ( SELECT Scan_1.Country FROM Scan_1 WHERE Country NOT IN (SELECT Country FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT country FROM tvshow.TV_Channel  EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the distinct countries of all TV channels ; #2 = Scan the table Cartoon and retrieve all the cartoons written by Todd Casey along with their channels ; #3 = Scan the table TV_Channel and retrieve the ids and countries of all TV channels ; #4 = Join #2 and #3 based on the matching channel ids and retrieve the countries ; #5 = Return all the countries from #1 that are not present in #4 to find the countries' TV channels that are not playing any cartoon written by Todd Casey"
    },
    {
        "id": "e544df3d47b4c732fba6bbe69959eb06d71a4b9701f1c2d772f07a2bd1a3e3b4",
        "question": "What are the countries that are not playing cartoons written by Todd Casey?",
        "query": "SELECT country FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Country ] ; #2 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #3 = Scan Table [ TV_Channel ] Output [ id , Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Channel = #3.id ] Output [ #3.Country ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Country = #4.Country ] Output [ #1.Country ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Country FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_3 AS ( SELECT id, Country FROM tvshow.TV_Channel ), Join_4 AS ( SELECT Scan_3.Country FROM Scan_2 JOIN Scan_3 ON Scan_2.Channel = Scan_3.id ), Except_5 AS ( SELECT Scan_1.Country FROM Scan_1 WHERE Country NOT IN (SELECT Country FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT country FROM tvshow.TV_Channel  EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the distinct countries ; #2 = Scan the table Cartoon and retrieve the cartoons written by Todd Casey along with the corresponding channel ; #3 = Scan the table TV_Channel and retrieve the IDs and countries of all channels ; #4 = Join #2 and #3 based on the matching channel IDs and retrieve the countries ; #5 = Find the countries that are not playing the cartoons written by Todd Casey by excluding the countries from #4 from the distinct countries obtained from #1"
    },
    {
        "id": "1e794a6002b4eb201d69fd387733237b9ee039ee07e7e045ed7bcba1df37db8f",
        "question": "Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
        "query": "SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Michael Chang' ] Output [ Directed_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Distinct [ true ] Output [ #2.Country , #2.series_name ] ; #4 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #5 = Scan Table [ TV_Channel ] Output [ id , series_name , Country ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Channel = #5.id ] Output [ #5.series_name , #5.Country ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.series_name = #6.series_name ] Output [ #3.Country , #3.series_name ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Michael Chang' ), Scan_2 AS ( SELECT id, series_name, Country FROM tvshow.TV_Channel ), Join_3 AS ( SELECT DISTINCT Scan_2.Country, Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ), Scan_4 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Scan_5 AS ( SELECT id, series_name, Country FROM tvshow.TV_Channel ), Join_6 AS ( SELECT Scan_5.series_name, Scan_5.Country FROM Scan_4 JOIN Scan_5 ON Scan_4.Channel = Scan_5.id ), Intersect_7 AS ( SELECT Join_3.Country, Join_3.series_name FROM Join_3 WHERE series_name IN (SELECT series_name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones'",
        "qd": "#1 = Scan the table Cartoon and retrieve the channels that are playing cartoons directed by Michael Chang ; #2 = Scan the table TV_Channel and retrieve the IDs, series names, and countries of all TV channels ; #3 = Join #1 and #2 based on the matching channel IDs and retrieve the countries and series names ; #4 = Scan the table Cartoon and retrieve the channels that are playing cartoons directed by Ben Jones ; #5 = Scan the table TV_Channel and retrieve the IDs, series names, and countries of all TV channels ; #6 = Join #4 and #5 based on the matching channel IDs and retrieve the series names and countries ; #7 = Intersect #3 and #6 based on the matching series names and retrieve the countries and series names"
    },
    {
        "id": "e6393c117f414da854c082eff60f93bd0300723381b35c6e2b65aaba840d0ea0",
        "question": "What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
        "query": "SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Michael Chang' ] Output [ Directed_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Distinct [ true ] Output [ #2.Country , #2.series_name ] ; #4 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #5 = Scan Table [ TV_Channel ] Output [ id , series_name , Country ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Channel = #5.id ] Output [ #5.series_name , #5.Country ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.series_name = #6.series_name ] Output [ #3.Country , #3.series_name ]",
        "cte": "WITH Scan_1 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Michael Chang' ), Scan_2 AS ( SELECT id, series_name, Country FROM tvshow.TV_Channel ), Join_3 AS ( SELECT DISTINCT Scan_2.Country, Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ), Scan_4 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Scan_5 AS ( SELECT id, series_name, Country FROM tvshow.TV_Channel ), Join_6 AS ( SELECT Scan_5.series_name, Scan_5.Country FROM Scan_4 JOIN Scan_5 ON Scan_4.Channel = Scan_5.id ), Intersect_7 AS ( SELECT Join_3.Country, Join_3.series_name FROM Join_3 WHERE series_name IN (SELECT series_name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones'",
        "qd": "#1 = Scan the table Cartoon and retrieve the channels that are playing cartoons directed by Michael Chang ; #2 = Scan the table TV_Channel and retrieve the IDs, series names, and countries of all TV channels ; #3 = Join #1 and #2 based on the matching channel IDs and retrieve the countries and series names ; #4 = Scan the table Cartoon and retrieve the channels that are playing cartoons directed by Ben Jones ; #5 = Scan the table TV_Channel and retrieve the IDs, series names, and countries of all TV channels ; #6 = Join #4 and #5 based on the matching channel IDs and retrieve the series names and countries ; #7 = Intersect #3 and #6 based on the matching series names and retrieve the countries and series names"
    },
    {
        "id": "c64e0faa9e89897971fbbb82dd7381df2d0f37bc67ff227a876b71f041eb036f",
        "question": "find the pixel aspect ratio and nation of the tv channels that do not use English.",
        "query": "SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language <> 'English' ] Output [ Language , Country , Pixel_aspect_ratio_PAR ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, Country, Pixel_aspect_ratio_PAR FROM tvshow.TV_Channel WHERE Language <> 'English' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel  WHERE LANGUAGE ! = 'English'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the language, country, and pixel aspect ratio of the TV channels that do not use English."
    },
    {
        "id": "216deec7ce39e86c5ef67a4c5259db2aeabae0a3db17c2270cc93df36cee7e30",
        "question": "What is the pixel aspect ratio and country of origin for all TV channels that do not use English?",
        "query": "SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language <> 'English' ] Output [ Language , Country , Pixel_aspect_ratio_PAR ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, Country, Pixel_aspect_ratio_PAR FROM tvshow.TV_Channel WHERE Language <> 'English' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel  WHERE LANGUAGE ! = 'English'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the language, country, and pixel aspect ratio for all TV channels that do not use English."
    },
    {
        "id": "34ae116d68862a3d031e45083c8c14f67053408224f2484c61530216d7152422",
        "question": "find id of the tv channels that from the countries where have more than two tv channels.",
        "query": "SELECT Id from tvshow.TV_Channel where country in (SELECT country from tvshow.TV_Channel GROUP BY country HAVING Count(*) > 2)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ id , country ] ; #2 = Aggregate [ #1 ] GroupBy [ country ] Output [ countstar as Count_Star , country ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 2 ] Output [ country ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.country = #3.country ] Output [ #1.id ]",
        "cte": "WITH Scan_1 AS ( SELECT id, country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country FROM Scan_1 GROUP BY country ), Filter_3 AS ( SELECT country FROM Aggregate_2 WHERE Count_Star > 2 ), Join_4 AS ( SELECT Scan_1.id FROM Scan_1 JOIN Filter_3 ON Scan_1.country = Filter_3.country ) SELECT * FROM Join_4",
        "clean_query": "SELECT Id from tvshow.TV_Channel where country in (SELECT country from tvshow.TV_Channel GROUP BY country HAVING Count(*) > 2)",
        "qd": "#1 = Scan the table TV_Channel and retrieve the ids and countries of all TV channels. ; #2 = Group #1 by country and count the number of TV channels in each country. ; #3 = Filter the records from #2 and retrieve the countries with more than two TV channels. ; #4 = Join #1 and #3 based on the matching country and retrieve the ids of the TV channels."
    },
    {
        "id": "4030ca9a53a02732ea943743b6fe00d6d8750e215cf82b9ad4d9d63fd796c938",
        "question": "What are the ids of all tv channels in countries that have more than 2 TV channels?",
        "query": "SELECT Id from tvshow.TV_Channel where country in (SELECT country from tvshow.TV_Channel GROUP BY country HAVING Count(*) > 2)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ id , country ] ; #2 = Aggregate [ #1 ] GroupBy [ country ] Output [ countstar as Count_Star , country ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 2 ] Output [ country ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.country = #3.country ] Output [ #1.id ]",
        "cte": "WITH Scan_1 AS ( SELECT id, country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country FROM Scan_1 GROUP BY country ), Filter_3 AS ( SELECT country FROM Aggregate_2 WHERE Count_Star > 2 ), Join_4 AS ( SELECT Scan_1.id FROM Scan_1 JOIN Filter_3 ON Scan_1.country = Filter_3.country ) SELECT * FROM Join_4",
        "clean_query": "SELECT Id from tvshow.TV_Channel where country in (SELECT country from tvshow.TV_Channel GROUP BY country HAVING Count(*) > 2)",
        "qd": "#1 = Scan the table TV_Channel and retrieve the ids and countries of all TV channels ; #2 = Group #1 by country and aggregate the count of TV channels per country ; #3 = Filter the records from #2 to only include the countries with more than 2 TV channels ; #4 = Join #1 and #3 based on the matching country and retrieve the ids of the TV channels"
    },
    {
        "id": "327bca9bb7bc2bad6f1c5c3550a309028f5d3855e7c1ec6922cdd503aa6bd187",
        "question": "find the id of tv channels that do not play any cartoon directed by Ben Jones.",
        "query": "SELECT id FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel = #1.id ] Output [ #1.id ]",
        "cte": "WITH Scan_1 AS ( SELECT id FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.id FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT id FROM tvshow.TV_Channel  EXCEPT SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones'",
        "qd": "#1 = Scan the table TV_Channel to retrieve the IDs of all TV channels ; #2 = Scan the table Cartoon to retrieve the channels that have cartoons directed by Ben Jones ; #3 = Return the IDs of the TV channels that are not in the list of channels from #2, which means they do not play any cartoon directed by Ben Jones"
    },
    {
        "id": "26be22a865b394ee60cdcb1dadda77678afbeceda9793eee650b327d8025b6a4",
        "question": "What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
        "query": "SELECT id FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel = #1.id ] Output [ #1.id ]",
        "cte": "WITH Scan_1 AS ( SELECT id FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.id FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT id FROM tvshow.TV_Channel  EXCEPT SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones'",
        "qd": "#1 = Scan the table TV_Channel and retrieve the IDs of all TV channels ; #2 = Scan the table Cartoon and retrieve the channels of all cartoons directed by Ben Jones ; #3 = Return the IDs of all TV channels that are not in #2 and have no cartoons directed by Ben Jones"
    },
    {
        "id": "5916846cb35aee32cb93f7b29358c8341b8cd43935cd8392e41b0cc4bd7f0183",
        "question": "find the package option of the tv channel that do not have any cartoon directed by Ben Jones.",
        "query": "SELECT package_option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' ) ",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ id , Package_Option ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel IS NULL OR #1.id = #2.Channel ] Output [ #1.Package_Option ]",
        "cte": "WITH Scan_1 AS ( SELECT id, Package_Option FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.Package_Option FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT package_option FROM tvshow.TV_Channel  WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones' )",
        "qd": "#1 = Scan the table TV_Channel and retrieve the ids and package options of all TV channels ; #2 = Scan the table Cartoon and retrieve the IDs and channels of all cartoons directed by Ben Jones ; #3 = Return the package options of the TV channels that either do not have any cartoons directed by Ben Jones or have a matching channel ID"
    },
    {
        "id": "fe5adb59a95ba76edd9fc8f6822e8954695aa539cb3d1facb8be2529f01ddacf",
        "question": "What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?",
        "query": "SELECT package_option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' ) ",
        "qpl": "tvshow | #1 = Scan Table [ TV_Channel ] Output [ id , Package_Option ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel IS NULL OR #1.id = #2.Channel ] Output [ #1.Package_Option ]",
        "cte": "WITH Scan_1 AS ( SELECT id, Package_Option FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.Package_Option FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT package_option FROM tvshow.TV_Channel  WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones' )",
        "qd": "#1 = Scan the table TV_Channel and retrieve the IDs and package options of all TV channels ; #2 = Scan the table Cartoon and retrieve the channels of all cartoons directed by Ben Jones ; #3 = Return the package options from #1 that are either not in #2 or have a matching ID in #2 but the channel is empty"
    },
    {
        "id": "e7fcce4afab160c8a195796f3ea815d73d529587aa5c18bb9f11330e7cef0a2e",
        "question": "How many poker players are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM poker_player.poker_player",
        "qd": "#1 = Scan the table poker_player and retrieve a constant value of 1 for each record ; #2 = Aggregate the count of all records from #1 to find the total number of poker players"
    },
    {
        "id": "ad8d6ae8b20c0d4474d54cfe992634403c35dd7cd7909986e366c0e742b93105",
        "question": "Count the number of poker players.",
        "query": "SELECT count ( * ) AS Count_Star FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM poker_player.poker_player",
        "qd": "#1 = Scan the table poker_player and retrieve a value of 1 for each record ; #2 = Aggregate the number of records from #1 to count the number of poker players"
    },
    {
        "id": "7fddb3f9985c9698f0563fda7153bc19b66174ba26976910b80a60aaf59640a5",
        "question": "List the earnings of poker players in descending order.",
        "query": "SELECT Earnings FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Sort [ #1 ] OrderBy [ Earnings DESC ] Output [ Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ) SELECT Earnings FROM Scan_1 ORDER BY Earnings DESC",
        "clean_query": "SELECT Earnings FROM poker_player.poker_player  ORDER BY Earnings DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings of all poker players ; #2 = Sort the records from #1 based on the earnings in descending order and retrieve the earnings of the poker players"
    },
    {
        "id": "61f7da4b5c699fa47aef91b666d0b11804b094b4fb440fc88764c661cc7fb277",
        "question": "What are the earnings of poker players, ordered descending by value?",
        "query": "SELECT Earnings FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Sort [ #1 ] OrderBy [ Earnings DESC ] Output [ Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ) SELECT Earnings FROM Scan_1 ORDER BY Earnings DESC",
        "clean_query": "SELECT Earnings FROM poker_player.poker_player  ORDER BY Earnings DESC",
        "qd": "#1 = Scan the table poker_player to retrieve the earnings of all poker players ; #2 = Sort the records from #1 based on the earnings in descending order and retrieve the earnings of poker players, ordered descending by value"
    },
    {
        "id": "67d0d7311467f93130cc61ed07eb52dea243bb0b8805dada1872d0b4869b620e",
        "question": "List the final tables made and the best finishes of poker players.",
        "query": "SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Final_Table_Made , Best_Finish ]",
        "cte": "WITH Scan_1 AS ( SELECT Final_Table_Made, Best_Finish FROM poker_player.poker_player ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player",
        "qd": "#1 = Scan the table poker_player and retrieve the final tables made and the best finishes of all poker players."
    },
    {
        "id": "501aeb236dcd162233fa7f85eef288c637da8ef7000d13a300b753843ca5d84c",
        "question": "What are the final tables made and best finishes for all poker players?",
        "query": "SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Final_Table_Made , Best_Finish ]",
        "cte": "WITH Scan_1 AS ( SELECT Final_Table_Made, Best_Finish FROM poker_player.poker_player ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player",
        "qd": "#1 = Scan the table poker_player and retrieve the final tables made and best finishes for all poker players."
    },
    {
        "id": "c348d12b01b02a3eddb926cec1d07d17ee281ad2cebf76d0f34fbec50d2a8658",
        "question": "What is the average earnings of poker players?",
        "query": "SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Aggregate [ #1 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings of all poker players ; #2 = Aggregate the average earnings from #1 to find the average earnings of poker players"
    },
    {
        "id": "e7fa38db30c3db68836b1449b6438e029192143eb94fa382df17ec3e016760e1",
        "question": "Return the average earnings across all poker players.",
        "query": "SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Aggregate [ #1 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings of all poker players. ; #2 = Aggregate the average of earnings from #1 to find the average earnings across all poker players."
    },
    {
        "id": "4f5e7016459adb9ad44e4ca87c1111a03cc59859b725f473faf61852f6d447b4",
        "question": "What is the money rank of the poker player with the highest earnings?",
        "query": "SELECT TOP 1 Money_Rank FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Money_Rank , Earnings ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Earnings DESC ] Output [ Money_Rank , Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Money_Rank, Earnings FROM poker_player.poker_player ), TopSort_2 AS ( SELECT TOP 1 Money_Rank, Earnings FROM Scan_1 ORDER BY Earnings DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Money_Rank FROM poker_player.poker_player  ORDER BY Earnings DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the money rank and earnings of all poker players ; #2 = Sort the records from #1 based on the earnings in descending order, select the first record, and identify the money rank of the poker player with the highest earnings"
    },
    {
        "id": "d3843868bf41d4824aeaf42e48f823c66c1cddefe42f17b1af2797eb10d4404a",
        "question": "Return the money rank of the player with the greatest earnings.",
        "query": "SELECT TOP 1 Money_Rank FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Money_Rank , Earnings ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Earnings DESC ] Output [ Money_Rank , Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Money_Rank, Earnings FROM poker_player.poker_player ), TopSort_2 AS ( SELECT TOP 1 Money_Rank, Earnings FROM Scan_1 ORDER BY Earnings DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Money_Rank FROM poker_player.poker_player  ORDER BY Earnings DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the money rank and earnings of all players ; #2 = Sort the records from #1 based on the earnings in descending order, select the first record, and retrieve the money rank of the player with the greatest earnings."
    },
    {
        "id": "a9c17fcf19a13f223416ed82289c1000f806514655d35b1590c3ad2d5f84cebf",
        "question": "What is the maximum number of final tables made among poker players with earnings less than 200000?",
        "query": "SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player WITH (FORCESCAN) WHERE Earnings < 200000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings < 200000.0 ] Output [ Final_Table_Made , Earnings ] ; #2 = Aggregate [ #1 ] Output [ MAX(Final_Table_Made) AS Max_Final_Table_Made ]",
        "cte": "WITH Scan_1 AS ( SELECT Final_Table_Made, Earnings FROM poker_player.poker_player WHERE Earnings < 200000.0 ), Aggregate_2 AS ( SELECT MAX(Final_Table_Made) AS Max_Final_Table_Made FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player  WHERE Earnings < 200000",
        "qd": "#1 = Scan the table poker_player and retrieve the final tables made and earnings of all poker players with earnings less than 200000 ; #2 = Calculate the maximum number of final tables made among the poker players with earnings less than 200000 and identify it as Max_Final_Table_Made."
    },
    {
        "id": "3102cd9aae10b96ebbf6c9abc056927ab9dbbab64da7a97f17bb5757b07eb70f",
        "question": "Return the maximum final tables made across all poker players who have earnings below 200000.",
        "query": "SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player WITH (FORCESCAN) WHERE Earnings < 200000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings < 200000.0 ] Output [ Final_Table_Made , Earnings ] ; #2 = Aggregate [ #1 ] Output [ MAX(Final_Table_Made) AS Max_Final_Table_Made ]",
        "cte": "WITH Scan_1 AS ( SELECT Final_Table_Made, Earnings FROM poker_player.poker_player WHERE Earnings < 200000.0 ), Aggregate_2 AS ( SELECT MAX(Final_Table_Made) AS Max_Final_Table_Made FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player  WHERE Earnings < 200000",
        "qd": "#1 = Scan the table poker_player and retrieve the final tables made and earnings of all poker players with earnings below 200,000. ; #2 = Aggregate the maximum number of final tables made from #1 to find the maximum final tables made across all poker players with earnings below 200,000."
    },
    {
        "id": "08a69a180305a344c510949c19179114ef27795b2597f6b53a9e8f126b7cde94",
        "question": "What are the names of poker players?",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID",
        "qd": "#1 = Scan the table poker_player and retrieve the people IDs of all poker players ; #2 = Scan the table people and retrieve the names and people IDs of all people ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the names of all poker players"
    },
    {
        "id": "9e5201c6e248666fa311ea7cccc6d4189470d448be20a0380a4062d80f82c71e",
        "question": "Return the names of all the poker players.",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID",
        "qd": "#1 = Scan the table poker_player to retrieve the People_ID of all poker players ; #2 = Scan the table people to retrieve the names and People_IDs of all people ; #3 = Join #1 and #2 based on the matching People_ID and retrieve the names of all the poker players"
    },
    {
        "id": "3854a4726f08605b3fc8736f407fd3320c4b070be41be27a18da970a13cabf86",
        "question": "What are the names of poker players whose earnings is higher than 300000?",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings > 300000.0 ] Output [ Earnings , People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player WHERE Earnings > 300000.0 ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000",
        "qd": "#1 = Scan the table poker_player to find the poker players with earnings higher than 300000 ; #2 = Scan the table people to retrieve the names and People IDs of all people ; #3 = Join #1 and #2 based on the matching People IDs and retrieve the names of the poker players with earnings higher than 300000"
    },
    {
        "id": "0304ccac6215bdeb68fee72019cb089b06fd44940d8a52dd0a70443824e39952",
        "question": "Give the names of poker players who have earnings above 300000.",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings > 300000.0 ] Output [ Earnings , People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player WHERE Earnings > 300000.0 ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings and player IDs of all poker players with earnings above 300000. ; #2 = Scan the table people and retrieve the names and player IDs of all people. ; #3 = Join #1 and #2 based on the matching player IDs and retrieve the names of the poker players with earnings above 300000."
    },
    {
        "id": "044f714d672d32a325bbfb225b0075e090856f30f465f5e162edb51e8f2525c0",
        "question": "List the names of poker players ordered by the final tables made in ascending order.",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Final_Table_Made , People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Final_Table_Made , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Final_Table_Made ASC ] Output [ Name , Final_Table_Made ]",
        "cte": "WITH Scan_1 AS ( SELECT Final_Table_Made, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Final_Table_Made, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Final_Table_Made FROM Join_3 ORDER BY Final_Table_Made ASC",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made",
        "qd": "#1 = Scan the table poker_player and retrieve the number of final tables made and the corresponding people IDs. ; #2 = Scan the table people and retrieve the names and corresponding people IDs of all players. ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the names and number of final tables made. ; #4 = Sort the records from #3 based on the number of final tables made in ascending order and retrieve the names."
    },
    {
        "id": "862cf18a84d6b570717481f1cee798370bd820600fed8d9fb547212392fc97d1",
        "question": "What are the names of poker players, ordered ascending by the number of final tables they have made?",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Final_Table_Made , People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Final_Table_Made , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Final_Table_Made ASC ] Output [ Name , Final_Table_Made ]",
        "cte": "WITH Scan_1 AS ( SELECT Final_Table_Made, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Final_Table_Made, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Final_Table_Made FROM Join_3 ORDER BY Final_Table_Made ASC",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made",
        "qd": "#1 = Scan the table poker_player and retrieve the number of final tables made and the corresponding people IDs ; #2 = Scan the table people and retrieve the names and people IDs of all players ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the names and number of final tables made ; #4 = Sort the records from #3 based on the number of final tables made in ascending order and retrieve the names of the poker players"
    },
    {
        "id": "4eaa950c1003fdf45a32673b42ff643ccb4dd6ed5d95e36682f364519dcc349b",
        "question": "What is the birth date of the poker player with the lowest earnings?",
        "query": "SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings , People_ID ] ; #2 = Scan Table [ people ] Output [ Birth_Date , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Birth_Date ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Earnings ASC ] Output [ Earnings , Birth_Date ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Birth_Date, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Earnings, Scan_2.Birth_Date FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Earnings, Birth_Date FROM Join_3 ORDER BY Earnings ASC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings and people IDs of all poker players ; #2 = Scan the table people and retrieve the birth dates and people IDs of all people ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the earnings and birth dates ; #4 = Sort the records from #3 based on the earnings in ascending order, select the first record, and identify the birth date of the poker player with the lowest earnings"
    },
    {
        "id": "134c01a812f1d002b8ec3b1bada53172b4e50778eb87d5b24cb776d6a94c731f",
        "question": "Return the birth date of the poker player with the lowest earnings.",
        "query": "SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings , People_ID ] ; #2 = Scan Table [ people ] Output [ Birth_Date , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Birth_Date ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Earnings ASC ] Output [ Earnings , Birth_Date ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Birth_Date, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Earnings, Scan_2.Birth_Date FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Earnings, Birth_Date FROM Join_3 ORDER BY Earnings ASC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings and people IDs of all poker players ; #2 = Scan the table people and retrieve the birth dates and people IDs of all people ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the earnings and birth dates ; #4 = Sort the records from #3 based on the earnings in ascending order, select the first record, and identify the birth date of the poker player with the lowest earnings"
    },
    {
        "id": "d01287301b3ab267c9011c0d72455a523c3ac26d89ed5a67dbe3e23e670b9d15",
        "question": "What is the money rank of the tallest poker player?",
        "query": "SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Money_Rank , People_ID ] ; #2 = Scan Table [ people ] Output [ Height , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Height , #1.Money_Rank ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Height DESC ] Output [ Height , Money_Rank ]",
        "cte": "WITH Scan_1 AS ( SELECT Money_Rank, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Height, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Height, Scan_1.Money_Rank FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Height, Money_Rank FROM Join_3 ORDER BY Height DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the money rank and people ID of all poker players ; #2 = Scan the table people and retrieve the height and people ID of all people ; #3 = Join #1 and #2 based on the matching people ID and retrieve the height and money rank ; #4 = Sort the records from #3 based on the height in descending order, select the first record, and retrieve the money rank of the tallest poker player"
    },
    {
        "id": "3527f8c88c2c02b87402400adb4ca1df78d5a8ed8137a2e68e5ae161490f83b2",
        "question": "Return the money rank of the poker player with the greatest height.",
        "query": "SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Money_Rank , People_ID ] ; #2 = Scan Table [ people ] Output [ Height , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Height , #1.Money_Rank ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Height DESC ] Output [ Height , Money_Rank ]",
        "cte": "WITH Scan_1 AS ( SELECT Money_Rank, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Height, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Height, Scan_1.Money_Rank FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Height, Money_Rank FROM Join_3 ORDER BY Height DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the money rank and people ID of all poker players ; #2 = Scan the table people and retrieve the height and people ID of all people ; #3 = Join #1 and #2 based on the matching people ID and retrieve the height and money rank ; #4 = Sort the records from #3 based on the height in descending order, select the first record, and identify the money rank of the poker player with the greatest height"
    },
    {
        "id": "7bcbec7f9317af4cda4f934c99013fba1b27971fdf1e19b737506f1e2bbbadb7",
        "question": "What is the average earnings of poker players with height higher than 200?",
        "query": "SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T1.Height > 200 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Predicate [ Height > 200.0 ] Output [ Height , People_ID ] ; #2 = Scan Table [ poker_player ] Output [ Earnings , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Earnings ] ; #4 = Aggregate [ #3 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Height, People_ID FROM poker_player.people WHERE Height > 200.0 ), Scan_2 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player ), Join_3 AS ( SELECT Scan_2.Earnings FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), Aggregate_4 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T1.Height > 200",
        "qd": "#1 = Scan the table people and retrieve the heights and people IDs of all people with a height higher than 200 ; #2 = Scan the table poker_player and retrieve the earnings and people IDs of all poker players ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the earnings of poker players with a height higher than 200 ; #4 = Calculate the average earnings of the poker players from #3 and identify the average earnings of poker players with a height higher than 200."
    },
    {
        "id": "a1bf2d8958be8dd95641c593f66002a2c88d11a9c30eb564d954c166ea5ddb70",
        "question": "Give average earnings of poker players who are taller than 200.",
        "query": "SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T1.Height > 200 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Predicate [ Height > 200.0 ] Output [ Height , People_ID ] ; #2 = Scan Table [ poker_player ] Output [ Earnings , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Earnings ] ; #4 = Aggregate [ #3 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Height, People_ID FROM poker_player.people WHERE Height > 200.0 ), Scan_2 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player ), Join_3 AS ( SELECT Scan_2.Earnings FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), Aggregate_4 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T1.Height > 200",
        "qd": "#1 = Scan the table people to find all the people who are taller than 200 ; #2 = Scan the table poker_player to find the earnings of all poker players ; #3 = Join #1 and #2 based on the matching People IDs and retrieve the earnings of poker players who are taller than 200 ; #4 = Calculate the average earnings of the poker players who are taller than 200 and output the average earnings as Avg_Earnings"
    },
    {
        "id": "3ea56ea638859870f74c819e5d8def86954d9136b038c68200c5e910b918ea0b",
        "question": "What are the names of poker players in descending order of earnings?",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings , People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Earnings DESC ] Output [ Name , Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Earnings, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Earnings FROM Join_3 ORDER BY Earnings DESC",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings and people IDs of all poker players ; #2 = Scan the table people and retrieve the names and people IDs of all people ; #3 = Join #1 and #2 based on the matching people IDs and retrieve the names and earnings of the poker players ; #4 = Sort the records from #3 based on the earnings in descending order and retrieve the names of the poker players"
    },
    {
        "id": "3b8ab4e1d255f68608b86f8899d6adfb0367f92a350579daf6bc26437288a126",
        "question": "Return the names of poker players sorted by their earnings descending.",
        "query": "SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings , People_ID ] ; #2 = Scan Table [ people ] Output [ Name , People_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Earnings DESC ] Output [ Name , Earnings ]",
        "cte": "WITH Scan_1 AS ( SELECT Earnings, People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT Name, People_ID FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Earnings, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Earnings FROM Join_3 ORDER BY Earnings DESC",
        "clean_query": "SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC",
        "qd": "#1 = Scan the table poker_player and retrieve the earnings and people IDs of all poker players ; #2 = Scan the table people and retrieve the names and people IDs of all people ; #3 = Join #1 and #2 based on the matching people ID and retrieve the earnings and names of the poker players ; #4 = Sort the records from #3 based on the earnings in descending order and retrieve the names of the poker players"
    },
    {
        "id": "a007a938175d709e14791598607b8aeb8b640dd14dd48f3e56eb97824e0acacd",
        "question": "What are different nationalities of people and the corresponding number of people from each nation?",
        "query": "SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ countstar AS Count_Star , Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Nationality FROM Scan_1 GROUP BY Nationality ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people  GROUP BY Nationality",
        "qd": "#1 = Scan the table People and retrieve the nationalities of all people ; #2 = Group #1 by nationality and count the number of people from each nation, retrieve the count and nationality"
    },
    {
        "id": "60381fe18778956685f148ed16d9626f22531748406bdbd7c0c99be5af63cc29",
        "question": "How many people are there of each nationality?",
        "query": "SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ countstar AS Count_Star , Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Nationality FROM Scan_1 GROUP BY Nationality ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people  GROUP BY Nationality",
        "qd": "#1 = Scan the table People and retrieve the nationality of all people ; #2 = Group the records from #1 by nationality and aggregate the count per nationality to find the number of people for each nationality"
    },
    {
        "id": "073332a5fd4d410cbe407ca5590f3591cff693649f96109da43bc8619671d08b",
        "question": "What is the most common nationality of people?",
        "query": "SELECT TOP 1 Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ countstar AS Count_Star , Nationality ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Nationality , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Nationality FROM Scan_1 GROUP BY Nationality ), TopSort_3 AS ( SELECT TOP 1 Nationality, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Nationality FROM poker_player.people  GROUP BY Nationality ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table people and retrieve the nationalities of all people ; #2 = Group the records from #1 by nationality and aggregate the count of people per nationality ; #3 = Sort the records from #2 based on the count of people in descending order, select the first record, and identify the nationality with the most number of people and its count."
    },
    {
        "id": "50dd67121490bcdaef67b0fa8e7b7c482ff5154f3c6dd54446ce3ba29ec3e40f",
        "question": "Give the nationality that is most common across all people.",
        "query": "SELECT TOP 1 Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ countstar AS Count_Star , Nationality ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Nationality , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Nationality FROM Scan_1 GROUP BY Nationality ), TopSort_3 AS ( SELECT TOP 1 Nationality, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Nationality FROM poker_player.people  GROUP BY Nationality ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table people and retrieve the nationality of all people. ; #2 = Group #1 by nationality and aggregate the count of records per nationality. ; #3 = Sort the records from #2 based on the count of people in each nationality in descending order, select the first record, and identify the nationality that is most common across all people and its count."
    },
    {
        "id": "d5a39686bba741ef689bc307f2c36a0afe1e3e7005626c834320c78d825a40e5",
        "question": "What are the nationalities that are shared by at least two people?",
        "query": "SELECT Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ countstar AS Count_Star , Nationality ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Nationality FROM Scan_1 GROUP BY Nationality ), Filter_3 AS ( SELECT Nationality FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT Nationality FROM poker_player.people  GROUP BY Nationality HAVING COUNT ( * ) > = 2",
        "qd": "#1 = Scan the table people and retrieve the nationalities of all people ; #2 = Group #1 by nationality and count the number of occurrences of each nationality ; #3 = Filter from #2 all the nationalities that have a count of at least 2"
    },
    {
        "id": "4d5cee55fec256b8f6850ffd68ea37b824569ff2bdd66b6393e896020179a357",
        "question": "Return the nationalities for which there are two or more people.",
        "query": "SELECT Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ countstar AS Count_Star , Nationality ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Nationality FROM Scan_1 GROUP BY Nationality ), Filter_3 AS ( SELECT Nationality FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT Nationality FROM poker_player.people  GROUP BY Nationality HAVING COUNT ( * ) > = 2",
        "qd": "#1 = Scan the table people and retrieve the nationalities of all people. ; #2 = Group #1 by nationality and aggregate the count per nationality to find the number of people for each nationality. ; #3 = Filter from #2 the nationalities with a count of 2 or more to find the nationalities for which there are two or more people."
    },
    {
        "id": "f3fa903b24fa8f9dc20a193fcf0256b80e56cd8c75cebe52ed4d28b5badf9486",
        "question": "List the names and birth dates of people in ascending alphabetical order of name.",
        "query": "SELECT Name , Birth_Date FROM poker_player.people WITH (FORCESCAN) ORDER BY Name ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Name , Birth_Date ] ; #2 = Sort [ #1 ] OrderBy [ Name ASC ] Output [ Name , Birth_Date ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Birth_Date FROM poker_player.people ) SELECT Name, Birth_Date FROM Scan_1 ORDER BY Name ASC",
        "clean_query": "SELECT Name , Birth_Date FROM poker_player.people  ORDER BY Name ASC",
        "qd": "#1 = Scan the table people and retrieve the names and birth dates of all people ; #2 = Sort the records from #1 based on the names in ascending alphabetical order and retrieve the names and birth dates"
    },
    {
        "id": "91bee6c64b55ed007541ee7bc3edc5cd2ac530d2f8aa720ebe0a6ac76f71ac0e",
        "question": "What are the names and birth dates of people, ordered by their names in alphabetical order?",
        "query": "SELECT Name , Birth_Date FROM poker_player.people WITH (FORCESCAN) ORDER BY Name ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Name , Birth_Date ] ; #2 = Sort [ #1 ] OrderBy [ Name ASC ] Output [ Name , Birth_Date ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Birth_Date FROM poker_player.people ) SELECT Name, Birth_Date FROM Scan_1 ORDER BY Name ASC",
        "clean_query": "SELECT Name , Birth_Date FROM poker_player.people  ORDER BY Name ASC",
        "qd": "#1 = Scan the table people and retrieve the names and birth dates of all people ; #2 = Sort the records from #1 based on the names in alphabetical order and retrieve the names and birth dates"
    },
    {
        "id": "e414d32b5423f613066d3bcdc923aeacd8d20f30e56c3f129024985e74d76087",
        "question": "Show names of people whose nationality is not \"Russia\".",
        "query": "SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE Nationality ! = 'Russia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Predicate [ Nationality <> 'Russia' ] Output [ Name , Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Nationality FROM poker_player.people WHERE Nationality <> 'Russia' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM poker_player.people  WHERE Nationality ! = 'Russia'",
        "qd": "#1 = Scan the table people and retrieve the names of people whose nationality is not \"Russia\"."
    },
    {
        "id": "dbbf44711e8fd308d37064f71594e0580d43a6aff100d52e2b3c507f986e8094",
        "question": "What are the names of people who are not from Russia?",
        "query": "SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE Nationality ! = 'Russia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Predicate [ Nationality <> 'Russia' ] Output [ Name , Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Nationality FROM poker_player.people WHERE Nationality <> 'Russia' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM poker_player.people  WHERE Nationality ! = 'Russia'",
        "qd": "#1 = Scan the table People and retrieve the names and nationalities of all people who are not from Russia"
    },
    {
        "id": "7e71dfe9b226654ff253bf9928829d6497f2bd6209adea612d4187885a79975a",
        "question": "List the names of people that are not poker players.",
        "query": "SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player WITH (FORCESCAN) ) ",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Name , People_ID ] ; #2 = Scan Table [ poker_player ] Output [ People_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.People_ID IS NULL OR #1.People_ID = #2.People_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, People_ID FROM poker_player.people ), Scan_2 AS ( SELECT People_ID FROM poker_player.poker_player ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE People_ID NOT IN (SELECT People_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Name FROM poker_player.people  WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player  )",
        "qd": "#1 = Scan the table people and retrieve the names and ID of all people ; #2 = Scan the table poker_player and retrieve the IDs of all poker players ; #3 = Find the names of people who are not poker players by excluding the IDs from #2 in #1 and retrieve their names"
    },
    {
        "id": "cbdbda7f6b5a8cb8a3e91eb569ed7fe4af064e5e9da84de6721c53d11042f4a6",
        "question": "What are the names of people who do not play poker?",
        "query": "SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player WITH (FORCESCAN) ) ",
        "qpl": "poker_player | #1 = Scan Table [ people ] Output [ Name , People_ID ] ; #2 = Scan Table [ poker_player ] Output [ People_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.People_ID IS NULL OR #1.People_ID = #2.People_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, People_ID FROM poker_player.people ), Scan_2 AS ( SELECT People_ID FROM poker_player.poker_player ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE People_ID NOT IN (SELECT People_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Name FROM poker_player.people  WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player  )",
        "qd": "#1 = Scan the table people and retrieve the names and IDs of all people. ; #2 = Scan the table poker_player and retrieve the IDs of all people who play poker. ; #3 = Find the names of people who do not play poker by subtracting the IDs from #2 from the IDs in #1 and retrieve their names."
    },
    {
        "id": "9a74739b1de108b16cb952da7dc049a7c4df7890b6f39ef2440ff75f46bd86ad",
        "question": "How many distinct nationalities are there?",
        "query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people",
        "qd": "#1 = Scan the table People and retrieve all distinct nationalities. ; #2 = Aggregate the count of distinct nationalities to find how many distinct nationalities are there."
    },
    {
        "id": "fbc04bab781dade7000cb80dc5e8d4b3dfa2941ca1a1e387497976c05365209d",
        "question": "Count the number of different nationalities.",
        "query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "poker_player | #1 = Scan Table [ people ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people",
        "qd": "#1 = Scan the table people and retrieve all distinct nationalities. ; #2 = Aggregate the number of distinct nationalities to find the count of different nationalities."
    },
    {
        "id": "f43bc5903436fd6a4ae16ce9b91ac3a7775e605b398c5ad823d597286507bbf1",
        "question": "How many states are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM voter_1.area_code_state WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ AREA_CODE_STATE ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM voter_1.AREA_CODE_STATE ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM voter_1.area_code_state",
        "qd": "#1 = Scan the table AREA_CODE_STATE and retrieve one record for each state ; #2 = Aggregate the number of records from #1 to find the total count of states"
    },
    {
        "id": "b792df4f0b5acb59b2cc8ad354f46c20b196000a4a1ee857ec47b5beef92fe3f",
        "question": "List the contestant numbers and names, ordered by contestant name descending.",
        "query": "SELECT contestant_number , contestant_name FROM voter_1.contestants WITH (FORCESCAN) ORDER BY contestant_name DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ CONTESTANTS ] Output [ contestant_name , contestant_number ] ; #2 = Sort [ #1 ] OrderBy [ contestant_name DESC ] Output [ contestant_name , contestant_number ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_name, contestant_number FROM voter_1.CONTESTANTS ) SELECT contestant_name, contestant_number FROM Scan_1 ORDER BY contestant_name DESC",
        "clean_query": "SELECT contestant_number , contestant_name FROM voter_1.contestants  ORDER BY contestant_name DESC",
        "qd": "#1 = Scan the table CONTESTANTS and retrieve the contestant names and numbers of all contestants.  ; #2 = Sort the records from #1 based on the contestant name in descending order and retrieve the contestant names and numbers."
    },
    {
        "id": "575ec295377477c9f31c046cc32ced0bff5306588047cf8a44524f07e76db154",
        "question": "List the vote ids, phone numbers and states of all votes.",
        "query": "SELECT vote_id , phone_number , state FROM voter_1.votes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ VOTES ] Output [ phone_number , state , vote_id ]",
        "cte": "WITH Scan_1 AS ( SELECT phone_number, state, vote_id FROM voter_1.VOTES ) SELECT * FROM Scan_1",
        "clean_query": "SELECT vote_id , phone_number , state FROM voter_1.votes",
        "qd": "#1 = Scan the VOTES table and retrieve the phone numbers, states, and vote IDs for all votes."
    },
    {
        "id": "e24254d972f8ecf7aa0697d04ee3434c79327bfec5fcb6eaa7ff5ba5537f66f6",
        "question": "What are the maximum and minimum values of area codes?",
        "query": "SELECT max ( area_code ) AS Max_area_code , min ( area_code ) AS Min_area_code FROM voter_1.area_code_state WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ AREA_CODE_STATE ] Output [ area_code ] ; #2 = Aggregate [ #1 ] Output [ MIN(area_code) AS Min_area_code , MAX(area_code) AS Max_area_code ]",
        "cte": "WITH Scan_1 AS ( SELECT area_code FROM voter_1.AREA_CODE_STATE ), Aggregate_2 AS ( SELECT MIN(area_code) AS Min_area_code, MAX(area_code) AS Max_area_code FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( area_code ) AS Max_area_code , min ( area_code ) AS Min_area_code FROM voter_1.area_code_state",
        "qd": "#1 = Scan the table AREA_CODE_STATE and retrieve all the area codes ; #2 = Aggregate the minimum and maximum values of the area codes to find the minimum and maximum values of the area codes"
    },
    {
        "id": "8ac627d9be26faacaad933328aa777c2ba3faa7b21cb4f3c343c13997de5c7a0",
        "question": "What is last date created of votes from the state 'CA'?",
        "query": "SELECT max ( created ) AS Max_created FROM voter_1.votes WITH (FORCESCAN) WHERE state = 'CA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ VOTES ] Predicate [ state = 'CA' ] Output [ created , state ] ; #2 = Aggregate [ #1 ] Output [ MAX(created) AS Max_created ]",
        "cte": "WITH Scan_1 AS ( SELECT created, state FROM voter_1.VOTES WHERE state = 'CA' ), Aggregate_2 AS ( SELECT MAX(created) AS Max_created FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( created ) AS Max_created FROM voter_1.votes  WHERE state = 'CA'",
        "qd": "#1 = Scan the table VOTES to find the records with the state 'CA' and retrieve the created dates and the state. ; #2 = Aggregate the records from #1 and find the maximum created date as the last date created of votes from the state 'CA'."
    },
    {
        "id": "5a8d71c970603ffa83f98d138980d8fe30589cc89224720daea8e4acd0e86daa",
        "question": "What are the names of the contestants whose names are not 'Jessie Alloway'",
        "query": "SELECT contestant_name FROM voter_1.contestants WITH (FORCESCAN) WHERE contestant_name ! = 'Jessie Alloway' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name <> 'Jessie Alloway' ] Output [ contestant_name ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name <> 'Jessie Alloway' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT contestant_name FROM voter_1.contestants  WHERE contestant_name ! = 'Jessie Alloway'",
        "qd": "#1 = Scan the table CONTESTANTS and retrieve all the names of the contestants that are not 'Jessie Alloway'."
    },
    {
        "id": "c1517697f4905f2a0efa5559d00932403e977d6eed11d9b1a5ddadf709b72f34",
        "question": "What are the distinct states and create time of all votes?",
        "query": "SELECT DISTINCT state , created FROM voter_1.votes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ VOTES ] Distinct [ true ] Output [ created , state ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT created, state FROM voter_1.VOTES ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT state , created FROM voter_1.votes",
        "qd": "#1 = Scan the table VOTES and retrieve all distinct values of created time and state"
    },
    {
        "id": "df8e2eaea9db6a1d91940430669a0e36d2ac025433b2a3df977d949a20aefcd3",
        "question": "What are the contestant numbers and names of the contestants who had at least two votes?",
        "query": "SELECT T1.contestant_number , T1.contestant_name FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number GROUP BY T1.contestant_number , T1.contestant_name HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ VOTES ] Output [ contestant_number ] ; #2 = Aggregate [ #1 ] GroupBy [ contestant_number ] Output [ countstar AS Count_Star , contestant_number ] ; #3 = Scan Table [ CONTESTANTS ] Output [ contestant_name , contestant_number ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.contestant_number = #3.contestant_number ] Output [ #3.contestant_number , #3.contestant_name , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ contestant_name , contestant_number ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_number FROM voter_1.VOTES ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, contestant_number FROM Scan_1 GROUP BY contestant_number ), Scan_3 AS ( SELECT contestant_name, contestant_number FROM voter_1.CONTESTANTS ), Join_4 AS ( SELECT Scan_3.contestant_number, Scan_3.contestant_name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.contestant_number = Scan_3.contestant_number ), Filter_5 AS ( SELECT contestant_name, contestant_number FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.contestant_number , T1.contestant_name FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number GROUP BY T1.contestant_number , T1.contestant_name HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table VOTES and retrieve the contestant numbers of all the votes ; #2 = Group #1 by contestant number and aggregate the count per contestant number to find the number of votes for each contestant ; #3 = Scan the table CONTESTANTS and retrieve the contestant names and numbers of all contestants ; #4 = Join #2 and #3 based on the matching contestant numbers and retrieve the contestant numbers, names, and vote counts ; #5 = Filter from #4 all the records with vote counts greater than or equal to 2 and retrieve the contestant names and numbers"
    },
    {
        "id": "bff2974c43a128f711181e493e2036cb2b26cb7aa8f12d9009b047620bef2c21",
        "question": "Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?",
        "query": "select TOP 1 WITH TIES t1.contestant_number , t1.contestant_name FROM voter_1.contestants AS T1 WITH (FORCESCAN) join voter_1.votes as t2 WITH (FORCESCAN) ON t1.contestant_number = t2.contestant_number group by t1.contestant_number , t1.contestant_name order by count ( * ) asc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ votes ] Output [ contestant_number ] ; #2 = Scan Table [ contestants ] Output [ contestant_number , contestant_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.contestant_number = #1.contestant_number ] Output [ #2.contestant_name , #2.contestant_number ] ; #4 = Aggregate [ #3 ] GroupBy [ contestant_name , contestant_number ] Output [ countstar AS Count_Star , contestant_number , contestant_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ contestant_number , contestant_name ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_number FROM voter_1.votes ), Scan_2 AS ( SELECT contestant_number, contestant_name FROM voter_1.contestants ), Join_3 AS ( SELECT Scan_2.contestant_name, Scan_2.contestant_number FROM Scan_1 JOIN Scan_2 ON Scan_2.contestant_number = Scan_1.contestant_number ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, contestant_number, contestant_name FROM Join_3 GROUP BY contestant_name , contestant_number, contestant_name, contestant_number ), TopSort_5 AS ( SELECT TOP 1 WITH TIES contestant_number, contestant_name FROM Aggregate_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 WITH TIES t1.contestant_number , t1.contestant_name FROM voter_1.contestants AS T1  join voter_1.votes as t2  ON t1.contestant_number = t2.contestant_number group by t1.contestant_number , t1.contestant_name order by count ( * ) asc",
        "qd": "#1 = Scan the table VOTES and retrieve the contestant numbers of all votes ; #2 = Scan the table CONTESTANTS and retrieve the contestant numbers and names of all contestants ; #3 = Join #1 and #2 based on the matching contestant numbers and retrieve the contestant names and numbers ; #4 = Group #3 by contestant name and number and aggregate the count per contestant to find the number of votes for each contestant ; #5 = Sort the records from #4 based on the count of votes in ascending order, select the first record, and identify the contestant number and name of the contestant who got the least votes"
    },
    {
        "id": "53f3c08f00b4abb2d3c3d200358f04020590cdb4126609068d72fb4b5cedda7e",
        "question": "What are the number of votes from state 'NY' or 'CA'?",
        "query": "SELECT count ( * ) AS Count_Star FROM voter_1.votes WITH (FORCESCAN) WHERE state = 'NY' OR state = 'CA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ votes ] Output [ state ] ; #2 = Filter [ #1 ] Predicate [ state = 'ca' OR state = 'ny' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT state FROM voter_1.votes ), Filter_2 AS ( SELECT 1 AS One FROM Scan_1 WHERE state = 'ca' OR state = 'ny' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM voter_1.votes  WHERE state = 'NY' OR state = 'CA'",
        "qd": "#1 = Scan the table Votes and retrieve the states of all votes ; #2 = Filter from #1 all the votes with states 'NY' or 'CA' and assign value 1 to each filtered record ; #3 = Aggregate the number of records of #2 and assign the result to Count_Star"
    },
    {
        "id": "5b137f43eb6a56ae4d554a5fbf6b1f1ad7fa607e9bad79dfc2d4daaba0ebdc2e",
        "question": "How many contestants did not get voted?",
        "query": "SELECT count ( * ) AS Count_Star FROM voter_1.contestants WITH (FORCESCAN) WHERE contestant_number NOT IN ( SELECT contestant_number FROM voter_1.votes WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ CONTESTANTS ] Output [ contestant_number ] ; #2 = Scan Table [ VOTES ] Output [ contestant_number ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.contestant_number = #1.contestant_number ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_number FROM voter_1.CONTESTANTS ), Scan_2 AS ( SELECT contestant_number FROM voter_1.VOTES ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE contestant_number NOT IN (SELECT contestant_number FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM voter_1.contestants  WHERE contestant_number NOT IN ( SELECT contestant_number FROM voter_1.votes  )",
        "qd": "#1 = Scan the table CONTESTANTS and retrieve the contestant numbers of all contestants. ; #2 = Scan the table VOTES and retrieve the contestant numbers of all votes. ; #3 = Find all the contestant numbers from #1 that are not present in #2 to find the contestants who did not get voted. ; #4 = Aggregate the count of all the contestant numbers in #3 to find the number of contestants who did not get voted."
    },
    {
        "id": "7f4d3002391a94f1350386c3c530f9f41872958aaab723ea73a778c124284968",
        "question": "What is the area code in which the most voters voted?",
        "query": "SELECT TOP 1 T1.area_code FROM voter_1.area_code_state AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.state = T2.state GROUP BY T1.area_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ VOTES ] Output [ state ] ; #2 = Aggregate [ #1 ] GroupBy [ state ] Output [ countstar AS Count_Star , state ] ; #3 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.state = #3.state ] Output [ #3.area_code , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ area_code , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT state FROM voter_1.VOTES ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, state FROM Scan_1 GROUP BY state ), Scan_3 AS ( SELECT area_code, state FROM voter_1.AREA_CODE_STATE ), Join_4 AS ( SELECT Scan_3.area_code, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.state = Scan_3.state ), TopSort_5 AS ( SELECT TOP 1 area_code, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.area_code FROM voter_1.area_code_state AS T1  JOIN voter_1.votes AS T2  ON T1.state = T2.state GROUP BY T1.area_code ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table VOTES and retrieve the states of all the voters. ; #2 = Group #1 by state and aggregate the count per state to find the number of voters in each state. ; #3 = Scan the table AREA_CODE_STATE and retrieve the area codes and states. ; #4 = Join #2 and #3 based on the matching state and retrieve the area code and the count of voters. ; #5 = Sort the records from #4 based on the count of voters in descending order, select the first record, and identify the area code in which the most voters voted and its count of voters."
    },
    {
        "id": "3ef872547c3c849b72137303c2397e4ddfa5620f0a8444b059405f38009ac1b5",
        "question": "What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?",
        "query": "SELECT T2.created , T2.state , T2.phone_number FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Tabatha Gehling' ] Output [ contestant_name , contestant_number ] ; #2 = Scan Table [ VOTES ] Output [ phone_number , created , state , contestant_number ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.contestant_number = #2.contestant_number ] Output [ #2.phone_number , #2.state , #2.created ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_name, contestant_number FROM voter_1.CONTESTANTS WHERE contestant_name = 'Tabatha Gehling' ), Scan_2 AS ( SELECT phone_number, created, state, contestant_number FROM voter_1.VOTES ), Join_3 AS ( SELECT Scan_2.phone_number, Scan_2.state, Scan_2.created FROM Scan_1 JOIN Scan_2 ON Scan_1.contestant_number = Scan_2.contestant_number ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.created , T2.state , T2.phone_number FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'",
        "qd": "#1 = Scan the table CONTESTANTS and retrieve the contestant name and number for the contestant named 'Tabatha Gehling' ; #2 = Scan the table VOTES and retrieve the phone number, create date, state, and contestant number for all votes ; #3 = Join #1 and #2 based on the matching contestant number and retrieve the phone number, state, and create date of the votes for the contestant named 'Tabatha Gehling'"
    },
    {
        "id": "997a9d9b23d45ca4e3b077ba7f5a6f03f5475311200c92805f200366cfc56736",
        "question": "List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
        "query": "SELECT T3.area_code FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3 WITH (FORCESCAN) ON T2.state = T3.state WHERE T1.contestant_name = 'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3 WITH (FORCESCAN) ON T2.state = T3.state WHERE T1.contestant_name = 'Kelly Clauss' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #2 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Tabatha Gehling' ] Output [ contestant_name , contestant_number ] ; #3 = Scan Table [ VOTES ] Output [ contestant_number , state ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.contestant_number = #3.contestant_number ] Output [ #3.state ] ; #5 = Intersect [ #1 , #4 ] Predicate [ #4.state = #1.state ] Output [ #1.area_code ] ; #6 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Kelly Clauss' ] Output [ contestant_name , contestant_number ] ; #7 = Scan Table [ VOTES ] Output [ contestant_number , state ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.contestant_number = #7.contestant_number ] Output [ #7.state ] ; #9 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.state = #9.state ] Output [ #9.area_code ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.area_code = #10.area_code ] Output [ #5.area_code ]",
        "cte": "WITH Scan_1 AS ( SELECT area_code, state FROM voter_1.AREA_CODE_STATE ), Scan_2 AS ( SELECT contestant_name, contestant_number FROM voter_1.CONTESTANTS WHERE contestant_name = 'Tabatha Gehling' ), Scan_3 AS ( SELECT contestant_number, state FROM voter_1.VOTES ), Join_4 AS ( SELECT Scan_3.state FROM Scan_2 JOIN Scan_3 ON Scan_2.contestant_number = Scan_3.contestant_number ), Intersect_5 AS ( SELECT Scan_1.area_code FROM Scan_1 WHERE state IN (SELECT state FROM Join_4) ), Scan_6 AS ( SELECT contestant_name, contestant_number FROM voter_1.CONTESTANTS WHERE contestant_name = 'Kelly Clauss' ), Scan_7 AS ( SELECT contestant_number, state FROM voter_1.VOTES ), Join_8 AS ( SELECT Scan_7.state FROM Scan_6 JOIN Scan_7 ON Scan_6.contestant_number = Scan_7.contestant_number ), Scan_9 AS ( SELECT area_code, state FROM voter_1.AREA_CODE_STATE ), Join_10 AS ( SELECT Scan_9.area_code FROM Join_8 JOIN Scan_9 ON Join_8.state = Scan_9.state ), Intersect_11 AS ( SELECT Intersect_5.area_code FROM Intersect_5 WHERE area_code IN (SELECT area_code FROM Join_10) ) SELECT * FROM Intersect_11",
        "clean_query": "SELECT T3.area_code FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3  ON T2.state = T3.state WHERE T1.contestant_name = 'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3  ON T2.state = T3.state WHERE T1.contestant_name = 'Kelly Clauss'",
        "qd": "#1 = Scan the table AREA_CODE_STATE and retrieve the area codes and states ; #2 = Scan the table CONTESTANTS and retrieve the contestant name and number of the contestant 'Tabatha Gehling' ; #3 = Scan the table VOTES and retrieve the contestant number and state of all votes ; #4 = Join #2 and #3 based on the matching contestant number and retrieve the states ; #5 = Find the area codes from #1 where voters voted for the contestant 'Tabatha Gehling' ; #6 = Scan the table CONTESTANTS and retrieve the contestant name and number of the contestant 'Kelly Clauss' ; #7 = Scan the table VOTES and retrieve the contestant number and state of all votes ; #8 = Join #6 and #7 based on the matching contestant number and retrieve the states ; #9 = Scan the table AREA_CODE_STATE and retrieve the area codes and states ; #10 = Join #8 and #9 based on the matching states and retrieve the area codes ; #11 = Find the area codes from #5 that are common with #10 and retrieve the area codes where voters voted for both the contestants 'Tabatha Gehling' and 'Kelly Clauss'"
    },
    {
        "id": "375f05a7144b42b7b01a5557989bdde5fbf222a82089e659eb469e04e6091ddb",
        "question": "Return the names of the contestants whose names contain the substring 'Al' .",
        "query": "select contestant_name FROM voter_1.contestants WITH (FORCESCAN) where contestant_name like '%al%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "voter_1 | #1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name like '%al%' ] Output [ contestant_name ]",
        "cte": "WITH Scan_1 AS ( SELECT contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name like '%al%' ) SELECT * FROM Scan_1",
        "clean_query": "select contestant_name FROM voter_1.contestants  where contestant_name like '%al%'",
        "qd": "#1 = Scan the table Contestants to find the names of contestants whose names contain the substring 'Al'"
    },
    {
        "id": "cbf9f39d623b23fe3ba8c7aa545d5a25e98577e97afccb06037e8b79412519ea",
        "question": "What are the names of all the countries that became independent after 1950?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE IndepYear > 1950 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear > 1950 ] Output [ Name , IndepYear ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, IndepYear FROM world_1.country WHERE IndepYear > 1950 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM world_1.country  WHERE IndepYear > 1950",
        "qd": "#1 = Scan the table country and retrieve the names and independence years of all the countries that became independent after 1950."
    },
    {
        "id": "1c36e57f9f01e92d2e032a36e5bd1662f81d141e75079ff1d91e1611247d3278",
        "question": "Give the names of the nations that were founded after 1950.",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE IndepYear > 1950 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear > 1950 ] Output [ Name , IndepYear ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, IndepYear FROM world_1.country WHERE IndepYear > 1950 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM world_1.country  WHERE IndepYear > 1950",
        "qd": "#1 = Scan the table country and retrieve the names and independence years of all nations that were founded after 1950."
    },
    {
        "id": "eda66e735c51570820c08ac218e6aa49fb6d80f3b459827f5ebb9b608188d08f",
        "question": "How many countries have a republic as their form of government?",
        "query": "SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm FROM world_1.country WHERE GovernmentForm = 'Republic' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE GovernmentForm = 'Republic'",
        "qd": "#1 = Scan the table country and retrieve the government form of all countries with 'Republic' as their form of government.  ; #2 = Aggregate the count of records from #1 to find the number of countries that have a republic as their form of government."
    },
    {
        "id": "4f0586d6a811c9dd3d73bdee44c39fc23377c7738abf1a2060ccbab35237dec4",
        "question": "How many countries have governments that are republics?",
        "query": "SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm FROM world_1.country WHERE GovernmentForm = 'Republic' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE GovernmentForm = 'Republic'",
        "qd": "#1 = Scan the table country and retrieve the records where the government form is 'Republic' ; #2 = Aggregate the number of records from #1 and output the count as the total number of countries that have governments that are republics."
    },
    {
        "id": "42e2d31ab3ab8660506a198d447bbeb3fe7a87e3dd1ce9a1ef067e3a6612d09f",
        "question": "What is the total surface area of the countries in the Caribbean region?",
        "query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Caribbean' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Caribbean' ] Output [ SurfaceArea , Region ] ; #2 = Aggregate [ #1 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Region FROM world_1.country WHERE Region = 'Caribbean' ), Aggregate_2 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Region = 'Caribbean'",
        "qd": "#1 = Scan the table country and retrieve the surface area and region of all countries in the Caribbean region. ; #2 = Aggregate the sum of surface areas from #1 to find the total surface area of the countries in the Caribbean region."
    },
    {
        "id": "9b0b35fe9d58a109152308667dfc887aad2df9802bb5be1a0a5a212734da450d",
        "question": "How much surface area do the countires in the Carribean cover together?",
        "query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Caribbean' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Caribbean' ] Output [ SurfaceArea , Region ] ; #2 = Aggregate [ #1 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Region FROM world_1.country WHERE Region = 'Caribbean' ), Aggregate_2 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Region = 'Caribbean'",
        "qd": "#1 = Scan the table country and retrieve the surface area and region of all countries ; #2 = Aggregate the sum of the surface area from #1 to find the total surface area covered by countries in the Caribbean"
    },
    {
        "id": "3193d5beb7c66a6847f2c9dbe3f4f3078a8c1d60b15e1d257646ae05dc950b32",
        "question": "Which continent is Anguilla in?",
        "query": "SELECT Continent FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Anguilla' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Anguilla' ] Output [ Name , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Continent FROM world_1.country WHERE Name = 'Anguilla' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Continent FROM world_1.country  WHERE Name = 'Anguilla'",
        "qd": "#1 = Scan the table country and retrieve the name and continent of the country with the name 'Anguilla'"
    },
    {
        "id": "90a8fb09639d78d2f2cca85fcc342eebec55dbb742658bab91e55d242e256e6b",
        "question": "What is the continent name which Anguilla belongs to?",
        "query": "SELECT Continent FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Anguilla' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Anguilla' ] Output [ Name , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Continent FROM world_1.country WHERE Name = 'Anguilla' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Continent FROM world_1.country  WHERE Name = 'Anguilla'",
        "qd": "#1 = Scan the table country and retrieve the name and continent of the country with the name 'Anguilla'."
    },
    {
        "id": "a7077b7a0f70fac078e95093cec8fb26d721a60f9c4c08398d4592e55fcb39c8",
        "question": "Which region is the city Kabul located in?",
        "query": "SELECT Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ city ] Predicate [ Name = 'Kabul' ] Output [ Name , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Region ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, CountryCode FROM world_1.city WHERE Name = 'Kabul' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
        "clean_query": "SELECT Region FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'",
        "qd": "#1 = Scan the table city and retrieve the name and country code of the city Kabul ; #2 = Scan the table country and retrieve the region and code of all countries ; #3 = Join #1 and #2 based on the matching country code and retrieve the region where the city Kabul is located"
    },
    {
        "id": "f13ab0950e935045b8c2cf6da9d54577f46a2563067fbd21c9f82411262a20ba",
        "question": "What region is Kabul in?",
        "query": "SELECT Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ city ] Predicate [ Name = 'Kabul' ] Output [ Name , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Region ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, CountryCode FROM world_1.city WHERE Name = 'Kabul' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
        "clean_query": "SELECT Region FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'",
        "qd": "#1 = Scan the table city and retrieve the name and country code of the city with the name 'Kabul' ; #2 = Scan the table country and retrieve the region and code of all countries ; #3 = Join #1 and #2 based on the matching country code and retrieve the region"
    },
    {
        "id": "b42c56ca3986518a42d21d9a1861a788415493c0260395d2d232b10d6da2bb65",
        "question": "Which language is the most popular in Aruba?",
        "query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , Percentage , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Percentage , #2.Language ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Percentage DESC ] Output [ Language , Percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT Language, Percentage, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Percentage, Scan_2.Language FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Language, Percentage FROM Join_3 ORDER BY Percentage DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC",
        "qd": "#1 = Scan the table country and retrieve the name and code of the country Aruba. ; #2 = Scan the table countrylanguage and retrieve the languages and percentages of all countries. ; #3 = Join #1 and #2 based on the matching country code and retrieve the language and percentage of Aruba. ; #4 = Sort the records from #3 based on the percentage in descending order, select the first record, and identify the language that is the most popular in Aruba and its percentage."
    },
    {
        "id": "1e42d2900c9e527b66357dcab22aba24c3b4847d0413b659e3577639518175f7",
        "question": "What language is predominantly spoken in Aruba?",
        "query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , Percentage , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Percentage , #2.Language ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Percentage DESC ] Output [ Language , Percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT Language, Percentage, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Percentage, Scan_2.Language FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Language, Percentage FROM Join_3 ORDER BY Percentage DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC",
        "qd": "#1 = Scan the table country to find the country with name Aruba and retrieve its name and code. ; #2 = Scan the table countrylanguage and retrieve the languages, percentages, and country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the languages and percentages. ; #4 = Sort the records from #3 based on the percentage in descending order, select the first record, and identify the language that is predominantly spoken in Aruba and its percentage."
    },
    {
        "id": "eaf31b9958df56510060b3166c48aad13728255fcd5fe25e6770bd3b14055dc6",
        "question": "What are the population and life expectancies in Brazil?",
        "query": "SELECT Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Brazil' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Brazil' ] Output [ Name , LifeExpectancy , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, LifeExpectancy, Population FROM world_1.country WHERE Name = 'Brazil' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Population , LifeExpectancy FROM world_1.country  WHERE Name = 'Brazil'",
        "qd": "#1 = Scan the table country to find the population and life expectancy of Brazil."
    },
    {
        "id": "02ea3ce3c1ca33852d94e1ec67b4c4456820afff93824fb3d341ce5c6c667d45",
        "question": "Give me Brazil\u2019s population and life expectancies.",
        "query": "SELECT Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Brazil' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Brazil' ] Output [ Name , LifeExpectancy , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, LifeExpectancy, Population FROM world_1.country WHERE Name = 'Brazil' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Population , LifeExpectancy FROM world_1.country  WHERE Name = 'Brazil'",
        "qd": "#1 = Scan the table country and retrieve the name, life expectancy, and population of Brazil."
    },
    {
        "id": "e1606375d3c23c6a2f2818d49e782b1425a672757cbc62f62375fa926d4a216c",
        "question": "What are the region and population of Angola?",
        "query": "SELECT Population , Region FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Angola' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Angola' ] Output [ Name , Region , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Region, Population FROM world_1.country WHERE Name = 'Angola' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Population , Region FROM world_1.country  WHERE Name = 'Angola'",
        "qd": "#1 = Scan the table country to find the records with the country name 'Angola' and retrieve the region and population of Angola."
    },
    {
        "id": "7956562de86b573a31dfeb98d0b90656fb45a70318182803401388262c78da8b",
        "question": "What region does Angola belong to and what is its population?",
        "query": "SELECT Population , Region FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Angola' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Angola' ] Output [ Name , Region , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Region, Population FROM world_1.country WHERE Name = 'Angola' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Population , Region FROM world_1.country  WHERE Name = 'Angola'",
        "qd": "#1 = Scan the table country to find the region and population of Angola"
    },
    {
        "id": "447bf0c569ae8d2fdba890134e396060901e148955b831579e829629ea319d33",
        "question": "What is the average expected life expectancy for countries in the region of Central Africa?",
        "query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Central Africa' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Central Africa' ] Output [ Region , LifeExpectancy ] ; #2 = Aggregate [ #1 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT Region, LifeExpectancy FROM world_1.country WHERE Region = 'Central Africa' ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Region = 'Central Africa'",
        "qd": "#1 = Scan the table country to find countries in the region of Central Africa and retrieve their region and life expectancy. ; #2 = Calculate the average life expectancy of the countries in #1 and retrieve the average as Avg_LifeExpectancy."
    },
    {
        "id": "ead8406fcf8f5ac508a3fa2fee7f4eadfc597b2934367ddaa29a95d3b2a7a0ab",
        "question": "How long is the people\u2019s average life expectancy in Central Africa?",
        "query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Central Africa' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Central Africa' ] Output [ Region , LifeExpectancy ] ; #2 = Aggregate [ #1 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT Region, LifeExpectancy FROM world_1.country WHERE Region = 'Central Africa' ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Region = 'Central Africa'",
        "qd": "#1 = Scan the table country and retrieve the region and life expectancy of all countries in Central Africa ; #2 = Calculate the average life expectancy from the records in #1 and retrieve the average life expectancy of the people in Central Africa"
    },
    {
        "id": "b6dbcf35e637466fb878964b2ca6759c7d8c27b687b8e18916214f47b4fb9708",
        "question": "What is the name of country that has the shortest life expectancy in Asia?",
        "query": "SELECT TOP 1 Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY LifeExpectancy OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , LifeExpectancy , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ LifeExpectancy ASC ] Output [ Name , LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, LifeExpectancy, Continent FROM world_1.country ), Filter_2 AS ( SELECT Name, LifeExpectancy FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, LifeExpectancy FROM Filter_2 ORDER BY LifeExpectancy ASC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Name FROM world_1.country  WHERE Continent = 'Asia' ORDER BY LifeExpectancy",
        "qd": "#1 = Scan the table country and retrieve the names, life expectancy, and continents of all countries ; #2 = Filter from #1 all the countries with an Asian continent and retrieve the names and life expectancy ; #3 = Sort the records from #2 based on the life expectancy in ascending order, select the first record, and identify the name of the country with the shortest life expectancy in Asia"
    },
    {
        "id": "6c9d0187eaa14d3822b76fab25575f0bd029a4aae739341d09c7aa944fbb9678",
        "question": "Give the name of the country in Asia with the lowest life expectancy.",
        "query": "SELECT TOP 1 Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY LifeExpectancy OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , LifeExpectancy , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ LifeExpectancy ASC ] Output [ Name , LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, LifeExpectancy, Continent FROM world_1.country ), Filter_2 AS ( SELECT Name, LifeExpectancy FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, LifeExpectancy FROM Filter_2 ORDER BY LifeExpectancy ASC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Name FROM world_1.country  WHERE Continent = 'Asia' ORDER BY LifeExpectancy",
        "qd": "#1 = Scan the table country and retrieve the names, life expectancies, and continents of all countries ; #2 = Filter from #1 all the countries with Asia continent and retrieve the names and life expectancies ; #3 = Sort the records from #2 based on the life expectancy in ascending order, select the first record, and identify the name of the country in Asia with the lowest life expectancy"
    },
    {
        "id": "ad1402fa95fd3fadae44e208dbad1503f63f97dff7c87df4e4ad632bf12f911b",
        "question": "What is the total population and maximum GNP in Asia?",
        "query": "SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ GNP , Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ GNP , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , MAX(GNP) AS Max_GNP ]",
        "cte": "WITH Scan_1 AS ( SELECT GNP, Population, Continent FROM world_1.country ), Filter_2 AS ( SELECT GNP, Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, MAX(GNP) AS Max_GNP FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country  WHERE Continent = 'Asia'",
        "qd": "#1 = Scan the table country and retrieve the GNP, population, and continent of all countries ; #2 = Filter from #1 all the countries with the continent Asia and retrieve the GNP and population ; #3 = Aggregate the sum of the population and the maximum GNP from #2 to find the total population and maximum GNP in Asia"
    },
    {
        "id": "a063d955c79fd05ec31becccdbd310b4bc3d29e965130d1e7c2b89b7f0e3e1b2",
        "question": "How many people live in Asia, and what is the largest GNP among them?",
        "query": "SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ GNP , Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ GNP , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , MAX(GNP) AS Max_GNP ]",
        "cte": "WITH Scan_1 AS ( SELECT GNP, Population, Continent FROM world_1.country ), Filter_2 AS ( SELECT GNP, Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, MAX(GNP) AS Max_GNP FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country  WHERE Continent = 'Asia'",
        "qd": "#1 = Scan the table country and retrieve the GNP, population, and continent of all countries ; #2 = Filter from #1 all the countries with Asia continent and retrieve the GNP and population ; #3 = Aggregate the sum of population and the maximum GNP from #2 to find the total population of Asia and the largest GNP among the countries in Asia"
    },
    {
        "id": "a413d0d9c13eaf0c7ba05ab34db24918f93f106adeb3d8c794efab911446ac22",
        "question": "What is the average life expectancy in African countries that are republics?",
        "query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , LifeExpectancy , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ LifeExpectancy ] ; #3 = Aggregate [ #2 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, LifeExpectancy, Continent FROM world_1.country WHERE GovernmentForm = 'Republic' ), Filter_2 AS ( SELECT LifeExpectancy FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'",
        "qd": "#1 = Scan the table country and retrieve the government form, life expectancy, and continent of all countries that are republics ; #2 = Filter from #1 all the countries with Africa continent and retrieve the life expectancy ; #3 = Calculate the average value of life expectancy from #2 and retrieve the average life expectancy in African countries that are republics"
    },
    {
        "id": "48d3b1951efeabcc1977bdb8ee2d1140c1f13dd2d22d9335243284834c4c12e1",
        "question": "Give the average life expectancy for countries in Africa which are republics?",
        "query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , LifeExpectancy , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ LifeExpectancy ] ; #3 = Aggregate [ #2 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, LifeExpectancy, Continent FROM world_1.country WHERE GovernmentForm = 'Republic' ), Filter_2 AS ( SELECT LifeExpectancy FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'",
        "qd": "#1 = Scan the table country and retrieve the government form, life expectancy, and continent of all countries that are republics ; #2 = Filter from #1 all the countries with Africa continent and retrieve the life expectancy ; #3 = Calculate the average life expectancy from #2 and retrieve the result as the average life expectancy for countries in Africa which are republics"
    },
    {
        "id": "6cc665c83afd60499ff4e24745c41e5fb4724d43e9409a2e72f07d8b013a4814",
        "question": "What is the total surface area of the continents Asia and Europe?",
        "query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OR Continent = 'Europe' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' OR Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Asia' OR Continent = 'Europe' ), Aggregate_3 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Continent = 'Asia' OR Continent = 'Europe'",
        "qd": "#1 = Scan the table country and retrieve the surface area and continent of all countries. ; #2 = Filter the records from #1 to find the countries with continent either Asia or Europe and retrieve the surface area. ; #3 = Aggregate the sum of surface areas from #2 to find the total surface area of the continents Asia and Europe."
    },
    {
        "id": "86c55881b46a5a574126c33dc389f48f0015abfa067f0bf84d197424dcfeab3f",
        "question": "Give the total surface area covered by countries in Asia or Europe.",
        "query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OR Continent = 'Europe' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' OR Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Asia' OR Continent = 'Europe' ), Aggregate_3 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Continent = 'Asia' OR Continent = 'Europe'",
        "qd": "#1 = Scan the table country and retrieve the surface area and continent of all countries. ; #2 = Filter from #1 all the countries with continent Asia or Europe and retrieve the surface area. ; #3 = Aggregate the sum of surface areas from #2 to find the total surface area covered by countries in Asia or Europe."
    },
    {
        "id": "87a14e66e6e77a9297169720ad579f780bf39faa6d4b05b82771e1e62f75d873",
        "question": "How many people live in Gelderland district?",
        "query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.city WITH (FORCESCAN) WHERE District = 'Gelderland' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ city ] Predicate [ District = 'Gelderland' ] Output [ Population , District ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Population, District FROM world_1.city WHERE District = 'Gelderland' ), Aggregate_2 AS ( SELECT SUM(Population) AS Sum_Population FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.city  WHERE District = 'Gelderland'",
        "qd": "#1 = Scan the table city and retrieve the population and district of all cities ; #2 = Aggregate the sum of population from #1 to find the total number of people living in Gelderland district"
    },
    {
        "id": "d63af966914473b096de571cad64b5b43edd5043e710afc66f28430d0095ca9b",
        "question": "What is the total population of Gelderland district?",
        "query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.city WITH (FORCESCAN) WHERE District = 'Gelderland' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ city ] Predicate [ District = 'Gelderland' ] Output [ Population , District ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Population, District FROM world_1.city WHERE District = 'Gelderland' ), Aggregate_2 AS ( SELECT SUM(Population) AS Sum_Population FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.city  WHERE District = 'Gelderland'",
        "qd": "#1 = Scan the table city and retrieve the population of all cities in the Gelderland district ; #2 = Aggregate the sum of population to find the total population of the Gelderland district"
    },
    {
        "id": "b08ef71ef93254d405738b9cd0374cff3985ee5e36c497a19f987ccff4384b5f",
        "question": "What is the average GNP and total population in all nations whose government is US territory?",
        "query": "SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'US Territory' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'US Territory' ] Output [ GovernmentForm , GNP , Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(GNP) AS Avg_GNP , SUM(Population) AS Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, GNP, Population FROM world_1.country WHERE GovernmentForm = 'US Territory' ), Aggregate_2 AS ( SELECT AVG(GNP) AS Avg_GNP, SUM(Population) AS Sum_Population FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country  WHERE GovernmentForm = 'US Territory'",
        "qd": "#1 = Scan the table country to find the nations with a government form of US Territory and retrieve the GNP and population of each nation. ; #2 = Aggregate the records from #1 to calculate the average GNP and the total population of the nations with a government form of US Territory."
    },
    {
        "id": "38149da0bf176f61c70db72f6915039e6dee7a9e184475459d86407d032bdf3d",
        "question": "Give the mean GNP and total population of nations which are considered US territory.",
        "query": "SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'US Territory' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'US Territory' ] Output [ GovernmentForm , GNP , Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(GNP) AS Avg_GNP , SUM(Population) AS Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, GNP, Population FROM world_1.country WHERE GovernmentForm = 'US Territory' ), Aggregate_2 AS ( SELECT AVG(GNP) AS Avg_GNP, SUM(Population) AS Sum_Population FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country  WHERE GovernmentForm = 'US Territory'",
        "qd": "#1 = Scan the table country and retrieve the government form, GNP, and population of all countries ; #2 = Filter from #1 all the countries with the government form 'US Territory' and retrieve the GNP and population ; #3 = Calculate the average GNP and sum of population for all the countries from #2"
    },
    {
        "id": "0107b0ffdcc55beb72507d69c0c32359b7bb551e3bcd2bac2dfb332b5809dc57",
        "question": "How many unique languages are spoken in the world?",
        "query": "SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Distinct [ true ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage",
        "qd": "#1 = Scan the table countrylanguage and retrieve all distinct languages spoken ; #2 = Aggregate the count of distinct languages to find the total number of unique languages spoken in the world"
    },
    {
        "id": "3c4d21d33530da607dd924e2bc3544cedcadf73d4cfb0e585c45b6a36baf5b23",
        "question": "What is the number of distinct languages used around the world?",
        "query": "SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Distinct [ true ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage",
        "qd": "#1 = Scan the table countrylanguage and retrieve all distinct languages used around the world ; #2 = Aggregate the count of distinct languages to find the number of distinct languages used around the world"
    },
    {
        "id": "40e5da0fbd145acd54d3d006d747228d77045559ef4773caa086c8734be6f556",
        "question": "How many type of governments are in Africa?",
        "query": "SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ GovernmentForm , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Distinct [ true ] Output [ GovernmentForm ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, Continent FROM world_1.country ), Filter_2 AS ( SELECT DISTINCT GovernmentForm FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country  WHERE Continent = 'Africa'",
        "qd": "#1 = Scan the table country and retrieve the government form and continent of all countries ; #2 = Filter from #1 all the countries with Africa continent and retrieve the distinct government forms ; #3 = Aggregate the count of distinct government forms in #2 and retrieve the total number of governments in Africa"
    },
    {
        "id": "c806b535829c219151ad9a84fea53ee58667be3b934659c7d28adde55c6b46f0",
        "question": "How many different forms of governments are there in Africa?",
        "query": "SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ GovernmentForm , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Distinct [ true ] Output [ GovernmentForm ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, Continent FROM world_1.country ), Filter_2 AS ( SELECT DISTINCT GovernmentForm FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country  WHERE Continent = 'Africa'",
        "qd": "#1 = Scan the table country and retrieve the government forms and continents of all countries ; #2 = Filter from #1 all the countries with the continent 'Africa' and retrieve the distinct government forms ; #3 = Aggregate the count of distinct government forms in #2 and retrieve the number of different forms of governments in Africa"
    },
    {
        "id": "26ad51ff8d130d2aa117e8cb6d7ef07ce38bfbc418daa39207a4140fd1f93afa",
        "question": "What is the total number of languages used in Aruba?",
        "query": "SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Code , #1.Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba'",
        "qd": "#1 = Scan the table country and retrieve the name and code of the country Aruba ; #2 = Scan the table countrylanguage and retrieve all country codes ; #3 = Join #1 and #2 based on the matching country code and retrieve the country code and name ; #4 = Aggregate the number of records in #3 to find the total number of languages used in Aruba"
    },
    {
        "id": "a1757bd28d3c99a6d0f79e9427ace21cf824ba79417c1559f8b20ff238b12c32",
        "question": "How many languages are spoken in Aruba?",
        "query": "SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Code , #1.Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba'",
        "qd": "#1 = Scan the table country and retrieve the name and code of the country with the name 'Aruba' ; #2 = Scan the table countrylanguage and retrieve all the country codes ; #3 = Join #1 and #2 based on the matching country code and retrieve the country code and name ; #4 = Aggregate the number of records in #3 to find the count of languages spoken in Aruba."
    },
    {
        "id": "2d5af1ae79c1eadb9a64c4e4ee431c883c34d42643e1275086b93079bebd1da4",
        "question": "How many official languages does Afghanistan have?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Afghanistan' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #1.Code , #1.Name ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Afghanistan' ), Scan_2 AS ( SELECT IsOfficial, CountryCode FROM world_1.countrylanguage ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T'",
        "qd": "#1 = Scan the table country and retrieve the country name and code of Afghanistan ; #2 = Scan the table countrylanguage and retrieve the IsOfficial and CountryCode of all languages ; #3 = Filter from #2 all the languages that are official ; #4 = Join #1 and #3 based on the matching country code and retrieve the country code and name ; #5 = Aggregate the number of records in #4 to find the count of official languages Afghanistan has"
    },
    {
        "id": "fcb55729d495351ebf7cd2023a68b2f96ba3ef9f97bf285aa825d8e40b9fb5b0",
        "question": "How many official languages are spoken in Afghanistan?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Afghanistan' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #1.Code , #1.Name ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Afghanistan' ), Scan_2 AS ( SELECT IsOfficial, CountryCode FROM world_1.countrylanguage ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T'",
        "qd": "#1 = Scan the table country to find the code and name of Afghanistan ; #2 = Scan the table countrylanguage and retrieve the official languages spoken in each country ; #3 = Filter from #2 all the records with IsOfficial equal to 'T' (true) to find the official languages ; #4 = Join #1 and #3 based on the matching country code and retrieve the country code and name ; #5 = Aggregate the count of records from #4 to find the number of official languages spoken in Afghanistan"
    },
    {
        "id": "6f2b7f8fdc2f6cbf4c2b61688a16fbb31573f8fc967ef5acad0f68f46876e896",
        "question": "What is name of the country that speaks the largest number of languages?",
        "query": "SELECT TOP 1 T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table country and retrieve the names and codes of all countries. ; #2 = Scan the table countrylanguage and retrieve all country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the names of the countries. ; #4 = Group #3 by name and aggregate the count per name to find the number of languages spoken in each country. ; #5 = Sort the records from #4 based on the count of languages in descending order, select the first record, and identify the name of the country that speaks the largest number of languages and its count of languages."
    },
    {
        "id": "4bd4410da025c4c92f23a5169756fb4e81a8495682cd19482dd9e8f84a988855",
        "question": "Give the name of the nation that uses the greatest amount of languages.",
        "query": "SELECT TOP 1 T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table country and retrieve the names and codes of all nations. ; #2 = Scan the table countrylanguage and retrieve all country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the names of the nations. ; #4 = Group #3 by name and aggregate the count per name to find the number of languages used by each nation. ; #5 = Sort the records from #4 based on the count of languages used in descending order, select the first record, and identify the name of the nation that uses the greatest amount of languages and the count of languages."
    },
    {
        "id": "196aa60352af0cf7e4ef042eadf2f963c0c3073019e762a018959cca24f67b02",
        "question": "Which continent has the most diverse languages?",
        "query": "SELECT TOP 1 T1.Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Code , Continent ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Continent ] ; #4 = Aggregate [ #3 ] GroupBy [ Continent ] Output [ countstar AS Count_Star , Continent ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT Code, Continent FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, Continent FROM Join_3 GROUP BY Continent ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Continent FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table country and retrieve the country codes and continents of all countries. ; #2 = Scan the table countrylanguage and retrieve all country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the continents. ; #4 = Group #3 by continent and aggregate the count per continent to find the number of languages in each continent. ; #5 = Sort the records from #4 based on the count of languages in descending order, select the first record, and identify the continent with the most diverse languages."
    },
    {
        "id": "7ddb8484384a410a4ee334b2add390a2c95c81ba0d19f7b4fce4db288fef6f2b",
        "question": "Which continent speaks the most languages?",
        "query": "SELECT TOP 1 T1.Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Code , Continent ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Continent ] ; #4 = Aggregate [ #3 ] GroupBy [ Continent ] Output [ countstar AS Count_Star , Continent ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT Code, Continent FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, Continent FROM Join_3 GROUP BY Continent ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Continent FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table country and retrieve the country codes and continents of all countries. ; #2 = Scan the table countrylanguage and retrieve all country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the continents. ; #4 = Group #3 by continent and aggregate the count per continent to find the number of languages spoken in each continent. ; #5 = Sort the records from #4 based on the count of languages in descending order, select the first record, and identify the continent that speaks the most languages and the count of languages."
    },
    {
        "id": "fdfea30a058eb1515bcf094ea6132c66bcd901c2ecc1be5f888c488c81485f8e",
        "question": "How many countries speak both English and Dutch?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ CountryCode , Language ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Distinct [ true ] Output [ #1.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ CountryCode , Language ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.CountryCode = #4.Code ] Distinct [ true ] Output [ #4.Name ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Distinct [ true ] Output [ #3.Name ] ; #8 = Aggregate [ #7 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'english' ), Join_3 AS ( SELECT DISTINCT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_2.CountryCode = Scan_1.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Scan_5 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'dutch' ), Join_6 AS ( SELECT DISTINCT Scan_4.Name FROM Scan_4 JOIN Scan_5 ON Scan_5.CountryCode = Scan_4.Code ), Join_7 AS ( SELECT DISTINCT Join_3.Name FROM Join_3 JOIN Join_6 ON Join_3.Name = Join_6.Name ), Aggregate_8 AS ( SELECT COUNT(*) AS Count_Star FROM Join_7 ) SELECT * FROM Aggregate_8",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10",
        "qd": "#1 = Scan the table country and retrieve the names and codes of all countries ; #2 = Scan the table countrylanguage and retrieve the country codes of all countries where English is spoken ; #3 = Join #1 and #2 based on the matching country code and retrieve the names of countries where English is spoken ; #4 = Scan the table country and retrieve the names and codes of all countries ; #5 = Scan the table countrylanguage and retrieve the country codes of all countries where Dutch is spoken ; #6 = Join #4 and #5 based on the matching country code and retrieve the names of countries where Dutch is spoken ; #7 = Join #3 and #6 based on matching country names to find the countries that speak both English and Dutch ; #8 = Aggregate the count of the records from #7 to find the number of countries that speak both English and Dutch"
    },
    {
        "id": "b23e766b20d801d1a7c381585433382250fd7b37aeabd1fa122e67c8d8381468",
        "question": "What is the number of nations that use English and Dutch?",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ CountryCode , Language ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Distinct [ true ] Output [ #1.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ CountryCode , Language ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.CountryCode = #4.Code ] Distinct [ true ] Output [ #4.Name ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Distinct [ true ] Output [ #3.Name ] ; #8 = Aggregate [ #7 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'english' ), Join_3 AS ( SELECT DISTINCT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_2.CountryCode = Scan_1.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Scan_5 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'dutch' ), Join_6 AS ( SELECT DISTINCT Scan_4.Name FROM Scan_4 JOIN Scan_5 ON Scan_5.CountryCode = Scan_4.Code ), Join_7 AS ( SELECT DISTINCT Join_3.Name FROM Join_3 JOIN Join_6 ON Join_3.Name = Join_6.Name ), Aggregate_8 AS ( SELECT COUNT(*) AS Count_Star FROM Join_7 ) SELECT * FROM Aggregate_8",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10",
        "qd": "#1 = Scan the table country and retrieve the name and code of all countries. ; #2 = Scan the table countrylanguage and retrieve the country codes and language of all countries that use English. ; #3 = Join #1 and #2 based on the matching country code and retrieve the names of the countries that use English. ; #4 = Scan the table country and retrieve the name and code of all countries. ; #5 = Scan the table countrylanguage and retrieve the country codes and language of all countries that use Dutch. ; #6 = Join #4 and #5 based on the matching country code and retrieve the names of the countries that use Dutch. ; #7 = Join #3 and #6 based on the matching country names and retrieve the names of the countries that use both English and Dutch. ; #8 = Aggregate the number of records in #7 to find the number of nations that use both English and Dutch."
    },
    {
        "id": "5c61e85b2ff5cd14b865b09f64f10986de9093ff1ecd8910423dc80bd72b86ba",
        "question": "What are the names of nations speak both English and French?",
        "query": "SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Name , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Code , #2.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Name = #4.Name ] Output [ #3.Code , #3.Name ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.Code = #6.CountryCode ] Distinct [ true ] Output [ #5.Code , #5.Name ] ; #8 = Aggregate [ #7 ] GroupBy [ Name ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Scan_2 AS ( SELECT Name, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Code, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Join_5 AS ( SELECT Join_3.Code, Join_3.Name FROM Join_3 JOIN Scan_4 ON Join_3.Name = Scan_4.Name ), Scan_6 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Join_7 AS ( SELECT DISTINCT Join_5.Code, Join_5.Name FROM Join_5 JOIN Scan_6 ON Join_5.Code = Scan_6.CountryCode ), Aggregate_8 AS ( SELECT Name FROM Join_7 GROUP BY Name ) SELECT * FROM Aggregate_8",
        "clean_query": "SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes for countries that speak French ; #2 = Scan the table country and retrieve the names and codes of all countries ; #3 = Join #1 and #2 based on the matching country code and retrieve the codes and names of countries that speak French ; #4 = Scan the table country and retrieve the names and codes of all countries ; #5 = Join #3 and #4 based on the matching country name and retrieve the codes and names of countries that speak both languages ; #6 = Scan the table countrylanguage and retrieve the country codes for countries that speak English ; #7 = Join #5 and #6 based on the matching country code and retrieve the codes and names of countries that speak both English and French without duplicate ; #8 = Group #7 by country name and aggregate the count per name"
    },
    {
        "id": "fe1e4fc69d4dfc7f14ea8c7ccb0d3d686be08850c06a3118dbb5c2c166fec18d",
        "question": "Give the names of nations that speak both English and French.",
        "query": "SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Name , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Code , #2.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Name = #4.Name ] Output [ #3.Code , #3.Name ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.Code = #6.CountryCode ] Distinct [ true ] Output [ #5.Code , #5.Name ] ; #8 = Aggregate [ #7 ] GroupBy [ Name ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Scan_2 AS ( SELECT Name, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Code, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Join_5 AS ( SELECT Join_3.Code, Join_3.Name FROM Join_3 JOIN Scan_4 ON Join_3.Name = Scan_4.Name ), Scan_6 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Join_7 AS ( SELECT DISTINCT Join_5.Code, Join_5.Name FROM Join_5 JOIN Scan_6 ON Join_5.Code = Scan_6.CountryCode ), Aggregate_8 AS ( SELECT Name FROM Join_7 GROUP BY Name ) SELECT * FROM Aggregate_8",
        "clean_query": "SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'",
        "qd": "#1 = Scan the table countrylanguage and retrieve all the country codes where the language spoken is French. ; #2 = Scan the table country and retrieve the names and codes of all nations. ; #3 = Join #1 and #2 based on the matching country codes and retrieve the codes and names of nations that speak French. ; #4 = Scan the table country and retrieve the names and codes of all nations. ; #5 = Join #3 and #4 based on the matching names and retrieve the codes and names of nations that speak both English and French. ; #6 = Scan the table countrylanguage and retrieve all the country codes where the language spoken is English. ; #7 = Join #5 and #6 based on the matching country codes without duplicates and retrieve the codes and names of nations that speak both English and French. ; #8 = Group #7 by name to find the names of nations that speak both English and French."
    },
    {
        "id": "cf7eea7b6f50c57390d38c86939bf535a224b057c31c25a666208629c5ce7a00",
        "question": "What are the names of nations where both English and French are official languages?",
        "query": "SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Code , #3.Name ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Name = #5.Name ] Output [ #4.Name , #4.Code ] ; #7 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #8 = Filter [ #7 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #9 = Join [ #6 , #8 ] Predicate [ #6.Code = #8.CountryCode ] Distinct [ true ] Output [ #6.Code , #6.Name ] ; #10 = Aggregate [ #9 ] GroupBy [ Name ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 'T' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Code, Scan_3.Name FROM Filter_2 JOIN Scan_3 ON Filter_2.CountryCode = Scan_3.Code ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Join_6 AS ( SELECT Join_4.Name, Join_4.Code FROM Join_4 JOIN Scan_5 ON Join_4.Name = Scan_5.Name ), Scan_7 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_8 AS ( SELECT CountryCode FROM Scan_7 WHERE IsOfficial = 'T' ), Join_9 AS ( SELECT DISTINCT Join_6.Code, Join_6.Name FROM Join_6 JOIN Filter_8 ON Join_6.Code = Filter_8.CountryCode ), Aggregate_10 AS ( SELECT Name FROM Join_9 GROUP BY Name ) SELECT * FROM Aggregate_10",
        "clean_query": "SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes where French is an official language. ; #2 = Filter the records from #1 to only include the ones where French is an official language. ; #3 = Scan the table country and retrieve the names and codes of all nations. ; #4 = Join #2 and #3 based on the matching country codes and retrieve the names and codes of the nations where French is an official language. ; #5 = Scan the table country and retrieve the names and codes of all nations. ; #6 = Join #4 and #5 based on the matching names and retrieve the names and codes of the nations where French is an official language. ; #7 = Scan the table countrylanguage and retrieve the country codes where English is an official language. ; #8 = Filter the records from #7 to only include the ones where English is an official language. ; #9 = Join #6 and #8 based on the matching country codes and retrieve the unique names and codes of the nations where both French and English are official languages. ; #10 = Group the records from #9 by name and aggregate the count of each nation to find the names of all nations where both English and French are official languages."
    },
    {
        "id": "dc5f3fb7030d664528f7de029349056a952430b2c758a96323474d603b11c727",
        "question": "Give the names of countries with English and French as official languages.",
        "query": "SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Code , #3.Name ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Name = #5.Name ] Output [ #4.Name , #4.Code ] ; #7 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #8 = Filter [ #7 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #9 = Join [ #6 , #8 ] Predicate [ #6.Code = #8.CountryCode ] Distinct [ true ] Output [ #6.Code , #6.Name ] ; #10 = Aggregate [ #9 ] GroupBy [ Name ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 'T' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Code, Scan_3.Name FROM Filter_2 JOIN Scan_3 ON Filter_2.CountryCode = Scan_3.Code ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Join_6 AS ( SELECT Join_4.Name, Join_4.Code FROM Join_4 JOIN Scan_5 ON Join_4.Name = Scan_5.Name ), Scan_7 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_8 AS ( SELECT CountryCode FROM Scan_7 WHERE IsOfficial = 'T' ), Join_9 AS ( SELECT DISTINCT Join_6.Code, Join_6.Name FROM Join_6 JOIN Filter_8 ON Join_6.Code = Filter_8.CountryCode ), Aggregate_10 AS ( SELECT Name FROM Join_9 GROUP BY Name ) SELECT * FROM Aggregate_10",
        "clean_query": "SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the language, isOfficial, and country code for all records with French as the language ; #2 = Filter from #1 all the records with isOfficial as 'T' and retrieve the country code  ; #3 = Scan the table country and retrieve the names and codes of all countries ; #4 = Join #2 and #3 based on the matching country code and retrieve the codes and names ; #5 = Scan the table country and retrieve the names and codes of all countries ; #6 = Join #4 and #5 based on the matching names and retrieve the names and codes ; #7 = Scan the table countrylanguage and retrieve the language, isOfficial, and country code for all records with English as the language ; #8 = Filter from #7 all the records with isOfficial as 'T' and retrieve the country code  ; #9 = Join #6 and #8 based on the matching codes and retrieve the unique codes and names  ; #10 = Group #9 by name and retrieve the names."
    },
    {
        "id": "50b5150d0be2fb25fb3c75ba5f9efedab022b25ddecc1718f39ef2cd8d319782",
        "question": "What is the number of distinct continents where Chinese is spoken?",
        "query": "SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Code , Continent ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Continent ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Chinese' ), Scan_2 AS ( SELECT Code, Continent FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes where Chinese is spoken ; #2 = Scan the table country and retrieve the codes and continents of all countries ; #3 = Join #1 and #2 based on the matching country codes and retrieve the distinct continents ; #4 = Count the number of distinct continents in #3 to find the number of distinct continents where Chinese is spoken"
    },
    {
        "id": "caf62133487d41ae6c81bff1ac1282aecfff3503c87cfb30cb05002b66459a4f",
        "question": "How many continents speak Chinese?",
        "query": "SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Code , Continent ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Continent ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Chinese' ), Scan_2 AS ( SELECT Code, Continent FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese'",
        "qd": "#1 = Scan the table countrylanguage to find all the countries that speak Chinese and retrieve their language and country codes. ; #2 = Scan the table country and retrieve the country codes and continents of all countries. ; #3 = Join #1 and #2 based on the matching country code and retrieve the continents. ; #4 = Aggregate the number of unique continents in #3 to find how many continents speak Chinese."
    },
    {
        "id": "4951f1256981c4e699025f83ed4e0568f0da2b0adfeb2a539dc76094ae288c84",
        "question": "What are the regions that use English or Dutch?",
        "query": "SELECT DISTINCT T1.Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' OR Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Region ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Dutch' OR Language = 'English' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.Region FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the languages and country codes of all languages that are either English or Dutch. ; #2 = Scan the table country and retrieve the regions and country codes of all countries. ; #3 = Join #1 and #2 based on the matching country codes and retrieve the regions without duplicates."
    },
    {
        "id": "67897312488350728a9012ddf25e860149ea5ed4025d589030cc862639fddb39",
        "question": "Which regions speak Dutch or English?",
        "query": "SELECT DISTINCT T1.Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' OR Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Region ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Dutch' OR Language = 'English' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.Region FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the languages and country codes of all countries that speak Dutch or English ; #2 = Scan the table country and retrieve the regions and codes of all countries ; #3 = Join #1 and #2 based on the matching country codes and retrieve the regions without duplicates that speak Dutch or English"
    },
    {
        "id": "9613549d75cadf3aaf9e382df3277d0bf72df467f14c96d5783c19c5479f5f9b",
        "question": "What are the countries where either English or Dutch is the official language ?",
        "query": "select t1.name FROM world_1.country AS t1 WITH (FORCESCAN) join world_1.countrylanguage as t2 WITH (FORCESCAN) on t1.code = t2.countrycode where t2.language = 'english' and isofficial = 't' union select t1.name FROM world_1.country AS t1 WITH (FORCESCAN) join world_1.countrylanguage as t2 WITH (FORCESCAN) on t1.code = t2.countrycode where t2.language = 'dutch' and isofficial = 't' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ Language , IsOfficial , CountryCode ] ; #6 = Filter [ #5 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #7 = Scan Table [ country ] Output [ Name , Code ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.CountryCode = #7.Code ] Output [ #7.Name ] ; #9 = Union [ #4 , #8 ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'english' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 't' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Name FROM Filter_2 JOIN Scan_3 ON Filter_2.CountryCode = Scan_3.Code ), Scan_5 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'dutch' ), Filter_6 AS ( SELECT CountryCode FROM Scan_5 WHERE IsOfficial = 't' ), Scan_7 AS ( SELECT Name, Code FROM world_1.country ), Join_8 AS ( SELECT Scan_7.Name FROM Filter_6 JOIN Scan_7 ON Filter_6.CountryCode = Scan_7.Code ), Union_9 AS ( SELECT Name FROM Join_4 UNION SELECT Name FROM Join_8 ) SELECT * FROM Union_9",
        "clean_query": "select t1.name FROM world_1.country AS t1  join world_1.countrylanguage as t2  on t1.code = t2.countrycode where t2.language = 'english' and isofficial = 't' union select t1.name FROM world_1.country AS t1  join world_1.countrylanguage as t2  on t1.code = t2.countrycode where t2.language = 'dutch' and isofficial = 't'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the language, official status, and country code for English language ; #2 = Filter #1 to retrieve the country codes where English is the official language ; #3 = Scan the table country and retrieve the names and codes of all countries ; #4 = Join #2 and #3 based on the matching country codes and retrieve the country names ; #5 = Scan the table countrylanguage and retrieve the language, official status, and country code for Dutch language ; #6 = Filter #5 to retrieve the country codes where Dutch is the official language ; #7 = Scan the table country and retrieve the names and codes of all countries ; #8 = Join #6 and #7 based on the matching country codes and retrieve the country names ; #9 = Union the country names from #4 and #8 to get the names of the countries where either English or Dutch is the official language."
    },
    {
        "id": "5f6c5c97e4535a57a648be9149e33db7045c08bc96516c2e753c41f04e1e2583",
        "question": "Which countries have either English or Dutch as an official language?",
        "query": "SELECT * FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND IsOfficial = 'T' UNION SELECT * FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' AND IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Code2 , Region , IndepYear , HeadOfState , Name , GNPOld , Continent , GNP , Capital , LifeExpectancy , LocalName , SurfaceArea , Code , Population , GovernmentForm ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.CountryCode = #1.Code ] Output [ #3.IsOfficial , #1.LifeExpectancy , #3.Percentage , #1.Code , #1.IndepYear , #1.Region , #1.Capital , #1.LocalName , #1.Name , #1.Continent , #1.Population , #1.HeadOfState , #1.GovernmentForm , #1.GNP , #1.Code2 , #1.SurfaceArea , #1.GNPOld , #3.Language , #3.CountryCode ] ; #5 = Scan Table [ country ] Output [ Code2 , Region , IndepYear , HeadOfState , Name , GNPOld , Continent , GNP , Capital , LifeExpectancy , LocalName , SurfaceArea , Code , Population , GovernmentForm ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #7 = Filter [ #6 ] Predicate [ IsOfficial = 'T' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #8 = Join [ #5 , #7 ] Predicate [ #7.CountryCode = #5.Code ] Output [ #5.Population , #5.Code2 , #7.IsOfficial , #5.Name , #5.LifeExpectancy , #5.Code , #7.Percentage , #5.Continent , #5.GNP , #7.Language , #5.GNPOld , #5.SurfaceArea , #5.IndepYear , #5.Region , #5.HeadOfState , #5.GovernmentForm , #7.CountryCode , #5.LocalName , #5.Capital ] ; #9 = Union [ #4 , #8 ] Output [ #4.CountryCode , #4.IsOfficial , #4.Code2 , #4.Percentage , #4.Language , #4.LifeExpectancy , #4.GNP , #4.Region , #4.GNPOld , #4.Name , #4.IndepYear , #4.SurfaceArea , #4.Capital , #4.HeadOfState , #4.Population , #4.GovernmentForm , #4.Code , #4.Continent , #4.LocalName ]",
        "cte": "WITH Scan_1 AS ( SELECT Code2, Region, IndepYear, HeadOfState, Name, GNPOld, Continent, GNP, Capital, LifeExpectancy, LocalName, SurfaceArea, Code, Population, GovernmentForm FROM world_1.country ), Scan_2 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_3 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Filter_3.IsOfficial, Scan_1.LifeExpectancy, Filter_3.Percentage, Scan_1.Code, Scan_1.IndepYear, Scan_1.Region, Scan_1.Capital, Scan_1.LocalName, Scan_1.Name, Scan_1.Continent, Scan_1.Population, Scan_1.HeadOfState, Scan_1.GovernmentForm, Scan_1.GNP, Scan_1.Code2, Scan_1.SurfaceArea, Scan_1.GNPOld, Filter_3.Language, Filter_3.CountryCode FROM Scan_1 JOIN Filter_3 ON Filter_3.CountryCode = Scan_1.Code ), Scan_5 AS ( SELECT Code2, Region, IndepYear, HeadOfState, Name, GNPOld, Continent, GNP, Capital, LifeExpectancy, LocalName, SurfaceArea, Code, Population, GovernmentForm FROM world_1.country ), Scan_6 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM world_1.countrylanguage WHERE Language = 'Dutch' ), Filter_7 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM Scan_6 WHERE IsOfficial = 'T' ), Join_8 AS ( SELECT Scan_5.Population, Scan_5.Code2, Filter_7.IsOfficial, Scan_5.Name, Scan_5.LifeExpectancy, Scan_5.Code, Filter_7.Percentage, Scan_5.Continent, Scan_5.GNP, Filter_7.Language, Scan_5.GNPOld, Scan_5.SurfaceArea, Scan_5.IndepYear, Scan_5.Region, Scan_5.HeadOfState, Scan_5.GovernmentForm, Filter_7.CountryCode, Scan_5.LocalName, Scan_5.Capital FROM Scan_5 JOIN Filter_7 ON Filter_7.CountryCode = Scan_5.Code ), Union_9 AS ( SELECT CountryCode, IsOfficial, Code2, Percentage, Language, LifeExpectancy, GNP, Region, GNPOld, Name, IndepYear, SurfaceArea, Capital, HeadOfState, Population, GovernmentForm, Code, Continent, LocalName FROM Join_4 UNION SELECT CountryCode, IsOfficial, Code2, Percentage, Language, LifeExpectancy, GNP, Region, GNPOld, Name, IndepYear, SurfaceArea, Capital, HeadOfState, Population, GovernmentForm, Code, Continent, LocalName FROM Join_8 ) SELECT * FROM Union_9",
        "clean_query": "SELECT * FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND IsOfficial = 'T' UNION SELECT * FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' AND IsOfficial = 'T'",
        "qd": "#1 = Scan the table country and retrieve all the attributes of each country ; #2 = Scan the table countrylanguage and retrieve the records with English as the language ; #3 = Filter the records from #2 to only include the ones with English as an official language ; #4 = Join #1 and #3 based on the matching country code and retrieve the attributes of the countries with English as an official language ; #5 = Scan the table country and retrieve all the attributes of each country ; #6 = Scan the table countrylanguage and retrieve the records with Dutch as the language ; #7 = Filter the records from #6 to only include the ones with Dutch as an official language ; #8 = Join #5 and #7 based on the matching country code and retrieve the attributes of the countries with Dutch as an official language ; #9 = Union #4 and #8 to retrieve the attributes of the countries with either English or Dutch as an official language"
    },
    {
        "id": "ec825644def6d351087212ad83bc285b307c370ff3598206227c45b0b4188c7f",
        "question": "Which language is the most popular on the Asian continent?",
        "query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Code , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #3 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Code = #3.CountryCode ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Language , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Code, Continent FROM world_1.country ), Filter_2 AS ( SELECT Code FROM Scan_1 WHERE Continent = 'Asia' ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_4 AS ( SELECT Scan_3.Language FROM Filter_2 JOIN Scan_3 ON Filter_2.Code = Scan_3.CountryCode ), Aggregate_5 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Language ), TopSort_6 AS ( SELECT TOP 1 Language, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table country and retrieve the country codes of all countries ; #2 = Filter from #1 all the countries with the continent as Asia and retrieve the country codes ; #3 = Scan the table countrylanguage and retrieve the languages and country codes ; #4 = Join #2 and #3 based on the matching country codes and retrieve the languages ; #5 = Group #4 by language and aggregate the count per language to find the popularity of each language in Asia ; #6 = Sort the records from #5 based on the count of popularity in descending order, select the first record, and identify the most popular language on the Asian continent and its count of population."
    },
    {
        "id": "bd6c48013f2fe3554e4971954f587f19ac143f32bfc43bc64107385601892a7f",
        "question": "What is the language that is used by the largest number of Asian nations?",
        "query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Code , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #3 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Code = #3.CountryCode ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Language , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Code, Continent FROM world_1.country ), Filter_2 AS ( SELECT Code FROM Scan_1 WHERE Continent = 'Asia' ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_4 AS ( SELECT Scan_3.Language FROM Filter_2 JOIN Scan_3 ON Filter_2.Code = Scan_3.CountryCode ), Aggregate_5 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Language ), TopSort_6 AS ( SELECT TOP 1 Language, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
        "clean_query": "SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table country and retrieve the country codes and continents of all countries. ; #2 = Filter from #1 all the countries with Asia continent and retrieve the country codes. ; #3 = Scan the table countrylanguage and retrieve the languages and country codes. ; #4 = Join #2 and #3 based on the matching country codes and retrieve the languages. ; #5 = Group #4 by language and aggregate the count per language to find the number of countries that use each language in Asia. ; #6 = Sort the records from #5 based on the count of countries in descending order, select the first record, and identify the language that is used by the largest number of Asian nations and its count of nations."
    },
    {
        "id": "325a3137319c748777644852730ad792ab3dcc7f88ab2407ae185d7899dde3c2",
        "question": "Which languages are spoken by only one country in republic governments?",
        "query": "SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language ] ; #4 = Aggregate [ #3 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 1 ] Output [ Language ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm = 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Language FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Language ), Filter_5 AS ( SELECT Language FROM Aggregate_4 WHERE Count_Star = 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1",
        "qd": "#1 = Scan the table country and retrieve the government form and country code of all countries with a republic government. ; #2 = Scan the table countrylanguage and retrieve the language and country code of all languages spoken. ; #3 = Join #1 and #2 based on the matching country code and retrieve the languages spoken in countries with a republic government. ; #4 = Group #3 by language and aggregate the count per language to find how many countries speak each language. ; #5 = Filter from #4 the languages that are spoken by only one country in republic governments and retrieve the language."
    },
    {
        "id": "b903ad5349ab796f8ca5e9ac20b113a4b545f06cd1b8fd03918a5b11ed313a29",
        "question": "What languages are only used by a single country with a republic government?",
        "query": "SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language ] ; #4 = Aggregate [ #3 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 1 ] Output [ Language ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm = 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Language FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Language ), Filter_5 AS ( SELECT Language FROM Aggregate_4 WHERE Count_Star = 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1",
        "qd": "#1 = Scan the table country and retrieve the government form and country code of all countries with a republic government. ; #2 = Scan the table countrylanguage and retrieve the languages and country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the languages. ; #4 = Group #3 by language and aggregate the count per language. ; #5 = Filter from #4 all the languages that have a count of 1 to find the languages that are only used by a single country with a republic government."
    },
    {
        "id": "26edc7b34917846dc6fb176c89ec97752e591daa31f3fadc5e0bcb84f4b56b2c",
        "question": "Find the city with the largest population that uses English.",
        "query": "SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ city ] Output [ Name , Population , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.CountryCode ] Output [ #2.Population , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_2 AS ( SELECT Name, Population, CountryCode FROM world_1.city ), Join_3 AS ( SELECT Scan_2.Population, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Name, Population FROM Join_3 ORDER BY Population DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1  JOIN world_1.countrylanguage AS T2  ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes of all countries that use the English language. ; #2 = Scan the table city and retrieve the names, populations, and country codes of all cities. ; #3 = Join #1 and #2 based on the matching country codes and retrieve the populations and names of the cities. ; #4 = Sort the records from #3 based on the population of the cities in descending order, select the first record, and identify the city with the largest population that uses English and its population."
    },
    {
        "id": "5ef06542a1781f98163159be9c68e3f95ece37b1693cc50f7cbc6bb37dbda369",
        "question": "What is the most populace city that speaks English?",
        "query": "SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ city ] Output [ Name , Population , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.CountryCode ] Output [ #2.Population , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_2 AS ( SELECT Name, Population, CountryCode FROM world_1.city ), Join_3 AS ( SELECT Scan_2.Population, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Name, Population FROM Join_3 ORDER BY Population DESC ) SELECT * FROM TopSort_4",
        "clean_query": "SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1  JOIN world_1.countrylanguage AS T2  ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes where English is spoken. ; #2 = Scan the table city and retrieve the names and populations of all cities. ; #3 = Join #1 and #2 based on the matching country codes and retrieve the populations and names of the cities where English is spoken. ; #4 = Sort the records from #3 based on the population in descending order, select the first record, and identify the name and population of the city with the highest population that speaks English."
    },
    {
        "id": "cf1777ff01be53121ea57ad7746f882c2f961f98fea981a64849e65d84fc5d67",
        "question": "Find the name, population and expected life length of asian country with the largest area?",
        "query": "SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population , LifeExpectancy , SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , SurfaceArea , LifeExpectancy , Population ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , LifeExpectancy , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population, LifeExpectancy, SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT Name, SurfaceArea, LifeExpectancy, Population FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, SurfaceArea, LifeExpectancy, Population FROM Filter_2 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country  WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC",
        "qd": "#1 = Scan the table country and retrieve the name, population, life expectancy, surface area, and continent of all countries. ; #2 = Filter from #1 all the countries with the continent 'Asia' and retrieve the name, surface area, life expectancy, and population. ; #3 = Sort the records from #2 based on the surface area in descending order, select the first record, and identify the name, surface area, life expectancy, and population of the Asian country with the largest area."
    },
    {
        "id": "076c9d19590b6ed576e8cbc4b87736164794b7f67abce410318e4a5a36166a83",
        "question": "What are the name, population, and life expectancy of the largest Asian country by land?",
        "query": "SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population , LifeExpectancy , SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , SurfaceArea , LifeExpectancy , Population ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , LifeExpectancy , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population, LifeExpectancy, SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT Name, SurfaceArea, LifeExpectancy, Population FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, SurfaceArea, LifeExpectancy, Population FROM Filter_2 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country  WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC",
        "qd": "#1 = Scan the table country and retrieve the name, population, life expectancy, and surface area of all countries. ; #2 = Filter from #1 all the countries with Asia as the continent and retrieve the name, population, life expectancy, and surface area. ; #3 = Sort the records from #2 based on the surface area in descending order, select the first record, and retrieve the name, population, and life expectancy of the largest Asian country by land."
    },
    {
        "id": "77339ce451bff4db5fb89e5639a28995743d1ebb7b76c82c33c1f952c058812d",
        "question": "What is average life expectancy in the countries where English is not the official language?",
        "query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , LifeExpectancy ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryCode = #4.Code ] Output [ #4.Name ] ; #6 = Except [ #1 , #5 ] Predicate [ #1.Name = #5.Name ] Output [ #1.LifeExpectancy ] ; #7 = Aggregate [ #6 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, LifeExpectancy FROM world_1.country ), Scan_2 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Join_5 AS ( SELECT Scan_4.Name FROM Filter_3 JOIN Scan_4 ON Filter_3.CountryCode = Scan_4.Code ), Except_6 AS ( SELECT Scan_1.LifeExpectancy FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_5) ), Aggregate_7 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Except_6 ) SELECT * FROM Aggregate_7",
        "clean_query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' )",
        "qd": "#1 = Scan the table country and retrieve the names and life expectancies of all countries ; #2 = Scan the table countrylanguage and retrieve the language, isOfficial status, and country codes for all languages ; #3 = Filter from #2 all the languages where English is the official language and retrieve the country codes ; #4 = Scan the table country and retrieve the names and codes of all countries ; #5 = Join #3 and #4 based on the matching country codes and retrieve the names ; #6 = Return the life expectancies of all countries from #1 that are not in #5 based on the matching names ; #7 = Calculate the average life expectancy from #6 to find the average life expectancy in the countries where English is not the official language"
    },
    {
        "id": "9e169afed9298dcaf606f723081977a0d33d4f22d10fc326ab83da4d35bc80d6",
        "question": "Give the mean life expectancy of countries in which English is not the official language.",
        "query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , LifeExpectancy ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryCode = #4.Code ] Output [ #4.Name ] ; #6 = Except [ #1 , #5 ] Predicate [ #1.Name = #5.Name ] Output [ #1.LifeExpectancy ] ; #7 = Aggregate [ #6 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, LifeExpectancy FROM world_1.country ), Scan_2 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Join_5 AS ( SELECT Scan_4.Name FROM Filter_3 JOIN Scan_4 ON Filter_3.CountryCode = Scan_4.Code ), Except_6 AS ( SELECT Scan_1.LifeExpectancy FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_5) ), Aggregate_7 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Except_6 ) SELECT * FROM Aggregate_7",
        "clean_query": "SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' )",
        "qd": "#1 = Scan the table country and retrieve the names and life expectancies of all countries ; #2 = Scan the table countrylanguage and retrieve the language, official status, and country codes for all languages ; #3 = Filter #2 to find all the countries where English is the official language ; #4 = Scan the table country and retrieve the names and country codes of all countries ; #5 = Join #3 and #4 based on the matching country codes and retrieve the names of the countries where English is the official language ; #6 = Find all the countries in #1 that are not in #5 and retrieve their life expectancies ; #7 = Aggregate the average life expectancy of the countries in #6"
    },
    {
        "id": "f7f4826cde3d4d2d0ff201160a9274986c4dc75f8346cba26e99e80fd3ccc0b4",
        "question": "What is the total number of people living in the nations that do not use English?",
        "query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Population ] ; #6 = Aggregate [ #5 ] Output [ SUM(Population) AS Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryCode = Scan_3.Code ), Except_5 AS ( SELECT Scan_1.Population FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ), Aggregate_6 AS ( SELECT SUM(Population) AS Sum_Population FROM Except_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' )",
        "qd": "#1 = Scan the table country and retrieve the names and populations of all countries. ; #2 = Scan the table countrylanguage and retrieve the country codes where the language used is English. ; #3 = Scan the table country and retrieve the names and codes of all countries. ; #4 = Join #2 and #3 based on the matching country codes and retrieve the names of the countries. ; #5 = Return the populations of the countries from #1 that are not in #4. ; #6 = Aggregate the sum of the populations from #5 to find the total number of people living in the nations that do not use English."
    },
    {
        "id": "aead834686e53b5a28f6330568c6b82b64797de7cded35cbc5b1feab82bda05c",
        "question": "How many people live in countries that do not speak English?",
        "query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Population ] ; #6 = Aggregate [ #5 ] Output [ SUM(Population) AS Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryCode = Scan_3.Code ), Except_5 AS ( SELECT Scan_1.Population FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ), Aggregate_6 AS ( SELECT SUM(Population) AS Sum_Population FROM Except_5 ) SELECT * FROM Aggregate_6",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' )",
        "qd": "#1 = Scan the table country and retrieve the names and populations of all countries ; #2 = Scan the table countrylanguage and retrieve the languages and country codes of all countries that speak English ; #3 = Scan the table country and retrieve the names and codes of all countries ; #4 = Join #2 and #3 based on the matching country code and retrieve the names of the countries that speak English ; #5 = Return the populations of all countries from #1 that do not have a matching name in #4 (countries that do not speak English) ; #6 = Aggregate the sum of the populations from #5 to find the total number of people living in countries that do not speak English"
    },
    {
        "id": "76aabb0a0ad501bbb8c847b9056b539fcd3780a5c7da5f754aee2fc436378746",
        "question": "What is the official language spoken in the country whose head of state is Beatrix?",
        "query": "SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ HeadOfState = 'Beatrix' ] Output [ HeadOfState , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #3.Language ]",
        "cte": "WITH Scan_1 AS ( SELECT HeadOfState, Code FROM world_1.country WHERE HeadOfState = 'Beatrix' ), Scan_2 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ) SELECT * FROM Join_4",
        "clean_query": "SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T'",
        "qd": "#1 = Scan the table country to find the country with the head of state as Beatrix and retrieve the head of state and country code ; #2 = Scan the table countrylanguage and retrieve the languages, isOfficial status, and country codes ; #3 = Filter from #2 all the official languages and retrieve the languages and country codes ; #4 = Join the records from #1 and #3 based on the matching country codes and retrieve the official language spoken in the country with the head of state as Beatrix"
    },
    {
        "id": "1d2463926c06c0b305d781cd6e0713784fbcac3498b19ded257d886e67364acc",
        "question": "What is the official language used in the country the name of whose head of state is Beatrix.",
        "query": "SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ HeadOfState = 'Beatrix' ] Output [ HeadOfState , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #3.Language ]",
        "cte": "WITH Scan_1 AS ( SELECT HeadOfState, Code FROM world_1.country WHERE HeadOfState = 'Beatrix' ), Scan_2 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ) SELECT * FROM Join_4",
        "clean_query": "SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T'",
        "qd": "#1 = Scan the table country and retrieve the head of state and code of the country with the name Beatrix ; #2 = Scan the table countrylanguage and retrieve the language, official status, and country code of all languages ; #3 = Filter from #2 all the languages that are official ; #4 = Join #1 and #3 based on the matching country code and retrieve the official language used in the country with the name Beatrix"
    },
    {
        "id": "24b9e3ac13501e8a2eb99f6d37af002f21006457b42f6138786b9a75515062a4",
        "question": "What is the total number of unique official languages spoken in the countries that are founded before 1930?",
        "query": "SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear < 1930 ] Output [ IndepYear , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Distinct [ true ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT IndepYear, Code FROM world_1.country WHERE IndepYear < 1930 ), Scan_2 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT DISTINCT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T'",
        "qd": "#1 = Scan the table country and retrieve the independence year and codes of all countries founded before 1930. ; #2 = Scan the table countrylanguage and retrieve the languages, official status, and country codes. ; #3 = Filter from #2 only the languages that are official. ; #4 = Join #1 and #3 based on the matching country codes and retrieve the unique official languages spoken in the countries founded before 1930. ; #5 = Aggregate the count of unique official languages to find the total number of unique official languages spoken in the countries founded before 1930."
    },
    {
        "id": "4081e5d7bc31db228a3c170e395df647ce46a1fd16e6f1ac5d2606249a8b1d37",
        "question": "For the countries founded before 1930, what is the total number of distinct official languages?",
        "query": "SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear < 1930 ] Output [ IndepYear , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , IsOfficial , CountryCode ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Distinct [ true ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT IndepYear, Code FROM world_1.country WHERE IndepYear < 1930 ), Scan_2 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT DISTINCT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T'",
        "qd": "#1 = Scan the table country and retrieve the independence year and country code of all countries founded before 1930 ; #2 = Scan the table countrylanguage and retrieve the languages, official status, and country code of all languages ; #3 = Filter from #2 all the languages that are officially spoken and retrieve the language and country code ; #4 = Join #1 and #3 based on the matching country codes and retrieve the distinct official languages ; #5 = Aggregate the count of distinct official languages in #4 and return the total number of distinct official languages for countries founded before 1930."
    },
    {
        "id": "1c3db4eb8cdcb620190283407819418853749cad50efe83d47189b48e2ecdde4",
        "question": "What are the countries that have greater surface area than any country in Europe?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Europe' ) ",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ MIN(SurfaceArea) AS Min_SurfaceArea ] ; #4 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.SurfaceArea > #3.Min_SurfaceArea ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Europe' ), Aggregate_3 AS ( SELECT MIN(SurfaceArea) AS Min_SurfaceArea FROM Filter_2 ), Scan_4 AS ( SELECT Name, SurfaceArea FROM world_1.country ), Join_5 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.SurfaceArea > Aggregate_3.Min_SurfaceArea ) SELECT * FROM Join_5",
        "clean_query": "SELECT Name FROM world_1.country  WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country  WHERE Continent = 'Europe' )",
        "qd": "#1 = Scan the table country and retrieve the surface area and continent of all countries ; #2 = Filter from #1 all the countries with Europe continent and retrieve their surface area ; #3 = Aggregate the minimum surface area from #2 ; #4 = Scan the table country and retrieve the name and surface area of all countries ; #5 = Join #3 and #4 based on the countries with surface area greater than the minimum surface area in Europe and retrieve the names of those countries"
    },
    {
        "id": "a1fb0df29395bbcc497b10676e7f0fcc9e1a41b4362640374d47995c3510d7a2",
        "question": "Which countries have greater area than that of any country in Europe?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Europe' ) ",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ MIN(SurfaceArea) AS Min_SurfaceArea ] ; #4 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.SurfaceArea > #3.Min_SurfaceArea ] Output [ #4.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Europe' ), Aggregate_3 AS ( SELECT MIN(SurfaceArea) AS Min_SurfaceArea FROM Filter_2 ), Scan_4 AS ( SELECT Name, SurfaceArea FROM world_1.country ), Join_5 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.SurfaceArea > Aggregate_3.Min_SurfaceArea ) SELECT * FROM Join_5",
        "clean_query": "SELECT Name FROM world_1.country  WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country  WHERE Continent = 'Europe' )",
        "qd": "#1 = Scan the table country and retrieve the surface area and continent of all countries ; #2 = Filter from #1 all the countries with Europe continent and retrieve the surface area ; #3 = Aggregate the minimum surface area from #2 ; #4 = Scan the table country and retrieve the names and surface areas of all countries ; #5 = Join #3 and #4 based on the surface area in #4 being greater than the minimum surface area in #3 and retrieve the names of the countries"
    },
    {
        "id": "8e3e0c5cc6890da0f2ac1becf06e642b0b35b4f63f9c20289406a40c69a77641",
        "question": "What are the African countries that have a  population less than any country in Asia?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND population < ( SELECT max ( population ) AS Max_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ) ",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MAX(Population) AS Max_Population ] ; #4 = Scan Table [ country ] Output [ Name , Population , Continent ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Africa' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population < #3.Max_Population ] Output [ #5.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Population, Continent FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT MAX(Population) AS Max_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Population, Continent FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Africa' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population < Aggregate_3.Max_Population ) SELECT * FROM Join_6",
        "clean_query": "SELECT Name FROM world_1.country  WHERE Continent = 'Africa' AND population < ( SELECT max ( population ) AS Max_population FROM world_1.country  WHERE Continent = 'Asia' )",
        "qd": "#1 = Scan the table country and retrieve the population and continent of all countries ; #2 = Filter from #1 all the countries with Asia continent and retrieve the population ; #3 = Aggregate the maximum population from #2 ; #4 = Scan the table country and retrieve the name, population, and continent of all countries ; #5 = Filter from #4 all the countries with Africa continent and retrieve the name and population ; #6 = Join #3 and #5 and retrieve the names of the African countries with a population less than the maximum population of any country in Asia."
    },
    {
        "id": "1e24f527faaaa8d4bbae1ada8b98e945ff2183598b52186f41e56c2ea6b45afa",
        "question": "Which African countries have a smaller population than that of any country in Asia?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND population < ( SELECT min ( population ) AS Min_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ) ",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MIN(Population) AS Min_Population ] ; #4 = Scan Table [ country ] Output [ Name , Population , Continent ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Africa' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population < #3.Min_Population ] Output [ #5.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Population, Continent FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT MIN(Population) AS Min_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Population, Continent FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Africa' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population < Aggregate_3.Min_Population ) SELECT * FROM Join_6",
        "clean_query": "SELECT Name FROM world_1.country  WHERE Continent = 'Africa' AND population < ( SELECT min ( population ) AS Min_population FROM world_1.country  WHERE Continent = 'Asia' )",
        "qd": "#1 = Scan table country and retrieve the population and continent of all countries ; #2 = Filter from #1 all the countries with Asia continent and retrieve the populations ; #3 = Aggregate the minimum population from #2 ; #4 = Scan table country and retrieve the names, populations, and continents of all countries ; #5 = Filter from #4 all the countries with Africa continent and retrieve the names and populations ; #6 = Join #3 and #5 based on the population and retrieve the names of the African countries with a smaller population than any country in Asia"
    },
    {
        "id": "b23e0c05a205accabd7aae54026cd0c93fc6315ab33314ad9de359fdc652715e",
        "question": "Which Asian countries have a population that is larger than any country in Africa?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' AND population > ( SELECT max ( population ) AS Max_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' ) ",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MAX(Population) AS Max_Population ] ; #4 = Scan Table [ country ] Output [ Name , Population , Continent ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Asia' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population > #3.Max_Population ] Output [ #5.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Population, Continent FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT MAX(Population) AS Max_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Population, Continent FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Asia' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population > Aggregate_3.Max_Population ) SELECT * FROM Join_6",
        "clean_query": "SELECT Name FROM world_1.country  WHERE Continent = 'Asia' AND population > ( SELECT max ( population ) AS Max_population FROM world_1.country  WHERE Continent = 'Africa' )",
        "qd": "#1 = Scan the table country and retrieve the population and continent of all countries ; #2 = Filter from #1 all the countries with Africa continent and retrieve the population ; #3 = Find the maximum population among the countries from #2 ; #4 = Scan the table country and retrieve the name, population, and continent of all countries ; #5 = Filter from #4 all the countries with Asia continent and retrieve the name and population ; #6 = Join #3 and #5 and find the countries from #5 with a population larger than the maximum population from #3. Retrieve the names of these countries"
    },
    {
        "id": "4a26693e8b64b388a869f74c12041375fe55f7851e8138794063998f3b04f9f3",
        "question": "What are the Asian countries which have a population larger than that of any country in Africa?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' AND population > ( SELECT min ( population ) AS Min_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' ) ",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MIN(Population) AS Min_Population ] ; #4 = Scan Table [ country ] Output [ Name , Population , Continent ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Asia' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population > #3.Min_Population ] Output [ #5.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Population, Continent FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT MIN(Population) AS Min_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Population, Continent FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Asia' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population > Aggregate_3.Min_Population ) SELECT * FROM Join_6",
        "clean_query": "SELECT Name FROM world_1.country  WHERE Continent = 'Asia' AND population > ( SELECT min ( population ) AS Min_population FROM world_1.country  WHERE Continent = 'Africa' )",
        "qd": "#1 = Scan the table country and retrieve the populations and continents of all countries ; #2 = Filter from #1 all the countries with Africa as the continent and retrieve the populations ; #3 = Aggregate the minimum population from #2 ; #4 = Scan the table country and retrieve the names, populations, and continents of all countries ; #5 = Filter from #4 all the countries with Asia as the continent and retrieve the names and populations ; #6 = Join #3 and #5 based on the condition that the population in #5 is larger than the minimum population in #3 and retrieve the names of the Asian countries"
    },
    {
        "id": "3344efc6cf9baa0bfa29c17aab9d688f6b48c8f4b7d92cf472dd385b9d171429",
        "question": "What are the country codes for countries that do not speak English?",
        "query": "SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #4 = Except [ #2 , #3 ] Predicate [ #2.CountryCode = #3.CountryCode ] Output [ #2.CountryCode ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_4 AS ( SELECT Aggregate_2.CountryCode FROM Aggregate_2 WHERE CountryCode NOT IN (SELECT CountryCode FROM Scan_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT CountryCode FROM world_1.countrylanguage  EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'",
        "qd": "#1 = Scan the table countrylanguage and retrieve all the country codes. ; #2 = Group #1 by country code to find the distinct country codes. ; #3 = Scan the table countrylanguage and retrieve the country codes for countries that speak English. ; #4 = Return all the country codes that are in #2 but not in #3 to find the country codes for countries that do not speak English."
    },
    {
        "id": "d75c9b7a13adce151a16d7cca833ab0cb99145f5a35857c3008c4f22ddb3bf44",
        "question": "Return the country codes for countries that do not speak English.",
        "query": "SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #4 = Except [ #2 , #3 ] Predicate [ #2.CountryCode = #3.CountryCode ] Output [ #2.CountryCode ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_4 AS ( SELECT Aggregate_2.CountryCode FROM Aggregate_2 WHERE CountryCode NOT IN (SELECT CountryCode FROM Scan_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT CountryCode FROM world_1.countrylanguage  EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'",
        "qd": "#1 = Scan the table countrylanguage and retrieve all country codes. ; #2 = Group #1 by country code to find the distinct country codes. ; #3 = Scan the table countrylanguage and retrieve the languages and country codes of all countries that speak English. ; #4 = Return the country codes that are in #2 and not in #3 to find the country codes for countries that do not speak English."
    },
    {
        "id": "deabaedeb3981927bf1f396a795b435a3035bd61ca255b76038121b2dbae91d2",
        "question": "What are the country codes of countries where people use languages other than English?",
        "query": "SELECT DISTINCT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language <> 'English' ] Output [ Language , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language <> 'English' ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT DISTINCT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE ! = 'English'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes of countries where people use languages other than English ; #2 = Group the records from #1 by country code to find the country codes of countries where people use languages other than English"
    },
    {
        "id": "d1f8533f2672bfc50cab0c09ffe4250953ede5126b08584e81b5315b1947af94",
        "question": "Give the country codes for countries in which people speak langauges that are not English.",
        "query": "SELECT DISTINCT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language <> 'English' ] Output [ Language , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language <> 'English' ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT DISTINCT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE ! = 'English'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the language and country codes of all languages except English ; #2 = Group #1 by country code and retrieve the country codes of countries in which people speak languages that are not English"
    },
    {
        "id": "411e3a9f339783dbf100ebab4a646a530bbbf7c0315e64cb7fc5982f87dd007e",
        "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?",
        "query": "SELECT Code FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm <> 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Output [ #1.Code ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm <> 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_3 AS ( SELECT Scan_1.Code FROM Scan_1 WHERE Code NOT IN (SELECT CountryCode FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Code FROM world_1.country  WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'",
        "qd": "#1 = Scan the table country and retrieve the government forms and codes of all countries that are not Republic ; #2 = Scan the table countrylanguage and retrieve the languages and country codes of all countries that speak English ; #3 = Return the codes of the countries from #1 that do not have English as their language and are not Republic government form."
    },
    {
        "id": "37f9a40298fb04b95b25179baa94b661d7fd499541ebb2c201308c9abf2387cf",
        "question": "Return the codes of countries that do not speak English and do not have Republics for governments.",
        "query": "SELECT Code FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm <> 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Output [ #1.Code ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm <> 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_3 AS ( SELECT Scan_1.Code FROM Scan_1 WHERE Code NOT IN (SELECT CountryCode FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Code FROM world_1.country  WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'",
        "qd": "#1 = Scan the table country and retrieve the codes of all countries that do not have Republics for governments ; #2 = Scan the table countrylanguage and retrieve the codes of all countries that speak English ; #3 = Return the codes of countries that are in #1 and are not in #2, which means the countries that do not speak English and do not have Republics for governments."
    },
    {
        "id": "c0a940b8887f4c7ef794eee72ddfb7b8c13f2f0d081cf6d873573933faf69e99",
        "question": "Which cities are in European countries where English is not the official language?",
        "query": "SELECT DISTINCT T2.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T4 WITH (FORCESCAN) ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name , Code ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #4 = Filter [ #3 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.CountryCode = #5.Code ] Output [ #5.Name ] ; #7 = Except [ #2 , #6 ] Predicate [ #2.Name = #6.Name ] Output [ #2.Code ] ; #8 = Scan Table [ city ] Output [ Name , CountryCode ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.Code = #8.CountryCode ] Distinct [ true ] Output [ #8.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code, Continent FROM world_1.country ), Filter_2 AS ( SELECT Name, Code FROM Scan_1 WHERE Continent = 'Europe' ), Scan_3 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_4 AS ( SELECT CountryCode FROM Scan_3 WHERE IsOfficial = 'T' ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Join_6 AS ( SELECT Scan_5.Name FROM Filter_4 JOIN Scan_5 ON Filter_4.CountryCode = Scan_5.Code ), Except_7 AS ( SELECT Filter_2.Code FROM Filter_2 WHERE Name NOT IN (SELECT Name FROM Join_6) ), Scan_8 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_9 AS ( SELECT DISTINCT Scan_8.Name FROM Except_7 JOIN Scan_8 ON Except_7.Code = Scan_8.CountryCode ) SELECT * FROM Join_9",
        "clean_query": "SELECT DISTINCT T2.Name FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3  JOIN world_1.countrylanguage AS T4  ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' )",
        "qd": "#1 = Scan the table country and retrieve the names, codes, and continents of all countries ; #2 = Filter from #1 all the countries with Europe continent and retrieve the names and codes ; #3 = Scan the table countrylanguage and retrieve the languages, isOfficial flags, and country codes ; #4 = Filter from #3 all the official English languages and retrieve the country codes ; #5 = Scan the table country and retrieve the names and codes of all countries ; #6 = Join #4 and #5 based on the matching country codes and retrieve the names ; #7 = Return all the country codes from #2 that are not in #6 and retrieve the country codes ; #8 = Scan the table city and retrieve the names and country codes of all cities ; #9 = Join #7 and #8 based on the matching country codes and retrieve the city names without duplicates"
    },
    {
        "id": "0d84fb9681915bfd4ab3a629c27b5ce0af8fc3c65ff7132f2d4cee75b10a0153",
        "question": "What are the names of cities in Europe for which English is not the official language?",
        "query": "SELECT DISTINCT T2.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T4 WITH (FORCESCAN) ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name , Code ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #4 = Filter [ #3 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.CountryCode = #5.Code ] Output [ #5.Name ] ; #7 = Except [ #2 , #6 ] Predicate [ #2.Name = #6.Name ] Output [ #2.Code ] ; #8 = Scan Table [ city ] Output [ Name , CountryCode ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.Code = #8.CountryCode ] Distinct [ true ] Output [ #8.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code, Continent FROM world_1.country ), Filter_2 AS ( SELECT Name, Code FROM Scan_1 WHERE Continent = 'Europe' ), Scan_3 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_4 AS ( SELECT CountryCode FROM Scan_3 WHERE IsOfficial = 'T' ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Join_6 AS ( SELECT Scan_5.Name FROM Filter_4 JOIN Scan_5 ON Filter_4.CountryCode = Scan_5.Code ), Except_7 AS ( SELECT Filter_2.Code FROM Filter_2 WHERE Name NOT IN (SELECT Name FROM Join_6) ), Scan_8 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_9 AS ( SELECT DISTINCT Scan_8.Name FROM Except_7 JOIN Scan_8 ON Except_7.Code = Scan_8.CountryCode ) SELECT * FROM Join_9",
        "clean_query": "SELECT DISTINCT T2.Name FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3  JOIN world_1.countrylanguage AS T4  ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' )",
        "qd": "#1 = Scan the table country and retrieve the names, codes, and continents of all countries ; #2 = Filter from #1 all the countries with Europe as the continent and retrieve the names and codes ; #3 = Scan the table countrylanguage and retrieve the languages, isOfficial values, and country codes of all languages ; #4 = Filter from #3 all the languages that are English and retrieve the country codes ; #5 = Scan the table country and retrieve the names and codes of all countries ; #6 = Join #4 and #5 based on the matching country codes and retrieve the names ; #7 = return all the country codes from #2 that are not in #6 and retrieve the names of the cities ; #8 = Scan the table city and retrieve the names and country codes of all cities ; #9 = Join #7 and #8 based on the matching country codes without duplicates and retrieve the names of the cities in Europe for which English is not the official language"
    },
    {
        "id": "d4255528f288011bf282f9c70db59fb67c2df7481c80b30ccdb2bb1bb10a28d6",
        "question": "Which unique cities are in Asian countries where Chinese is the official language ?",
        "query": "select distinct t3.name FROM world_1.country AS t1 WITH (FORCESCAN) join world_1.countrylanguage as t2 WITH (FORCESCAN) on t1.code = t2.countrycode join world_1.city as t3 WITH (FORCESCAN) on t1.code = t3.countrycode where t2.isofficial = 't' and t2.language = 'chinese' and t1.continent = 'asia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'chinese' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Code , Continent ] ; #4 = Filter [ #3 ] Predicate [ Continent = 'asia' ] Output [ Code ] ; #5 = Join [ #2 , #4 ] Predicate [ #2.CountryCode = #4.Code ] Output [ #2.CountryCode ] ; #6 = Scan Table [ city ] Output [ Name , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.CountryCode = #6.CountryCode ] Distinct [ true ] Output [ #6.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'chinese' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 't' ), Scan_3 AS ( SELECT Code, Continent FROM world_1.country ), Filter_4 AS ( SELECT Code FROM Scan_3 WHERE Continent = 'asia' ), Join_5 AS ( SELECT Filter_2.CountryCode FROM Filter_2 JOIN Filter_4 ON Filter_2.CountryCode = Filter_4.Code ), Scan_6 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_7 AS ( SELECT DISTINCT Scan_6.Name FROM Join_5 JOIN Scan_6 ON Join_5.CountryCode = Scan_6.CountryCode ) SELECT * FROM Join_7",
        "clean_query": "select distinct t3.name FROM world_1.country AS t1  join world_1.countrylanguage as t2  on t1.code = t2.countrycode join world_1.city as t3  on t1.code = t3.countrycode where t2.isofficial = 't' and t2.language = 'chinese' and t1.continent = 'asia'",
        "qd": "#1 = Scan the table countrylanguage to find the countries where Chinese is the official language ; #2 = Filter #1 to retrieve the country codes of the countries where Chinese is the official language ; #3 = Scan the table country to retrieve the country codes and continents of all countries ; #4 = Filter #3 to retrieve the country codes of the Asian countries ; #5 = Join #2 and #4 based on the matching country codes and retrieve the country codes where Chinese is the official language in Asian countries ; #6 = Scan the table city to retrieve the names and country codes of all cities ; #7 = Join #5 and #6 based on the matching country codes and retrieve the unique city names in Asian countries where Chinese is the official language"
    },
    {
        "id": "0236e60074389525ae99b74bd2a1c01b56e74854227b6ac59849d44d9a5c6c00",
        "question": "Return the different names of cities that are in Asia and for which Chinese is the official language.",
        "query": "SELECT DISTINCT T3.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode JOIN world_1.city AS T3 WITH (FORCESCAN) ON T1.Code = T3.CountryCode WHERE T2.IsOfficial = 'T' AND T2.Language = 'Chinese' AND T1.Continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Code , Continent ] ; #4 = Filter [ #3 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #5 = Join [ #2 , #4 ] Predicate [ #2.CountryCode = #4.Code ] Output [ #2.CountryCode ] ; #6 = Scan Table [ city ] Output [ Name , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.CountryCode = #6.CountryCode ] Distinct [ true ] Output [ #6.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'Chinese' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 'T' ), Scan_3 AS ( SELECT Code, Continent FROM world_1.country ), Filter_4 AS ( SELECT Code FROM Scan_3 WHERE Continent = 'Asia' ), Join_5 AS ( SELECT Filter_2.CountryCode FROM Filter_2 JOIN Filter_4 ON Filter_2.CountryCode = Filter_4.Code ), Scan_6 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_7 AS ( SELECT DISTINCT Scan_6.Name FROM Join_5 JOIN Scan_6 ON Join_5.CountryCode = Scan_6.CountryCode ) SELECT * FROM Join_7",
        "clean_query": "SELECT DISTINCT T3.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode JOIN world_1.city AS T3  ON T1.Code = T3.CountryCode WHERE T2.IsOfficial = 'T' AND T2.Language = 'Chinese' AND T1.Continent = 'Asia'",
        "qd": "#1 = Scan the table countrylanguage and retrieve the language, IsOfficial, and country code of all languages ; #2 = Filter from #1 all the languages with Chinese and retrieve the country codes ; #3 = Scan the table country and retrieve the country codes and continents of all countries ; #4 = Filter from #3 all the countries in Asia and retrieve the country codes ; #5 = Join #2 and #4 based on the matching country codes and retrieve the country codes ; #6 = Scan the table city and retrieve the names and country codes of all cities ; #7 = Join #5 and #6 based on the matching country codes and retrieve the names of cities without duplicates"
    },
    {
        "id": "4a689d6560058bdd8adf9567862f41d9fd0787c77beb5f837b9b44c155a76705",
        "question": "What are the name, independence year, and surface area of the country with the smallest population?",
        "query": "SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country WITH (FORCESCAN) ORDER BY Population OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , IndepYear , Population ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Population ASC ] Output [ Name , SurfaceArea , IndepYear , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, SurfaceArea, IndepYear, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, IndepYear, Population FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country  ORDER BY Population",
        "qd": "#1 = Scan the table country and retrieve the name, surface area, independence year, and population of all countries ; #2 = Sort the records from #1 based on the population in ascending order, select the first record, and retrieve the name, surface area, independence year, and population of the country with the smallest population"
    },
    {
        "id": "e4c52b785e1632bd04805745f66503d7b650c8b3033ce632e1c491a6b718b3cf",
        "question": "Give the name, year of independence, and surface area of the country that has the lowest population.",
        "query": "SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country WITH (FORCESCAN) ORDER BY Population OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , IndepYear , Population ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Population ASC ] Output [ Name , SurfaceArea , IndepYear , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, SurfaceArea, IndepYear, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, IndepYear, Population FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country  ORDER BY Population",
        "qd": "#1 = Scan the table country and retrieve the name, surface area, year of independence, and population of all countries. ; #2 = Sort the records from #1 based on the population in ascending order, select the first record, and identify the name, surface area, and year of independence of the country with the lowest population."
    },
    {
        "id": "8501b8421d3703c0f326d035b6a98713416838884d95dce6d6d6f9e9785e9513",
        "question": "What are the population, name and leader of the country with the largest area?",
        "query": "SELECT TOP 1 Name , population , HeadOfState FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , HeadOfState ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , HeadOfState ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, SurfaceArea, Population, HeadOfState FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, Population, HeadOfState FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name , population , HeadOfState FROM world_1.country  ORDER BY SurfaceArea DESC",
        "qd": "#1 = Scan the table country and retrieve the name, surface area, population, and head of state of all countries. ; #2 = Sort the records from #1 based on the surface area in descending order, select the first record, and retrieve the name, surface area, population, and head of state of the country with the largest area."
    },
    {
        "id": "d7fc07e68990b36dc06d1e0618a67411b9ca8d0cdbb2507c1994df52cec72a11",
        "question": "Give the name, population, and head of state for the country that has the largest area.",
        "query": "SELECT TOP 1 Name , population , HeadOfState FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , HeadOfState ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , HeadOfState ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, SurfaceArea, Population, HeadOfState FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, Population, HeadOfState FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name , population , HeadOfState FROM world_1.country  ORDER BY SurfaceArea DESC",
        "qd": "#1 = Scan the table country and retrieve the name, surface area, population, and head of state of all countries ; #2 = Sort the records from #1 based on the surface area in descending order, select the first record, and identify the name, population, and head of state of the country with the largest area"
    },
    {
        "id": "e8085d6ad1c2965658080e2c0ebc3816ca37ec522dd5cad2606e9607878526d6",
        "question": "Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages.",
        "query": "SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name, Count_Star FROM Aggregate_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2",
        "qd": "#1 = Scan the table country and retrieve the names and codes of all countries. ; #2 = Scan the table countrylanguage and retrieve all the country codes. ; #3 = Join #1 and #2 based on the matching country code and retrieve the names of the countries. ; #4 = Group #3 by name and aggregate the count per name to find the number of languages spoken in each country. ; #5 = Filter from #4 all the records with a count of languages spoken greater than 2 and retrieve the country names and the counts of languages spoken."
    },
    {
        "id": "2c0de20779e40a8f22108d64a6d535afadb5261fca03a654dfb32a79b1987e60",
        "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?",
        "query": "SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Name , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name, Count_Star FROM Aggregate_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2",
        "qd": "#1 = Scan the table country and retrieve the names and codes of all countries ; #2 = Scan the table countrylanguage and retrieve all country codes ; #3 = Join #1 and #2 based on the matching country code and retrieve the names of the countries ; #4 = Group #3 by name and aggregate the count per name to find the number of languages spoken in each country ; #5 = Filter from #4 all the records with a count of languages greater than 2 and retrieve the names of the countries and the count of languages they speak"
    },
    {
        "id": "b5f8586908d9c60a605f91dcdce8a372301ffec88f551fc7611f66e2e04a5840",
        "question": "Find the number of cities in each district whose population is greater than the average population of cities?",
        "query": "SELECT count ( * ) AS Count_Star , District FROM world_1.city WITH (FORCESCAN) WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city WITH (FORCESCAN) ) GROUP BY District ",
        "qpl": "world_1 | #1 = Scan Table [ city ] Output [ Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(Population) AS Avg_Population ] ; #3 = Scan Table [ city ] Output [ Population , District ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Population > #2.Avg_Population ] Output [ #3.District ] ; #5 = Aggregate [ #4 ] GroupBy [ District ] Output [ countstar AS Count_Star , District ]",
        "cte": "WITH Scan_1 AS ( SELECT Population FROM world_1.city ), Aggregate_2 AS ( SELECT AVG(Population) AS Avg_Population FROM Scan_1 ), Scan_3 AS ( SELECT Population, District FROM world_1.city ), Join_4 AS ( SELECT District FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Population > Aggregate_2.Avg_Population ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, District FROM Join_4 GROUP BY District ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT count ( * ) AS Count_Star , District FROM world_1.city  WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city  ) GROUP BY District",
        "qd": "#1 = Scan the table city and retrieve the population of all cities. ; #2 = Aggregate the population from #1 to find the average population of all cities. ; #3 = Scan the table city and retrieve the population and district of all cities. ; #4 = Join #2 and #3 based on the condition that the population of a city is greater than the average population from #2. ; #5 = Group #4 by district and aggregate the count of cities per district to find the number of cities in each district whose population is greater than the average population of cities."
    },
    {
        "id": "f5e097f81472a5f1334b7da4a4ef498e2d1370ef2466d6fe70ffd87c12059458",
        "question": "How many cities in each district have a population that is above the average population across all cities?",
        "query": "SELECT count ( * ) AS Count_Star , District FROM world_1.city WITH (FORCESCAN) WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city WITH (FORCESCAN) ) GROUP BY District ",
        "qpl": "world_1 | #1 = Scan Table [ city ] Output [ Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(Population) AS Avg_Population ] ; #3 = Scan Table [ city ] Output [ Population , District ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Population > #2.Avg_Population ] Output [ #3.District ] ; #5 = Aggregate [ #4 ] GroupBy [ District ] Output [ countstar AS Count_Star , District ]",
        "cte": "WITH Scan_1 AS ( SELECT Population FROM world_1.city ), Aggregate_2 AS ( SELECT AVG(Population) AS Avg_Population FROM Scan_1 ), Scan_3 AS ( SELECT Population, District FROM world_1.city ), Join_4 AS ( SELECT District FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Population > Aggregate_2.Avg_Population ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, District FROM Join_4 GROUP BY District ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT count ( * ) AS Count_Star , District FROM world_1.city  WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city  ) GROUP BY District",
        "qd": "#1 = Scan the table city and retrieve the population of all cities ; #2 = Aggregate the average population across all cities and assign it as Avg_Population ; #3 = Scan the table city and retrieve the population and district of all cities ; #4 = Join #2 and #3 based on the cities with population greater than Avg_Population and retrieve the districts ; #5 = Group #4 by district and aggregate the count of cities per district"
    },
    {
        "id": "d470e09983752f911b63e42f813e74b44f366f7c126cfd843b5dc8b70d8a80dd",
        "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.",
        "query": "SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country WITH (FORCESCAN) GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ GovernmentForm , LifeExpectancy , Population ] ; #2 = Aggregate [ #1 ] GroupBy [ GovernmentForm ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , SUM(Population) AS Sum_Population , GovernmentForm ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy > 72.0 ] Output [ GovernmentForm , Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, LifeExpectancy, Population FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, SUM(Population) AS Sum_Population, GovernmentForm FROM Scan_1 GROUP BY GovernmentForm ), Filter_3 AS ( SELECT GovernmentForm, Sum_Population FROM Aggregate_2 WHERE Avg_LifeExpectancy > 72.0 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country  GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72",
        "qd": "#1 = Scan the table country and retrieve the government form, life expectancy, and population of each country ; #2 = Group #1 by government form and calculate the average life expectancy and the sum of population for each government form ; #3 = Filter from #2 the records with an average life expectancy longer than 72 and retrieve the government form and the sum of population for each government form"
    },
    {
        "id": "effadf8df6dc99841f6c5970c502b75ffa1c1763e6c4dbecda029eb47c339b71",
        "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?",
        "query": "SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country WITH (FORCESCAN) GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ GovernmentForm , LifeExpectancy , Population ] ; #2 = Aggregate [ #1 ] GroupBy [ GovernmentForm ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , SUM(Population) AS Sum_Population , GovernmentForm ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy > 72.0 ] Output [ GovernmentForm , Sum_Population ]",
        "cte": "WITH Scan_1 AS ( SELECT GovernmentForm, LifeExpectancy, Population FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, SUM(Population) AS Sum_Population, GovernmentForm FROM Scan_1 GROUP BY GovernmentForm ), Filter_3 AS ( SELECT GovernmentForm, Sum_Population FROM Aggregate_2 WHERE Avg_LifeExpectancy > 72.0 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country  GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72",
        "qd": "#1 = Scan the table country and retrieve the government form, life expectancy, and population of all countries ; #2 = Group #1 by government form and aggregate the average life expectancy and sum of population for each government form ; #3 = Filter from #2 the records with average life expectancy greater than 72.0 and retrieve the government form and sum of population for each government form"
    },
    {
        "id": "e60ca4d3c1158e28353a8f15c12a2c2846a2d48f2f3bf754959163476896c575",
        "question": "Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?",
        "query": "SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country WITH (FORCESCAN) GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ LifeExpectancy , Population , Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , SUM(Population) AS Sum_Population , Continent ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy < 72.0 ] Output [ Sum_Population , Avg_LifeExpectancy , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT LifeExpectancy, Population, Continent FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, SUM(Population) AS Sum_Population, Continent FROM Scan_1 GROUP BY Continent ), Filter_3 AS ( SELECT Sum_Population, Avg_LifeExpectancy, Continent FROM Aggregate_2 WHERE Avg_LifeExpectancy < 72.0 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country  GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72",
        "qd": "#1 = Scan the table country and retrieve the life expectancy, population, and continent of all countries ; #2 = Group #1 by continent and calculate the average life expectancy and sum of population for each continent ; #3 = Filter from #2 the records where the average life expectancy is shorter than 72.0, and retrieve the sum of population, average life expectancy, and continent for each continent"
    },
    {
        "id": "44db72f54c47304dbbd1f800ba4272ad3c910e06f260585d08261e5501deaddd",
        "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?",
        "query": "SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country WITH (FORCESCAN) GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ LifeExpectancy , Population , Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , SUM(Population) AS Sum_Population , Continent ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy < 72.0 ] Output [ Sum_Population , Avg_LifeExpectancy , Continent ]",
        "cte": "WITH Scan_1 AS ( SELECT LifeExpectancy, Population, Continent FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, SUM(Population) AS Sum_Population, Continent FROM Scan_1 GROUP BY Continent ), Filter_3 AS ( SELECT Sum_Population, Avg_LifeExpectancy, Continent FROM Aggregate_2 WHERE Avg_LifeExpectancy < 72.0 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country  GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72",
        "qd": "#1 = Scan the table country and retrieve the life expectancy, population, and continent of all countries ; #2 = Group #1 by continent and aggregate the average life expectancy and sum of population for each continent ; #3 = Filter from #2 all the continents with average life expectancy less than 72 and retrieve the sum of population, average life expectancy, and continent"
    },
    {
        "id": "22fcbb5f6a1777be8b833f8a2bc392d1c77031be64764d8c10e70ae9a4d5e94b",
        "question": "What are the names and areas of countries with the top 5 largest area?",
        "query": "SELECT TOP 5 Name , SurfaceArea FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #2 = TopSort [ #1 ] Rows [ 5 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, SurfaceArea FROM world_1.country ), TopSort_2 AS ( SELECT TOP 5 Name, SurfaceArea FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 5 Name , SurfaceArea FROM world_1.country  ORDER BY SurfaceArea DESC",
        "qd": "#1 = Scan the table country and retrieve the names and surface areas of all countries ; #2 = Sort the records from #1 based on the surface area in descending order, select the top 5 records, and retrieve the names and surface areas of the countries with the largest area."
    },
    {
        "id": "cd4f8032e1b1e509a1649a730f3394d342daf5f43398b10aed829e6a4dfbe85b",
        "question": "Return the names and surface areas of the 5 largest countries.",
        "query": "SELECT TOP 5 Name , SurfaceArea FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #2 = TopSort [ #1 ] Rows [ 5 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, SurfaceArea FROM world_1.country ), TopSort_2 AS ( SELECT TOP 5 Name, SurfaceArea FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 5 Name , SurfaceArea FROM world_1.country  ORDER BY SurfaceArea DESC",
        "qd": "#1 = Scan the table country and retrieve the names and surface areas of all countries ; #2 = Sort the records from #1 based on the surface area in descending order, select the top 5 records, and retrieve the names and surface areas of the 5 largest countries"
    },
    {
        "id": "28ddb7e6b593e16d58aa021532f2d9e57af7b7574f003c9bc9d699893cf9f603",
        "question": "What are names of countries with the top 3 largest population?",
        "query": "SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 3 Name FROM world_1.country  ORDER BY Population DESC",
        "qd": "#1 = Scan the table country and retrieve the names and populations of all countries ; #2 = Sort the records from #1 based on the population in descending order, select the top 3 records, and retrieve the names of the countries with the top 3 largest population"
    },
    {
        "id": "a0d50025a0dacc9b581e55f5d52ab1998a2dbf2f8f5f5d67a453d729b68fa414",
        "question": "Return the names of the 3 most populated countries.",
        "query": "SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 3 Name FROM world_1.country  ORDER BY Population DESC",
        "qd": "#1 = Scan the table country and retrieve the names and populations of all countries ; #2 = Sort the records from #1 based on the population in descending order, select the top 3 records, and retrieve the names of the 3 most populated countries."
    },
    {
        "id": "942ebb3b2f283625abe8cb0f069bc441f28e042e63ea9dbad0891cdf9bdcf33b",
        "question": "What are the names of the nations with the 3 lowest populations?",
        "query": "SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population ASC ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 3 Name FROM world_1.country  ORDER BY Population ASC",
        "qd": "#1 = Scan the table country and retrieve the names and populations of all nations ; #2 = Sort the records from #1 based on the population in ascending order, select the top 3 records, and retrieve the names of the nations with the 3 lowest populations"
    },
    {
        "id": "173f849d4bec55e9caad720de4a82d892641f70b6b43abbd5c0e7447006ac41b",
        "question": "Return the names of the 3 countries with the fewest people.",
        "query": "SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population ASC ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 3 Name FROM world_1.country  ORDER BY Population ASC",
        "qd": "#1 = Scan the table country and retrieve the names and populations of all countries. ; #2 = Sort the records from #1 based on the population in ascending order, select the first 3 records, and retrieve the names and populations of the 3 countries with the fewest people."
    },
    {
        "id": "5cba4e69aae92b9f05c0830dd3c8732a06eb00f0a2fa55052e50eba9644d1333",
        "question": "how many countries are in Asia?",
        "query": "SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'asia' ] Output [ 1 as ONE ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Continent FROM world_1.country ), Filter_2 AS ( SELECT 1 as ONE FROM Scan_1 WHERE Continent = 'asia' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE continent = 'Asia'",
        "qd": "#1 = Scan the table country and retrieve the continents of all countries ; #2 = Filter from #1 all the countries with Asia continent and create a column with value 1 for each country ; #3 = Aggregate and count the number of records with value 1 in #2 to find out how many countries are in Asia."
    },
    {
        "id": "52dc4eb9635d36ed792f4224850acccdee7af499d06a3a62e4d20a8fe807686a",
        "question": "Count the number of countries in Asia.",
        "query": "SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Output [ Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'asia' ] Output [ 1 as ONE ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Continent FROM world_1.country ), Filter_2 AS ( SELECT 1 as ONE FROM Scan_1 WHERE Continent = 'asia' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE continent = 'Asia'",
        "qd": "#1 = Scan the table country and retrieve the continent of all countries. ; #2 = Filter from #1 all the countries with continent Asia and assign a value of 1 to each record. ; #3 = Aggregate the number of records in #2 to find the count of countries in Asia."
    },
    {
        "id": "3a1b4170c50ef2fb65e0ffaa67b45ab9282a898ec6581c895060e31332cf025b",
        "question": "What are the names of the countries that are in the continent of Europe and have a population of 80000?",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Europe' AND Population = '80000' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Population = 80000 ] Output [ Name , Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population, Continent FROM world_1.country WHERE Population = 80000 ), Filter_2 AS ( SELECT Name FROM Scan_1 WHERE Continent = 'Europe' ) SELECT * FROM Filter_2",
        "clean_query": "SELECT Name FROM world_1.country  WHERE continent = 'Europe' AND Population = '80000'",
        "qd": "#1 = Scan the table country and retrieve the names, population, and continents of all countries with a population of 80000 ; #2 = Filter from #1 all the countries with the continent of Europe and retrieve the names"
    },
    {
        "id": "96e58374f4e8995981abdae0add2d49bb797fb8e70ebe07715e6906b533c1775",
        "question": "Give the names of countries that are in Europe and have a population equal to 80000.",
        "query": "SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Europe' AND Population = '80000' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ Population = 80000 ] Output [ Name , Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population, Continent FROM world_1.country WHERE Population = 80000 ), Filter_2 AS ( SELECT Name FROM Scan_1 WHERE Continent = 'Europe' ) SELECT * FROM Filter_2",
        "clean_query": "SELECT Name FROM world_1.country  WHERE continent = 'Europe' AND Population = '80000'",
        "qd": "#1 = Scan the table country and retrieve the names, populations, and continents of all countries with a population equal to 80000. ; #2 = Filter from #1 all the countries with Europe continent and retrieve the names."
    },
    {
        "id": "18f17add3885280a0a30c8986a4b02372b3efe4cc11524ebcf759748834e7f3f",
        "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?",
        "query": "select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country WITH (FORCESCAN) where continent = 'north america' and surfacearea > 3000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ SurfaceArea > 3000.0 ] Output [ SurfaceArea , Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'north america' ] Output [ SurfaceArea , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , AVG(SurfaceArea) AS Avg_SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Population, Continent FROM world_1.country WHERE SurfaceArea > 3000.0 ), Filter_2 AS ( SELECT SurfaceArea, Population FROM Scan_1 WHERE Continent = 'north america' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, AVG(SurfaceArea) AS Avg_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country  where continent = 'north america' and surfacearea > 3000",
        "qd": "#1 = Scan the table country to find the countries whose surface area is bigger than 3000 and retrieve the surface area, population, and continent ; #2 = Filter the records from #1 to find the countries in the continent of North America and retrieve the surface area and population ; #3 = Aggregate the sum of the population and the average surface area from #2 to find the total population and average area of countries in the continent of North America whose area is bigger than 3000"
    },
    {
        "id": "a7b231276cbde5622a0f9f60560e0af1bab62d204e97a49af38c91aa73d0f2c0",
        "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .",
        "query": "select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country WITH (FORCESCAN) where continent = 'north america' and surfacearea > 3000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ country ] Predicate [ SurfaceArea > 3000.0 ] Output [ SurfaceArea , Population , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'north america' ] Output [ SurfaceArea , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , AVG(SurfaceArea) AS Avg_SurfaceArea ]",
        "cte": "WITH Scan_1 AS ( SELECT SurfaceArea, Population, Continent FROM world_1.country WHERE SurfaceArea > 3000.0 ), Filter_2 AS ( SELECT SurfaceArea, Population FROM Scan_1 WHERE Continent = 'north america' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, AVG(SurfaceArea) AS Avg_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
        "clean_query": "select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country  where continent = 'north america' and surfacearea > 3000",
        "qd": "#1 = Scan the table country and retrieve the surface area, population, and continent of countries with a surface area greater than 3000. ; #2 = Filter from #1 all the countries with the North America continent and retrieve the surface area and population. ; #3 = Aggregate the sum of the population and the average surface area of the countries in North America with a surface area greater than 3000."
    },
    {
        "id": "2531b53784175464db3290bd4ce5272d913cecfecb1ae586d9d36047e4493035",
        "question": "What are the cities whose population is between 160000 and 900000?",
        "query": "SELECT name FROM world_1.city WITH (FORCESCAN) WHERE Population BETWEEN 160000 AND 900000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ city ] Predicate [ Population >= 160000 AND Population <= 900000 ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.city WHERE Population >= 160000 AND Population <= 900000 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name FROM world_1.city  WHERE Population BETWEEN 160000 AND 900000",
        "qd": "#1 = Scan the table city and retrieve the names and populations of all cities whose population is between 160000 and 900000."
    },
    {
        "id": "066534f971100acbd4ecf9d5a5ec2ac78b6c117238983af48d09b97b812e2236",
        "question": "Return the names of cities that have a population between 160000 and 900000 .",
        "query": "select name FROM world_1.city WITH (FORCESCAN) where population between 160000 and 900000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ city ] Predicate [ Population >= 160000 AND Population <= 900000 ] Output [ Name , Population ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Population FROM world_1.city WHERE Population >= 160000 AND Population <= 900000 ) SELECT * FROM Scan_1",
        "clean_query": "select name FROM world_1.city  where population between 160000 and 900000",
        "qd": "#1 = Scan the table city and retrieve the names of cities that have a population between 160000 and 900000."
    },
    {
        "id": "7d87dde5ac17ed632e07ab362831b1b48cbfcfa82d40bf5164a4590ca7894143",
        "question": "Which language is spoken by the largest number of countries?",
        "query": "SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Language , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Language, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage  GROUP BY LANGUAGE ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table countrylanguage and retrieve all languages ; #2 = Group #1 by language and count the number of countries that speak each language ; #3 = Sort the records from #2 based on the count of countries in descending order, select the first record, and identify the language spoken by the largest number of countries and its count of countries."
    },
    {
        "id": "92a0c46b93d249a1e5a2e1086fd87aae4f97324b1cca25ecbdad7407df10a42f",
        "question": "Give the language that is spoken in the most countries.",
        "query": "SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Language , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Language, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage  GROUP BY LANGUAGE ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table countrylanguage and retrieve the languages spoken in all countries. ; #2 = Group the records from #1 by language and aggregate the count per language to find the number of countries that speak each language. ; #3 = Sort the records from #2 based on the count of countries in descending order, select the first record, and identify the language that is spoken in the most countries and its count of countries."
    },
    {
        "id": "68c96d827202512a504df23f6ab033cb7b1ac9782afc82257aeab24e8c645959",
        "question": "What is the language spoken by the largest percentage of people in each country?",
        "query": "SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE , CountryCode OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode , Language ] Output [ CountryCode, Language, MAX(percentage) AS Max_percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode, Language, MAX(percentage) AS Max_percentage FROM Scan_1 GROUP BY CountryCode, Language, CountryCode , Language ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  GROUP BY LANGUAGE , CountryCode",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country code, percentage, and language of all records. ; #2 = Group #1 by country code and language, and aggregate the maximum percentage spoken in each country."
    },
    {
        "id": "a5a6fef561cf350fc2c0f61225c80048d3e41977999c3e030b470ed1c19485e9",
        "question": "What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?",
        "query": "SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE , CountryCode OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode , Language ] Output [ CountryCode, Language, MAX(percentage) AS Max_percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode, Language, MAX(percentage) AS Max_percentage FROM Scan_1 GROUP BY CountryCode, Language, CountryCode , Language ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  GROUP BY LANGUAGE , CountryCode",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes, percentages, and languages spoken by each country ; #2 = Group #1 by country code and language, and aggregate the maximum percentage for each combination of country and language. Retrieve the country codes, languages, and maximum percentages."
    },
    {
        "id": "16efa1d00b88ef4622bb7345796502ef8e42ddb5fdc95f2e66d3ed8ca53f44cf",
        "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?",
        "query": "SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Spanish' ] Output [ Language , Percentage , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ countstar AS Count_Star , MAX(Percentage) AS Max_Percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, Percentage, CountryCode FROM world_1.countrylanguage WHERE Language = 'Spanish' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, MAX(Percentage) AS Max_Percentage FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
        "qd": "#1 = Scan the table countrylanguage and retrieve the language, percentage, and country code of all the records where the language is Spanish ; #2 = Group the records from #1 by country code and aggregate the count of records and the maximum percentage of Spanish speakers to find the total number of countries where Spanish is spoken by the largest percentage of people."
    },
    {
        "id": "a1fd3e36763de62d67634d2be00cc30e68e90ed8288550458734eb39e0156e48",
        "question": "Count the number of countries for which Spanish is the predominantly spoken language.",
        "query": "SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Spanish' ] Output [ Language , Percentage , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ countstar AS Count_Star , MAX(Percentage) AS Max_Percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT Language, Percentage, CountryCode FROM world_1.countrylanguage WHERE Language = 'Spanish' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, MAX(Percentage) AS Max_Percentage FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
        "qd": "#1 = Scan the table countrylanguage and retrieve the records of all countries where Spanish is the spoken language, along with the percentage of speakers and the country code ; #2 = Group the records from #1 by country code and aggregate the count of records and the maximum percentage of speakers to find the number of countries where Spanish is the predominantly spoken language"
    },
    {
        "id": "5ff7298e82e25f73402caec694fb894b9528e6e8552ae504972b448f45281a6b",
        "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?",
        "query": "SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'spanish' ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode , MAX(Percentage) as Max_Percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage WHERE Language = 'spanish' ), Aggregate_2 AS ( SELECT CountryCode, MAX(Percentage) as Max_Percentage FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
        "qd": "#1 = Scan the table countrylanguage and retrieve the country codes and percentages where Spanish is spoken ; #2 = Group #1 by country code and aggregate the maximum percentage of Spanish speakers to find the codes of countries where Spanish is spoken by the largest percentage of people"
    },
    {
        "id": "e0f60ed999370f8735907bbe27e1dc40ae9fe4e929fb31a12cc67e9f84d28816",
        "question": "Return the codes of countries for which Spanish is the predominantly spoken language.",
        "query": "SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'spanish' ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode , MAX(Percentage) as Max_Percentage ]",
        "cte": "WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage WHERE Language = 'spanish' ), Aggregate_2 AS ( SELECT CountryCode, MAX(Percentage) as Max_Percentage FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
        "qd": "#1 = Scan the table countrylanguage and retrieve the CountryCode and Percentage for all languages where the language is Spanish ; #2 = Group the records from #1 by CountryCode and aggregate the maximum percentage for each country to find the countries where Spanish is the predominantly spoken language and retrieve the CountryCode"
    },
    {
        "id": "e3cddc01a42e6e4c8742e8b32c7081491e9ad65503bb886b0e38660e5c8f9e59",
        "question": "How many conductors are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM orchestra.conductor",
        "qd": "#1 = Scan the table conductor and retrieve a field with the value 1 for each conductor ; #2 = Aggregate the number of records in #1 to find the count of conductors"
    },
    {
        "id": "29ca0628d7688ba66867d6b2b9c69262aed688372b572e9bfb32690f4dfb508c",
        "question": "Count the number of conductors.",
        "query": "SELECT count ( * ) AS Count_Star FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM orchestra.conductor",
        "qd": "#1 = Scan the table conductor and retrieve a constant value of 1 for each conductor. ; #2 = Aggregate the number of records from #1 to find the count of conductors."
    },
    {
        "id": "1a9e7cad0a48794e4ee18f147764337a553b0709e9a446f572b6fc855fc872d2",
        "question": "List the names of conductors in ascending order of age.",
        "query": "SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM orchestra.conductor ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
        "clean_query": "SELECT Name FROM orchestra.conductor  ORDER BY Age ASC",
        "qd": "#1 = Scan the table conductor and retrieve the names and ages of all conductors ; #2 = Sort the records from #1 based on the age in ascending order and retrieve the names and ages"
    },
    {
        "id": "023663de7188fe415732228ff855e71fab5db97f44ddd42d8472b0f437beeb7a",
        "question": "What are the names of conductors, ordered by age?",
        "query": "SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Age FROM orchestra.conductor ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
        "clean_query": "SELECT Name FROM orchestra.conductor  ORDER BY Age ASC",
        "qd": "#1 = Scan the table conductor and retrieve the names and ages of all conductors ; #2 = Sort the records from #1 based on the age in ascending order and retrieve the names and ages"
    },
    {
        "id": "e42e09df5ba3b939399271de5fec1b7bcb6fd4f75c9a0ebc3b54f0823831ff38",
        "question": "What are the names of conductors whose nationalities are not \"USA\"?",
        "query": "SELECT Name FROM orchestra.conductor WITH (FORCESCAN) WHERE Nationality ! = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Predicate [ Nationality <> 'USA' ] Output [ Name , Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Nationality FROM orchestra.conductor WHERE Nationality <> 'USA' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM orchestra.conductor  WHERE Nationality ! = 'USA'",
        "qd": "#1 = Scan the table conductor and retrieve the names of all conductors whose nationalities are not \"USA\""
    },
    {
        "id": "d52b2fe734438314b9c3e2d3f0bd85983be6b638f7cdd57539fce25c52bfaa38",
        "question": "Return the names of conductors that do not have the nationality \"USA\".",
        "query": "SELECT Name FROM orchestra.conductor WITH (FORCESCAN) WHERE Nationality ! = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Predicate [ Nationality <> 'USA' ] Output [ Name , Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Nationality FROM orchestra.conductor WHERE Nationality <> 'USA' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM orchestra.conductor  WHERE Nationality ! = 'USA'",
        "qd": "#1 = Scan the table conductor and retrieve the names of all conductors who do not have the nationality \"USA\"."
    },
    {
        "id": "6b65ceb9aba024837ed659880317510fa7c5a5b16560bf85c2308d4fb5e398fd",
        "question": "What are the record companies of orchestras in descending order of years in which they were founded?",
        "query": "SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) ORDER BY Year_of_Founded DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company , Year_of_Founded ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Founded DESC ] Output [ Record_Company , Year_of_Founded ]",
        "cte": "WITH Scan_1 AS ( SELECT Record_Company, Year_of_Founded FROM orchestra.orchestra ) SELECT Record_Company, Year_of_Founded FROM Scan_1 ORDER BY Year_of_Founded DESC",
        "clean_query": "SELECT Record_Company FROM orchestra.orchestra  ORDER BY Year_of_Founded DESC",
        "qd": "#1 = Scan the table orchestra and retrieve the record companies and years of founding for all orchestras ; #2 = Sort the records from #1 based on the year of founding in descending order and retrieve the record companies and years of founding"
    },
    {
        "id": "df0d5aca30e690984137713a6b519a67f62563e44b1d3e5c69ca9b4155364f3b",
        "question": "Return the record companies of orchestras, sorted descending by the years in which they were founded.",
        "query": "SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) ORDER BY Year_of_Founded DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company , Year_of_Founded ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Founded DESC ] Output [ Record_Company , Year_of_Founded ]",
        "cte": "WITH Scan_1 AS ( SELECT Record_Company, Year_of_Founded FROM orchestra.orchestra ) SELECT Record_Company, Year_of_Founded FROM Scan_1 ORDER BY Year_of_Founded DESC",
        "clean_query": "SELECT Record_Company FROM orchestra.orchestra  ORDER BY Year_of_Founded DESC",
        "qd": "#1 = Scan the table orchestra and retrieve the record companies and years of foundation for all orchestras ; #2 = Sort the records from #1 based on the year of foundation in descending order and retrieve the record companies"
    },
    {
        "id": "998f04b839afe54f9a8e1ec684ceb8a3ee1a4ad91dda2611a9867a29391d132c",
        "question": "What is the average attendance of shows?",
        "query": "SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ show ] Output [ Attendance ] ; #2 = Aggregate [ #1 ] Output [ AVG(Attendance) AS Avg_Attendance ]",
        "cte": "WITH Scan_1 AS ( SELECT Attendance FROM orchestra.show ), Aggregate_2 AS ( SELECT AVG(Attendance) AS Avg_Attendance FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW",
        "qd": "#1 = Scan the table show and retrieve the attendance of all shows ; #2 = Aggregate the average attendance of all shows to find the average attendance of shows"
    },
    {
        "id": "6bbd055316a1a875b11f3caec173eb5a08b28dcebb6f61a5fb6c67d187d5d415",
        "question": "Return the average attendance across all shows.",
        "query": "SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ show ] Output [ Attendance ] ; #2 = Aggregate [ #1 ] Output [ AVG(Attendance) AS Avg_Attendance ]",
        "cte": "WITH Scan_1 AS ( SELECT Attendance FROM orchestra.show ), Aggregate_2 AS ( SELECT AVG(Attendance) AS Avg_Attendance FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW",
        "qd": "#1 = Scan the table show and retrieve the attendance of all shows ; #2 = Aggregate the average attendance from #1 to find the average attendance across all shows"
    },
    {
        "id": "185d457b4daa3628c437828ee9ad39f78143b5f76428b6d1991904e89b9b7ec4",
        "question": "What are the maximum and minimum share of performances whose type is not \"Live final\".",
        "query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance WITH (FORCESCAN) WHERE TYPE ! = 'Live final' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ performance ] Predicate [ Type <> 'Live final' ] Output [ Share , Type ] ; #2 = Aggregate [ #1 ] Output [ MAX(Share) AS Max_Share , MIN(Share) AS Min_Share ]",
        "cte": "WITH Scan_1 AS ( SELECT Share, Type FROM orchestra.performance WHERE Type <> 'Live final' ), Aggregate_2 AS ( SELECT MAX(Share) AS Max_Share, MIN(Share) AS Min_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance  WHERE TYPE ! = 'Live final'",
        "qd": "#1 = Scan the table performance and retrieve the shares and types of all performances that are not \"Live final\". ; #2 = Aggregate the maximum and minimum shares from #1 and identify the maximum and minimum share of performances that are not \"Live final\"."
    },
    {
        "id": "bcc64c0bb22e3f9f4d8fd691b32c0951929c845558050f560d0cb8ec9d35aa9f",
        "question": "Return the maximum and minimum shares for performances that do not have the type \"Live final\".",
        "query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance WITH (FORCESCAN) WHERE TYPE ! = 'Live final' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ performance ] Predicate [ Type <> 'Live final' ] Output [ Share , Type ] ; #2 = Aggregate [ #1 ] Output [ MAX(Share) AS Max_Share , MIN(Share) AS Min_Share ]",
        "cte": "WITH Scan_1 AS ( SELECT Share, Type FROM orchestra.performance WHERE Type <> 'Live final' ), Aggregate_2 AS ( SELECT MAX(Share) AS Max_Share, MIN(Share) AS Min_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance  WHERE TYPE ! = 'Live final'",
        "qd": "#1 = Scan the table Performance and retrieve the share and type of all performances that are not \"Live final\" ; #2 = Aggregate the maximum and minimum shares from #1 as Max Share and Min Share"
    },
    {
        "id": "1945cc8311cc7faaa4f993120e9e91e02ec404f2dd194708081e7ac521de00ba",
        "question": "How many different nationalities do conductors have?",
        "query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor",
        "qd": "#1 = Scan the table conductor and retrieve all the distinct nationalities of conductors ; #2 = Aggregate the number of distinct nationalities found in #1 and output the count of different nationalities conductors have."
    },
    {
        "id": "12ced80a38250c5c815da4230bfbddaf6b6310ee3e3c49b50a0747f812fdd80c",
        "question": "Count the number of different nationalities of conductors.",
        "query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor",
        "qd": "#1 = Scan the table conductor and retrieve the distinct nationalities of all conductors ; #2 = Aggregate the count of distinct nationalities to find the number of different nationalities of conductors"
    },
    {
        "id": "f32f921b7e1bb2c2a6a65e5e2c8979d5327e1a196ff0365c2e9f2547a5766f1b",
        "question": "List names of conductors in descending order of years of work.",
        "query": "SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ) SELECT Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC",
        "clean_query": "SELECT Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC",
        "qd": "#1 = Scan the table conductor and retrieve the names and years of work of all conductors. ; #2 = Sort the records from #1 based on the years of work in descending order and retrieve the names of conductors."
    },
    {
        "id": "e1c968c860459137f04af68da9abc88ba0199c805ad1c700791b8e06de9d9b00",
        "question": "What are the names of conductors, sorted descending by the number of years they have worked?",
        "query": "SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ) SELECT Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC",
        "clean_query": "SELECT Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC",
        "qd": "#1 = Scan the table conductor and retrieve the names and years of work of all conductors ; #2 = Sort the records from #1 based on the years of work in descending order and retrieve the names of conductors"
    },
    {
        "id": "6aa937ac96aa0f82051b2f20f694460c36d303d0182fbfdc794547f31f98e84d",
        "question": "List the name of the conductor with the most years of work.",
        "query": "SELECT TOP 1 Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ), TopSort_2 AS ( SELECT TOP 1 Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC",
        "qd": "#1 = Scan the table conductor and retrieve the names and years of work of all conductors ; #2 = Sort the records from #1 based on the years of work in descending order, select the first record, and identify the name of the conductor with the most years of work"
    },
    {
        "id": "7b60704a707282ff6d06ee3878ad4f01c67cc82227ec275359829b2c1cba6515",
        "question": "What is the name of the conductor who has worked the greatest number of years?",
        "query": "SELECT TOP 1 Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ), TopSort_2 AS ( SELECT TOP 1 Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC",
        "qd": "#1 = Scan the table conductor and retrieve the names and years of work for all conductors ; #2 = Sort the records from #1 based on the years of work in descending order, select the first record, and identify the name of the conductor who has worked the greatest number of years"
    },
    {
        "id": "47842e1ee406532450416aa3a3b74cc576643fbc9dfe9d4bffca7d9d676ecccf",
        "question": "Show the names of conductors and the orchestras they have conducted.",
        "query": "SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID , Orchestra ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #1.Name , #2.Orchestra ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID, Orchestra FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_2.Orchestra FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID",
        "qd": "#1 = Scan the table conductor and retrieve the conductor IDs and names of all conductors ; #2 = Scan the table orchestra and retrieve the conductor IDs and orchestras of all orchestras ; #3 = Join #1 and #2 based on the matching conductor IDs and retrieve the names of the conductors and the orchestras they have conducted"
    },
    {
        "id": "ff3b230011a43e158f188c66978cc47d9dafc64bc34fcc368317639768ba0419",
        "question": "What are the names of conductors as well as the corresonding orchestras that they have conducted?",
        "query": "SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID , Orchestra ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #1.Name , #2.Orchestra ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID, Orchestra FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_2.Orchestra FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID",
        "qd": "#1 = Scan the table Conductor and retrieve the conductor IDs and names of all conductors ; #2 = Scan the table Orchestra and retrieve the conductor IDs and names of all orchestras ; #3 = Join #1 and #2 based on the matching conductor ID and retrieve the names of conductors as well as the corresponding orchestras"
    },
    {
        "id": "bd62d7dedb5bfdf4408dfe5cc9e377d5b62d7a60f33ed0609c915537c6964341",
        "question": "Show the names of conductors that have conducted more than one orchestras.",
        "query": "SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1",
        "qd": "#1 = Scan the table conductor to retrieve the conductor ID and names of all conductors ; #2 = Scan the table orchestra to retrieve the conductor IDs ; #3 = Join #1 and #2 based on the matching conductor ID and retrieve the names of the conductors ; #4 = Group #3 by conductor name and conductor ID and aggregate the count of conductors per name ; #5 = Filter #4 to retrieve the names of conductors who have conducted more than one orchestra"
    },
    {
        "id": "23198886c398bd787db193781c1338ba26d87ad2e4f9b63d02819e9fd757ecbc",
        "question": "What are the names of conductors who have conducted at more than one orchestra?",
        "query": "SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1",
        "qd": "#1 = Scan the table conductor and retrieve the conductor IDs and names of all conductors ; #2 = Scan the table orchestra and retrieve the conductor IDs of all orchestras ; #3 = Join #1 and #2 based on the matching conductor ID and retrieve the names and conductor IDs ; #4 = Group #3 by name and conductor ID and aggregate the count of conductor IDs per name to find the number of orchestras each conductor has conducted ; #5 = Filter from #4 all the conductors with a count of conductor IDs greater than 1 and retrieve their names"
    },
    {
        "id": "3b3a4ebe0ad418bead19cc531246d103d023da54e666715365d14d3219b84639",
        "question": "Show the name of the conductor that has conducted the most number of orchestras.",
        "query": "SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table conductor and retrieve the conductor IDs and names of all conductors ; #2 = Scan the table orchestra and retrieve the conductor IDs of all orchestras ; #3 = Join #1 and #2 based on the matching conductor ID and retrieve the names of the conductors ; #4 = Group #3 by name and conductor ID and aggregate the count of orchestras conducted by each conductor ; #5 = Sort the records from #4 based on the count of orchestras in descending order, select the first record, and identify the name of the conductor who has conducted the most number of orchestras and the count of orchestras conducted."
    },
    {
        "id": "029a30407cbfd44db13238d8122ed6af9d93a9a0eb4dfa9fafbdd7c07c9e6d91",
        "question": "What is the name of the conductor who has conducted the most orchestras?",
        "query": "SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table conductor and retrieve the conductor IDs and names of all conductors. ; #2 = Scan the table orchestra and retrieve all conductor IDs. ; #3 = Join #1 and #2 based on the matching conductor ID and retrieve the names of the conductors. ; #4 = Group #3 by name and conductor ID and aggregate the count per conductor to find how many orchestras each conductor has conducted. ; #5 = Sort the records from #4 based on the count of orchestras in descending order, select the first record, and identify the name of the conductor who has conducted the most orchestras."
    },
    {
        "id": "f6382cc791510b0b5267aa6fe2219f8af8fa14534798187ff413f54375b1333f",
        "question": "Please show the name of the conductor that has conducted orchestras founded after 2008.",
        "query": "SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2008.0 ] Output [ Conductor_ID , Year_of_Founded ] ; #2 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Year_of_Founded FROM orchestra.orchestra WHERE Year_of_Founded > 2008.0 ), Scan_2 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008",
        "qd": "#1 = Scan the table orchestra to find all the orchestras that were founded after 2008 and retrieve the conductor IDs and year of founding. ; #2 = Scan the table conductor to retrieve the conductor IDs and names of all conductors. ; #3 = Join #1 and #2 based on the matching conductor IDs and retrieve the names of the conductors that have conducted orchestras founded after 2008."
    },
    {
        "id": "eb81b335df82730a2915851df1bd7d6ce9dd0e5aab61ca14535b1f22398ebb9f",
        "question": "What are the names of conductors who have conducted orchestras founded after the year 2008?",
        "query": "SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2008.0 ] Output [ Conductor_ID , Year_of_Founded ] ; #2 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Conductor_ID, Year_of_Founded FROM orchestra.orchestra WHERE Year_of_Founded > 2008.0 ), Scan_2 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008",
        "qd": "#1 = Scan the table orchestra and retrieve the conductor IDs and years of founding of all orchestras founded after the year 2008 ; #2 = Scan the table conductor and retrieve the conductor IDs and names of all conductors ; #3 = Join #1 and #2 based on the matching conductor IDs and retrieve the names of conductors"
    },
    {
        "id": "2b498fdf0e61dd8e384e559787a60d74066bf3945e4a574b958a7e65d8676f8b",
        "question": "Please show the different record companies and the corresponding number of orchestras.",
        "query": "SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra  GROUP BY Record_Company",
        "qd": "#1 = Scan the table orchestra and retrieve the record company column ; #2 = Group #1 by record company and count the number of orchestras for each record company"
    },
    {
        "id": "a580c27e04c6eaff182b09c757eac7709d4949a57857163ecf6f41adeb7e5063",
        "question": "How many orchestras does each record company manage?",
        "query": "SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra  GROUP BY Record_Company",
        "qd": "#1 = Scan the table orchestra and retrieve the record company of each orchestra ; #2 = Group the records from #1 by record company and aggregate the count per record company to find the number of orchestras managed by each record company."
    },
    {
        "id": "8f5134a55bcc35aa15116970a07f380e26620ed0e44157fb4a7a5afdeea9b368",
        "question": "Please show the record formats of orchestras in ascending order of count.",
        "query": "SELECT Major_Record_Format FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] GroupBy [ Major_Record_Format ] Output [ Major_Record_Format , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Count_Star ASC ] Output [ Major_Record_Format , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Major_Record_Format, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Major_Record_Format ) SELECT Major_Record_Format, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC",
        "clean_query": "SELECT Major_Record_Format FROM orchestra.orchestra  GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC",
        "qd": "#1 = Scan the table orchestra and retrieve the major record formats of all orchestras. ; #2 = Group #1 by major record format and count the number of occurrences for each format. ; #3 = Sort the records from #2 based on the count of occurrences in ascending order, and retrieve the major record format and count."
    },
    {
        "id": "7569cefc19424ebb6ee479425b4d76d5f2227a77640326c89b0d7ecc30cb1451",
        "question": "What are the major record formats of orchestras, sorted by their frequency?",
        "query": "SELECT Major_Record_Format FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] GroupBy [ Major_Record_Format ] Output [ Major_Record_Format , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Count_Star ASC ] Output [ Major_Record_Format , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Major_Record_Format, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Major_Record_Format ) SELECT Major_Record_Format, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC",
        "clean_query": "SELECT Major_Record_Format FROM orchestra.orchestra  GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC",
        "qd": "#1 = Scan the table orchestra and retrieve the major record formats of all orchestras ; #2 = Group the records from #1 by major record format and aggregate the count of each format ; #3 = Sort the records from #2 based on the count of each format in ascending order and retrieve the major record format and its count"
    },
    {
        "id": "f1cf3d5bc498895a312f9d97a3c23ed602f4cb8b41f09d88666d37f56f9a4c4b",
        "question": "List the record company shared by the most number of orchestras.",
        "query": "SELECT TOP 1 Record_Company FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Record_Company , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ), TopSort_3 AS ( SELECT TOP 1 Record_Company, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Record_Company FROM orchestra.orchestra  GROUP BY Record_Company ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table orchestra and retrieve the record company of all orchestras. ; #2 = Group the records from #1 by record company and aggregate the count of orchestras per record company. ; #3 = Sort the records from #2 based on the count of orchestras in descending order, select the first record, and list the record company that is shared by the most number of orchestras along with the count of orchestras."
    },
    {
        "id": "ca57dfe053d7730d47f8a7dec696ff0bffb0c4a5ae2eddc518636c0a9cc93899",
        "question": "What is the record company used by the greatest number of orchestras?",
        "query": "SELECT TOP 1 Record_Company FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Record_Company , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ), TopSort_3 AS ( SELECT TOP 1 Record_Company, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Record_Company FROM orchestra.orchestra  GROUP BY Record_Company ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table orchestra and retrieve the record company used by each orchestra ; #2 = Group the records from #1 by record company and aggregate the count per record company to find the number of orchestras using each record company ; #3 = Sort the records from #2 based on the count of orchestras in descending order, select the first record, and identify the record company that is used by the greatest number of orchestras and the count of orchestras."
    },
    {
        "id": "a5b58ec921e463893a58faab86400b125f114b5c0469aa70c41f39267cc6731e",
        "question": "List the names of orchestras that have no performance.",
        "query": "SELECT Orchestra FROM orchestra.orchestra WITH (FORCESCAN) WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance WITH (FORCESCAN) ) ",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Orchestra_ID , Orchestra ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Orchestra_ID IS NULL OR #1.Orchestra_ID = #2.Orchestra_ID ] Output [ #1.Orchestra ]",
        "cte": "WITH Scan_1 AS ( SELECT Orchestra_ID, Orchestra FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Except_3 AS ( SELECT Scan_1.Orchestra FROM Scan_1 WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Orchestra FROM orchestra.orchestra  WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance  )",
        "qd": "#1 = Scan the table orchestra and retrieve the orchestra IDs and names of all orchestras. ; #2 = Scan the table performance and retrieve the orchestra IDs. ; #3 = Find the orchestras that are in #1 but not in #2, considering cases where the orchestra ID is null or the orchestra ID matches in #1 and #2. Retrieve the names of these orchestras."
    },
    {
        "id": "d7ae9ecca2a02d1ea9bab41b4eb1fb9f4020c46bb3c6f7cf3723d9032eb7b454",
        "question": "What are the orchestras that do not have any performances?",
        "query": "SELECT Orchestra FROM orchestra.orchestra WITH (FORCESCAN) WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance WITH (FORCESCAN) ) ",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Orchestra_ID , Orchestra ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Orchestra_ID IS NULL OR #1.Orchestra_ID = #2.Orchestra_ID ] Output [ #1.Orchestra ]",
        "cte": "WITH Scan_1 AS ( SELECT Orchestra_ID, Orchestra FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Except_3 AS ( SELECT Scan_1.Orchestra FROM Scan_1 WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Orchestra FROM orchestra.orchestra  WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance  )",
        "qd": "#1 = Scan the table orchestra and retrieve the orchestra IDs and names of all orchestras ; #2 = Scan the table performance and retrieve the orchestra IDs ; #3 = Return all the orchestra names from #1 that either do not have any performance records or have a matching orchestra ID in #2"
    },
    {
        "id": "ee422562896a77aa11e6c9ce20da92a2899b4cc499fba146b5cdd42528824b2b",
        "question": "Show the record companies shared by orchestras founded before 2003 and after 2003.",
        "query": "SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded > 2003 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded < 2003.0 ] Distinct [ true ] Output [ Record_Company , Year_of_Founded ] ; #2 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2003.0 ] Output [ Record_Company , Year_of_Founded ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Record_Company = #2.Record_Company ] Output [ #1.Record_Company ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Record_Company, Year_of_Founded FROM orchestra.orchestra WHERE Year_of_Founded < 2003.0 ), Scan_2 AS ( SELECT Record_Company, Year_of_Founded FROM orchestra.orchestra WHERE Year_of_Founded > 2003.0 ), Intersect_3 AS ( SELECT Scan_1.Record_Company FROM Scan_1 WHERE Record_Company IN (SELECT Record_Company FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded > 2003",
        "qd": "#1 = Scan the table orchestra and retrieve the record companies of all orchestras founded before 2003 without duplicates ; #2 = Scan the table orchestra and retrieve the record companies of all orchestras founded after 2003 ; #3 = Find the record companies that are shared by both the orchestras founded before 2003 and the orchestras founded after 2003"
    },
    {
        "id": "8459b8d82356291d3db2f69ff1945ee3befbb954a1417532e973e93e6b13ad59",
        "question": "What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
        "query": "SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded > 2003 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded < 2003.0 ] Distinct [ true ] Output [ Record_Company , Year_of_Founded ] ; #2 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2003.0 ] Output [ Record_Company , Year_of_Founded ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Record_Company = #2.Record_Company ] Output [ #1.Record_Company ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Record_Company, Year_of_Founded FROM orchestra.orchestra WHERE Year_of_Founded < 2003.0 ), Scan_2 AS ( SELECT Record_Company, Year_of_Founded FROM orchestra.orchestra WHERE Year_of_Founded > 2003.0 ), Intersect_3 AS ( SELECT Scan_1.Record_Company FROM Scan_1 WHERE Record_Company IN (SELECT Record_Company FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded > 2003",
        "qd": "#1 = Scan the table orchestra and retrieve the record companies of all orchestras founded before 2003 ; #2 = Scan the table orchestra and retrieve the record companies of all orchestras founded after 2003 ; #3 = Intersect the record companies from #1 and #2 to find the record companies that are used by both orchestras Founded before 2003 and those founded after 2003"
    },
    {
        "id": "d23e45e01461740b309c05a03a6520364714fb42bf3fee6b1e3eac7a4799d8ce",
        "question": "Find the number of orchestras whose record format is \"CD\" or \"DVD\".",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Predicate [ Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra  WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD'",
        "qd": "#1 = Scan the table orchestra and retrieve the major record format of all orchestras whose record format is either \"CD\" or \"DVD\" ; #2 = Aggregate the number of distinct major record formats from #1 to find the number of orchestras whose record format is \"CD\" or \"DVD\""
    },
    {
        "id": "7d60a9326e8a1da50b5701c2e6673c4f854992058ca200c3a5559c18d5021645",
        "question": "Count the number of orchestras that have CD or DVD as their record format.",
        "query": "SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Predicate [ Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra  WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD'",
        "qd": "#1 = Scan the table orchestra and retrieve the major record format of all orchestras that have either CD or DVD as their major record format. ; #2 = Aggregate the number of records from #1 and retrieve the count of orchestras that have CD or DVD as their major record format."
    },
    {
        "id": "59326357caa3607e771939182ff7aba6e9ba310af53c484ee2df9ae783da60ac",
        "question": "Show the years in which orchestras that have given more than one performance are founded.",
        "query": "SELECT Year_of_Founded FROM orchestra.orchestra AS T1 WITH (FORCESCAN) JOIN orchestra.performance AS T2 WITH (FORCESCAN) ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Orchestra_ID ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Orchestra_ID = #1.Orchestra_ID ] Output [ #1.Orchestra_ID , #1.Year_of_Founded ] ; #4 = Aggregate [ #3 ] GroupBy [ Year_of_Founded, Orchestra_ID ] Output [ Year_of_Founded , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Year_of_Founded ]",
        "cte": "WITH Scan_1 AS ( SELECT Year_of_Founded, Orchestra_ID FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Join_3 AS ( SELECT Scan_1.Orchestra_ID, Scan_1.Year_of_Founded FROM Scan_1 JOIN Scan_2 ON Scan_2.Orchestra_ID = Scan_1.Orchestra_ID ), Aggregate_4 AS ( SELECT Year_of_Founded, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Year_of_Founded, Orchestra_ID, Year_of_Founded ), Filter_5 AS ( SELECT Year_of_Founded FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT Year_of_Founded FROM orchestra.orchestra AS T1  JOIN orchestra.performance AS T2  ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1",
        "qd": "#1 = Scan the table orchestra and retrieve the years of foundation and orchestra IDs of all orchestras ; #2 = Scan the table performance and retrieve the orchestra IDs ; #3 = Join #1 and #2 based on the matching orchestra IDs and retrieve the orchestra IDs and years of foundation ; #4 = Group #3 by year of foundation and orchestra ID and aggregate the count of performances for each year and orchestra ; #5 = Filter from #4 all the records with count of performances greater than 1 and retrieve the years of foundation"
    },
    {
        "id": "481adaa806fc03fa0926f62a1fe0fe0d32e3d298f98873d4b71f0ff3030c88c8",
        "question": "What are years of founding for orchestras that have had more than a single performance?",
        "query": "SELECT Year_of_Founded FROM orchestra.orchestra AS T1 WITH (FORCESCAN) JOIN orchestra.performance AS T2 WITH (FORCESCAN) ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "orchestra | #1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Orchestra_ID ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Orchestra_ID = #1.Orchestra_ID ] Output [ #1.Orchestra_ID , #1.Year_of_Founded ] ; #4 = Aggregate [ #3 ] GroupBy [ Year_of_Founded, Orchestra_ID ] Output [ Year_of_Founded , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Year_of_Founded ]",
        "cte": "WITH Scan_1 AS ( SELECT Year_of_Founded, Orchestra_ID FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Join_3 AS ( SELECT Scan_1.Orchestra_ID, Scan_1.Year_of_Founded FROM Scan_1 JOIN Scan_2 ON Scan_2.Orchestra_ID = Scan_1.Orchestra_ID ), Aggregate_4 AS ( SELECT Year_of_Founded, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Year_of_Founded, Orchestra_ID, Year_of_Founded ), Filter_5 AS ( SELECT Year_of_Founded FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT Year_of_Founded FROM orchestra.orchestra AS T1  JOIN orchestra.performance AS T2  ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1",
        "qd": "#1 = Scan the table orchestra and retrieve the year of founding and orchestra IDs of all orchestras ; #2 = Scan the table performance and retrieve the orchestra IDs ; #3 = Join #1 and #2 based on the matching Orchestra IDs and retrieve the orchestra IDs and year of founding ; #4 = Group #3 by year of founding and orchestra ID and aggregate the count of performances per year of founding ; #5 = Filter from #4 the years of founding where the count of performances is greater than 1 and retrieve the years of founding"
    },
    {
        "id": "a207ddf9057f47af297b04e7f41856ac20a50fd2ed34907fb81ce862098d865b",
        "question": "How many high schoolers are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler",
        "qd": "#1 = Scan the table Highschooler and retrieve a constant value of 1 for each record ; #2 = Aggregate the number of records in #1 to find the total count of high schoolers"
    },
    {
        "id": "50c5d19b474f0dd61efdf6f2d8172cfb693e85bb6d2ee13d375870cddfb4fbac",
        "question": "Count the number of high schoolers.",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler",
        "qd": "#1 = Scan the table Highschooler and retrieve a column with the value \"1\" for each high schooler record ; #2 = Aggregate the number of records from #1 to count the number of high schoolers"
    },
    {
        "id": "ac7fe855633f31421a9bd706d23dfb20d80b0b538b0dc8520b1ebb91bc942e58",
        "question": "Show the names and grades of each high schooler.",
        "query": "SELECT name , grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade , name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, name FROM network_1.Highschooler ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , grade FROM network_1.Highschooler",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades and names of each high schooler."
    },
    {
        "id": "236dcef9e2b84f096ed08b1920b85a8df68af104b942aa599e0635cdb1e04178",
        "question": "What are the names and grades for each high schooler?",
        "query": "SELECT name , grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade , name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, name FROM network_1.Highschooler ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , grade FROM network_1.Highschooler",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades and names of each high schooler"
    },
    {
        "id": "e26742908088fa6b5a4a123e0c3d581e1de7fab7b51949cba4c73da7766784f9",
        "question": "Show all the grades of the high schoolers.",
        "query": "SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ) SELECT * FROM Scan_1",
        "clean_query": "SELECT grade FROM network_1.Highschooler",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades of all the high schoolers."
    },
    {
        "id": "a78bd98cec62dcd2412bb4c46df0a833d83f005bae19b95ec2402f74142e86b9",
        "question": "What is the grade of each high schooler?",
        "query": "SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ) SELECT * FROM Scan_1",
        "clean_query": "SELECT grade FROM network_1.Highschooler",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades of each high schooler."
    },
    {
        "id": "6df74d6511b3ad4d9033a1211957b3e5a2d11dba71e49fa907fd46472495da9e",
        "question": "What grade is Kyle in?",
        "query": "SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ grade , name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, name FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT grade FROM network_1.Highschooler  WHERE name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler and retrieve the grade of the student named Kyle."
    },
    {
        "id": "83bd88f309e485989759ac4a128180397925d2a7c8d9281b6ea2185f18b060b7",
        "question": "Return the grade for the high schooler named Kyle.",
        "query": "SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ grade , name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, name FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT grade FROM network_1.Highschooler  WHERE name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler and retrieve the grade of the high schooler named Kyle."
    },
    {
        "id": "8a7eabc2f2afb4a40166c43715cce40cf1f8c574ace9542f0fc2f58fe4eb1b29",
        "question": "Show the names of all high schoolers in grade 10.",
        "query": "SELECT name FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 10 ] Output [ grade , name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, name FROM network_1.Highschooler WHERE grade = 10 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name FROM network_1.Highschooler  WHERE grade = 10",
        "qd": "#1 = Scan the table Highschooler and retrieve the names of all high schoolers in grade 10."
    },
    {
        "id": "7094eb8f4f43e802578dfb2597cdb2cf41222e5ebbf4ff0686bba8aa79a0b702",
        "question": "What are the names of all high schoolers in grade 10?",
        "query": "SELECT name FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 10 ] Output [ grade , name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, name FROM network_1.Highschooler WHERE grade = 10 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name FROM network_1.Highschooler  WHERE grade = 10",
        "qd": "#1 = Scan the table Highschooler and retrieve the names of all high schoolers in grade 10."
    },
    {
        "id": "0139e20814b0aee45d3111cbedd1d8d1b6453db970e4bf1a7b8b7202091a6f35",
        "question": "Show the ID of the high schooler named Kyle.",
        "query": "SELECT ID FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT ID FROM network_1.Highschooler  WHERE name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler to find the ID of the high schooler named Kyle."
    },
    {
        "id": "5cf1353ac1891a373d83fb718050a23c6c0ec5d44a08d41958a4d89149fef383",
        "question": "What is Kyle's id?",
        "query": "SELECT ID FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT ID FROM network_1.Highschooler  WHERE name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler to find the ID of the student named Kyle"
    },
    {
        "id": "3305381ed75e65f12ec11aaaaf8facba1833f5626c1485c860de2fda47f7085d",
        "question": "How many high schoolers are there in grade 9 or 10?",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 9 OR grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 9 OR grade = 10 ] Output [ grade ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler WHERE grade = 9 OR grade = 10 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler  WHERE grade = 9 OR grade = 10",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades of all high schoolers who are in grade 9 or 10 ; #2 = Aggregate the count of the number of records in #1 to find the total number of high schoolers in grade 9 or 10"
    },
    {
        "id": "bd1edcbd11ce93f7ca5db25e0f6a2121942bb60f441d1551ad5bfaedcaa0bad0",
        "question": "Count the number of high schoolers in grades 9 or 10.",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 9 OR grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 9 OR grade = 10 ] Output [ grade ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler WHERE grade = 9 OR grade = 10 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Highschooler  WHERE grade = 9 OR grade = 10",
        "qd": "#1 = Scan the table Highschooler to find the high schoolers in grades 9 or 10 ; #2 = Aggregate the count of records from #1 to find the number of high schoolers in grades 9 or 10"
    },
    {
        "id": "2fd1f2fb8e00ca6198f226e0484c696991787954ae2f6ca11ca96be1973dd548",
        "question": "Show the number of high schoolers for each grade.",
        "query": "SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler  GROUP BY grade",
        "qd": "#1 = Scan the table Highschooler and retrieve the grade of each high schooler ; #2 = Group the records from #1 by grade and aggregate the count of records per grade to show the number of high schoolers for each grade"
    },
    {
        "id": "22ee91deb377e46643d31c252f10263c8b22928407d5e83e3dfea73e93a2912f",
        "question": "How many high schoolers are in each grade?",
        "query": "SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler  GROUP BY grade",
        "qd": "#1 = Scan the table Highschooler and retrieve the grade of all high schoolers ; #2 = Group #1 by grade and aggregate the count of records to find the number of high schoolers in each grade"
    },
    {
        "id": "442a4d8280938cee442476698a6d9ec2f0f13c4983f75bd715496be8f10bb3ef",
        "question": "Which grade has the most high schoolers?",
        "query": "SELECT TOP 1 grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ grade , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), TopSort_3 AS ( SELECT TOP 1 grade, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 grade FROM network_1.Highschooler  GROUP BY grade ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades of all high schoolers ; #2 = Group #1 by grade and aggregate the count of each grade to find the number of high schoolers in each grade ; #3 = Sort the records from #2 based on the count of high schoolers in descending order, select the first record, and identify the grade that has the most high schoolers and the corresponding count of high schoolers."
    },
    {
        "id": "7e3bd780ec04ba80fb47a192efc6c0fff9a6a083d07990a499435bf06c681be3",
        "question": "Return the grade that has the greatest number of high schoolers.",
        "query": "SELECT TOP 1 grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ grade , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), TopSort_3 AS ( SELECT TOP 1 grade, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 grade FROM network_1.Highschooler  GROUP BY grade ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades of all high schoolers. ; #2 = Group #1 by grade and aggregate the count of high schoolers per grade. ; #3 = Sort the records from #2 based on the count of high schoolers in descending order, select the first record, and identify the grade with the greatest number of high schoolers and its count of high schoolers."
    },
    {
        "id": "23c4fe45297b48d8ee466d2d1d6ec177bcea9379322d3dc4925ed1db0e1ecdd1",
        "question": "Show me all grades that have at least 4 students.",
        "query": "SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade HAVING count ( * ) > = 4 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 4 ] Output [ grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), Filter_3 AS ( SELECT grade FROM Aggregate_2 WHERE Count_Star >= 4 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT grade FROM network_1.Highschooler  GROUP BY grade HAVING count ( * ) > = 4",
        "qd": "#1 = Scan the table Highschooler and retrieve the grade of all students ; #2 = Group #1 by grade and aggregate the count of students per grade ; #3 = Filter from #2 all the grades with at least 4 students"
    },
    {
        "id": "525bacec227d0a51200bf17117551ede5163d4d834a2d0362f0855cbea4248ee",
        "question": "Which grades have 4 or more high schoolers?",
        "query": "SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade HAVING count ( * ) > = 4 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 4 ] Output [ grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), Filter_3 AS ( SELECT grade FROM Aggregate_2 WHERE Count_Star >= 4 ) SELECT * FROM Filter_3",
        "clean_query": "SELECT grade FROM network_1.Highschooler  GROUP BY grade HAVING count ( * ) > = 4",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades of all high schoolers ; #2 = Group #1 by grade and aggregate the count per grade ; #3 = Filter from #2 all the grades with a count of 4 or more high schoolers"
    },
    {
        "id": "75f66dc81cbf3a3f27d33d5d675fd43a1794de57f3234cbc274fa97f50765b86",
        "question": "Show the student IDs and numbers of friends corresponding to each.",
        "query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend  GROUP BY student_id",
        "qd": "#1 = Scan the table Friend and retrieve the student IDs of all the students who have friends ; #2 = Group the records from #1 by student ID and aggregate the count of friends for each student ID"
    },
    {
        "id": "62e0e49372c6619ec2e9e395882058f8052df231fccbd47054d60d4d0cece143",
        "question": "How many friends does each student have?",
        "query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend  GROUP BY student_id",
        "qd": "#1 = Scan the table Friend and retrieve the student IDs of all friendships ; #2 = Group #1 by student ID and aggregate the count of friendships per student to find how many friends each student has"
    },
    {
        "id": "507830019925b62844542338e9b6778272fc8cc3a8c55222862e45e5cc10eec6",
        "question": "Show the names of high school students and their corresponding number of friends.",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all high school students. ; #2 = Scan the table Friend and retrieve the student IDs of all friendships. ; #3 = Join #1 and #2 based on the matching IDs and retrieve the student IDs and names. ; #4 = Group #3 by student ID and aggregate the count of friendships for each student to find the number of friends each high school student has."
    },
    {
        "id": "7b30574d1ca66d7665e969229dd704a800f08994530b06fe62e3eb4fb57a6ab5",
        "question": "What are the names of the high schoolers and how many friends does each have?",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers. ; #2 = Scan the table Friend and retrieve the student IDs of all friendships. ; #3 = Join #1 and #2 based on the matching IDs and retrieve the student IDs and names of all high schoolers. ; #4 = Group #3 by student ID and aggregate the count of friendships per student to find the number of friends each high schooler has. Also, retrieve their names."
    },
    {
        "id": "9ac26cfb14e02c1544639c9d16255b9fe612fbbfbf90f627a8c841571f1565b1",
        "question": "What is the name of the high schooler who has the greatest number of friends?",
        "query": "SELECT TOP 1 T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ] ; #3 = Scan Table [ Highschooler ] Output [ ID , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #2.Count_Star , #3.name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Friend and retrieve the student IDs of all friendships ; #2 = Group the records from #1 by student ID and aggregate the count of friendships per student ; #3 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers ; #4 = Join #2 and #3 based on the matching student ID to retrieve the count of friendships and names ; #5 = Sort the records from #4 based on the count of friendships in descending order, select the first record, and identify the name of the high schooler who has the greatest number of friends and the count of their friendships."
    },
    {
        "id": "72a560902ad1a26b3705b36166d2d4bb791b70869b75743abfae8ace99e81301",
        "question": "Return the name of the high school student with the most friends.",
        "query": "SELECT TOP 1 T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ] ; #3 = Scan Table [ Highschooler ] Output [ ID , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #2.Count_Star , #3.name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Friend to retrieve the student IDs of all connections between high school students ; #2 = Group the records from #1 by student ID and count the number of connections per student ; #3 = Scan the table Highschooler to retrieve the IDs and names of all high school students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the count of connections and the name of each student ; #5 = Sort the records from #4 based on the count of connections in descending order, select the first record, and identify the name of the high school student with the most friends and the number of friends they have."
    },
    {
        "id": "263ffac75ab9c422dd579995c62f4fdbd85d5041d6cdb5c017af4d1158c376a7",
        "question": "Show the names of high schoolers who have at least 3 friends.",
        "query": "SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 3 ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 3 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers. ; #2 = Scan the table Friend and retrieve the student IDs of all friends. ; #3 = Join #1 and #2 based on the matching student ID and retrieve the friend IDs and names. ; #4 = Group #3 by student ID and aggregate the count of friends per student along with their names. ; #5 = Filter from #4 all the records with a count of friends greater than or equal to 3 and retrieve the names of high schoolers."
    },
    {
        "id": "07a63f1a5bc074a87b3ef04fa8dda9f595a429c36cc22af4b69b862e7c6ec7bf",
        "question": "What are the names of high schoolers who have 3 or more friends?",
        "query": "SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 3 ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 3 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers ; #2 = Scan the table Friend and retrieve the student IDs of all friendships ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student IDs and names ; #4 = Group #3 by student ID and aggregate the count of friends per student to find the number of friends for each high schooler ; #5 = Filter from #4 the records where the count of friends is greater than or equal to 3 and retrieve the names of the high schoolers"
    },
    {
        "id": "76315f6ac3350f7af835b9f7f6a46ec89579cd792877b93f61a84ee2ad621932",
        "question": "Show the names of all of the high schooler Kyle's friends.",
        "query": "SELECT T3.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3 WITH (FORCESCAN) ON T1.friend_id = T3.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ friend_id , student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.friend_id ] ; #4 = Scan Table [ Highschooler ] Output [ ID , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.friend_id = #4.ID ] Output [ #4.name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT friend_id, student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.friend_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_5 AS ( SELECT Scan_4.name FROM Join_3 JOIN Scan_4 ON Join_3.friend_id = Scan_4.ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T3.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3  ON T1.friend_id = T3.id WHERE T2.name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers with the name Kyle ; #2 = Scan the table Friend and retrieve the friend IDs and student IDs of all friendships ; #3 = Join #1 and #2 based on the matching student IDs and retrieve the friend IDs ; #4 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers ; #5 = Join #3 and #4 based on the matching friend IDs and retrieve the names of all of Kyle's friends"
    },
    {
        "id": "d8eacdf8a3d6a1f89099265b0457ac988f631378f30f90fd38ada84b418b65c0",
        "question": "Return the names of friends of the high school student Kyle.",
        "query": "SELECT T3.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3 WITH (FORCESCAN) ON T1.friend_id = T3.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ friend_id , student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.friend_id ] ; #4 = Scan Table [ Highschooler ] Output [ ID , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.friend_id = #4.ID ] Output [ #4.name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT friend_id, student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.friend_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_5 AS ( SELECT Scan_4.name FROM Join_3 JOIN Scan_4 ON Join_3.friend_id = Scan_4.ID ) SELECT * FROM Join_5",
        "clean_query": "SELECT T3.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3  ON T1.friend_id = T3.id WHERE T2.name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler and retrieve the ID and name of the high school student with the name Kyle ; #2 = Scan the table Friend and retrieve the friend IDs and student IDs ; #3 = Join #1 and #2 based on the matching student ID and retrieve the friend IDs ; #4 = Scan the table Highschooler and retrieve the IDs and names of all high school students ; #5 = Join #3 and #4 based on the matching friend ID and retrieve the names of the friends of the high school student Kyle"
    },
    {
        "id": "b7b03db85ab48e278ad66f39305dfa4aa1bf37d7b21f77b565e7d380007d2127",
        "question": "How many friends does the high school student Kyle have?",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.ID , #1.name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.ID, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler to find the student with the name Kyle ; #2 = Scan the table Friend to retrieve all the friends' IDs ; #3 = Join #1 and #2 based on the matching student ID and retrieve the IDs and names of Kyle's friends ; #4 = Aggregate the number of records from #3 to find the count of friends that the high school student Kyle has"
    },
    {
        "id": "aaea944f7fbfe65c0aa2473b9e9ade93b8f024fc0c932efc0b05d3c9fe2cd13f",
        "question": "Count the number of friends Kyle has.",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.ID , #1.name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.ID, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler to find the ID and name of the student with the name 'Kyle' ; #2 = Scan the table Friend to find all the student IDs of Kyle's friends ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student ID and name of Kyle's friends ; #4 = Aggregate the number of records in #3 to find the count of friends that Kyle has"
    },
    {
        "id": "2a1d61f34fe5ad0f7a58c53d75caa500a2803b2c6147c10377c44408591e4e43",
        "question": "Show ids of all students who do not have any friends.",
        "query": "SELECT id FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT student_id FROM network_1.Friend WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.ID ]",
        "cte": "WITH Scan_1 AS ( SELECT ID FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.ID FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT id FROM network_1.Highschooler  EXCEPT SELECT student_id FROM network_1.Friend",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs of all students ; #2 = Scan the table Friend and retrieve the student IDs of all friendships ; #3 = Group #2 by student ID to find the students who have friends ; #4 = Find the IDs of all students that are not in #3 to find the students who do not have any friends"
    },
    {
        "id": "329f0c5f35657ebf6607ade381231dcb736e68b0a28915213b0fd689088299d5",
        "question": "What are the ids of high school students who do not have friends?",
        "query": "SELECT id FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT student_id FROM network_1.Friend WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.ID ]",
        "cte": "WITH Scan_1 AS ( SELECT ID FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.ID FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ) SELECT * FROM Except_4",
        "clean_query": "SELECT id FROM network_1.Highschooler  EXCEPT SELECT student_id FROM network_1.Friend",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs of all high school students. ; #2 = Scan the table Friend and retrieve the student IDs. ; #3 = Group #2 by student ID and aggregate to find the friend IDs of each student. ; #4 = Find the IDs of high school students who do not have any friends by excluding the IDs from #3."
    },
    {
        "id": "bd4233682bf105762e3a9cb82f6a771c3ebd7fdecb6567ca4cce013ad6c9bbdf",
        "question": "Show names of all high school students who do not have any friends.",
        "query": "SELECT name FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Distinct [ true ] Output [ name ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Scan Table [ Friend ] Output [ student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.ID = #3.student_id ] Output [ #2.name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT name FROM network_1.Highschooler ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_3 AS ( SELECT student_id FROM network_1.Friend ), Join_4 AS ( SELECT Scan_2.name FROM Scan_2 JOIN Scan_3 ON Scan_2.ID = Scan_3.student_id ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE name NOT IN (SELECT name FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT name FROM network_1.Highschooler  EXCEPT SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id",
        "qd": "#1 = Scan the table Highschooler and retrieve the names of all high school students ; #2 = Scan the table Highschooler and retrieve the IDs and names of all high school students ; #3 = Scan the table Friend and retrieve the student IDs who have friends ; #4 = Join #2 and #3 based on the matching IDs and retrieve the names of students who have friends ; #5 = Return the names of students that are in #1 but not in #4 to find the names of high school students who do not have any friends."
    },
    {
        "id": "33d486052fda33a467d56045245ac5652e2c7e0abde302e86bd834c64c63b41b",
        "question": "What are the names of students who have no friends?",
        "query": "SELECT name FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Distinct [ true ] Output [ name ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Scan Table [ Friend ] Output [ student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.ID = #3.student_id ] Output [ #2.name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT name FROM network_1.Highschooler ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_3 AS ( SELECT student_id FROM network_1.Friend ), Join_4 AS ( SELECT Scan_2.name FROM Scan_2 JOIN Scan_3 ON Scan_2.ID = Scan_3.student_id ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE name NOT IN (SELECT name FROM Join_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT name FROM network_1.Highschooler  EXCEPT SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id",
        "qd": "#1 = Scan the table Highschooler and retrieve the names of all students ; #2 = Scan the table Highschooler and retrieve the IDs and names of all students ; #3 = Scan the table Friend and retrieve the student IDs ; #4 = Join #2 and #3 based on the matching student ID and retrieve the names of the students ; #5 = Return all the names from #1 that are not in #4 to find the names of the students who have no friends"
    },
    {
        "id": "76ef862e3c511c50ec1ff363f7b90eadbad4ccac85a6b9d3d4cf4b027b49a5d1",
        "question": "Show the ids of high schoolers who have friends and are also liked by someone else.",
        "query": "SELECT student_id FROM network_1.Friend WITH (FORCESCAN) INTERSECT SELECT liked_id FROM network_1.Likes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Likes ] Output [ liked_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.liked_id = #2.student_id ] Output [ #2.student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT liked_id FROM network_1.Likes ), Intersect_4 AS ( SELECT Aggregate_2.student_id FROM Aggregate_2 WHERE student_id IN (SELECT liked_id FROM Scan_3) ) SELECT * FROM Intersect_4",
        "clean_query": "SELECT student_id FROM network_1.Friend  INTERSECT SELECT liked_id FROM network_1.Likes",
        "qd": "#1 = Scan the table Friend and retrieve the student IDs of all high schoolers who have friends ; #2 = Group #1 by student ID to find the unique high schoolers who have friends ; #3 = Scan the table Likes and retrieve the liked IDs of high schoolers ; #4 = Find the intersection between #2 and #3 based on the matching liked IDs and retrieve the student IDs of high schoolers who have friends and are also liked by someone else"
    },
    {
        "id": "0b31c5a9abc4e7a1d92494ccca165c2c92d1134087b6c066d1b3ce747a13c3f7",
        "question": "What are the ids of students who both have friends and are liked?",
        "query": "SELECT student_id FROM network_1.Friend WITH (FORCESCAN) INTERSECT SELECT liked_id FROM network_1.Likes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Likes ] Output [ liked_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.liked_id = #2.student_id ] Output [ #2.student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT liked_id FROM network_1.Likes ), Intersect_4 AS ( SELECT Aggregate_2.student_id FROM Aggregate_2 WHERE student_id IN (SELECT liked_id FROM Scan_3) ) SELECT * FROM Intersect_4",
        "clean_query": "SELECT student_id FROM network_1.Friend  INTERSECT SELECT liked_id FROM network_1.Likes",
        "qd": "#1 = Scan the table Friend and retrieve all the student ids who have friends ; #2 = Group the records from #1 by student id to find the student ids who have friends ; #3 = Scan the table Likes and retrieve all the liked ids ; #4 = Intersect the student ids from #2 and the liked ids from #3 to find the student ids who both have friends and are liked"
    },
    {
        "id": "56d9b7569da6cfd36c31daac378eeebeed9acb76698e67c63f49a3fce4e8d187",
        "question": "Show name of all students who have some friends and also are liked by someone else.",
        "query": "SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.liked_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Distinct [ true ] Output [ #1.name ] ; #4 = Scan Table [ Likes ] Output [ liked_id ] ; #5 = Scan Table [ Highschooler ] Output [ ID , name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.liked_id = #5.ID ] Output [ #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT DISTINCT Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT liked_id FROM network_1.Likes ), Scan_5 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_6 AS ( SELECT Scan_5.name FROM Scan_4 JOIN Scan_5 ON Scan_4.liked_id = Scan_5.ID ), Intersect_7 AS ( SELECT Join_3.name FROM Join_3 WHERE name IN (SELECT name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.liked_id = T2.id",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all students ; #2 = Scan the table Friend and retrieve the student IDs ; #3 = Join #1 and #2 based on the matching student ID and retrieve the names of the students ; #4 = Scan the table Likes and retrieve the liked IDs ; #5 = Scan the table Highschooler and retrieve the IDs and names of all students ; #6 = Join #4 and #5 based on the matching liked ID and retrieve the names of the students ; #7 = Intersect #3 and #6 based on the matching names and retrieve the names of the students who have some friends and are also liked by someone else."
    },
    {
        "id": "751312a14e1b895457b1e3416dd352a7abcadef9679147be4cb3252af11101a7",
        "question": "What are the names of high schoolers who both have friends and are liked?",
        "query": "SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.liked_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Distinct [ true ] Output [ #1.name ] ; #4 = Scan Table [ Likes ] Output [ liked_id ] ; #5 = Scan Table [ Highschooler ] Output [ ID , name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.liked_id = #5.ID ] Output [ #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT DISTINCT Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT liked_id FROM network_1.Likes ), Scan_5 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_6 AS ( SELECT Scan_5.name FROM Scan_4 JOIN Scan_5 ON Scan_4.liked_id = Scan_5.ID ), Intersect_7 AS ( SELECT Join_3.name FROM Join_3 WHERE name IN (SELECT name FROM Join_6) ) SELECT * FROM Intersect_7",
        "clean_query": "SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.liked_id = T2.id",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers ; #2 = Scan the table Friend and retrieve all the student IDs with friends ; #3 = Join #1 and #2 based on the matching student ID and retrieve the names of the high schoolers with friends without duplicates ; #4 = Scan the table Likes and retrieve all the liked IDs ; #5 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers ; #6 = Join #4 and #5 based on the matching liked ID and retrieve the names of the high schoolers who are liked ; #7 = Intersect #3 and #6 based on the matching names and retrieve the names of the high schoolers who both have friends and are liked"
    },
    {
        "id": "6aac79de3dfb498f14e452ccffef52b0fbffb19db5276bb259b6dd6196e2c474",
        "question": "Count the number of likes for each student id.",
        "query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes  GROUP BY student_id",
        "qd": "#1 = Scan the table Likes and retrieve the student IDs of all likes ; #2 = Group #1 by student ID and count the number of likes for each student ID, retrieve the count and student ID"
    },
    {
        "id": "f58f82e66f2a77494424f80aa471496689fb273caf330128dc3b95ffc6d3ace7",
        "question": "How many likes correspond to each student id?",
        "query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , student_id ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, student_id FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes  GROUP BY student_id",
        "qd": "#1 = Scan the table Likes and retrieve the student IDs of all likes ; #2 = Group #1 by student ID and aggregate the count of likes for each student ID to find the number of likes corresponding to each student ID"
    },
    {
        "id": "ff92bf186cb026e0855344183504608a989cfe970c6d5cc696280faa3f1ed561",
        "question": "Show the names of high schoolers who have likes, and numbers of likes for each.",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id",
        "qd": "#1 = Scan the table Likes and retrieve the student IDs of all likes ; #2 = Scan the table Highschooler and retrieve the IDs and names of all high schoolers ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student IDs and names ; #4 = Group #3 by student ID and aggregate the count of records to find the number of likes for each high schooler, also retrieve the names"
    },
    {
        "id": "26ba285d395198118d592f466d811b5cfb823cb3e3c6b816162f719160149536",
        "question": "What are the names of high schoolers who have likes, and how many likes does each have?",
        "query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id",
        "qd": "#1 = Scan the table Likes and retrieve the student IDs of all students who have likes ; #2 = Scan the table Highschooler and retrieve the student IDs and names of all high schoolers ; #3 = Join #1 and #2 based on matching student IDs and retrieve the student IDs and names ; #4 = Group #3 by student ID and aggregate the count of records per student to find the number of likes each high schooler has and retrieve their names"
    },
    {
        "id": "587e9458cada672d2d3927d405dbd2f9bca706e71eb19a1a0e6d26d029033252",
        "question": "What is the name of the high schooler who has the greatest number of likes?",
        "query": "select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) join network_1.highschooler as t2 WITH (FORCESCAN) ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.student_id = #1.ID ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] WithTies [ true ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_2.student_id = Scan_1.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), TopSort_5 AS ( SELECT TOP 1 WITH TIES name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1  join network_1.highschooler as t2  ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc",
        "qd": "#1 = Scan the table Highschooler to retrieve the IDs and names of all high schoolers. ; #2 = Scan the table Likes to retrieve the student IDs of all likes. ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student ID and name. ; #4 = Group #3 by student ID and aggregate the count of likes per student to find the number of likes for each high schooler. ; #5 = Sort the records from #4 based on the count of likes in descending order, select the first record (with ties), and identify the name of the high schooler who has the greatest number of likes."
    },
    {
        "id": "92f7870d8e544dec954c41ef4da65daa4fb2cba5f0706f1d73c2442f423a6dd8",
        "question": "Give the name of the student with the most likes.",
        "query": "select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) join network_1.highschooler as t2 WITH (FORCESCAN) ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.student_id = #1.ID ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] WithTies [ true ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_2.student_id = Scan_1.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), TopSort_5 AS ( SELECT TOP 1 WITH TIES name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1  join network_1.highschooler as t2  ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc",
        "qd": "#1 = Scan the table Highschooler and retrieve the IDs and names of all students. ; #2 = Scan the table Likes and retrieve all the student IDs of who are liked. ; #3 = Join #1 and #2 based on the matching student IDs and retrieve the student IDs and names. ; #4 = Group #3 by student ID and aggregate the count of likes per student to find the number of likes for each student. ; #5 = Sort the records from #4 based on the count of likes in descending order, select the student with the highest count, and identify the name of the student with the most likes."
    },
    {
        "id": "a5718dce78aa6a1cb4b8449f5ac89c6e167966f9905923340a77326aba16ba34",
        "question": "Show the names of students who have at least 2 likes.",
        "query": "SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Likes and retrieve the IDs of all students who have liked at least one item. ; #2 = Scan the table Highschooler and retrieve the IDs and names of all students. ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student IDs and names. ; #4 = Group #3 by student ID and aggregate the count of likes per student. ; #5 = Filter from #4 all students with a count of likes greater than or equal to 2, and retrieve their names."
    },
    {
        "id": "5f078cf8840141aae2115e123c9cdd40f90ec682501edb26c3d06816b9a4eca2",
        "question": "What are the names of students who have 2 or more likes?",
        "query": "SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Likes and retrieve the student IDs of all students who have made likes ; #2 = Scan the table Highschooler and retrieve the IDs and names of all students ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student IDs and names ; #4 = Group #3 by student ID and aggregate the count per student to find the number of likes each student has ; #5 = Filter from #4 all the students with a count of likes greater than or equal to 2 and retrieve their names"
    },
    {
        "id": "664f0c6f067262d02049ca69c3f9f7726e6d086c3325b29eca9eb11398448854",
        "question": "Show the names of students who have a grade higher than 5 and have at least 2 friends.",
        "query": "SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade > 5 ] Output [ grade , ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, ID, name FROM network_1.Highschooler WHERE grade > 5 ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades, IDs, and names of all students with a grade higher than 5 ; #2 = Scan the table Friend and retrieve all the student IDs ; #3 = Join #1 and #2 based on the matching IDs and retrieve the student IDs and names ; #4 = Group #3 by student ID and aggregate the count of friends per student to find the number of friends for each student ; #5 = Filter from #4 all the students with at least 2 friends and retrieve their names"
    },
    {
        "id": "0958c0b2d43af122aef2fbe2e3aa770ae881b8f5b43febf6c3f9a3b5cf13e025",
        "question": "What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?",
        "query": "SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade > 5 ] Output [ grade , ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, ID, name FROM network_1.Highschooler WHERE grade > 5 ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Highschooler and retrieve the names of all high schoolers with a grade over 5 ; #2 = Scan the table Friend and retrieve all the student IDs ; #3 = Join #1 and #2 based on the matching ID and retrieve the names of the high schoolers ; #4 = Group #3 by student ID and aggregate the count per student ID to find the number of friends each high schooler has ; #5 = Filter from #4 all the high schoolers with 2 or more friends and retrieve their names"
    },
    {
        "id": "3682b3829c0ef3cdd72b77929881f34ffb80f004698e5f6de20618175c13a2b2",
        "question": "How many likes does Kyle have?",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.ID , #1.name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_1.ID, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler and retrieve the ID and name of the student with the name 'Kyle' ; #2 = Scan the table Likes and retrieve the student IDs of all likes ; #3 = Join #1 and #2 based on the matching ID and retrieve the IDs and names of the students who liked by Kyle ; #4 = Aggregate the count of all records from #3 to find how many likes Kyle has"
    },
    {
        "id": "3124e28ac1a7fe690afecd460ac8ece90d118c90179e403c6d3922793b87a58c",
        "question": "Return the number of likes that the high schooler named Kyle has.",
        "query": "SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.ID , #1.name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_1.ID, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'",
        "qd": "#1 = Scan the table Highschooler and retrieve the ID and name of the high schooler with the name Kyle ; #2 = Scan the table Likes and retrieve the student IDs of all likes ; #3 = Join #1 and #2 based on the matching student ID and retrieve the student ID and name of the high schooler named Kyle who has likes ; #4 = Aggregate the number of records from #3 to find the number of likes that the high schooler named Kyle has."
    },
    {
        "id": "e60783a38fbe587fae22b5119c426af2faa291ec352b32ee73bd46e4d75c0c43",
        "question": "Find the average grade of all students who have some friends.",
        "query": "SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Highschooler ] Output [ grade , ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.grade ] ; #5 = Aggregate [ #4 ] Output [ AVG(grade) AS Avg_grade ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT grade, ID FROM network_1.Highschooler ), Join_4 AS ( SELECT Scan_3.grade FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), Aggregate_5 AS ( SELECT AVG(grade) AS Avg_grade FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler  WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )",
        "qd": "#1 = Scan the table Friend and retrieve the student IDs of all students with friends ; #2 = Group #1 by student ID to find all the students with at least one friend ; #3 = Scan the table Highschooler and retrieve the grades and IDs of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the grades ; #5 = Calculate the average grade of all the grades from #4 to find the average grade of all students who have some friends"
    },
    {
        "id": "e2e869b34513e5bed08d8f4fbbc0bbf12e76f971c72c6a06fd9e413fda048afc",
        "question": "What is the average grade of students who have friends?",
        "query": "SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Highschooler ] Output [ grade , ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.grade ] ; #5 = Aggregate [ #4 ] Output [ AVG(grade) AS Avg_grade ]",
        "cte": "WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT grade, ID FROM network_1.Highschooler ), Join_4 AS ( SELECT Scan_3.grade FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), Aggregate_5 AS ( SELECT AVG(grade) AS Avg_grade FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler  WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )",
        "qd": "#1 = Scan the table Friend and retrieve the student IDs of all students who have friends ; #2 = Group #1 by student ID to find all unique student IDs who have friends ; #3 = Scan the table Highschooler and retrieve the grades and IDs of all students ; #4 = Join #2 and #3 based on the matching student ID and retrieve the grades of students who have friends ; #5 = Calculate the average grade from #4 to find the average grade of students who have friends"
    },
    {
        "id": "bf6b1d29e11ed83843dd7359807c686a7503effa62469509bf03de3a88b35b89",
        "question": "Find the minimum grade of students who have no friends.",
        "query": "SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade , ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.grade ] ; #5 = Aggregate [ #4 ] Output [ MIN(grade) AS Min_grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, ID FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.grade FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ), Aggregate_5 AS ( SELECT MIN(grade) AS Min_grade FROM Except_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler  WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades and IDs of all students ; #2 = Scan the table Friend and retrieve the IDs of all students who have friends ; #3 = Group #2 by student ID to find all the students who have friends ; #4 = Return the grades of the students from #1 who do not have friends ; #5 = Aggregate the minimum grade from #4 to find the minimum grade of students who have no friends"
    },
    {
        "id": "ba2f6f7ee2f6c495a1a659ea8490d0ed8808d5ae72b806c1fc73d1ca4972d780",
        "question": "What is the lowest grade of students who do not have any friends?",
        "query": "SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "network_1 | #1 = Scan Table [ Highschooler ] Output [ grade , ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.grade ] ; #5 = Aggregate [ #4 ] Output [ MIN(grade) AS Min_grade ]",
        "cte": "WITH Scan_1 AS ( SELECT grade, ID FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.grade FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ), Aggregate_5 AS ( SELECT MIN(grade) AS Min_grade FROM Except_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler  WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )",
        "qd": "#1 = Scan the table Highschooler and retrieve the grades and IDs of all students ; #2 = Scan the table Friend and retrieve all the student IDs ; #3 = Group #2 by student ID to find all the student IDs who have friends ; #4 = return the grades of students from #1 that are not in #3 to find the students who do not have any friends ; #5 = find the minimum grade from #4 to identify the lowest grade among students who do not have any friends."
    },
    {
        "id": "f626b9a2929fc139061b844dbf890d7ba521f6aa73d94c8973a3d0c6049a9e93",
        "question": "Which states have both owners and professionals living there?",
        "query": "SELECT state FROM dog_kennels.Owners WITH (FORCESCAN) INTERSECT SELECT state FROM dog_kennels.Professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Distinct [ true ] Output [ state ] ; #2 = Scan Table [ Professionals ] Output [ state ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.state = #2.state ] Output [ #1.state ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT state FROM dog_kennels.Owners ), Scan_2 AS ( SELECT state FROM dog_kennels.Professionals ), Intersect_3 AS ( SELECT Scan_1.state FROM Scan_1 WHERE state IN (SELECT state FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT state FROM dog_kennels.Owners  INTERSECT SELECT state FROM dog_kennels.Professionals",
        "qd": "#1 = Scan the table Owners and retrieve the distinct states where owners are living. ; #2 = Scan the table Professionals and retrieve the states where professionals are living. ; #3 = Intersect the states from #1 and #2 based on the matching states and retrieve the states where both owners and professionals are living."
    },
    {
        "id": "9fb99b3230c59f8e93e31e9f3330ec2ef766cee0661a5362446bccfa564a4dc5",
        "question": "Find the states where both owners and professionals live.",
        "query": "SELECT state FROM dog_kennels.Owners WITH (FORCESCAN) INTERSECT SELECT state FROM dog_kennels.Professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Distinct [ true ] Output [ state ] ; #2 = Scan Table [ Professionals ] Output [ state ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.state = #2.state ] Output [ #1.state ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT state FROM dog_kennels.Owners ), Scan_2 AS ( SELECT state FROM dog_kennels.Professionals ), Intersect_3 AS ( SELECT Scan_1.state FROM Scan_1 WHERE state IN (SELECT state FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT state FROM dog_kennels.Owners  INTERSECT SELECT state FROM dog_kennels.Professionals",
        "qd": "#1 = Scan the table Owners and retrieve the distinct states where owners live. ; #2 = Scan the table Professionals and retrieve the states where professionals live. ; #3 = Intersect the states from #1 and #2 based on matching states and retrieve the states where both owners and professionals live."
    },
    {
        "id": "decfc871b13ceaffd983db7df7c5c5dd6962b493f507d45cc62e8e2e3a87588a",
        "question": "What is the average age of the dogs who have gone through any treatments?",
        "query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age , dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.dog_id = #1.dog_id ] Output [ #1.age ] ; #4 = Aggregate [ #3 ] Output [ AVG(age) AS Avg_age ]",
        "cte": "WITH Scan_1 AS ( SELECT age, dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Intersect_3 AS ( SELECT Scan_1.age FROM Scan_1 WHERE dog_id IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(age) AS Avg_age FROM Intersect_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Dogs and retrieve the ages and IDs of all dogs ; #2 = Scan the table Treatments and retrieve the IDs of all dogs that have gone through treatments ; #3 = Intersect #1 and #2 based on the matching dog IDs and retrieve the ages of dogs that have gone through treatments ; #4 = Calculate the average age of the dogs from #3 to find the average age of the dogs who have gone through any treatments"
    },
    {
        "id": "157adfc6e10475a6903221bfc25168a40ae9a2ef7302d6de45ef016f64c3a329",
        "question": "Find the average age of the dogs who went through treatments.",
        "query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age , dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.dog_id = #1.dog_id ] Output [ #1.age ] ; #4 = Aggregate [ #3 ] Output [ AVG(age) AS Avg_age ]",
        "cte": "WITH Scan_1 AS ( SELECT age, dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Intersect_3 AS ( SELECT Scan_1.age FROM Scan_1 WHERE dog_id IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(age) AS Avg_age FROM Intersect_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Dogs and retrieve the ages and IDs of all dogs ; #2 = Scan the table Treatments and retrieve the IDs of the dogs who went through treatments ; #3 = Intersect the records from #1 and #2 based on the matching dog IDs and retrieve the ages ; #4 = Aggregate the average age of all the dogs in #3"
    },
    {
        "id": "2d5aaf3ed4a87a7bfd3f47e80b31b63bc9cb52e1d5ab8aadfb5e21f80c15d4f4",
        "question": "Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.",
        "query": "SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Indiana' ] Output [ cell_number , last_name , professional_id , state ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , last_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.last_name , #3.professional_id , #3.cell_number ] ; #5 = Aggregate [ #4 ] GroupBy [ professional_id ] Output [ countstar AS Count_Star , cell_number , last_name , professional_id ] ; #6 = Filter [ #5 ] Predicate [ Count_Star > 2 ] Output [ cell_number , last_name , professional_id ] ; #7 = Union [ #1 , #6 ] Output [ #1.last_name , #1.cell_number , #1.professional_id ]",
        "cte": "WITH Scan_1 AS ( SELECT cell_number, last_name, professional_id, state FROM dog_kennels.Professionals WHERE state = 'Indiana' ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT cell_number, last_name, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.last_name, Scan_3.professional_id, Scan_3.cell_number FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, cell_number, last_name, professional_id FROM Join_4 GROUP BY last_name, professional_id, cell_number ), Filter_6 AS ( SELECT cell_number, last_name, professional_id FROM Aggregate_5 WHERE Count_Star > 2 ), Union_7 AS ( SELECT last_name, cell_number, professional_id FROM Scan_1 UNION SELECT last_name, cell_number, professional_id FROM Filter_6 ) SELECT * FROM Union_7",
        "clean_query": "SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals  WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2",
        "qd": "#1 = Scan the table Professionals and retrieve the cell number, last name, and professional ID of professionals living in the state of Indiana. ; #2 = Scan the table Treatments and retrieve all professional IDs. ; #3 = Scan the table Professionals and retrieve the cell number, last name, and professional ID of all professionals. ; #4 = Join #2 and #3 based on the matching professional ID and retrieve the last name, professional ID, and cell number. ; #5 = Group #4 by professional ID and aggregate the count of treatments per professional. ; #6 = Filter from #5 all professionals with more than 2 treatments and retrieve their cell number, last name, and professional ID. ; #7 = Union #1 and #6 and retrieve the last name, cell number, and professional ID."
    },
    {
        "id": "8b33d8ebee3c820fd9c6f45fa6f76eeda92b42b72cc32487f29cfa4b79175f7b",
        "question": "Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.",
        "query": "SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Indiana' ] Output [ cell_number , last_name , professional_id , state ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , last_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.last_name , #3.professional_id , #3.cell_number ] ; #5 = Aggregate [ #4 ] GroupBy [ professional_id ] Output [ countstar AS Count_Star , cell_number , last_name , professional_id ] ; #6 = Filter [ #5 ] Predicate [ Count_Star > 2 ] Output [ cell_number , last_name , professional_id ] ; #7 = Union [ #1 , #6 ] Output [ #1.last_name , #1.cell_number , #1.professional_id ]",
        "cte": "WITH Scan_1 AS ( SELECT cell_number, last_name, professional_id, state FROM dog_kennels.Professionals WHERE state = 'Indiana' ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT cell_number, last_name, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.last_name, Scan_3.professional_id, Scan_3.cell_number FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star, cell_number, last_name, professional_id FROM Join_4 GROUP BY last_name, professional_id, cell_number ), Filter_6 AS ( SELECT cell_number, last_name, professional_id FROM Aggregate_5 WHERE Count_Star > 2 ), Union_7 AS ( SELECT last_name, cell_number, professional_id FROM Scan_1 UNION SELECT last_name, cell_number, professional_id FROM Filter_6 ) SELECT * FROM Union_7",
        "clean_query": "SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals  WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2",
        "qd": "#1 = Scan the table Professionals and retrieve the cell number, last name, and professional ID of all professionals who live in the state of Indiana ; #2 = Scan the table Treatments and retrieve the professional IDs of all treatments performed ; #3 = Scan the table Professionals and retrieve the cell number, last name, and professional ID of all professionals ; #4 = Join #2 and #3 based on the matching professional ID and retrieve the last name, professional ID, and cell number ; #5 = Group #4 by professional ID and aggregate the count of treatments per professional ; #6 = Filter from #5 all the professionals with more than two treatments and retrieve the cell number, last name, and professional ID ; #7 = Union #1 and #6 and retrieve the last name, cell number, and professional ID"
    },
    {
        "id": "8ff76f894695250cc3219a3776484c51d536e913fbbfae05da57575988b3aaeb",
        "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .",
        "query": "select name FROM dog_kennels.dogs WITH (FORCESCAN) where dog_id not in ( select dog_id FROM dog_kennels.treatments WITH (FORCESCAN) group by dog_id having sum ( cost_of_treatment ) > 1000 ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id , name ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #3 = Aggregate [ #2 ] GroupBy [ dog_id ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , dog_id ] ; #4 = Filter [ #3 ] Predicate [ Sum_cost_of_treatment > 1000.0 ] Output [ dog_id ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.dog_id = #1.dog_id ] Output [ #1.name ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id, name FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Aggregate_3 AS ( SELECT SUM(cost_of_treatment) AS Sum_cost_of_treatment, dog_id FROM Scan_2 GROUP BY dog_id ), Filter_4 AS ( SELECT dog_id FROM Aggregate_3 WHERE Sum_cost_of_treatment > 1000.0 ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Filter_4) ) SELECT * FROM Except_5",
        "clean_query": "select name FROM dog_kennels.dogs  where dog_id not in ( select dog_id FROM dog_kennels.treatments  group by dog_id having sum ( cost_of_treatment ) > 1000 )",
        "qd": "#1 = Scan the table Dogs and retrieve the dog IDs and names of all dogs ; #2 = Scan the table Treatments and retrieve the cost of treatment and dog IDs of all treatments ; #3 = Group #2 by dog ID and aggregate the sum of the cost of treatment for each dog ; #4 = Filter from #3 all the dogs with a sum cost of treatment greater than 1000 ; #5 = Return all the dogs from #1 that are not in #4 and retrieve their names"
    },
    {
        "id": "2e6a21ea522f1a50f525947926f0f042d7a8194f313d7a60aa58fe70c5062144",
        "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?",
        "query": "select name FROM dog_kennels.dogs WITH (FORCESCAN) where dog_id not in ( select dog_id FROM dog_kennels.treatments WITH (FORCESCAN) group by dog_id having sum ( cost_of_treatment ) > 1000 ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id , name ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #3 = Aggregate [ #2 ] GroupBy [ dog_id ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , dog_id ] ; #4 = Filter [ #3 ] Predicate [ Sum_cost_of_treatment > 1000.0 ] Output [ dog_id ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.dog_id = #1.dog_id ] Output [ #1.name ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id, name FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Aggregate_3 AS ( SELECT SUM(cost_of_treatment) AS Sum_cost_of_treatment, dog_id FROM Scan_2 GROUP BY dog_id ), Filter_4 AS ( SELECT dog_id FROM Aggregate_3 WHERE Sum_cost_of_treatment > 1000.0 ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Filter_4) ) SELECT * FROM Except_5",
        "clean_query": "select name FROM dog_kennels.dogs  where dog_id not in ( select dog_id FROM dog_kennels.treatments  group by dog_id having sum ( cost_of_treatment ) > 1000 )",
        "qd": "#1 = Scan the table Dogs and retrieve the dog IDs and names of all dogs ; #2 = Scan the table Treatments and retrieve the cost of treatment and dog IDs of all treatments ; #3 = Group #2 by dog ID and aggregate the sum of cost of treatment per dog ; #4 = Filter from #3 all the records with a sum of cost of treatment greater than 1000.0 ; #5 = Return the names of the dogs from #1 that are not in #4"
    },
    {
        "id": "1f6246464b62f765bf1b1cd4fb9ab00f47b5ee2aa8b7ba1ac9112ecf774c5483",
        "question": "Which first names are used for professionals or owners but are not used as dog names?",
        "query": "SELECT first_name FROM dog_kennels.Professionals WITH (FORCESCAN) UNION SELECT first_name FROM dog_kennels.Owners WITH (FORCESCAN) EXCEPT SELECT name FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ first_name ] ; #2 = Scan Table [ Owners ] Output [ first_name ] ; #3 = Union [ #1 , #2 ] Output [ #1.first_name ] ; #4 = Scan Table [ Dogs ] Output [ name ] ; #5 = Except [ #3 , #4 ] Predicate [ #4.name = #3.first_name ] Output [ #3.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT first_name FROM dog_kennels.Owners ), Union_3 AS ( SELECT first_name FROM Scan_1 UNION SELECT first_name FROM Scan_2 ), Scan_4 AS ( SELECT name FROM dog_kennels.Dogs ), Except_5 AS ( SELECT Union_3.first_name FROM Union_3 WHERE first_name NOT IN (SELECT name FROM Scan_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT first_name FROM dog_kennels.Professionals  UNION SELECT first_name FROM dog_kennels.Owners  EXCEPT SELECT name FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Professionals and retrieve the first names of all professionals ; #2 = Scan the table Owners and retrieve the first names of all owners ; #3 = Union #1 and #2 and retrieve all the first names ; #4 = Scan the table Dogs and retrieve the names of all dogs ; #5 = Return all the first names from #3 that are not used as dog names"
    },
    {
        "id": "79cef8a73b2fd8b66f165d4c4c9e563cfeea07472ea739d817c32c35983b8c2f",
        "question": "Find the first names that are used for professionals or owners but are not used as dog names.",
        "query": "SELECT first_name FROM dog_kennels.Professionals WITH (FORCESCAN) UNION SELECT first_name FROM dog_kennels.Owners WITH (FORCESCAN) EXCEPT SELECT name FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ first_name ] ; #2 = Scan Table [ Owners ] Output [ first_name ] ; #3 = Union [ #1 , #2 ] Output [ #1.first_name ] ; #4 = Scan Table [ Dogs ] Output [ name ] ; #5 = Except [ #3 , #4 ] Predicate [ #4.name = #3.first_name ] Output [ #3.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT first_name FROM dog_kennels.Owners ), Union_3 AS ( SELECT first_name FROM Scan_1 UNION SELECT first_name FROM Scan_2 ), Scan_4 AS ( SELECT name FROM dog_kennels.Dogs ), Except_5 AS ( SELECT Union_3.first_name FROM Union_3 WHERE first_name NOT IN (SELECT name FROM Scan_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT first_name FROM dog_kennels.Professionals  UNION SELECT first_name FROM dog_kennels.Owners  EXCEPT SELECT name FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Professionals and retrieve the first names of all professionals ; #2 = Scan the table Owners and retrieve the first names of all owners ; #3 = Union the first names from #1 and #2 ; #4 = Scan the table Dogs and retrieve the names of all dogs ; #5 = Return the first names from #3 that are not present in #4, which are the first names used for professionals or owners but not used as dog names."
    },
    {
        "id": "8fc7a2ee5a2eb6023b8e472bb2464ab3199f614879d09a2882a8e5e7053c079b",
        "question": "Which professional did not operate any treatment on dogs? List the professional's id, role and email.",
        "query": "SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals WITH (FORCESCAN) EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ professional_id , role_code , email_address ] ; #2 = Scan Table [ Professionals ] Output [ professional_id , role_code , email_address ] ; #3 = Scan Table [ Treatments ] Output [ professional_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.professional_id = #2.professional_id ] Output [ #2.professional_id , #2.email_address , #2.role_code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.professional_id = #4.professional_id ] Output [ #1.email_address , #1.professional_id , #1.role_code ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id, role_code, email_address FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT professional_id, role_code, email_address FROM dog_kennels.Professionals ), Scan_3 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Intersect_4 AS ( SELECT Scan_2.professional_id, Scan_2.email_address, Scan_2.role_code FROM Scan_2 WHERE professional_id IN (SELECT professional_id FROM Scan_3) ), Except_5 AS ( SELECT Scan_1.email_address, Scan_1.professional_id, Scan_1.role_code FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Intersect_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals  EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id",
        "qd": "#1 = Scan the table Professionals and retrieve the professional's id, role, and email of all professionals ; #2 = Scan the table Professionals and retrieve the professional's id, role, and email of all professionals ; #3 = Scan the table Treatments and retrieve the professional's id of all treatments performed on dogs ; #4 = Intersect #2 and #3 based on the matching professional's id and retrieve the professional's id, email, and role ; #5 = return the email, professional's id, and role from #1 that is not in #4 to find the professionals who did not operate any treatment on dogs"
    },
    {
        "id": "36adc0f401efd9e40060af9ac99b36de507b24338108ea1174f7e522094865df",
        "question": "Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
        "query": "SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals WITH (FORCESCAN) EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ professional_id , role_code , email_address ] ; #2 = Scan Table [ Professionals ] Output [ professional_id , role_code , email_address ] ; #3 = Scan Table [ Treatments ] Output [ professional_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.professional_id = #2.professional_id ] Output [ #2.professional_id , #2.email_address , #2.role_code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.professional_id = #4.professional_id ] Output [ #1.email_address , #1.professional_id , #1.role_code ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id, role_code, email_address FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT professional_id, role_code, email_address FROM dog_kennels.Professionals ), Scan_3 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Intersect_4 AS ( SELECT Scan_2.professional_id, Scan_2.email_address, Scan_2.role_code FROM Scan_2 WHERE professional_id IN (SELECT professional_id FROM Scan_3) ), Except_5 AS ( SELECT Scan_1.email_address, Scan_1.professional_id, Scan_1.role_code FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Intersect_4) ) SELECT * FROM Except_5",
        "clean_query": "SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals  EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id",
        "qd": "#1 = Scan the table Professionals and retrieve the professional ID, role code, and email address of all professionals. ; #2 = Scan the table Professionals and retrieve the professional ID, role code, and email address of all professionals. ; #3 = Scan the table Treatments and retrieve the professional IDs of all treatments performed. ; #4 = Intersect #2 and #3 based on the matching professional ID and retrieve the professional ID, email address, and role code. ; #5 = Return the email addresses, professional IDs, and role codes from #1 that are not in #4, identifying the professionals who did not perform any treatment on dogs."
    },
    {
        "id": "4c7d617842ecf4c2c442a7865d9226b92d5fc0b85e7dbe47701a24899111864b",
        "question": "Which owner owns the most dogs? List the owner id, first name and last name.",
        "query": "SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Owners AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ owner_id ] ; #2 = Aggregate [ #1 ] GroupBy [ owner_id ] Output [ countstar AS Count_Star , owner_id ] ; #3 = Scan Table [ Owners ] Output [ first_name , last_name , owner_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.last_name , #3.first_name , #2.Count_Star , #2.owner_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , owner_id , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, owner_id FROM Scan_1 GROUP BY owner_id ), Scan_3 AS ( SELECT first_name, last_name, owner_id FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.last_name, Scan_3.first_name, Aggregate_2.Count_Star, Aggregate_2.owner_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.owner_id = Scan_3.owner_id ), TopSort_5 AS ( SELECT TOP 1 first_name, last_name, owner_id, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Owners AS T2  ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Dogs and retrieve the owner IDs of all dogs ; #2 = Group #1 by owner ID and count the number of dogs per owner ; #3 = Scan the table Owners and retrieve the first name, last name, and owner ID of all owners ; #4 = Join #2 and #3 based on the matching owner IDs and retrieve the last name, first name, count of dogs, and owner ID ; #5 = Sort the records from #4 based on the count of dogs in descending order, select the first record, and identify the owner with the most dogs by their owner ID, first name, and last name."
    },
    {
        "id": "66ca5dbbeaf6330e1e4962deede1ffbb618a38a3ed59cf7c08d11c553f1497cb",
        "question": "Return the owner id, first name and last name of the owner who has the most dogs.",
        "query": "SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Owners AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ owner_id ] ; #2 = Aggregate [ #1 ] GroupBy [ owner_id ] Output [ countstar AS Count_Star , owner_id ] ; #3 = Scan Table [ Owners ] Output [ first_name , last_name , owner_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.last_name , #3.first_name , #2.Count_Star , #2.owner_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , last_name , owner_id , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, owner_id FROM Scan_1 GROUP BY owner_id ), Scan_3 AS ( SELECT first_name, last_name, owner_id FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.last_name, Scan_3.first_name, Aggregate_2.Count_Star, Aggregate_2.owner_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.owner_id = Scan_3.owner_id ), TopSort_5 AS ( SELECT TOP 1 first_name, last_name, owner_id, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Owners AS T2  ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Dogs and retrieve the owner IDs of all dogs ; #2 = Aggregate the number of dogs per owner ID in #1 ; #3 = Scan the table Owners and retrieve the first name, last name, and owner ID of all owners ; #4 = Join #2 and #3 based on the matching owner IDs and retrieve the last name, first name, count of dogs, and owner ID ; #5 = Sort the records from #4 based on the count of dogs in descending order, select the first record, and retrieve the first name, last name, owner ID, and count of dogs"
    },
    {
        "id": "846e09f26beeee5ebb3abf7a28810861967194e38262b68ea53c0d47e8b2709e",
        "question": "Which professionals have done at least two treatments? List the professional's id, role, and first name.",
        "query": "SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ countstar AS Count_Star , professional_id ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id , role_code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #3.professional_id , #2.Count_Star , #3.role_code ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ first_name , professional_id , role_code ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, professional_id FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT first_name, professional_id, role_code FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.first_name, Scan_3.professional_id, Aggregate_2.Count_Star, Scan_3.role_code FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT first_name, professional_id, role_code FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Treatments to retrieve the professional IDs of all treatments ; #2 = Group the professional IDs from #1 and aggregate the count for each professional ; #3 = Scan the table Professionals to retrieve the first name, professional ID, and role code of all professionals ; #4 = Join #2 and #3 based on the matching professional IDs and retrieve the first name, professional ID, role code, and count ; #5 = Filter from #4 all the records with a count of treatments greater than or equal to 2 and retrieve the first name, professional ID, and role code of the professionals"
    },
    {
        "id": "ef4c1b5e130aa488efbf131f5a392c01c95c1e9be40ff4af6960a1d9f3e744a0",
        "question": "What are the id, role, and first name of the professionals who have performed two or more treatments?",
        "query": "SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ countstar AS Count_Star , professional_id ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id , role_code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #3.professional_id , #2.Count_Star , #3.role_code ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ first_name , professional_id , role_code ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, professional_id FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT first_name, professional_id, role_code FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.first_name, Scan_3.professional_id, Aggregate_2.Count_Star, Scan_3.role_code FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT first_name, professional_id, role_code FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Treatments and retrieve the professional IDs of all treatments performed ; #2 = Group #1 by professional ID and count the number of treatments performed by each professional ; #3 = Scan the table Professionals and retrieve the first names, professional IDs, and role codes of all professionals ; #4 = Join #2 and #3 based on the matching professional IDs and retrieve the first names, professional IDs, role codes, and the count of treatments performed ; #5 = Filter from #4 all the professionals with a count of treatments performed equal to or greater than 2 and retrieve the first names, professional IDs, and role codes"
    },
    {
        "id": "ad9d991e1f140de0bcbb72b639b2b2c55ef989561d953b6b65c0c60098413bba",
        "question": "What is the name of the breed with the most dogs?",
        "query": "SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Breeds ] Output [ breed_code , breed_name ] ; #2 = Scan Table [ Dogs ] Output [ breed_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.breed_code = #2.breed_code ] Output [ #1.breed_name ] ; #4 = Aggregate [ #3 ] GroupBy [ breed_name ] Output [ countstar AS Count_Star , breed_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , breed_name ]",
        "cte": "WITH Scan_1 AS ( SELECT breed_code, breed_name FROM dog_kennels.Breeds ), Scan_2 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.breed_name FROM Scan_1 JOIN Scan_2 ON Scan_1.breed_code = Scan_2.breed_code ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, breed_name FROM Join_3 GROUP BY breed_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, breed_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Breeds and retrieve the breed codes and names of all breeds. ; #2 = Scan the table Dogs and retrieve the breed codes of all dogs. ; #3 = Join #1 and #2 based on the matching breed code and retrieve the breed names. ; #4 = Group #3 by breed name and aggregate the count per breed name to find the number of dogs in each breed. ; #5 = Sort the records from #4 based on the count of dogs in descending order, select the first record, and identify the name of the breed with the most dogs and its count of dogs."
    },
    {
        "id": "6940b25b51becbeb25e648b50fc48812060854804e93b48086f08f8e01bd3638",
        "question": "Which breed do the most dogs have? Give me the breed name.",
        "query": "SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Breeds ] Output [ breed_code , breed_name ] ; #2 = Scan Table [ Dogs ] Output [ breed_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.breed_code = #2.breed_code ] Output [ #1.breed_name ] ; #4 = Aggregate [ #3 ] GroupBy [ breed_name ] Output [ countstar AS Count_Star , breed_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , breed_name ]",
        "cte": "WITH Scan_1 AS ( SELECT breed_code, breed_name FROM dog_kennels.Breeds ), Scan_2 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.breed_name FROM Scan_1 JOIN Scan_2 ON Scan_1.breed_code = Scan_2.breed_code ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, breed_name FROM Join_3 GROUP BY breed_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, breed_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Breeds and retrieve the breed code and breed name of all breeds ; #2 = Scan the table Dogs and retrieve the breed code of all dogs ; #3 = Join #1 and #2 based on the matching breed code and retrieve the breed name ; #4 = Group #3 by breed name and aggregate the count per breed name to find the number of dogs for each breed ; #5 = Sort the records from #4 based on the count of dogs in descending order, select the first record, and identify the breed with the most dogs and its count."
    },
    {
        "id": "661ea27e7e8bc59503dbef3470b98ed3b9d917be0339f18d8dcb7f4268ed669f",
        "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.",
        "query": "SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ last_name , owner_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.last_name , #3.owner_id , #2.dog_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.owner_id , #4.last_name ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ countstar AS Count_Star , last_name , owner_id ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ last_name , owner_id , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT last_name, owner_id FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.last_name, Scan_3.owner_id, Scan_2.dog_id FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.owner_id, Join_4.last_name FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star, last_name, owner_id FROM Join_5 GROUP BY last_name, owner_id ), TopSort_7 AS ( SELECT TOP 1 last_name, owner_id, Count_Star FROM Aggregate_6 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_7",
        "clean_query": "SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Treatments and retrieve the dog IDs of all the treatments ; #2 = Scan the table Dogs and retrieve the owner IDs and dog IDs of all dogs ; #3 = Scan the table Owners and retrieve the last names and owner IDs of all owners ; #4 = Join #2 and #3 based on the matching owner ID and retrieve the last names and owner IDs ; #5 = Join #1 and #4 based on the matching dog ID and retrieve the owner IDs and last names ; #6 = Group #5 by owner ID and aggregate the count of treatments per owner to find the number of treatments paid by each owner ; #7 = Sort the records from #6 based on the count of treatments in descending order, select the first record, and identify the owner with the most treatments paid and their owner ID and last name."
    },
    {
        "id": "e8547401e95957bca35ed38ffb63b21c97fd2a30d03f18821da27f7671f398df",
        "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.",
        "query": "SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ last_name , owner_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.last_name , #3.owner_id , #2.dog_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.owner_id , #4.last_name ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ countstar AS Count_Star , last_name , owner_id ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ last_name , owner_id , Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT last_name, owner_id FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.last_name, Scan_3.owner_id, Scan_2.dog_id FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.owner_id, Join_4.last_name FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star, last_name, owner_id FROM Join_5 GROUP BY last_name, owner_id ), TopSort_7 AS ( SELECT TOP 1 last_name, owner_id, Count_Star FROM Aggregate_6 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_7",
        "clean_query": "SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC",
        "qd": "#1 = Scan the table Treatments to retrieve the dog IDs of all treatments ; #2 = Scan the table Dogs to retrieve the owner IDs and dog IDs of all dogs ; #3 = Scan the table Owners to retrieve the last names and owner IDs of all owners ; #4 = Join #2 and #3 based on the matching owner ID and retrieve the last names and owner IDs ; #5 = Join #1 and #4 based on the matching dog ID and retrieve the owner IDs and last names ; #6 = Group #5 by owner ID and aggregate the count of treatments per owner ; #7 = Sort the records from #6 based on the count of treatments in descending order, select the first record, and identify the owner ID and last name of the owner who spent the most on treatments of his or her dogs."
    },
    {
        "id": "769c4f1348155baa4d093eb503db38362725a9c83d68fe615b476ac3e3c2d803",
        "question": "What is the description of the treatment type that costs the least money in total?",
        "query": "SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #2 = Aggregate [ #1 ] GroupBy [ treatment_type_code ] Output [ treatment_type_code , SUM(cost_of_treatment) AS Sum_cost_of_treatment ] ; #3 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.treatment_type_code = #3.treatment_type_code ] Output [ #3.treatment_type_description , #2.Sum_cost_of_treatment ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment ASC ] Output [ Sum_cost_of_treatment , treatment_type_description ]",
        "cte": "WITH Scan_1 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT treatment_type_code, SUM(cost_of_treatment) AS Sum_cost_of_treatment FROM Scan_1 GROUP BY treatment_type_code ), Scan_3 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Join_4 AS ( SELECT Scan_3.treatment_type_description, Aggregate_2.Sum_cost_of_treatment FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.treatment_type_code = Scan_3.treatment_type_code ), TopSort_5 AS ( SELECT TOP 1 Sum_cost_of_treatment, treatment_type_description FROM Join_4 ORDER BY Sum_cost_of_treatment ASC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC",
        "qd": "#1 = Scan the table Treatments and retrieve the cost of treatment and treatment type code of all treatments ; #2 = Group #1 by treatment type code and aggregate the sum of cost of treatment to find the total cost for each treatment type ; #3 = Scan the table Treatment_Types and retrieve the treatment type code and treatment type description ; #4 = Join #2 and #3 based on the matching treatment type code and retrieve the treatment type description and total cost of each treatment type ; #5 = Sort the records from #4 based on the total cost of treatment in ascending order, select the first record, and identify the description of the treatment type that costs the least money in total"
    },
    {
        "id": "8712f813e382b9eadb483db8adea6999189ff315c912822cb725e49f6fb06f95",
        "question": "Give me the description of the treatment type whose total cost is the lowest.",
        "query": "SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #2 = Aggregate [ #1 ] GroupBy [ treatment_type_code ] Output [ treatment_type_code , SUM(cost_of_treatment) AS Sum_cost_of_treatment ] ; #3 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.treatment_type_code = #3.treatment_type_code ] Output [ #3.treatment_type_description , #2.Sum_cost_of_treatment ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment ASC ] Output [ Sum_cost_of_treatment , treatment_type_description ]",
        "cte": "WITH Scan_1 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT treatment_type_code, SUM(cost_of_treatment) AS Sum_cost_of_treatment FROM Scan_1 GROUP BY treatment_type_code ), Scan_3 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Join_4 AS ( SELECT Scan_3.treatment_type_description, Aggregate_2.Sum_cost_of_treatment FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.treatment_type_code = Scan_3.treatment_type_code ), TopSort_5 AS ( SELECT TOP 1 Sum_cost_of_treatment, treatment_type_description FROM Join_4 ORDER BY Sum_cost_of_treatment ASC ) SELECT * FROM TopSort_5",
        "clean_query": "SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC",
        "qd": "#1 = Scan the table Treatments and retrieve the cost and treatment type code of all treatments ; #2 = Group #1 by treatment type code and aggregate the sum of the costs per treatment type ; #3 = Scan the table Treatment_Types and retrieve the treatment type code and description of all treatment types ; #4 = Join #2 and #3 based on the matching treatment type code and retrieve the description and sum of costs ; #5 = Sort the records from #4 based on the sum of costs in ascending order, select the first record, and identify the description of the treatment type whose total cost is the lowest"
    },
    {
        "id": "d4c083cb95db6dcb9ca733446fc4c7c4a43e2b085ee182b10d387d7b8d4694d6",
        "question": "Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.",
        "query": "SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ zip_code , owner_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #2.dog_id , #3.owner_id , #3.zip_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.owner_id , #4.zip_code , #1.cost_of_treatment ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , zip_code , owner_id ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment DESC ] Output [ Sum_cost_of_treatment , zip_code , owner_id ]",
        "cte": "WITH Scan_1 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT zip_code, owner_id FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_2.dog_id, Scan_3.owner_id, Scan_3.zip_code FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.owner_id, Join_4.zip_code, Scan_1.cost_of_treatment FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT SUM(cost_of_treatment) AS Sum_cost_of_treatment, zip_code, owner_id FROM Join_5 GROUP BY zip_code, owner_id ), TopSort_7 AS ( SELECT TOP 1 Sum_cost_of_treatment, zip_code, owner_id FROM Aggregate_6 ORDER BY Sum_cost_of_treatment DESC ) SELECT * FROM TopSort_7",
        "clean_query": "SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC",
        "qd": "#1 = Scan the table Treatments and retrieve the cost of treatment and dog IDs for all treatments ; #2 = Scan the table Dogs and retrieve the owner IDs and dog IDs for all dogs ; #3 = Scan the table Owners and retrieve the zip codes and owner IDs for all owners ; #4 = Join #2 and #3 based on the matching owner IDs and retrieve the dog IDs, owner IDs, and zip codes ; #5 = Join #1 and #4 based on the matching dog IDs and retrieve the owner IDs, zip codes, and cost of treatment ; #6 = Group #5 by owner ID and calculate the sum of the cost of treatment for each owner, and retrieve the sum of cost of treatment, zip code, and owner ID ; #7 = Sort the records from #6 based on the sum of the cost of treatment in descending order, select the first record, and identify the owner who has paid the largest amount of money in total for their dogs, along with their owner ID and zip code."
    },
    {
        "id": "78201a51f6489492d9712ea0074012d00b05eae33689bd9392a73b71b99c588a",
        "question": "Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.",
        "query": "SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ zip_code , owner_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #2.dog_id , #3.owner_id , #3.zip_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.owner_id , #4.zip_code , #1.cost_of_treatment ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , zip_code , owner_id ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment DESC ] Output [ Sum_cost_of_treatment , zip_code , owner_id ]",
        "cte": "WITH Scan_1 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT zip_code, owner_id FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_2.dog_id, Scan_3.owner_id, Scan_3.zip_code FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.owner_id, Join_4.zip_code, Scan_1.cost_of_treatment FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT SUM(cost_of_treatment) AS Sum_cost_of_treatment, zip_code, owner_id FROM Join_5 GROUP BY zip_code, owner_id ), TopSort_7 AS ( SELECT TOP 1 Sum_cost_of_treatment, zip_code, owner_id FROM Aggregate_6 ORDER BY Sum_cost_of_treatment DESC ) SELECT * FROM TopSort_7",
        "clean_query": "SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC",
        "qd": "#1 = Scan the table Treatments to find the cost of treatment and dog IDs for all treatments ; #2 = Scan the table Dogs to find the owner IDs and dog IDs for all dogs ; #3 = Scan the table Owners to find the zip codes and owner IDs for all owners ; #4 = Join #2 and #3 based on the matching owner IDs and retrieve the dog IDs, owner IDs, and zip codes ; #5 = Join #1 and #4 based on the matching dog IDs and retrieve the owner IDs, zip codes, and costs of treatments ; #6 = Group #5 by owner ID and aggregate the sum of cost of treatments for each owner to find the total amount spent by each owner for their dogs ; #7 = Sort the records from #6 based on the sum of cost of treatments in descending order, select the first record, and identify the owner ID and zip code of the owner who spent the most money in total for his or her dogs."
    },
    {
        "id": "a7ac46f6fac1b59f3e7af600f51d43c2cb3e999a65bed7a25b53c188b5ea89d5",
        "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.",
        "query": "SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ countstar AS Count_Star , professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.professional_id , #2.Count_Star , #3.cell_number ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ cell_number , professional_id ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, professional_id FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT cell_number, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.professional_id, Aggregate_2.Count_Star, Scan_3.cell_number FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT cell_number, professional_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Treatments and retrieve the professional IDs of all the treatments ; #2 = Group #1 by professional ID and aggregate the count of treatments per professional ID ; #3 = Scan the table Professionals and retrieve the cell phone numbers and professional IDs of all professionals ; #4 = Join #2 and #3 based on the matching professional ID and retrieve the professional ID, treatment count, and cell phone number ; #5 = Filter from #4 all the professionals with at least two types of treatments and retrieve the cell phone number and professional ID"
    },
    {
        "id": "a72bc94122c8335bb8ef116a28ae80c1bcafdbcf89ef8fca8233fe7a04a89520",
        "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.",
        "query": "SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ countstar AS Count_Star , professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.professional_id , #2.Count_Star , #3.cell_number ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ cell_number , professional_id ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, professional_id FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT cell_number, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.professional_id, Aggregate_2.Count_Star, Scan_3.cell_number FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT cell_number, professional_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2",
        "qd": "#1 = Scan the table Treatments and retrieve the professional IDs of all treatments ; #2 = Group #1 by professional ID and count the number of treatments per professional ID ; #3 = Scan the table Professionals and retrieve the cell phone and professional ID of all professionals ; #4 = Join #2 and #3 based on the matching professional ID and retrieve the professional ID, count of treatments, and cell phone ; #5 = Filter from #4 all the professionals with a count of treatments greater than or equal to 2 and retrieve the cell phone and professional ID"
    },
    {
        "id": "74853798510bb1be5881fc985b194c00060b2fa3fafaf8b2d0658e70f2d759f0",
        "question": "What are the first name and last name of the professionals who have done treatment with cost below average?",
        "query": "SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ) ",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #2 = Aggregate [ #1 ] Output [ AVG(cost_of_treatment) AS Avg_cost_of_treatment ] ; #3 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.cost_of_treatment < #2.Avg_cost_of_treatment ] Output [ #3.cost_of_treatment ] ; #5 = Scan Table [ Professionals ] Output [ first_name , last_name ] ; #6 = Join [ #4 , #5 ] Distinct [ true ] Output [ #5.last_name , #5.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT AVG(cost_of_treatment) AS Avg_cost_of_treatment FROM Scan_1 ), Scan_3 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Join_4 AS ( SELECT cost_of_treatment FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.cost_of_treatment < Aggregate_2.Avg_cost_of_treatment ), Scan_5 AS ( SELECT first_name, last_name FROM dog_kennels.Professionals ), Join_6 AS ( SELECT DISTINCT Scan_5.last_name, Scan_5.first_name FROM Join_4 CROSS JOIN Scan_5 ) SELECT * FROM Join_6",
        "clean_query": "SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1  CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Treatments and retrieve the cost of treatment for all treatments ; #2 = Aggregate the cost of treatment from #1 and calculate the average cost ; #3 = Scan the table Treatments and retrieve the cost of treatment for all treatments ; #4 = Join #2 and #3 based on the condition that the cost of treatment is below the average cost ; #5 = Scan the table Professionals and retrieve the first name and last name of all professionals ; #6 = Join #4 and #5 to retrieve the first name and last name of professionals who have done treatments with cost below average"
    },
    {
        "id": "c8a261b56b3fd317715e20ae964633fe39d27e415421d119333cd698a3f48fb7",
        "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.",
        "query": "SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ) ",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #2 = Aggregate [ #1 ] Output [ AVG(cost_of_treatment) AS Avg_cost_of_treatment ] ; #3 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.cost_of_treatment < #2.Avg_cost_of_treatment ] Output [ #3.cost_of_treatment ] ; #5 = Scan Table [ Professionals ] Output [ first_name , last_name ] ; #6 = Join [ #4 , #5 ] Distinct [ true ] Output [ #5.last_name , #5.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT AVG(cost_of_treatment) AS Avg_cost_of_treatment FROM Scan_1 ), Scan_3 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Join_4 AS ( SELECT cost_of_treatment FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.cost_of_treatment < Aggregate_2.Avg_cost_of_treatment ), Scan_5 AS ( SELECT first_name, last_name FROM dog_kennels.Professionals ), Join_6 AS ( SELECT DISTINCT Scan_5.last_name, Scan_5.first_name FROM Join_4 CROSS JOIN Scan_5 ) SELECT * FROM Join_6",
        "clean_query": "SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1  CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Treatments and retrieve the cost of treatment for each treatment ; #2 = Calculate the average cost of treatment from #1 ; #3 = Scan the table Treatments and retrieve the cost of treatment for each treatment ; #4 = Join #2 and #3 based on the condition that the cost of treatment is less than the average cost of treatment and retrieve the cost of treatment ; #5 = Scan the table Professionals and retrieve the first names and last names of all professionals ; #6 = Join #4 and #5 based on the matching cost of treatment and retrieve the last names and first names of the professionals who have operated a treatment that costs less than the average"
    },
    {
        "id": "6b6e1c6478e1e38f5482e86be34aee7b06e9b39a193ea87dfdd42bee7e5d3092",
        "question": "List the date of each treatment, together with the first name of the professional who operated it.",
        "query": "SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.Professionals AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ date_of_treatment , professional_id ] ; #2 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ #1.date_of_treatment , #2.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT date_of_treatment, professional_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_3 AS ( SELECT Scan_1.date_of_treatment, Scan_2.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.professional_id = Scan_2.professional_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.Professionals AS T2  ON T1.professional_id = T2.professional_id",
        "qd": "#1 = Scan the table Treatments and retrieve the date of each treatment and the professional ID who operated it. ; #2 = Scan the table Professionals and retrieve the first name and professional ID of all professionals. ; #3 = Join #1 and #2 based on the matching professional ID and retrieve the date of treatment and first name of the professional who operated it."
    },
    {
        "id": "5cce379b4051e866afaec01797e5a9818e966ef70d3e2d375c35ce632f044540",
        "question": "What are the date and the operating professional's first name of each treatment?",
        "query": "SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.Professionals AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ date_of_treatment , professional_id ] ; #2 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ #1.date_of_treatment , #2.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT date_of_treatment, professional_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_3 AS ( SELECT Scan_1.date_of_treatment, Scan_2.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.professional_id = Scan_2.professional_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.Professionals AS T2  ON T1.professional_id = T2.professional_id",
        "qd": "#1 = Scan the table Treatments and retrieve the date of treatment and professional ID of each treatment ; #2 = Scan the table Professionals and retrieve the first name and professional ID of each professional ; #3 = Join #1 and #2 based on the matching professional ID and retrieve the date of treatment and first name of each treatment."
    },
    {
        "id": "a2a172d7d2a542d70069554cde5ff036f577151c427f34994ab64326401a47dc",
        "question": "List the cost of each treatment and the corresponding treatment type description.",
        "query": "SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.treatment_types AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.treatment_type_code = #2.treatment_type_code ] Output [ #2.cost_of_treatment , #1.treatment_type_description ]",
        "cte": "WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Join_3 AS ( SELECT Scan_2.cost_of_treatment, Scan_1.treatment_type_description FROM Scan_1 JOIN Scan_2 ON Scan_1.treatment_type_code = Scan_2.treatment_type_code ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.treatment_types AS T2  ON T1.treatment_type_code = T2.treatment_type_code",
        "qd": "#1 = Scan the table Treatment_Types and retrieve the treatment type code and description for all treatments ; #2 = Scan the table Treatments and retrieve the cost of treatment and treatment type code for all treatments ; #3 = Join #1 and #2 based on the matching treatment type code and retrieve the cost of each treatment and the corresponding treatment type description."
    },
    {
        "id": "95b58705014ea9cafe1d2b2967eceea55b90e10025390a1d8c79348f47380569",
        "question": "What are the cost and treatment type description of each treatment?",
        "query": "SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.treatment_types AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.treatment_type_code = #2.treatment_type_code ] Output [ #2.cost_of_treatment , #1.treatment_type_description ]",
        "cte": "WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Join_3 AS ( SELECT Scan_2.cost_of_treatment, Scan_1.treatment_type_description FROM Scan_1 JOIN Scan_2 ON Scan_1.treatment_type_code = Scan_2.treatment_type_code ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.treatment_types AS T2  ON T1.treatment_type_code = T2.treatment_type_code",
        "qd": "#1 = Scan the table Treatment_Types and retrieve the treatment type codes and descriptions ; #2 = Scan the table Treatments and retrieve the costs of treatments and treatment type codes ; #3 = Join #1 and #2 based on the matching treatment type codes and retrieve the costs of treatments and treatment type descriptions"
    },
    {
        "id": "fc8eb2a4b3514db63e9649bd5c29860d9397dcfdb5806eefd7e7f601c363bf28",
        "question": "List each owner's first name, last name, and the size of his for her dog.",
        "query": "SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ owner_id , size_code ] ; #2 = Scan Table [ Owners ] Output [ first_name , last_name , owner_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.last_name , #2.first_name , #1.size_code ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id, size_code FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT first_name, last_name, owner_id FROM dog_kennels.Owners ), Join_3 AS ( SELECT Scan_2.last_name, Scan_2.first_name, Scan_1.size_code FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id",
        "qd": "#1 = Scan the table Dogs and retrieve the owner IDs and size codes of all dogs ; #2 = Scan the table Owners and retrieve the first name, last name, and owner IDs of all owners ; #3 = Join #1 and #2 based on the matching owner IDs and retrieve the last name, first name, and size code"
    },
    {
        "id": "09a03a898de94d379933b176c750be6d83e799a2d7d31e03de82e63888e69ed1",
        "question": "What are each owner's first name, last name, and the size of their dog?",
        "query": "SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ owner_id , size_code ] ; #2 = Scan Table [ Owners ] Output [ first_name , last_name , owner_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.last_name , #2.first_name , #1.size_code ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id, size_code FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT first_name, last_name, owner_id FROM dog_kennels.Owners ), Join_3 AS ( SELECT Scan_2.last_name, Scan_2.first_name, Scan_1.size_code FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id",
        "qd": "#1 = Scan the table Dogs and retrieve the owner IDs and size codes of all dogs ; #2 = Scan the table Owners and retrieve the first names, last names, and owner IDs of all owners ; #3 = Join #1 and #2 based on the matching owner ID and retrieve the last names, first names, and size codes"
    },
    {
        "id": "eded0e3c6d25bb3895cd6104eb9495428d4b8d1a9186de3ce6786eedecc9a792",
        "question": "List pairs of the owner's first name and the dogs's name.",
        "query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Output [ first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #1.first_name , #2.name ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.first_name, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id",
        "qd": "#1 = Scan the table Owners and retrieve the first names and owner IDs of all owners ; #2 = Scan the table Dogs and retrieve the owner IDs and names of all dogs ; #3 = Join #1 and #2 based on the matching owner ID and retrieve the first names and names of the owners and dogs"
    },
    {
        "id": "a18b1ec289665e858ed449e97f2baf04c419f3a8ecbc84d40b899776cc8686ec",
        "question": "What are each owner's first name and their dogs's name?",
        "query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Output [ first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #1.first_name , #2.name ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.first_name, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id",
        "qd": "#1 = Scan the table Owners and retrieve the first names and owner IDs of all owners ; #2 = Scan the table Dogs and retrieve the owner IDs and names of all dogs ; #3 = Join #1 and #2 based on the matching owner ID and retrieve the first names and names"
    },
    {
        "id": "17831c8c47493e469a43da0b31f0b95d91ce356b726429b57d3929c4aa04974e",
        "question": "List the names of the dogs of the rarest breed and the treatment dates of them.",
        "query": "SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs WITH (FORCESCAN) GROUP BY breed_code ORDER BY count ( * ) ASC ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ breed_code ] ; #2 = Aggregate [ #1 ] GroupBy [ breed_code ] Output [ countstar AS Count_Star , breed_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ breed_code , Count_Star ] ; #4 = Scan Table [ Dogs ] Output [ breed_code , dog_id , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.breed_code = #4.breed_code ] Output [ #4.dog_id , #4.name ] ; #6 = Scan Table [ Treatments ] Output [ date_of_treatment , dog_id ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.dog_id = #6.dog_id ] Output [ #6.date_of_treatment , #5.name ]",
        "cte": "WITH Scan_1 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, breed_code FROM Scan_1 GROUP BY breed_code ), TopSort_3 AS ( SELECT TOP 1 breed_code, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC ), Scan_4 AS ( SELECT breed_code, dog_id, name FROM dog_kennels.Dogs ), Join_5 AS ( SELECT Scan_4.dog_id, Scan_4.name FROM TopSort_3 JOIN Scan_4 ON TopSort_3.breed_code = Scan_4.breed_code ), Scan_6 AS ( SELECT date_of_treatment, dog_id FROM dog_kennels.Treatments ), Join_7 AS ( SELECT Scan_6.date_of_treatment, Join_5.name FROM Join_5 JOIN Scan_6 ON Join_5.dog_id = Scan_6.dog_id ) SELECT * FROM Join_7",
        "clean_query": "SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs  GROUP BY breed_code ORDER BY count ( * ) ASC )",
        "qd": "#1 = Scan the table Dogs and retrieve the breed code of all dogs ; #2 = Group #1 by breed code and aggregate the count of each breed ; #3 = Sort the records from #2 based on the count of each breed in ascending order, select the first record, and retrieve the breed code and the count of dogs for the rarest breed ; #4 = Scan the table Dogs and retrieve the breed code, dog IDs, and names of all dogs ; #5 = Join #3 and #4 based on the matching breed code and retrieve the dog IDs and names of dogs for the rarest breed ; #6 = Scan the table Treatments and retrieve the treatment dates and dog IDs of all treatments ; #7 = Join #5 and #6 based on the matching dog ID and retrieve the treatment dates and names of dogs for the rarest breed"
    },
    {
        "id": "55985502904668903fc70726bab09acf27f4a63cb38da420aac63d72edfcc8ac",
        "question": "Which dogs are of the rarest breed? Show their names and treatment dates.",
        "query": "SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs WITH (FORCESCAN) GROUP BY breed_code ORDER BY count ( * ) ASC ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ breed_code ] ; #2 = Aggregate [ #1 ] GroupBy [ breed_code ] Output [ countstar AS Count_Star , breed_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ breed_code , Count_Star ] ; #4 = Scan Table [ Dogs ] Output [ breed_code , dog_id , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.breed_code = #4.breed_code ] Output [ #4.dog_id , #4.name ] ; #6 = Scan Table [ Treatments ] Output [ date_of_treatment , dog_id ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.dog_id = #6.dog_id ] Output [ #6.date_of_treatment , #5.name ]",
        "cte": "WITH Scan_1 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, breed_code FROM Scan_1 GROUP BY breed_code ), TopSort_3 AS ( SELECT TOP 1 breed_code, Count_Star FROM Aggregate_2 ORDER BY Count_Star ASC ), Scan_4 AS ( SELECT breed_code, dog_id, name FROM dog_kennels.Dogs ), Join_5 AS ( SELECT Scan_4.dog_id, Scan_4.name FROM TopSort_3 JOIN Scan_4 ON TopSort_3.breed_code = Scan_4.breed_code ), Scan_6 AS ( SELECT date_of_treatment, dog_id FROM dog_kennels.Treatments ), Join_7 AS ( SELECT Scan_6.date_of_treatment, Join_5.name FROM Join_5 JOIN Scan_6 ON Join_5.dog_id = Scan_6.dog_id ) SELECT * FROM Join_7",
        "clean_query": "SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs  GROUP BY breed_code ORDER BY count ( * ) ASC )",
        "qd": "#1 = Scan the table Dogs and retrieve the breed codes of all dogs ; #2 = Group all the breed codes from #1 and aggregate the count per breed code to find the number of dogs in each breed ; #3 = Sort the records from #2 based on the count of dogs per breed in ascending order, select the first record, and identify the rarest breed ; #4 = Scan the table Dogs and retrieve the breed code, dog IDs, and names of all dogs ; #5 = Join #3 and #4 based on the matching breed code and retrieve the dog IDs and names of the dogs with the rarest breed ; #6 = Scan the table Treatments and retrieve the treatment dates and dog IDs of all treatments ; #7 = Join #5 and #6 based on the matching dog ID and retrieve the treatment dates and names of the dogs with the rarest breed"
    },
    {
        "id": "01d36d186ac9bd072310196a084016e2239ab53dc2afc337552b1b90e333e482",
        "question": "Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.",
        "query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state = 'Virginia' ] Output [ state , first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #1.first_name , #2.name ]",
        "cte": "WITH Scan_1 AS ( SELECT state, first_name, owner_id FROM dog_kennels.Owners WHERE state = 'Virginia' ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.first_name, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia'",
        "qd": "#1 = Scan the table Owners and retrieve the state and first name of all owners who live in Virginia ; #2 = Scan the table Dogs and retrieve the owner ID and name of all dogs ; #3 = Join #1 and #2 based on the matching owner IDs and retrieve the first name of the owner and the name of the dog"
    },
    {
        "id": "3def30b1ac991f058d5d2835e68edd88f98f0b397ec317e4db5c6ad6cacb91fb",
        "question": "Find the first names of owners living in Virginia and the names of dogs they own.",
        "query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state = 'Virginia' ] Output [ state , first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #1.first_name , #2.name ]",
        "cte": "WITH Scan_1 AS ( SELECT state, first_name, owner_id FROM dog_kennels.Owners WHERE state = 'Virginia' ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.first_name, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia'",
        "qd": "#1 = Scan the table Owners to find the first names and owner IDs of owners living in Virginia ; #2 = Scan the table Dogs and retrieve the owner IDs and names of all dogs ; #3 = Join #1 and #2 based on the matching owner IDs and retrieve the first names of owners and names of dogs they own."
    },
    {
        "id": "96ecc85b71033293fa2c714428724abb820b7d37ef95d0c06006e19e54d286a8",
        "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?",
        "query": "SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ date_arrived , date_departed , dog_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Distinct [ true ] Output [ #2.date_departed , #2.date_arrived ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT date_arrived, date_departed, dog_id FROM dog_kennels.Dogs ), Join_3 AS ( SELECT DISTINCT Scan_2.date_departed, Scan_2.date_arrived FROM Scan_1 JOIN Scan_2 ON Scan_1.dog_id = Scan_2.dog_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id",
        "qd": "#1 = Scan the table Treatments and retrieve the IDs of all dogs that have undergone a treatment ; #2 = Scan the table Dogs and retrieve the arriving and departing dates along with the dog IDs ; #3 = Join #1 and #2 based on the matching dog IDs to retrieve the arriving and departing dates of the dogs that have undergone a treatment"
    },
    {
        "id": "52e8fb837195616b49756027ccc6ca0ce0a8345e015fb0650c436258d6d84414",
        "question": "Find the arriving date and the departing date of the dogs that received a treatment.",
        "query": "SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ date_arrived , date_departed , dog_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Distinct [ true ] Output [ #2.date_departed , #2.date_arrived ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT date_arrived, date_departed, dog_id FROM dog_kennels.Dogs ), Join_3 AS ( SELECT DISTINCT Scan_2.date_departed, Scan_2.date_arrived FROM Scan_1 JOIN Scan_2 ON Scan_1.dog_id = Scan_2.dog_id ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id",
        "qd": "#1 = Scan the table Treatments and retrieve the dog IDs of all dogs that received a treatment. ; #2 = Scan the table Dogs and retrieve the arriving date and departing date of all dogs along with their dog IDs. ; #3 = Join the results from #1 and #2 based on the matching dog IDs and retrieve the arriving date and departing date of the dogs that received a treatment."
    },
    {
        "id": "cb384f0755ee64aadab7999c2dfdc55442be5549699fa4be5be6b2bc0a111457",
        "question": "List the last name of the owner owning the youngest dog.",
        "query": "SELECT T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ owners ] Output [ owner_id , last_name ] ; #2 = Scan Table [ dogs ] Output [ owner_id , age ] ; #3 = Filter [ #2 ] Predicate [ age IS NOT NULL ] Output [ owner_id , age ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ age DESC ] WithTies [ True ] Output [ age, owner_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #4.owner_id = #1.owner_id ] Output [ #1.last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id, last_name FROM dog_kennels.owners ), Scan_2 AS ( SELECT owner_id, age FROM dog_kennels.dogs ), Filter_3 AS ( SELECT owner_id, age FROM Scan_2 WHERE age IS NOT NULL ), TopSort_4 AS ( SELECT TOP 1 WITH TIES age, owner_id FROM Filter_3 ORDER BY age DESC ), Join_5 AS ( SELECT Scan_1.last_name FROM Scan_1 JOIN TopSort_4 ON TopSort_4.owner_id = Scan_1.owner_id ) SELECT * FROM Join_5",
        "clean_query": "SELECT T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs  )",
        "qd": "#1 = Scan the table Owners and retrieve the owner IDs and last names of all owners ; #2 = Scan the table Dogs and retrieve the owner IDs and ages of all dogs ; #3 = Filter from #2 all the dogs with non-null ages and retrieve the owner IDs and ages ; #4 = Sort the records from #3 based on the age of the dogs in descending order, select the latest record, and retrieve the owner ID and age of the youngest dog(s) ; #5 = Join #1 and #4 based on the matching owner IDs and retrieve the last names of the owners owning the youngest dog(s)"
    },
    {
        "id": "bb647a855ae3fa4248d333184af9d583778c8243f925a40ea45b59085a0376b2",
        "question": "Who owns the youngest dog? Give me his or her last name.",
        "query": "SELECT T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , age ] ; #3 = Filter [ #2 ] Predicate [ age IS NOT NULL ] Output [ owner_id , age ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ age DESC ] WithTies [ true ] Output [ owner_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #4.owner_id = #1.owner_id ] Output [ #1.last_name ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id, last_name FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id, age FROM dog_kennels.Dogs ), Filter_3 AS ( SELECT owner_id, age FROM Scan_2 WHERE age IS NOT NULL ), TopSort_4 AS ( SELECT TOP 1 WITH TIES owner_id FROM Filter_3 ORDER BY age DESC ), Join_5 AS ( SELECT Scan_1.last_name FROM Scan_1 JOIN TopSort_4 ON TopSort_4.owner_id = Scan_1.owner_id ) SELECT * FROM Join_5",
        "clean_query": "SELECT T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs  )",
        "qd": "#1 = Scan the table Owners and retrieve the owner IDs and last names of all owners ; #2 = Scan the table Dogs and retrieve the owner IDs and ages of all dogs ; #3 = Filter from #2 all the records with non-null ages, retrieve the owner IDs and ages ; #4 = Sort the records from #3 based on the age in descending order, select all records with ties, and retrieve the owner IDs ; #5 = Join #1 and #4 based on the matching owner ID and retrieve the last name of the owner who owns the youngest dog"
    },
    {
        "id": "92e6a8f3680fa91a51338547b40a58e01a2044a47b181bc2301d2f71ed3a9817",
        "question": "List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.",
        "query": "SELECT email_address FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Hawaii' OR state = 'Wisconsin' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Hawaii' OR state = 'Wisconsin' ] Output [ state , email_address ]",
        "cte": "WITH Scan_1 AS ( SELECT state, email_address FROM dog_kennels.Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT email_address FROM dog_kennels.Professionals  WHERE state = 'Hawaii' OR state = 'Wisconsin'",
        "qd": "#1 = Scan the table Professionals and retrieve the state and email address of all the professionals who live in the state of Hawaii or the state of Wisconsin."
    },
    {
        "id": "2cf656ceb1eb210f1f81d421ee219bde550d715a32a6c7677ff2fa5526174d2f",
        "question": "What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?",
        "query": "SELECT email_address FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Hawaii' OR state = 'Wisconsin' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Hawaii' OR state = 'Wisconsin' ] Output [ state , email_address ]",
        "cte": "WITH Scan_1 AS ( SELECT state, email_address FROM dog_kennels.Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT email_address FROM dog_kennels.Professionals  WHERE state = 'Hawaii' OR state = 'Wisconsin'",
        "qd": "#1 = Scan the table Professionals and retrieve the email addresses of all professionals living in either the state of Hawaii or the state of Wisconsin."
    },
    {
        "id": "73901c0e2644fd7bcca864ab987842eae3371572f3f1c7c7323bba227247e5a3",
        "question": "What are the arriving date and the departing date of all the dogs?",
        "query": "SELECT date_arrived , date_departed FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ date_arrived , date_departed ]",
        "cte": "WITH Scan_1 AS ( SELECT date_arrived, date_departed FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
        "clean_query": "SELECT date_arrived , date_departed FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the arriving date and departing date of all the dogs."
    },
    {
        "id": "179ac3c6aa019713305f70d101ac1fc9a2c0fb2b8dafbb0ee2a5290079d80fc0",
        "question": "List the arrival date and the departure date for all the dogs.",
        "query": "SELECT date_arrived , date_departed FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ date_arrived , date_departed ]",
        "cte": "WITH Scan_1 AS ( SELECT date_arrived, date_departed FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
        "clean_query": "SELECT date_arrived , date_departed FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the arrival date and departure date for all the dogs."
    },
    {
        "id": "64fc77b18d68161ef02cddfa0391c902fd60785ca67c788616dce5eff2d8ec7c",
        "question": "How many dogs went through any treatments?",
        "query": "SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ dog_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT dog_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments",
        "qd": "#1 = Scan the table Treatments and retrieve the distinct dog IDs of all treatments ; #2 = Aggregate the number of distinct dog IDs from #1 to find the number of dogs that went through any treatments."
    },
    {
        "id": "fe44aae95327f765fe37a47604e56e4242c7f5a1ebc738c17d59cda92f4e9cc5",
        "question": "Count the number of dogs that went through a treatment.",
        "query": "SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ dog_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT dog_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments",
        "qd": "#1 = Scan the table Treatments and retrieve all the distinct dog IDs of the dogs that went through a treatment ; #2 = Aggregate the count of the distinct dog IDs to find the number of dogs that went through a treatment"
    },
    {
        "id": "cdc8145fd792a6edaffb1bd812a01f52de104c77fbc0a642f538ef1ea0887887",
        "question": "How many professionals have performed any treatment to dogs?",
        "query": "SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments",
        "qd": "#1 = Scan the table Treatments and retrieve a distinct list of professional IDs who have performed any treatment to dogs ; #2 = Aggregate the number of professional IDs from #1 to find how many professionals have performed any treatment to dogs."
    },
    {
        "id": "064cdc0cdd3190421bd5ff7a37e51119776ea589c73a6415f867acf56fce848d",
        "question": "Find the number of professionals who have ever treated dogs.",
        "query": "SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments",
        "qd": "#1 = Scan the table Treatments and retrieve the distinct professional IDs who have treated dogs ; #2 = Aggregate the count of distinct professional IDs from #1 to find the number of professionals who have ever treated dogs"
    },
    {
        "id": "5c621a2c9379a00f609d9e0aa243a240affd345c59eac074076072a0019e1f3e",
        "question": "Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.",
        "query": "SELECT role_code , street , city , state FROM dog_kennels.professionals WITH (FORCESCAN) WHERE city LIKE '%West%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ city like '%West%' ] Output [ state , city , role_code , street ]",
        "cte": "WITH Scan_1 AS ( SELECT state, city, role_code, street FROM dog_kennels.Professionals WHERE city like '%West%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT role_code , street , city , state FROM dog_kennels.professionals  WHERE city LIKE '%West%'",
        "qd": "#1 = Scan the table Professionals and retrieve the state, city, role code, and street of professionals who live in a city that contains the substring 'West'."
    },
    {
        "id": "967c3c6ebe4369045d9dde46ef6cc5d3dad46a05783e44a3d183ee2c1b3b1d59",
        "question": "Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
        "query": "SELECT role_code , street , city , state FROM dog_kennels.professionals WITH (FORCESCAN) WHERE city LIKE '%West%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ city like '%West%' ] Output [ state , city , role_code , street ]",
        "cte": "WITH Scan_1 AS ( SELECT state, city, role_code, street FROM dog_kennels.Professionals WHERE city like '%West%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT role_code , street , city , state FROM dog_kennels.professionals  WHERE city LIKE '%West%'",
        "qd": "#1 = Scan the table Professionals and retrieve the state, city, role, and street of all professionals living in a city that contains the substring 'West'."
    },
    {
        "id": "dfeb5c39fcfaa04fbe29e401a052a5057e480adbb6384afdcf777c02c5a13a38",
        "question": "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.",
        "query": "SELECT first_name , last_name , email_address FROM dog_kennels.Owners WITH (FORCESCAN) WHERE state LIKE '%North%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state like '%North%' ] Output [ first_name , last_name , state , email_address ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, last_name, state, email_address FROM dog_kennels.Owners WHERE state like '%North%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT first_name , last_name , email_address FROM dog_kennels.Owners  WHERE state LIKE '%North%'",
        "qd": "#1 = Scan the table Owners and retrieve the first name, last name, state, and email of all owners whose state name contains the substring 'North'."
    },
    {
        "id": "02ee31443afa5b62019b5b08c0de715d262a4191a0e90dd4451a9d5d1a293efc",
        "question": "Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.",
        "query": "SELECT first_name , last_name , email_address FROM dog_kennels.Owners WITH (FORCESCAN) WHERE state LIKE '%North%' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state like '%North%' ] Output [ first_name , last_name , state , email_address ]",
        "cte": "WITH Scan_1 AS ( SELECT first_name, last_name, state, email_address FROM dog_kennels.Owners WHERE state like '%North%' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT first_name , last_name , email_address FROM dog_kennels.Owners  WHERE state LIKE '%North%'",
        "qd": "#1 = Scan the table Owners and retrieve the first name, last name, state, and email address of all owners whose state name contains the substring 'North'."
    },
    {
        "id": "5e6dcd4f1c2e3953b79fdcda1cbd89c2bb9db999951cce84429b3be188edd3ba",
        "question": "How many dogs have an age below the average?",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) ",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ] ; #3 = Scan Table [ Dogs ] Output [ age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.age < #2.Avg_age ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ), Scan_3 AS ( SELECT age FROM dog_kennels.Dogs ), Join_4 AS ( SELECT 1 AS One FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.age < Aggregate_2.Avg_age ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs  WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  )",
        "qd": "#1 = Scan the table Dogs and retrieve the age of all dogs ; #2 = Aggregate #1 and calculate the average age of all dogs ; #3 = Scan the table Dogs and retrieve the age of all dogs ; #4 = Join #2 and #3 to find the dogs with an age below the average age ; #5 = Aggregate #4 and count the number of dogs with an age below the average"
    },
    {
        "id": "d99c040d6524f2a05b4ba4f4ffe1aebca0489bba1ed41e3d2f14264a23dcaab2",
        "question": "Count the number of dogs of an age below the average.",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) ",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ] ; #3 = Scan Table [ Dogs ] Output [ age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.age < #2.Avg_age ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ), Scan_3 AS ( SELECT age FROM dog_kennels.Dogs ), Join_4 AS ( SELECT 1 AS One FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.age < Aggregate_2.Avg_age ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs  WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  )",
        "qd": "#1 = Scan the table Dogs and retrieve the age of all dogs ; #2 = Aggregate the average age from #1 ; #3 = Scan the table Dogs and retrieve the age of all dogs ; #4 = Join #2 and #3 based on the dogs' age being below the average age and count the number of occurrences ; #5 = Aggregate the count of occurrences from #4 to find the number of dogs with an age below the average age"
    },
    {
        "id": "433878795dbaeb06e20ccdf8f7b8f57b4490fc5649d2e72bce7e7585deacbf03",
        "question": "How much does the most recent treatment cost?",
        "query": "SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ORDER BY date_of_treatment DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ date_of_treatment , cost_of_treatment ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_of_treatment DESC ] Output [ date_of_treatment , cost_of_treatment ]",
        "cte": "WITH Scan_1 AS ( SELECT date_of_treatment, cost_of_treatment FROM dog_kennels.Treatments ), TopSort_2 AS ( SELECT TOP 1 date_of_treatment, cost_of_treatment FROM Scan_1 ORDER BY date_of_treatment DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments  ORDER BY date_of_treatment DESC",
        "qd": "#1 = Scan the table Treatments to find the dates and costs of all treatments ; #2 = Sort the records from #1 based on the date of treatment in descending order, select the first record, and identify the cost of the most recent treatment"
    },
    {
        "id": "261b8f31c3472cd304eb89de390eab8847db8e7264ae2f27808562dbb6c75d24",
        "question": "Show me the cost of the most recently performed treatment.",
        "query": "SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ORDER BY date_of_treatment DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatments ] Output [ date_of_treatment , cost_of_treatment ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_of_treatment DESC ] Output [ date_of_treatment , cost_of_treatment ]",
        "cte": "WITH Scan_1 AS ( SELECT date_of_treatment, cost_of_treatment FROM dog_kennels.Treatments ), TopSort_2 AS ( SELECT TOP 1 date_of_treatment, cost_of_treatment FROM Scan_1 ORDER BY date_of_treatment DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments  ORDER BY date_of_treatment DESC",
        "qd": "#1 = Scan the table Treatments and retrieve the date and cost of all treatments ; #2 = Sort the records from #1 based on the date of treatment in descending order, select the first record, and retrieve the date and cost of the most recently performed treatment"
    },
    {
        "id": "78dcba3c4a0a01a2b294e2d6c29257905932d8253d58e95ad5b2a863957910ae",
        "question": "How many dogs have not gone through any treatment?",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE dog_id NOT IN ( SELECT dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs  WHERE dog_id NOT IN ( SELECT dog_id FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Dogs and retrieve the dog IDs of all dogs. ; #2 = Scan the table Treatments and retrieve the dog IDs of all dogs who have gone through treatments. ; #3 = Return all the dog IDs from #1 that are not in #2 to find all the dogs who have not gone through any treatment. ; #4 = Aggregate the number of all dogs in #3 to find how many dogs have not gone through any treatment."
    },
    {
        "id": "2a8ea35ad7f723889d27b267bef72d3992a72b5dba5bd3d7c127682db1db41aa",
        "question": "Tell me the number of dogs that have not received any treatment .",
        "query": "select count ( * ) AS Count_Star FROM dog_kennels.dogs WITH (FORCESCAN) where dog_id not in ( select dog_id FROM dog_kennels.treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "select count ( * ) AS Count_Star FROM dog_kennels.dogs  where dog_id not in ( select dog_id FROM dog_kennels.treatments  )",
        "qd": "#1 = Scan the table Dogs and retrieve the dog IDs of all dogs ; #2 = Scan the table Treatments and retrieve the dog IDs of all dogs that have received treatments ; #3 = Return all the dog IDs from #1 that are not in #2 to find the dog IDs of dogs that have not received any treatment ; #4 = Aggregate the count of all dog IDs in #3 to find the number of dogs that have not received any treatment"
    },
    {
        "id": "c77304be5a473c9034ca40868437e0b9f90523b4106fb5e2fa4db8724e5109b5",
        "question": "How many owners temporarily do not have any dogs?",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners WITH (FORCESCAN) WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Output [ owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE owner_id NOT IN (SELECT owner_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners  WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs  )",
        "qd": "#1 = Scan the table Owners and retrieve all the owner IDs ; #2 = Scan the table Dogs and retrieve all the owner IDs ; #3 = Return all the owner IDs that are in #1 but not in #2 to find the owners who temporarily do not have any dogs ; #4 = Aggregate the count of records in #3 to find the number of owners who temporarily do not have any dogs"
    },
    {
        "id": "767f67bdff974cd007a4ef44b18713af81def3a6d3999f59653e9508ab25c234",
        "question": "Find the number of owners who do not own any dogs at this moment.",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners WITH (FORCESCAN) WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Owners ] Output [ owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE owner_id NOT IN (SELECT owner_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners  WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs  )",
        "qd": "#1 = Scan the table Owners and retrieve all the owner IDs ; #2 = Scan the table Dogs and retrieve all the owner IDs ; #3 = Return all the owner IDs from #1 that are not in #2 to find the owners who do not own any dogs at this moment ; #4 = Aggregate the number of all owners in #3"
    },
    {
        "id": "6606a29dd2b7f2d93ea8e171a867970cf5da5496ddb77658dc04d73678da4f44",
        "question": "How many professionals did not operate any treatment on dogs?",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ professional_id ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals  WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Professionals and retrieve the professional IDs of all professionals ; #2 = Scan the table Treatments and retrieve the professional IDs of all treatments ; #3 = Return all the professional IDs that are in #1 but not in #2 to find the professionals who did not operate any treatment on dogs ; #4 = Count the number of records in #3 to find the number of professionals who did not operate any treatment on dogs"
    },
    {
        "id": "ea3eaa087a14e4f6fc7c7c334cff9088ec99f3d6c4c5e9da66d1ce24146ede11",
        "question": "Find the number of professionals who have not treated any dogs.",
        "query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ professional_id ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals  WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments  )",
        "qd": "#1 = Scan the table Professionals and retrieve all the professional IDs ; #2 = Scan the table Treatments and retrieve all the professional IDs ; #3 = Return all the professional IDs that are not present in #2 to find the professionals who have not treated any dogs ; #4 = Count the number of records in #3 to find the number of professionals who have not treated any dogs"
    },
    {
        "id": "11757dbf072cf94f23cb22210fb8ca4455a8343fc40e151645d31758e9de045d",
        "question": "List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.",
        "query": "SELECT name , age , weight FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE abandoned_yn = 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Predicate [ abandoned_yn = 1 ] Output [ abandoned_yn , weight , age , name ]",
        "cte": "WITH Scan_1 AS ( SELECT abandoned_yn, weight, age, name FROM dog_kennels.Dogs WHERE abandoned_yn = 1 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , age , weight FROM dog_kennels.Dogs  WHERE abandoned_yn = 1",
        "qd": "#1 = Scan the table Dogs and retrieve the abandoned status, weight, age, and name of all dogs that have been abandoned."
    },
    {
        "id": "32ff77c2b84d8fdfca0153500392286944ab8a6286191e53738a1bbf35ae9632",
        "question": "What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.",
        "query": "SELECT name , age , weight FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE abandoned_yn = 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Predicate [ abandoned_yn = 1 ] Output [ abandoned_yn , weight , age , name ]",
        "cte": "WITH Scan_1 AS ( SELECT abandoned_yn, weight, age, name FROM dog_kennels.Dogs WHERE abandoned_yn = 1 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT name , age , weight FROM dog_kennels.Dogs  WHERE abandoned_yn = 1",
        "qd": "#1 = Scan the table Dogs and retrieve the names, ages, and weights of all the dogs that were abandoned"
    },
    {
        "id": "b5a4050650d175c17ca4a9ec4d0c3a55e0950b773d6cd0d07c3d7f1204ea44e5",
        "question": "What is the average age of all the dogs?",
        "query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ]",
        "cte": "WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the age of all the dogs. ; #2 = Calculate the average age of all the dogs from #1 and retrieve the average age as Avg_age."
    },
    {
        "id": "753b0e7cd97e2a2870fcc6afa6c4512421986fad6e8ffc72c01b48e16e203d9d",
        "question": "Compute the average age of all the dogs.",
        "query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ]",
        "cte": "WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the age of all dogs. ; #2 = Aggregate the average age of all dogs from #1 and compute the average age of all the dogs."
    },
    {
        "id": "508534bf0da2fdfac341224de99be1122d48ac8789e1c28ff1cb466571264236",
        "question": "What is the age of the oldest dog?",
        "query": "SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ MAX(age) AS Max_age ]",
        "cte": "WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT MAX(age) AS Max_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the ages of all dogs ; #2 = Find the maximum age from #1 to determine the age of the oldest dog"
    },
    {
        "id": "0fafa609fb687bd11e39aafb14e0ffb70a27929a9b591f3c196cc875ede3ebf9",
        "question": "Tell me the age of the oldest dog.",
        "query": "SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ MAX(age) AS Max_age ]",
        "cte": "WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT MAX(age) AS Max_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the age of all dogs. ; #2 = Aggregate the maximum value of age from #1 to find the age of the oldest dog."
    },
    {
        "id": "71de702627518d63a910bbd9bb7f366eddb8c5bd2464b78e4637839084874c71",
        "question": "How much does each charge type costs? List both charge type and amount.",
        "query": "SELECT charge_type , charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_amount , charge_type ]",
        "cte": "WITH Scan_1 AS ( SELECT charge_amount, charge_type FROM dog_kennels.Charges ) SELECT * FROM Scan_1",
        "clean_query": "SELECT charge_type , charge_amount FROM dog_kennels.Charges",
        "qd": "#1 = Scan the table charges and retrieve the charge amount and charge type for each charge type"
    },
    {
        "id": "5f2da74090ff46835a02f0b81d6fba00e4efcc8ddf7d14a503595b0354bdb3b6",
        "question": "List each charge type and its amount.",
        "query": "SELECT charge_type , charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_amount , charge_type ]",
        "cte": "WITH Scan_1 AS ( SELECT charge_amount, charge_type FROM dog_kennels.Charges ) SELECT * FROM Scan_1",
        "clean_query": "SELECT charge_type , charge_amount FROM dog_kennels.Charges",
        "qd": "#1 = Scan the table Charges and retrieve the charge amount and charge type for each charge type."
    },
    {
        "id": "0b041ebce208085bea5e35531b4a6cdbde7156f9c58a9b2bd26415a0ebd102b1",
        "question": "How much does the most expensive charge type costs?",
        "query": "SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_amount ] ; #2 = Aggregate [ #1 ] Output [ MAX(charge_amount) AS Max_charge_amount ]",
        "cte": "WITH Scan_1 AS ( SELECT charge_amount FROM dog_kennels.Charges ), Aggregate_2 AS ( SELECT MAX(charge_amount) AS Max_charge_amount FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges",
        "qd": "#1 = Scan the table Charges and retrieve the charge amount of all charge types ; #2 = Find the maximum charge amount from the records in #1 to identify the cost of the most expensive charge type"
    },
    {
        "id": "fc656750ad557e7b823554bc96113a1f7f9ecc12fbb70e851c875598e29ecd85",
        "question": "What is the charge amount of the most expensive charge type?",
        "query": "SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_amount ] ; #2 = Aggregate [ #1 ] Output [ MAX(charge_amount) AS Max_charge_amount ]",
        "cte": "WITH Scan_1 AS ( SELECT charge_amount FROM dog_kennels.Charges ), Aggregate_2 AS ( SELECT MAX(charge_amount) AS Max_charge_amount FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges",
        "qd": "#1 = Scan the table Charges and retrieve the charge amount of all charge types ; #2 = Aggregate #1 and find the maximum charge amount to identify the charge amount of the most expensive charge type."
    },
    {
        "id": "09c9bbb573dcab0c927cbe7d112f91c8834c15a2eb31f230e5f325df5793bdf6",
        "question": "List the email, cell phone and home phone of all the professionals.",
        "query": "SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ cell_number , home_phone , email_address ]",
        "cte": "WITH Scan_1 AS ( SELECT cell_number, home_phone, email_address FROM dog_kennels.Professionals ) SELECT * FROM Scan_1",
        "clean_query": "SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals",
        "qd": "#1 = Scan the table Professionals and retrieve the cell numbers, home phones, and email addresses of all the professionals."
    },
    {
        "id": "e2aacdecf6d3b52d1802827572ef278aa2c5f3d76b5c6d26fcae103c47a8f0f2",
        "question": "What are the email, cell phone and home phone of each professional?",
        "query": "SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Professionals ] Output [ cell_number , home_phone , email_address ]",
        "cte": "WITH Scan_1 AS ( SELECT cell_number, home_phone, email_address FROM dog_kennels.Professionals ) SELECT * FROM Scan_1",
        "clean_query": "SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals",
        "qd": "#1 = Scan the table Professionals and retrieve the email address, cell phone, and home phone of each professional."
    },
    {
        "id": "4b2ac205277d7c5884472a73b7c2e9091542447d1c927af072dc0edc0bac2b1e",
        "question": "What are all the possible breed type and size type combinations?",
        "query": "SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Distinct [ true ] Output [ breed_code , size_code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT breed_code, size_code FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs",
        "qd": "#1 = Scan the table Dogs and retrieve all the distinct breed codes and size codes to find all the possible breed type and size type combinations."
    },
    {
        "id": "4776864cae0889340c0a3b3d4cf577b53714a560aac3a5e0b584b2fad0fede8f",
        "question": "Find the distinct breed type and size type combinations for dogs.",
        "query": "SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Dogs ] Distinct [ true ] Output [ breed_code , size_code ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT breed_code, size_code FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
        "clean_query": "SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs",
        "qd": "#1 = Scan the table Dogs and retrieve the distinct combinations of breed code and size code."
    },
    {
        "id": "9468ef5d219c1fc8111244fca69f0d535063a6e7bc3bb6219ce500e89256e5d0",
        "question": "List the first name of all the professionals along with the description of the treatment they have done.",
        "query": "SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3 WITH (FORCESCAN) ON T2.treatment_type_code = T3.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ treatment_type_code , professional_id ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #2.treatment_type_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.treatment_type_code = #4.treatment_type_code ] Distinct [ true ] Output [ #1.treatment_type_description , #4.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT treatment_type_code, professional_id FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.first_name, Scan_2.treatment_type_code FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Join_5 AS ( SELECT DISTINCT Scan_1.treatment_type_description, Join_4.first_name FROM Scan_1 JOIN Join_4 ON Scan_1.treatment_type_code = Join_4.treatment_type_code ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3  ON T2.treatment_type_code = T3.treatment_type_code",
        "qd": "#1 = Scan the table Treatment_Types and retrieve the treatment type codes and descriptions of all treatments ; #2 = Scan the table Treatments and retrieve the treatment type codes and professional IDs of all treatments ; #3 = Scan the table Professionals and retrieve the first names and professional IDs of all professionals ; #4 = Join #2 and #3 based on the matching professional IDs and retrieve the first names ; #5 = Join #1 and #4 based on the matching treatment type codes and retrieve the treatment type descriptions and first names of professionals. Remove any duplicate records."
    },
    {
        "id": "af31c2dbac0d1ab65d2339c0d55235dc257c160e670af45309e001bba3098cdd",
        "question": "What are each professional's first name and description of the treatment they have performed?",
        "query": "SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3 WITH (FORCESCAN) ON T2.treatment_type_code = T3.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ treatment_type_code , professional_id ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #2.treatment_type_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.treatment_type_code = #4.treatment_type_code ] Distinct [ true ] Output [ #1.treatment_type_description , #4.first_name ]",
        "cte": "WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT treatment_type_code, professional_id FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.first_name, Scan_2.treatment_type_code FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Join_5 AS ( SELECT DISTINCT Scan_1.treatment_type_description, Join_4.first_name FROM Scan_1 JOIN Join_4 ON Scan_1.treatment_type_code = Join_4.treatment_type_code ) SELECT * FROM Join_5",
        "clean_query": "SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3  ON T2.treatment_type_code = T3.treatment_type_code",
        "qd": "#1 = Scan the table Treatment_Types and retrieve the treatment type codes and descriptions of all treatment types. ; #2 = Scan the table Treatments and retrieve the treatment type codes and professional IDs of all treatments performed. ; #3 = Scan the table Professionals and retrieve the first names and professional IDs of all professionals. ; #4 = Join #2 and #3 based on the matching professional IDs and retrieve the first names and treatment type codes. ; #5 = Join #1 and #4 based on the matching treatment type codes, remove duplicates and retrieve the treatment type descriptions and first names of each professional."
    },
    {
        "id": "8c12cf9b50cade1629258a9e8344630d0a188e5a5d2f19b038075767850b934f",
        "question": "How many singers are there?",
        "query": "SELECT count ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM singer.singer",
        "qd": "#1 = Scan the table singer and retrieve the records ; #2 = Aggregate the count of all records from #1 to find the total number of singers"
    },
    {
        "id": "804c8e18ba30e708d50724b2884ec025fcc5e03cf2f010b2e756c50555cf7bb3",
        "question": "What is the count of singers?",
        "query": "SELECT count ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM singer.singer",
        "qd": "#1 = Scan the table Singer and retrieve a constant value of 1 for each singer ; #2 = Aggregate the records from #1 to count the number of singers and retrieve the count."
    },
    {
        "id": "b9ea969d4c1a883ed38c19942e7eb9b608a8f06861c97fdde9839c049fa21c88",
        "question": "List the name of singers in ascending order of net worth.",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = Sort [ #1 ] OrderBy [ Net_Worth_Millions ASC ] Output [ Name , Net_Worth_Millions ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ) SELECT Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions ASC",
        "clean_query": "SELECT Name FROM singer.singer  ORDER BY Net_Worth_Millions ASC",
        "qd": "#1 = Scan the table singer and retrieve the names and net worth of all singers ; #2 = Sort the records from #1 based on the net worth in ascending order and retrieve the names"
    },
    {
        "id": "011a772567169c804c61ebdecf6dcc9f19f77788577f9b41c55d6f917bd638fc",
        "question": "What are the names of singers ordered by ascending net worth?",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions ASC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = Sort [ #1 ] OrderBy [ Net_Worth_Millions ASC ] Output [ Name , Net_Worth_Millions ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ) SELECT Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions ASC",
        "clean_query": "SELECT Name FROM singer.singer  ORDER BY Net_Worth_Millions ASC",
        "qd": "#1 = Scan the table singer and retrieve the names and net worth of all singers ; #2 = Sort the records from #1 based on the net worth in ascending order and retrieve the names of the singers"
    },
    {
        "id": "c9a7efa3930c9f7e3a10444caceb7e50835b86408bdd65b9a89aebbd3db71302",
        "question": "What are the birth year and citizenship of singers?",
        "query": "SELECT Birth_Year , Citizenship FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Birth_Year , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Birth_Year, Citizenship FROM singer.singer ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Birth_Year , Citizenship FROM singer.singer",
        "qd": "#1 = Scan the table singer and retrieve the birth year and citizenship of all singers."
    },
    {
        "id": "b949490e009a7f50dfe5876c63c8f31a252c1e327bee7cf800057e949a391ee3",
        "question": "What are the birth years and citizenships of the singers?",
        "query": "SELECT Birth_Year , Citizenship FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Birth_Year , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Birth_Year, Citizenship FROM singer.singer ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Birth_Year , Citizenship FROM singer.singer",
        "qd": "#1 = Scan the table singer and retrieve the birth years and citizenships of all singers."
    },
    {
        "id": "8c8870ec05f32246c5b7955c28f5c81d57e9115f47091d631a393c7bd79a4581",
        "question": "List the name of singers whose citizenship is not \"France\".",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Citizenship ! = 'France' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Predicate [ Citizenship <> 'France' ] Output [ Name , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Citizenship FROM singer.singer WHERE Citizenship <> 'France' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM singer.singer  WHERE Citizenship ! = 'France'",
        "qd": "#1 = Scan the table singer and retrieve the names of all singers whose citizenship is not \"France\"."
    },
    {
        "id": "550e5e82df704280579aec36cce4557a6a0a38b91cf057b63a589c368210022a",
        "question": "What are the names of the singers who are not French citizens?",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Citizenship ! = 'France' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Predicate [ Citizenship <> 'France' ] Output [ Name , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Citizenship FROM singer.singer WHERE Citizenship <> 'France' ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM singer.singer  WHERE Citizenship ! = 'France'",
        "qd": "#1 = Scan the table Singer and retrieve the names and citizenships of all singers who are not French citizens."
    },
    {
        "id": "d98f8fe8157483e3c7d8cfc11da276a7efd8100150eb4e6e7170ed40aa5b1e4f",
        "question": "Show the name of singers whose birth year is either 1948 or 1949?",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year = 1948 OR Birth_Year = 1949 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year = 1948.0 OR Birth_Year = 1949.0 ] Output [ Name , Birth_Year ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Birth_Year FROM singer.singer WHERE Birth_Year = 1948.0 OR Birth_Year = 1949.0 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM singer.singer  WHERE Birth_Year = 1948 OR Birth_Year = 1949",
        "qd": "#1 = Scan the table singer and retrieve the names of singers whose birth year is either 1948 or 1949."
    },
    {
        "id": "5b29113c5ab990f62b686fbdc871914d99e8e268ea27a89a31141d06be57b7a9",
        "question": "What are the names of the singers whose birth years are either 1948 or 1949?",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year = 1948 OR Birth_Year = 1949 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year = 1948.0 OR Birth_Year = 1949.0 ] Output [ Name , Birth_Year ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Birth_Year FROM singer.singer WHERE Birth_Year = 1948.0 OR Birth_Year = 1949.0 ) SELECT * FROM Scan_1",
        "clean_query": "SELECT Name FROM singer.singer  WHERE Birth_Year = 1948 OR Birth_Year = 1949",
        "qd": "#1 = Scan the table singer and retrieve the names of the singers whose birth years are either 1948 or 1949"
    },
    {
        "id": "58c46fcc34a7383d2e710c843d03f5bf99d9592aa7e497a33a507a2e6058fe5f",
        "question": "What is the name of the singer with the largest net worth?",
        "query": "SELECT TOP 1 Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Net_Worth_Millions DESC ] Output [ Name , Net_Worth_Millions ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ), TopSort_2 AS ( SELECT TOP 1 Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name FROM singer.singer  ORDER BY Net_Worth_Millions DESC",
        "qd": "#1 = Scan the table singer and retrieve the names and net worth of all singers ; #2 = Sort the records from #1 based on the net worth in descending order, select the first record, and identify the name of the singer with the largest net worth."
    },
    {
        "id": "73af14f9e8271c97b343c331de6a984ba197bd3ba69a66b4418187b22f316392",
        "question": "What is the name of the singer who is worth the most?",
        "query": "SELECT TOP 1 Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Net_Worth_Millions DESC ] Output [ Name , Net_Worth_Millions ]",
        "cte": "WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ), TopSort_2 AS ( SELECT TOP 1 Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions DESC ) SELECT * FROM TopSort_2",
        "clean_query": "SELECT TOP 1 Name FROM singer.singer  ORDER BY Net_Worth_Millions DESC",
        "qd": "#1 = Scan the table singer and retrieve the names and net worth of all singers ; #2 = Sort the records from #1 based on the net worth in descending order, select the first record, and identify the name of the singer who is worth the most"
    },
    {
        "id": "4f42fde37cbd059904929409566173c2576d719495a3d5923a4e396355823e91",
        "question": "Show different citizenship of singers and the number of singers of each citizenship.",
        "query": "SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ countstar AS Count_Star , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Citizenship FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer  GROUP BY Citizenship",
        "qd": "#1 = Scan the table singer and retrieve the citizenship of all singers ; #2 = Group #1 by citizenship and aggregate the count of records per citizenship to find the number of singers of each citizenship"
    },
    {
        "id": "99d01cadde9a3a585cfb95149c86e586e956c4807f67adea88f25cac11d941cf",
        "question": "For each citizenship, how many singers are from that country?",
        "query": "SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ countstar AS Count_Star , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Citizenship FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer  GROUP BY Citizenship",
        "qd": "#1 = Scan the table singer and retrieve the citizenship of all singers ; #2 = Group #1 by citizenship and aggregate the count of singers per citizenship to find how many singers are from each country."
    },
    {
        "id": "87a3b0989ee1dc1513ab72ca2965ce5304ba36e5ef0d89b458a1814f7fbcdb6c",
        "question": "Please show the most common citizenship of singers.",
        "query": "SELECT TOP 1 Citizenship FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ countstar AS Count_Star , Citizenship ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Citizenship FROM Scan_1 GROUP BY Citizenship ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Citizenship FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "SELECT TOP 1 Citizenship FROM singer.singer  GROUP BY Citizenship ORDER BY COUNT ( * ) DESC",
        "qd": "#1 = Scan the table Singer and retrieve the citizenship of all singers ; #2 = Group the records from #1 by citizenship and aggregate the count per citizenship to find the most common citizenship of singers ; #3 = Sort the records from #2 based on the count of singers in descending order, select the first record, and identify the most common citizenship of singers and its count."
    },
    {
        "id": "7c9e7a7be63f400ff33df576791e0fd53332a3d954a89aa0cb953b4eb70b1682",
        "question": "What is the most common singer citizenship ?",
        "query": "select TOP 1 citizenship FROM singer.singer WITH (FORCESCAN) group by citizenship order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ countstar AS Count_Star , Citizenship ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Citizenship FROM Scan_1 GROUP BY Citizenship ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Citizenship FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
        "clean_query": "select TOP 1 citizenship FROM singer.singer  group by citizenship order by count ( * ) desc",
        "qd": "#1 = Scan the table singer and retrieve the citizenship of all the singers ; #2 = Group #1 by citizenship and aggregate the count per citizenship to find the number of singers with each citizenship ; #3 = Sort the records from #2 based on the count of singers in descending order, select the first record, and identify the most common singer citizenship and its count."
    },
    {
        "id": "9561b97b13a187930d20fc2c295e7c02162337366bbcd10dbbf6095d1bfd95ce",
        "question": "Show different citizenships and the maximum net worth of singers of each citizenship.",
        "query": "SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Net_Worth_Millions , Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Net_Worth_Millions, Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions, Citizenship FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer  GROUP BY Citizenship",
        "qd": "#1 = Scan the table singer and retrieve the net worth and citizenship of all singers ; #2 = Group #1 by citizenship and aggregate the maximum net worth of singers for each citizenship, and retrieve the maximum net worth and citizenship"
    },
    {
        "id": "697dfd5ef5b2393132d9a7c62561764004455e1c985cc95ce70a0ccc10fa9cd6",
        "question": "For each citizenship, what is the maximum net worth?",
        "query": "SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Net_Worth_Millions , Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions , Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT Net_Worth_Millions, Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions, Citizenship FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer  GROUP BY Citizenship",
        "qd": "#1 = Scan the table singer and retrieve the net worth and citizenship of all singers ; #2 = Group #1 by citizenship and find the maximum net worth for each citizenship and retrieve the maximum net worth and citizenship"
    },
    {
        "id": "e75d3a7f87b0a33d06fce6ca17196f4c588fc1be645276004b8fc026e5de12d8",
        "question": "Show titles of songs and names of singers.",
        "query": "SELECT T2.Title , T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #2 = Scan Table [ song ] Output [ Singer_ID , Title ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name , #2.Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Name FROM singer.singer ), Scan_2 AS ( SELECT Singer_ID, Title FROM singer.song ), Join_3 AS ( SELECT Scan_1.Name, Scan_2.Title FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.Title , T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID",
        "qd": "#1 = Scan the table singer and retrieve the singer IDs and names of all singers ; #2 = Scan the table song and retrieve the singer IDs and titles of all songs ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the names of singers and titles of songs"
    },
    {
        "id": "95b11b7b6da3a1a61a86398786d17ce1182a1250691e9475819940d233798069",
        "question": "What are the song titles and singer names?",
        "query": "SELECT T2.Title , T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #2 = Scan Table [ song ] Output [ Singer_ID , Title ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name , #2.Title ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Name FROM singer.singer ), Scan_2 AS ( SELECT Singer_ID, Title FROM singer.song ), Join_3 AS ( SELECT Scan_1.Name, Scan_2.Title FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.Title , T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID",
        "qd": "#1 = Scan the table singer and retrieve the singer IDs and names of all singers ; #2 = Scan the table song and retrieve the singer IDs and titles of all songs ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the names of the singers and titles of the songs"
    },
    {
        "id": "6526137048ae8dec7f67b1d156501fe03e65412e05ce2362239d91b62eb64ae3",
        "question": "Show distinct names of singers that have songs with sales more than 300000.",
        "query": "SELECT DISTINCT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ song ] Predicate [ Sales > 300000.0 ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Distinct [ true ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song WHERE Sales > 300000.0 ), Scan_2 AS ( SELECT Singer_ID, Name FROM singer.singer ), Join_3 AS ( SELECT DISTINCT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000",
        "qd": "#1 = Scan the table song and retrieve the singer IDs and sales of all songs with sales more than 300000 ; #2 = Scan the table singer and retrieve the singer IDs and names of all singers ; #3 = Join #1 and #2 based on the matching singer IDs, remove duplicates and retrieve distinct names of singers"
    },
    {
        "id": "993f7da6bf9f3c08f1e566829f9baa9a8e5d5f1ec7f62cd1cc76d32e74fc924a",
        "question": "what are the different names of the singers that have sales more than 300000?",
        "query": "SELECT DISTINCT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ song ] Predicate [ Sales > 300000.0 ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Distinct [ true ] Output [ #2.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song WHERE Sales > 300000.0 ), Scan_2 AS ( SELECT Singer_ID, Name FROM singer.singer ), Join_3 AS ( SELECT DISTINCT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
        "clean_query": "SELECT DISTINCT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000",
        "qd": "#1 = Scan the table song to find all the singer IDs and sales amounts of songs with sales more than 300000 ; #2 = Scan the table singer to retrieve the singer IDs and names of all singers ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the names of the singers without duplicates"
    },
    {
        "id": "0185d5551797ce6214ec07f1a2a8d2791d103019f6b83bb6fe52fc6322a0807b",
        "question": "Show the names of singers that have more than one song.",
        "query": "SELECT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ song ] Output [ Singer_ID ] ; #2 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID FROM singer.song ), Scan_2 AS ( SELECT Singer_ID, Name FROM singer.singer ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1",
        "qd": "#1 = Scan the table song and retrieve the singer IDs of all songs ; #2 = Scan the table singer and retrieve the singer IDs and names of all singers ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the names ; #4 = Group #3 by name and aggregate the count of songs per singer ; #5 = Filter from #4 all the singers with a count of songs greater than 1 and retrieve their names"
    },
    {
        "id": "3b3211d0463e7b65bdc40f6c3989d1bfeb949e049510419df985111529653097",
        "question": "What are the names of the singers that have more than one songs?",
        "query": "SELECT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ song ] Output [ Singer_ID ] ; #2 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID FROM singer.song ), Scan_2 AS ( SELECT Singer_ID, Name FROM singer.singer ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
        "clean_query": "SELECT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1",
        "qd": "#1 = Scan the table song and retrieve the singer IDs of all songs ; #2 = Scan the table singer and retrieve the singer IDs and names of all singers ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the names ; #4 = Group #3 by name and aggregate the count of songs per singer to find the number of songs for each singer ; #5 = Filter from #4 all the singers with more than one song and retrieve their names"
    },
    {
        "id": "979d85d193f3882cf9f01bfff9c1151c9ab871fd99ba917b143d4970cf33cc05",
        "question": "Show the names of singers and the total sales of their songs.",
        "query": "SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ song ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Sales , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , SUM(Sales) AS Sum_Sales ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song ), Scan_2 AS ( SELECT Singer_ID, Name FROM singer.singer ), Join_3 AS ( SELECT Scan_1.Sales, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, SUM(Sales) AS Sum_Sales FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name",
        "qd": "#1 = Scan the table song and retrieve the singer IDs and sales of all songs ; #2 = Scan the table singer and retrieve the singer IDs and names of all singers ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the sales and names ; #4 = Group #3 by name and aggregate the sum of sales to find the total sales of each singer's songs, and retrieve the names of singers and their total sales"
    },
    {
        "id": "8ddb7c07d3458e79a1b0ab40bec542aa9573847464da7037e2e78d99b362b74d",
        "question": "For each singer name, what is the total sales for their songs?",
        "query": "SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ song ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Sales , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , SUM(Sales) AS Sum_Sales ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song ), Scan_2 AS ( SELECT Singer_ID, Name FROM singer.singer ), Join_3 AS ( SELECT Scan_1.Sales, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, SUM(Sales) AS Sum_Sales FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
        "clean_query": "SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name",
        "qd": "#1 = Scan the table song to retrieve the singer IDs and sales of all songs ; #2 = Scan the table singer to retrieve the singer IDs and names of all singers ; #3 = Join #1 and #2 based on the matching singer IDs and retrieve the sales and names ; #4 = Group #3 by name and aggregate the sum of sales for each singer to find the total sales for their songs"
    },
    {
        "id": "1285a88105c026db53a8c6bc8a43ea895a25c3eef88da5796b307750abd1692f",
        "question": "List the name of singers that do not have any song.",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song WITH (FORCESCAN) ) ",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #2 = Scan Table [ song ] Output [ Singer_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Singer_ID IS NULL OR #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Name FROM singer.singer ), Scan_2 AS ( SELECT Singer_ID FROM singer.song ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Singer_ID NOT IN (SELECT Singer_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Name FROM singer.singer  WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song  )",
        "qd": "#1 = Scan the table singer and retrieve the singer IDs and names of all singers ; #2 = Scan the table song and retrieve the singer IDs of all songs ; #3 = Find the singers from #1 who do not have any songs by excluding the ones with singer ID matching in #2, and retrieve their names"
    },
    {
        "id": "32e1d3180f2d4a1423db0aafca0f239d324b1efe137c80c4c83049c8a3525e55",
        "question": "What is the sname of every sing that does not have any song?",
        "query": "SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song WITH (FORCESCAN) ) ",
        "qpl": "singer | #1 = Scan Table [ singer ] Output [ Singer_ID , Name ] ; #2 = Scan Table [ song ] Output [ Singer_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Singer_ID IS NULL OR #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name ]",
        "cte": "WITH Scan_1 AS ( SELECT Singer_ID, Name FROM singer.singer ), Scan_2 AS ( SELECT Singer_ID FROM singer.song ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Singer_ID NOT IN (SELECT Singer_ID FROM Scan_2) ) SELECT * FROM Except_3",
        "clean_query": "SELECT Name FROM singer.singer  WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song  )",
        "qd": "#1 = Scan the table singer and retrieve the singer IDs and names of all singers ; #2 = Scan the table song and retrieve the singer IDs of all songs ; #3 = Return all the names from #1 that are not in #2 or have a null singer ID to find the names of singers who do not have any songs."
    },
    {
        "id": "28a57a5b75f7a8f40eec87da513ebdcad210610f006d483f39f4de5e4d14f7a7",
        "question": "Show the citizenship shared by singers with birth year before 1945 and after 1955.",
        "query": "SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year > 1955 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year < 1945.0 ] Distinct [ true ] Output [ Birth_Year , Citizenship ] ; #2 = Scan Table [ singer ] Predicate [ Birth_Year > 1955.0 ] Output [ Birth_Year , Citizenship ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Citizenship = #2.Citizenship ] Output [ #1.Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Birth_Year, Citizenship FROM singer.singer WHERE Birth_Year < 1945.0 ), Scan_2 AS ( SELECT Birth_Year, Citizenship FROM singer.singer WHERE Birth_Year > 1955.0 ), Intersect_3 AS ( SELECT Scan_1.Citizenship FROM Scan_1 WHERE Citizenship IN (SELECT Citizenship FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT Citizenship FROM singer.singer  WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer  WHERE Birth_Year > 1955",
        "qd": "#1 = Scan the table singer and retrieve distinct birth years and citizenship of singers with birth year before 1945 ; #2 = Scan the table singer and retrieve birth years and citizenship of singers with birth year after 1955 ; #3 = Find the intersection of the citizenship of singers from #1 and #2 to find the citizenship shared by singers with birth year before 1945 and after 1955."
    },
    {
        "id": "341f8b90b4223634d3f86dfbdbdb6e798b7ae3bffe8641e55dafa4f3b7536d88",
        "question": "What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
        "query": "SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year > 1955 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year < 1945.0 ] Distinct [ true ] Output [ Birth_Year , Citizenship ] ; #2 = Scan Table [ singer ] Predicate [ Birth_Year > 1955.0 ] Output [ Birth_Year , Citizenship ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Citizenship = #2.Citizenship ] Output [ #1.Citizenship ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT Birth_Year, Citizenship FROM singer.singer WHERE Birth_Year < 1945.0 ), Scan_2 AS ( SELECT Birth_Year, Citizenship FROM singer.singer WHERE Birth_Year > 1955.0 ), Intersect_3 AS ( SELECT Scan_1.Citizenship FROM Scan_1 WHERE Citizenship IN (SELECT Citizenship FROM Scan_2) ) SELECT * FROM Intersect_3",
        "clean_query": "SELECT Citizenship FROM singer.singer  WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer  WHERE Birth_Year > 1955",
        "qd": "#1 = Scan the table singer and retrieve the distinct birth years and citizenships of singers with a birth year before 1945 ; #2 = Scan the table singer and retrieve the birth years and citizenships of singers with a birth year after 1955 ; #3 = Intersect #1 and #2 based on the matching citizenships and retrieve the citizenships"
    },
    {
        "id": "b3221e9c112854ef99fba5d334b12427914fef6cde224429b25a501e64e6c4ae",
        "question": "How many available features are there in total?",
        "query": "SELECT count ( * ) AS Count_Star FROM real_estate_properties.Other_Available_Features WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "real_estate_properties | #1 = Scan Table [ Other_Available_Features ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
        "cte": "WITH Scan_1 AS ( SELECT 1 AS One FROM real_estate_properties.Other_Available_Features ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
        "clean_query": "SELECT count ( * ) AS Count_Star FROM real_estate_properties.Other_Available_Features",
        "qd": "#1 = Scan the table Other_Available_Features and retrieve a constant value of 1 for each record ; #2 = Aggregate the number of records from #1 to find the total count of available features"
    },
    {
        "id": "2eae79665e670663f892b02b5ab203781851af06ec08b956ad48104a9ff70be6",
        "question": "What is the feature type name of feature AirCon?",
        "query": "SELECT T2.feature_type_name FROM real_estate_properties.Other_Available_Features AS T1 WITH (FORCESCAN) JOIN real_estate_properties.Ref_Feature_Types AS T2 WITH (FORCESCAN) ON T1.feature_type_code = T2.feature_type_code WHERE T1.feature_name = 'AirCon' OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "real_estate_properties | #1 = Scan Table [ Other_Available_Features ] Predicate [ feature_name = 'AirCon' ] Output [ feature_type_code , feature_name ] ; #2 = Scan Table [ Ref_Feature_Types ] Output [ feature_type_code , feature_type_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.feature_type_code = #2.feature_type_code ] Output [ #2.feature_type_name ]",
        "cte": "WITH Scan_1 AS ( SELECT feature_type_code, feature_name FROM real_estate_properties.Other_Available_Features WHERE feature_name = 'AirCon' ), Scan_2 AS ( SELECT feature_type_code, feature_type_name FROM real_estate_properties.Ref_Feature_Types ), Join_3 AS ( SELECT Scan_2.feature_type_name FROM Scan_1 JOIN Scan_2 ON Scan_1.feature_type_code = Scan_2.feature_type_code ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.feature_type_name FROM real_estate_properties.Other_Available_Features AS T1  JOIN real_estate_properties.Ref_Feature_Types AS T2  ON T1.feature_type_code = T2.feature_type_code WHERE T1.feature_name = 'AirCon'",
        "qd": "#1 = Scan the table Other_Available_Features and retrieve the feature type code and name of all features with the name 'AirCon' ; #2 = Scan the table Ref_Feature_Types and retrieve the feature type code and name of all feature types ; #3 = Join #1 and #2 based on the matching feature type code and retrieve the feature type name for the feature 'AirCon'"
    },
    {
        "id": "767d8f34f1b268c7832d789fbb1f662604e9db7d49975fb7b642cb8ca235ce34",
        "question": "Show the property type descriptions of properties belonging to that code.",
        "query": "SELECT T2.property_type_description FROM real_estate_properties.Properties AS T1 WITH (FORCESCAN) JOIN real_estate_properties.Ref_Property_Types AS T2 WITH (FORCESCAN) ON T1.property_type_code = T2.property_type_code GROUP BY T2.property_type_description , T1.property_type_code OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "real_estate_properties | #1 = Scan Table [ Properties ] Distinct [ true ] Output [ property_type_code ] ; #2 = Scan Table [ Ref_Property_Types ] Output [ property_type_code , property_type_description ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.property_type_code = #2.property_type_code ] Output [ #2.property_type_description ]",
        "cte": "WITH Scan_1 AS ( SELECT DISTINCT property_type_code FROM real_estate_properties.Properties ), Scan_2 AS ( SELECT property_type_code, property_type_description FROM real_estate_properties.Ref_Property_Types ), Join_3 AS ( SELECT Scan_2.property_type_description FROM Scan_1 JOIN Scan_2 ON Scan_1.property_type_code = Scan_2.property_type_code ) SELECT * FROM Join_3",
        "clean_query": "SELECT T2.property_type_description FROM real_estate_properties.Properties AS T1  JOIN real_estate_properties.Ref_Property_Types AS T2  ON T1.property_type_code = T2.property_type_code GROUP BY T2.property_type_description , T1.property_type_code",
        "qd": "#1 = Scan the table Properties and retrieve the unique property type codes of all properties ; #2 = Scan the table Ref_Property_Types and retrieve the property type codes and descriptions ; #3 = Join #1 and #2 based on the matching property type codes and retrieve the property type descriptions of properties belonging to that code"
    },
    {
        "id": "226cd9a74a1b2e51610774012d114c254e10c37065ac9d0b0e0f451343dcc72e",
        "question": "What are the names of properties that are either houses or apartments with more than 1 room?",
        "query": "SELECT property_name FROM real_estate_properties.Properties WITH (FORCESCAN) WHERE property_type_code = 'House' UNION SELECT property_name FROM real_estate_properties.Properties WITH (FORCESCAN) WHERE property_type_code = 'Apartment' AND room_count > 1 OPTION (HASH JOIN, ORDER GROUP)",
        "qpl": "real_estate_properties | #1 = Scan Table [ Properties ] Predicate [ property_type_code = 'House' ] Output [ property_type_code , property_name ] ; #2 = Scan Table [ Properties ] Predicate [ room_count > 1 AND property_type_code = 'Apartment' ] Output [ property_type_code , property_name , room_count ] ; #3 = Union [ #1 , #2 ] Output [ #1.property_name ]",
        "cte": "WITH Scan_1 AS ( SELECT property_type_code, property_name FROM real_estate_properties.Properties WHERE property_type_code = 'House' ), Scan_2 AS ( SELECT property_type_code, property_name, room_count FROM real_estate_properties.Properties WHERE room_count > 1 AND property_type_code = 'Apartment' ), Union_3 AS ( SELECT property_name FROM Scan_1 UNION SELECT property_name FROM Scan_2 ) SELECT * FROM Union_3",
        "clean_query": "SELECT property_name FROM real_estate_properties.Properties  WHERE property_type_code = 'House' UNION SELECT property_name FROM real_estate_properties.Properties  WHERE property_type_code = 'Apartment' AND room_count > 1",
        "qd": "#1 = Scan the table Properties and retrieve the property type code and names of all the properties with house type ; #2 = Scan the table Properties and retrieve the property type code, names, and room count of all the properties with more than 1 room and apartment type ; #3 = Union #1 and #2 and retrieve the property names"
    }
]