[
  {
    "id":"e968c73bf4c0d4b6fa12af529a4c949f561b0a51ef8510f0029c9dee84948ba4",
    "db_id":"concert_singer",
    "question":"How many singers do we have?",
    "query":"SELECT count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM concert_singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM concert_singer.singer"
  },
  {
    "id":"de71b4f79c1ad3c71f523f6436acef9f69f5ca098b441f5055416ac23bf9bb75",
    "db_id":"concert_singer",
    "question":"What is the total number of singers?",
    "query":"SELECT count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM concert_singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM concert_singer.singer"
  },
  {
    "id":"e394ac9df4f6eff3fff54c2cd85d37190b1ae1f4e30dd63e1577150115b277d3",
    "db_id":"concert_singer",
    "question":"Show name, country, age for all singers ordered by age from the oldest to the youngest.",
    "query":"SELECT name , country , age FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Country , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Country , Age ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Name , Country , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Country , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Country, Age FROM concert_singer.singer ) SELECT Name, Country, Age FROM Scan_1 ORDER BY Age DESC",
    "clean_query":"SELECT name , country , age FROM concert_singer.singer  ORDER BY age DESC"
  },
  {
    "id":"b67ff822c24588338ffb03a8d5dfa10d171e0b5e7187fc901ceb178b9e60260e",
    "db_id":"concert_singer",
    "question":"What are the names, countries, and ages for every singer in descending order of age?",
    "query":"SELECT name , country , age FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Country , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Country , Age ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Name , Country , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Country , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Country, Age FROM concert_singer.singer ) SELECT Name, Country, Age FROM Scan_1 ORDER BY Age DESC",
    "clean_query":"SELECT name , country , age FROM concert_singer.singer  ORDER BY age DESC"
  },
  {
    "id":"53334ecd19e94f941108a87084020b87e9f5c41dc547b09d9aae53339cc69b0d",
    "db_id":"concert_singer",
    "question":"What is the average, minimum, and maximum age of all singers from France?",
    "query":"SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer WITH (FORCESCAN) WHERE country = 'France' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Country = 'France' ] Output [ Country , Age ] ; #2 = Aggregate [ #1 ] Output [ MAX(Age) AS Max_Age , MIN(Age) AS Min_Age , AVG(Age) AS Avg_Age ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Country = 'France' ] Output [ Country , Age ] ; #2 = Aggregate [ #1 ] Output [ MAX(Age) AS Max_Age , MIN(Age) AS Min_Age , AVG(Age) AS Avg_Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Country, Age FROM concert_singer.singer WHERE Country = 'France' ), Aggregate_2 AS ( SELECT MAX(Age) AS Max_Age, MIN(Age) AS Min_Age, AVG(Age) AS Avg_Age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer  WHERE country = 'France'"
  },
  {
    "id":"2c9124545e4b80beca6be6f312295f8cefc9dacdef86c65bcb177ccb138f723b",
    "db_id":"concert_singer",
    "question":"What is the average, minimum, and maximum age for all French singers?",
    "query":"SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer WITH (FORCESCAN) WHERE country = 'France' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Country = 'France' ] Output [ Country , Age ] ; #2 = Aggregate [ #1 ] Output [ MAX(Age) AS Max_Age , MIN(Age) AS Min_Age , AVG(Age) AS Avg_Age ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Country = 'France' ] Output [ Country , Age ] ; #2 = Aggregate [ #1 ] Output [ MAX(Age) AS Max_Age , MIN(Age) AS Min_Age , AVG(Age) AS Avg_Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Country, Age FROM concert_singer.singer WHERE Country = 'France' ), Aggregate_2 AS ( SELECT MAX(Age) AS Max_Age, MIN(Age) AS Min_Age, AVG(Age) AS Avg_Age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( age ) AS Avg_age , min ( age ) AS Min_age , max ( age ) AS Max_age FROM concert_singer.singer  WHERE country = 'France'"
  },
  {
    "id":"950b12210f92f7fe8accf0f9ee01cdde5d5eddbb4ee55d11c62f35fcbd04a945",
    "db_id":"concert_singer",
    "question":"Show the name and the release year of the song by the youngest singer.",
    "query":"SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Song_Name , Age , Song_release_year ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Song_Name , Age , Song_release_year ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Song_Name , Age , Song_release_year ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Song_Name , Age , Song_release_year ]",
    "cte":"WITH Scan_1 AS ( SELECT Song_Name, Age, Song_release_year FROM concert_singer.singer ), TopSort_2 AS ( SELECT TOP 1 Song_Name, Age, Song_release_year FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer  ORDER BY age"
  },
  {
    "id":"4f7180a6789311e9ad1d037c95fcb731331d0639d72e703d6dd5e1c58b5c24d8",
    "db_id":"concert_singer",
    "question":"What are the names and release years for all the songs of the youngest singer?",
    "query":"SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Song_Name , Age , Song_release_year ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Song_Name , Age , Song_release_year ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Song_Name , Age , Song_release_year ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Song_Name , Age , Song_release_year ]",
    "cte":"WITH Scan_1 AS ( SELECT Song_Name, Age, Song_release_year FROM concert_singer.singer ), TopSort_2 AS ( SELECT TOP 1 Song_Name, Age, Song_release_year FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 song_name , song_release_year FROM concert_singer.singer  ORDER BY age"
  },
  {
    "id":"510cd2705d653711d8a98af4c2f583205aad0b5adf2325464970f860083224cd",
    "db_id":"concert_singer",
    "question":"What are all distinct countries where singers above age 20 are from?",
    "query":"SELECT DISTINCT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age > 20 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Age > 20 ] Distinct [ true ] Output [ Country ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Age > 20 ] Distinct [ true ] Output [ Country ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Country FROM concert_singer.singer WHERE Age > 20 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT country FROM concert_singer.singer  WHERE age > 20"
  },
  {
    "id":"caaf4a80c883edab18f4e7e85da3f3348e643534f21bcb95b97ba3db14647a8d",
    "db_id":"concert_singer",
    "question":"What are  the different countries with singers above age 20?",
    "query":"SELECT DISTINCT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age > 20 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Age > 20 ] Distinct [ true ] Output [ Country ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Age > 20 ] Distinct [ true ] Output [ Country ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Country FROM concert_singer.singer WHERE Age > 20 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT country FROM concert_singer.singer  WHERE age > 20"
  },
  {
    "id":"eafbe8022e6e84b49effffba29e56d289b5d1e4c269a3c3933fb377ba09b6cb9",
    "db_id":"concert_singer",
    "question":"Show all countries and the number of singers in each country.",
    "query":"SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) GROUP BY country OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM concert_singer.singer ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer  GROUP BY country"
  },
  {
    "id":"e8e546b0d9e9fefa4c5f113010413fe3e77ee7f4f56456dc19a3d3ddb8314793",
    "db_id":"concert_singer",
    "question":"How many singers are from each country?",
    "query":"SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer WITH (FORCESCAN) GROUP BY country OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM concert_singer.singer ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT country , count ( * ) AS Count_Star FROM concert_singer.singer  GROUP BY country"
  },
  {
    "id":"b622b7727c2f59b8d9162a06af9d125c7b91f2b7cad4d9ba976a52a14dcbd86b",
    "db_id":"concert_singer",
    "question":"List all song names by singers above the average age.",
    "query":"SELECT song_name FROM concert_singer.singer WITH (FORCESCAN) WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ] ; #3 = Scan Table [ singer ] Output [ Song_Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Age > #2.Avg_Age ] Output [ #3.Song_Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ] ; #3 = Scan Table [ singer ] Output [ Song_Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Age > #2.Avg_Age ] Output [ #3.Song_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Age FROM concert_singer.singer ), Aggregate_2 AS ( SELECT AVG(Age) AS Avg_Age FROM Scan_1 ), Scan_3 AS ( SELECT Song_Name, Age FROM concert_singer.singer ), Join_4 AS ( SELECT Song_Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Age > Aggregate_2.Avg_Age ) SELECT * FROM Join_4",
    "clean_query":"SELECT song_name FROM concert_singer.singer  WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer  )"
  },
  {
    "id":"bc82973d8a4f671f6ef6a3b4e3a994c811d7f72d0410a6437d4195f8c5b8a0ce",
    "db_id":"concert_singer",
    "question":"What are all the song names by singers who are older than average?",
    "query":"SELECT song_name FROM concert_singer.singer WITH (FORCESCAN) WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ] ; #3 = Scan Table [ singer ] Output [ Song_Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Age > #2.Avg_Age ] Output [ #3.Song_Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ] ; #3 = Scan Table [ singer ] Output [ Song_Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Age > #2.Avg_Age ] Output [ #3.Song_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Age FROM concert_singer.singer ), Aggregate_2 AS ( SELECT AVG(Age) AS Avg_Age FROM Scan_1 ), Scan_3 AS ( SELECT Song_Name, Age FROM concert_singer.singer ), Join_4 AS ( SELECT Song_Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Age > Aggregate_2.Avg_Age ) SELECT * FROM Join_4",
    "clean_query":"SELECT song_name FROM concert_singer.singer  WHERE age > ( SELECT avg ( age ) AS Avg_age FROM concert_singer.singer  )"
  },
  {
    "id":"702b793672d277ed4c482f92123e570d1e078e384702f2391b7b7bde241442cd",
    "db_id":"concert_singer",
    "question":"Show location and name for all stadiums with a capacity between 5000 and 10000.",
    "query":"SELECT LOCATION , name FROM concert_singer.stadium WITH (FORCESCAN) WHERE capacity BETWEEN 5000 AND 10000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ stadium ] Predicate [ Capacity >= 5000 AND Capacity <= 10000 ] Output [ Name , Capacity , Location ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Predicate [ Capacity >= 5000 AND Capacity <= 10000 ] Output [ Name , Capacity , Location ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Capacity, Location FROM concert_singer.stadium WHERE Capacity >= 5000 AND Capacity <= 10000 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT LOCATION , name FROM concert_singer.stadium  WHERE capacity BETWEEN 5000 AND 10000"
  },
  {
    "id":"03d124ae45b4ce58b2dcbf28e5bd3e207107ab62ee5a796cf67d278f03da5991",
    "db_id":"concert_singer",
    "question":"What are the locations and names of all stations with capacity between 5000 and 10000?",
    "query":"SELECT LOCATION , name FROM concert_singer.stadium WITH (FORCESCAN) WHERE capacity BETWEEN 5000 AND 10000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ stadium ] Predicate [ Capacity >= 5000 AND Capacity <= 10000 ] Output [ Name , Capacity , Location ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Predicate [ Capacity >= 5000 AND Capacity <= 10000 ] Output [ Name , Capacity , Location ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Capacity, Location FROM concert_singer.stadium WHERE Capacity >= 5000 AND Capacity <= 10000 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT LOCATION , name FROM concert_singer.stadium  WHERE capacity BETWEEN 5000 AND 10000"
  },
  {
    "id":"9d0778eb0707002333a0bf777d868b7a14384e4a6da008beda575d4c56628f95",
    "db_id":"concert_singer",
    "question":"What is the maximum capacity and the average of all stadiums ?",
    "query":"select max ( capacity ) AS Max_capacity , average from concert_singer.stadium group by average",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Capacity , Average ] ; #2 = Aggregate [ #1 ] GroupBy [ Average ] Output [ MAX(Capacity) AS Max_Capacity , Average ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity , Average ] ; #2 = Aggregate [ #1 ] GroupBy [ Average ] Output [ MAX(Capacity) AS Max_Capacity , Average ]",
    "cte":"WITH Scan_1 AS ( SELECT Capacity, Average FROM concert_singer.stadium ), Aggregate_2 AS ( SELECT MAX(Capacity) AS Max_Capacity, Average FROM Scan_1 GROUP BY Average ) SELECT * FROM Aggregate_2",
    "clean_query":"select max ( capacity ) AS Max_capacity , average from concert_singer.stadium group by average"
  },
  {
    "id":"b9856abd94006487ca31911b34964cc7e41c7ac610e84c761ed5d107e75be80b",
    "db_id":"concert_singer",
    "question":"What is the average and maximum capacities for all stadiums ?",
    "query":"select avg ( capacity ) AS Avg_capacity , max ( capacity ) AS Max_capacity FROM concert_singer.stadium WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Capacity ] ; #2 = Aggregate [ #1 ] Output [ AVG(Capacity) AS Avg_Capacity , MAX(Capacity) AS Max_Capacity ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity ] ; #2 = Aggregate [ #1 ] Output [ AVG(Capacity) AS Avg_Capacity , MAX(Capacity) AS Max_Capacity ]",
    "cte":"WITH Scan_1 AS ( SELECT Capacity FROM concert_singer.stadium ), Aggregate_2 AS ( SELECT AVG(Capacity) AS Avg_Capacity, MAX(Capacity) AS Max_Capacity FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"select avg ( capacity ) AS Avg_capacity , max ( capacity ) AS Max_capacity FROM concert_singer.stadium"
  },
  {
    "id":"f2d22804f55d8c9889b17e685d05553725cce3ad4a081019ff11f72de7e9c8f1",
    "db_id":"concert_singer",
    "question":"What is the name and capacity for the stadium with highest average attendance?",
    "query":"SELECT TOP 1 name , capacity FROM concert_singer.stadium WITH (FORCESCAN) ORDER BY average DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Name , Capacity , Average ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Average DESC ] Output [ Name , Capacity , Average ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Capacity , Average ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Average DESC ] Output [ Name , Capacity , Average ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Capacity, Average FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Name, Capacity, Average FROM Scan_1 ORDER BY Average DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 name , capacity FROM concert_singer.stadium  ORDER BY average DESC"
  },
  {
    "id":"567783c3df80bd4ff5f729ab5c7b8fc416c10a71799c470a6d2c3beb6ed5fcc9",
    "db_id":"concert_singer",
    "question":"What is the name and capacity for the stadium with the highest average attendance?",
    "query":"SELECT TOP 1 name , capacity FROM concert_singer.stadium WITH (FORCESCAN) ORDER BY average DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Name , Capacity , Average ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Average DESC ] Output [ Name , Capacity , Average ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Capacity , Average ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Average DESC ] Output [ Name , Capacity , Average ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Capacity, Average FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Name, Capacity, Average FROM Scan_1 ORDER BY Average DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 name , capacity FROM concert_singer.stadium  ORDER BY average DESC"
  },
  {
    "id":"b8c847904e750fe4416bc380d732457def4ae381a28aa719d6a951f5fc9d7fad",
    "db_id":"concert_singer",
    "question":"How many concerts are there in year 2014 or 2015?",
    "query":"SELECT count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) WHERE YEAR = 2014 OR YEAR = 2015 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year = 2014 OR Year = 2015 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 OR Year = 2015 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert WHERE Year = 2014 OR Year = 2015 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM concert_singer.concert  WHERE YEAR = 2014 OR YEAR = 2015"
  },
  {
    "id":"c3d09bbd5ef44b3e809bb09034af2f560f4d623215e8376b9b7c125a7a724849",
    "db_id":"concert_singer",
    "question":"How many concerts occurred in 2014 or 2015?",
    "query":"SELECT count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) WHERE YEAR = 2014 OR YEAR = 2015 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year = 2014 OR Year = 2015 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 OR Year = 2015 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert WHERE Year = 2014 OR Year = 2015 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM concert_singer.concert  WHERE YEAR = 2014 OR YEAR = 2015"
  },
  {
    "id":"dcd57f330d2deb88d06e3aa786b8bad819dc63de5e9110d4fbb94cbab2d57c1f",
    "db_id":"concert_singer",
    "question":"Show the stadium name and the number of concerts in each stadium.",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ concert ] Output [ Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Stadium_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Name , countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Output [ Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Stadium_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Scan_2 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_1.Stadium_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Stadium_ID ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id"
  },
  {
    "id":"d011124ee39b8a8168783bbde992cc343aa3b925ea416d5262d1d21b8276ec93",
    "db_id":"concert_singer",
    "question":"For each stadium, how many concerts play there?",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ concert ] Output [ Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Stadium_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Name , countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Output [ Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Stadium_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Scan_2 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_1.Stadium_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Stadium_ID ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id GROUP BY T2.name , T1.stadium_id"
  },
  {
    "id":"1b4ff28beddb2e20b5b98772dc08dc31b033b25d3bb666da28b6bfc81b517174",
    "db_id":"concert_singer",
    "question":"Show the stadium name and capacity with most number of concerts in year 2014 or after.",
    "query":"SELECT TOP 1 T2.name , T2.capacity FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.year > = 2014 GROUP BY T2.name , T2.capacity , T2.stadium_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year >= 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Capacity , Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Capacity , Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year >= 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Capacity , Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Capacity , Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year >= 2014 ), Scan_2 AS ( SELECT Capacity, Stadium_ID, Name FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_2.Stadium_ID, Scan_2.Capacity, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Capacity, Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Stadium_ID, Capacity ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Capacity, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.name , T2.capacity FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.year > = 2014 GROUP BY T2.name , T2.capacity , T2.stadium_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"6b4498103b5d61a19827ce25667aea3019ce7675511bd6745692252c786e1437",
    "db_id":"concert_singer",
    "question":"What is the name and capacity of the stadium with the most concerts after 2013 ?",
    "query":"select TOP 1 t2.name , t2.capacity FROM concert_singer.concert AS t1 WITH (FORCESCAN) join concert_singer.stadium as t2 WITH (FORCESCAN) on t1.stadium_id = t2.stadium_id where t1.year > 2013 group by t2.name , t2.capacity , t2.stadium_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year > 2013 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Capacity , Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Capacity , Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year > 2013 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Stadium_ID ] Output [ Capacity , Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Capacity , Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year > 2013 ), Scan_2 AS ( SELECT Capacity, Stadium_ID, Name FROM concert_singer.stadium ), Join_3 AS ( SELECT Scan_2.Stadium_ID, Scan_2.Capacity, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Aggregate_4 AS ( SELECT Capacity, Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Stadium_ID, Capacity ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Capacity, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 t2.name , t2.capacity FROM concert_singer.concert AS t1  join concert_singer.stadium as t2  on t1.stadium_id = t2.stadium_id where t1.year > 2013 group by t2.name , t2.capacity , t2.stadium_id order by count ( * ) desc"
  },
  {
    "id":"aa6bf7301371f2cff46a9c496cf9c22dbbb4cb140dfc89f2ac109fd69c17017a",
    "db_id":"concert_singer",
    "question":"Which year has most number of concerts?",
    "query":"SELECT TOP 1 YEAR FROM concert_singer.concert WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ concert ] Output [ Year ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Year ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Output [ Year ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Year ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert ), Aggregate_2 AS ( SELECT Year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Year ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Year FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 YEAR FROM concert_singer.concert  GROUP BY YEAR ORDER BY count ( * ) DESC"
  },
  {
    "id":"8314cff444da4190f678444cf54af0f671ea099bf1fd89b5c3d7fd8992206b6e",
    "db_id":"concert_singer",
    "question":"What is the year that had the most concerts?",
    "query":"SELECT TOP 1 YEAR FROM concert_singer.concert WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ concert ] Output [ Year ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Year ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Output [ Year ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Year ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM concert_singer.concert ), Aggregate_2 AS ( SELECT Year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Year ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Year FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 YEAR FROM concert_singer.concert  GROUP BY YEAR ORDER BY count ( * ) DESC"
  },
  {
    "id":"a2ffbc395f534bbcc3f680bff6c1171efc495cd5e4a165fd980fb0040bac4623",
    "db_id":"concert_singer",
    "question":"Show the stadium names without any concert.",
    "query":"SELECT name FROM concert_singer.stadium WITH (FORCESCAN) WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #2 = Scan Table [ concert ] Output [ Stadium_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Stadium_ID IS NULL OR #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #2 = Scan Table [ concert ] Output [ Stadium_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Stadium_ID IS NULL OR #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Scan_2 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT name FROM concert_singer.stadium  WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert  )"
  },
  {
    "id":"9891f13461359514e80f559cbff62c2204692fb32e2b850d48f587e0a2f068b0",
    "db_id":"concert_singer",
    "question":"What are the names of the stadiums without any concerts?",
    "query":"SELECT name FROM concert_singer.stadium WITH (FORCESCAN) WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #2 = Scan Table [ concert ] Output [ Stadium_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Stadium_ID IS NULL OR #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #2 = Scan Table [ concert ] Output [ Stadium_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Stadium_ID IS NULL OR #1.Stadium_ID = #2.Stadium_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Scan_2 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT name FROM concert_singer.stadium  WHERE stadium_id NOT IN ( SELECT stadium_id FROM concert_singer.concert  )"
  },
  {
    "id":"66e090db2c6354463561fac293917d6c63cedb67424cde7983e0d0e45c06013f",
    "db_id":"concert_singer",
    "question":"Show countries where a singer above age 40 and a singer below 30 are from.",
    "query":"SELECT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age > 40 INTERSECT SELECT country FROM concert_singer.singer WITH (FORCESCAN) WHERE age < 30 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Age > 40 ] Distinct [ true ] Output [ Country , Age ] ; #2 = Scan Table [ singer ] Predicate [ Age < 30 ] Output [ Country , Age ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Country = #2.Country ] Output [ #1.Country ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Age > 40 ] Distinct [ true ] Output [ Country , Age ] ; #2 = Scan Table [ singer ] Predicate [ Age < 30 ] Output [ Country , Age ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Country = #2.Country ] Output [ #1.Country ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Country, Age FROM concert_singer.singer WHERE Age > 40 ), Scan_2 AS ( SELECT Country, Age FROM concert_singer.singer WHERE Age < 30 ), Intersect_3 AS ( SELECT Scan_1.Country FROM Scan_1 WHERE Country IN (SELECT Country FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT country FROM concert_singer.singer  WHERE age > 40 INTERSECT SELECT country FROM concert_singer.singer  WHERE age < 30"
  },
  {
    "id":"6461e8c73ff28757df50984fd488bc500623f7b97be11073ca02266be64c7ea5",
    "db_id":"concert_singer",
    "question":"Show names for all stadiums except for stadiums having a concert in year 2014.",
    "query":"SELECT name FROM concert_singer.stadium WITH (FORCESCAN) EXCEPT SELECT T2.name FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ stadium ] Distinct [ true ] Output [ Name ] ; #2 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #3 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Distinct [ true ] Output [ Name ] ; #2 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #3 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Name FROM concert_singer.stadium ), Scan_2 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_3 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.Stadium_ID = Scan_3.Stadium_ID ), Except_5 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT name FROM concert_singer.stadium  EXCEPT SELECT T2.name FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014"
  },
  {
    "id":"e216cdd1ff98c38427880127f0d408f230492aace2ab20e4d7e13def209ba0cf",
    "db_id":"concert_singer",
    "question":"What are the names of all stadiums that did not have a concert in 2014?",
    "query":"SELECT name FROM concert_singer.stadium WITH (FORCESCAN) EXCEPT SELECT T2.name FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ stadium ] Distinct [ true ] Output [ Name ] ; #2 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #3 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Distinct [ true ] Output [ Name ] ; #2 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #3 = Scan Table [ stadium ] Output [ Name , Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Name FROM concert_singer.stadium ), Scan_2 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_3 AS ( SELECT Name, Stadium_ID FROM concert_singer.stadium ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.Stadium_ID = Scan_3.Stadium_ID ), Except_5 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT name FROM concert_singer.stadium  EXCEPT SELECT T2.name FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.year = 2014"
  },
  {
    "id":"b6618cc926b5b8cc6e09139cb718b03092808549394e8287aafb2b9044c491bf",
    "db_id":"concert_singer",
    "question":"Show the name and theme for all concerts and the number of singers in each concert.",
    "query":"SELECT T2.concert_name , T2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.concert AS T2 WITH (FORCESCAN) ON T1.concert_id = T2.concert_id GROUP BY T2.concert_name , T2.theme , T2.concert_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer_in_concert ] Output [ concert_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ concert_ID ] Output [ concert_ID , countstar AS Count_Star ] ; #3 = Scan Table [ concert ] Output [ Theme , concert_ID , concert_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.concert_ID = #3.concert_ID ] Output [ #3.Theme , #3.concert_Name , #2.Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ concert_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ concert_ID ] Output [ concert_ID , countstar AS Count_Star ] ; #3 = Scan Table [ concert ] Output [ Theme , concert_ID , concert_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.concert_ID = #3.concert_ID ] Output [ #3.Theme , #3.concert_Name , #2.Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT concert_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT concert_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY concert_ID ), Scan_3 AS ( SELECT Theme, concert_ID, concert_Name FROM concert_singer.concert ), Join_4 AS ( SELECT Scan_3.Theme, Scan_3.concert_Name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.concert_ID = Scan_3.concert_ID ) SELECT * FROM Join_4",
    "clean_query":"SELECT T2.concert_name , T2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.concert AS T2  ON T1.concert_id = T2.concert_id GROUP BY T2.concert_name , T2.theme , T2.concert_id"
  },
  {
    "id":"7acbdc4f7c108ce2c675170ef55882c7b9871fe3b5c8dbfee26a6f757a027492",
    "db_id":"concert_singer",
    "question":"What are the names , themes , and number of singers for every concert ?",
    "query":"select t2.concert_name , t2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS t1 WITH (FORCESCAN) join concert_singer.concert as t2 WITH (FORCESCAN) on t1.concert_id = t2.concert_id group by t2.concert_name , t2.theme , t2.concert_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer_in_concert ] Output [ concert_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ concert_ID ] Output [ concert_ID , countstar AS Count_Star ] ; #3 = Scan Table [ concert ] Output [ Theme , concert_ID , concert_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.concert_ID = #3.concert_ID ] Output [ #3.Theme , #3.concert_Name , #2.Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ concert_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ concert_ID ] Output [ concert_ID , countstar AS Count_Star ] ; #3 = Scan Table [ concert ] Output [ Theme , concert_ID , concert_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.concert_ID = #3.concert_ID ] Output [ #3.Theme , #3.concert_Name , #2.Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT concert_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT concert_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY concert_ID ), Scan_3 AS ( SELECT Theme, concert_ID, concert_Name FROM concert_singer.concert ), Join_4 AS ( SELECT Scan_3.Theme, Scan_3.concert_Name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.concert_ID = Scan_3.concert_ID ) SELECT * FROM Join_4",
    "clean_query":"select t2.concert_name , t2.theme , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS t1  join concert_singer.concert as t2  on t1.concert_id = t2.concert_id group by t2.concert_name , t2.theme , t2.concert_id"
  },
  {
    "id":"8dcbaac89354f86302d6a16bc620ce64674b57a5369eb808b45bf41afe1560de",
    "db_id":"concert_singer",
    "question":"List singer names and number of concerts for each singer.",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer_in_concert ] Output [ Singer_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Singer_ID ] Output [ Singer_ID , countstar AS Count_Star ] ; #3 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Singer_ID = #3.Singer_ID ] Output [ #2.Count_Star , #3.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ Singer_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Singer_ID ] Output [ Singer_ID , countstar AS Count_Star ] ; #3 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Singer_ID = #3.Singer_ID ] Output [ #2.Count_Star , #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT Singer_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Singer_ID ), Scan_3 AS ( SELECT Name, Singer_ID FROM concert_singer.singer ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Singer_ID = Scan_3.Singer_ID ) SELECT * FROM Join_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id"
  },
  {
    "id":"3b794e094e7479a816e8818a7514d0e91bc737440da6b6c76c26a0f6041aab68",
    "db_id":"concert_singer",
    "question":"What are the names of the singers and number of concerts for each person?",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer_in_concert ] Output [ Singer_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Singer_ID ] Output [ Singer_ID , countstar AS Count_Star ] ; #3 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Singer_ID = #3.Singer_ID ] Output [ #2.Count_Star , #3.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer_in_concert ] Output [ Singer_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Singer_ID ] Output [ Singer_ID , countstar AS Count_Star ] ; #3 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Singer_ID = #3.Singer_ID ] Output [ #2.Count_Star , #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID FROM concert_singer.singer_in_concert ), Aggregate_2 AS ( SELECT Singer_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Singer_ID ), Scan_3 AS ( SELECT Name, Singer_ID FROM concert_singer.singer ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Singer_ID = Scan_3.Singer_ID ) SELECT * FROM Join_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id GROUP BY T2.name , T2.singer_id"
  },
  {
    "id":"e0e10dd96631c9a039a0f6b68747d5eef73a3e9e37063de7381bdd2b09913603",
    "db_id":"concert_singer",
    "question":"List all singer names in concerts in year 2014.",
    "query":"SELECT T2.name FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3 WITH (FORCESCAN) ON T1.concert_id = T3.concert_id WHERE T3.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , concert_ID ] ; #2 = Scan Table [ singer_in_concert ] Output [ concert_ID , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.concert_ID = #2.concert_ID ] Output [ #2.Singer_ID ] ; #4 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Singer_ID = #4.Singer_ID ] Output [ #4.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , concert_ID ] ; #2 = Scan Table [ singer_in_concert ] Output [ concert_ID , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.concert_ID = #2.concert_ID ] Output [ #2.Singer_ID ] ; #4 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Singer_ID = #4.Singer_ID ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, concert_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT concert_ID, Singer_ID FROM concert_singer.singer_in_concert ), Join_3 AS ( SELECT Scan_2.Singer_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.concert_ID = Scan_2.concert_ID ), Scan_4 AS ( SELECT Name, Singer_ID FROM concert_singer.singer ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Singer_ID = Scan_4.Singer_ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T2.name FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3  ON T1.concert_id = T3.concert_id WHERE T3.year = 2014"
  },
  {
    "id":"647d2db94feaabbbdd3eecac3a26c557b1fb2a27a9e69a1f852d55b418ac6428",
    "db_id":"concert_singer",
    "question":"What are the names of the singers who performed in a concert in 2014?",
    "query":"SELECT T2.name FROM concert_singer.singer_in_concert AS T1 WITH (FORCESCAN) JOIN concert_singer.singer AS T2 WITH (FORCESCAN) ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3 WITH (FORCESCAN) ON T1.concert_id = T3.concert_id WHERE T3.year = 2014 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , concert_ID ] ; #2 = Scan Table [ singer_in_concert ] Output [ concert_ID , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.concert_ID = #2.concert_ID ] Output [ #2.Singer_ID ] ; #4 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Singer_ID = #4.Singer_ID ] Output [ #4.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , concert_ID ] ; #2 = Scan Table [ singer_in_concert ] Output [ concert_ID , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.concert_ID = #2.concert_ID ] Output [ #2.Singer_ID ] ; #4 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Singer_ID = #4.Singer_ID ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, concert_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT concert_ID, Singer_ID FROM concert_singer.singer_in_concert ), Join_3 AS ( SELECT Scan_2.Singer_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.concert_ID = Scan_2.concert_ID ), Scan_4 AS ( SELECT Name, Singer_ID FROM concert_singer.singer ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Singer_ID = Scan_4.Singer_ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T2.name FROM concert_singer.singer_in_concert AS T1  JOIN concert_singer.singer AS T2  ON T1.singer_id = T2.singer_id JOIN concert_singer.concert AS T3  ON T1.concert_id = T3.concert_id WHERE T3.year = 2014"
  },
  {
    "id":"b2572fa21c59deecda02eba022c89a012ca1699008c53c14477974811d2ab2b7",
    "db_id":"concert_singer",
    "question":"what is the name and nation of the singer who have a song having 'Hey' in its name?",
    "query":"SELECT name , country FROM concert_singer.singer WITH (FORCESCAN) WHERE song_name LIKE '%Hey%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Song_Name like '%Hey%' ] Output [ Name , Country , Song_Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Song_Name like '%Hey%' ] Output [ Name , Country , Song_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Country, Song_Name FROM concert_singer.singer WHERE Song_Name like '%Hey%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , country FROM concert_singer.singer  WHERE song_name LIKE '%Hey%'"
  },
  {
    "id":"ffae8b56f4857f97c781656cf84ccfa69b2b5afec94b6ada88e32db83cf75a0d",
    "db_id":"concert_singer",
    "question":"What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?",
    "query":"SELECT name , country FROM concert_singer.singer WITH (FORCESCAN) WHERE song_name LIKE '%Hey%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Song_Name like '%Hey%' ] Output [ Name , Country , Song_Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ singer ] Predicate [ Song_Name like '%Hey%' ] Output [ Name , Country , Song_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Country, Song_Name FROM concert_singer.singer WHERE Song_Name like '%Hey%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , country FROM concert_singer.singer  WHERE song_name LIKE '%Hey%'"
  },
  {
    "id":"41d3e92c786b0b23ab2969a8beed1284689a19b42473d98e6fdd654c6b4f7a2a",
    "db_id":"concert_singer",
    "question":"Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.",
    "query":"SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Distinct [ true ] Output [ #2.Location , #2.Name ] ; #4 = Scan Table [ concert ] Predicate [ Year = 2015 ] Output [ Year , Stadium_ID ] ; #5 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Stadium_ID = #5.Stadium_ID ] Output [ #5.Location , #5.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Output [ #3.Location , #3.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Distinct [ true ] Output [ #2.Location , #2.Name ] ; #4 = Scan Table [ concert ] Predicate [ Year = 2015 ] Output [ Year , Stadium_ID ] ; #5 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Stadium_ID = #5.Stadium_ID ] Output [ #5.Location , #5.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Output [ #3.Location , #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT Name, Stadium_ID, Location FROM concert_singer.stadium ), Join_3 AS ( SELECT DISTINCT Scan_2.Location, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Scan_4 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2015 ), Scan_5 AS ( SELECT Name, Stadium_ID, Location FROM concert_singer.stadium ), Join_6 AS ( SELECT Scan_5.Location, Scan_5.Name FROM Scan_4 JOIN Scan_5 ON Scan_4.Stadium_ID = Scan_5.Stadium_ID ), Intersect_7 AS ( SELECT Join_3.Location, Join_3.Name FROM Join_3 WHERE Name IN (SELECT Name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015"
  },
  {
    "id":"e12cf91c771fa037e6783e5800ff94968bc131b55bf15a098ff231834fa087d0",
    "db_id":"concert_singer",
    "question":"What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?",
    "query":"SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1 WITH (FORCESCAN) JOIN concert_singer.stadium AS T2 WITH (FORCESCAN) ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Distinct [ true ] Output [ #2.Location , #2.Name ] ; #4 = Scan Table [ concert ] Predicate [ Year = 2015 ] Output [ Year , Stadium_ID ] ; #5 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Stadium_ID = #5.Stadium_ID ] Output [ #5.Location , #5.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Output [ #3.Location , #3.Name ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ concert ] Predicate [ Year = 2014 ] Output [ Year , Stadium_ID ] ; #2 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Stadium_ID = #2.Stadium_ID ] Distinct [ true ] Output [ #2.Location , #2.Name ] ; #4 = Scan Table [ concert ] Predicate [ Year = 2015 ] Output [ Year , Stadium_ID ] ; #5 = Scan Table [ stadium ] Output [ Name , Stadium_ID , Location ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Stadium_ID = #5.Stadium_ID ] Output [ #5.Location , #5.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Output [ #3.Location , #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2014 ), Scan_2 AS ( SELECT Name, Stadium_ID, Location FROM concert_singer.stadium ), Join_3 AS ( SELECT DISTINCT Scan_2.Location, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Stadium_ID = Scan_2.Stadium_ID ), Scan_4 AS ( SELECT Year, Stadium_ID FROM concert_singer.concert WHERE Year = 2015 ), Scan_5 AS ( SELECT Name, Stadium_ID, Location FROM concert_singer.stadium ), Join_6 AS ( SELECT Scan_5.Location, Scan_5.Name FROM Scan_4 JOIN Scan_5 ON Scan_4.Stadium_ID = Scan_5.Stadium_ID ), Intersect_7 AS ( SELECT Join_3.Location, Join_3.Name FROM Join_3 WHERE Name IN (SELECT Name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2014 INTERSECT SELECT T2.name , T2.location FROM concert_singer.concert AS T1  JOIN concert_singer.stadium AS T2  ON T1.stadium_id = T2.stadium_id WHERE T1.Year = 2015"
  },
  {
    "id":"42d93c17d3b56bb252b66f63ab587d51a87c7c5714ad70b39b5c3bc9b6206343",
    "db_id":"concert_singer",
    "question":"Find the number of concerts happened in the stadium with the highest capacity .",
    "query":"select count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium WITH (FORCESCAN) order by capacity desc ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Capacity DESC ] Output [ Capacity , Stadium_ID ] ; #3 = Scan Table [ concert ] Output [ Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Capacity DESC ] Output [ Capacity , Stadium_ID ] ; #3 = Scan Table [ concert ] Output [ Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Capacity, Stadium_ID FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Capacity, Stadium_ID FROM Scan_1 ORDER BY Capacity DESC ), Scan_3 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Join_4 AS ( SELECT TopSort_2.Stadium_ID, TopSort_2.Capacity FROM TopSort_2 JOIN Scan_3 ON TopSort_2.Stadium_ID = Scan_3.Stadium_ID ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"select count ( * ) AS Count_Star FROM concert_singer.concert  where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium  order by capacity desc )"
  },
  {
    "id":"d96c4aa465d4471e493741e9b5bd593cb4cee234edcbb652473be660899b21cf",
    "db_id":"concert_singer",
    "question":"What are the number of concerts that occurred in the stadium with the largest capacity ?",
    "query":"select count ( * ) AS Count_Star FROM concert_singer.concert WITH (FORCESCAN) where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium WITH (FORCESCAN) order by capacity desc ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Capacity DESC ] Output [ Capacity , Stadium_ID ] ; #3 = Scan Table [ concert ] Output [ Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"concert_singer | #1 = Scan Table [ stadium ] Output [ Capacity , Stadium_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Capacity DESC ] Output [ Capacity , Stadium_ID ] ; #3 = Scan Table [ concert ] Output [ Stadium_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Stadium_ID = #3.Stadium_ID ] Output [ #2.Stadium_ID , #2.Capacity ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Capacity, Stadium_ID FROM concert_singer.stadium ), TopSort_2 AS ( SELECT TOP 1 Capacity, Stadium_ID FROM Scan_1 ORDER BY Capacity DESC ), Scan_3 AS ( SELECT Stadium_ID FROM concert_singer.concert ), Join_4 AS ( SELECT TopSort_2.Stadium_ID, TopSort_2.Capacity FROM TopSort_2 JOIN Scan_3 ON TopSort_2.Stadium_ID = Scan_3.Stadium_ID ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"select count ( * ) AS Count_Star FROM concert_singer.concert  where stadium_id = ( select TOP 1 stadium_id FROM concert_singer.stadium  order by capacity desc )"
  },
  {
    "id":"11f48bff71b58facc88ca7563664da98e0dda72f64e9130e8c18ead0c00c7bc8",
    "db_id":"pets_1",
    "question":"Find the number of pets whose weight is heavier than 10.",
    "query":"SELECT count ( * ) AS Count_Star FROM pets_1.pets WITH (FORCESCAN) WHERE weight > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ weight > 10.0 ] Output [ weight ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ weight > 10.0 ] Output [ weight ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT weight FROM pets_1.Pets WHERE weight > 10.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM pets_1.pets  WHERE weight > 10"
  },
  {
    "id":"b2964fe5bd1fd23fa2bcdde07996f8745f21fd16c8c9228fced51de099028872",
    "db_id":"pets_1",
    "question":"How many pets have a greater weight than 10?",
    "query":"SELECT count ( * ) AS Count_Star FROM pets_1.pets WITH (FORCESCAN) WHERE weight > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ weight > 10.0 ] Output [ weight ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ weight > 10.0 ] Output [ weight ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT weight FROM pets_1.Pets WHERE weight > 10.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM pets_1.pets  WHERE weight > 10"
  },
  {
    "id":"cbc8c9742f9ae63285f58dd8ef3664a68b1c4c9ca8cbd40a5b1fec608cd59749",
    "db_id":"pets_1",
    "question":"Find the weight of the youngest dog.",
    "query":"SELECT TOP 1 weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, pet_age FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 weight, pet_age FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 weight FROM pets_1.pets  ORDER BY pet_age"
  },
  {
    "id":"126dcbf655e9d0632f315fe6f8ed028a2c9578c87310dbb69752079828e3552c",
    "db_id":"pets_1",
    "question":"How much does the youngest dog weigh?",
    "query":"SELECT TOP 1 weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , pet_age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, pet_age FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 weight, pet_age FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 weight FROM pets_1.pets  ORDER BY pet_age"
  },
  {
    "id":"c5a692afde2f7670bc43c3d670e2d9235236da86cfd5f2e53f5c8b520a96a5a3",
    "db_id":"pets_1",
    "question":"Find the maximum weight for each type of pet. List the maximum weight and pet type.",
    "query":"SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets WITH (FORCESCAN) GROUP BY petType OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(weight) AS Max_weight , PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(weight) AS Max_weight , PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT MAX(weight) AS Max_weight, PetType FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets  GROUP BY petType"
  },
  {
    "id":"dbf216d50046bffe3525bbf214859163bbb25370ba59b212e66125d6db158dd4",
    "db_id":"pets_1",
    "question":"List the maximum weight and type for each type of pet.",
    "query":"SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets WITH (FORCESCAN) GROUP BY petType OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(weight) AS Max_weight , PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(weight) AS Max_weight , PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT MAX(weight) AS Max_weight, PetType FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( weight ) AS Max_weight , petType FROM pets_1.pets  GROUP BY petType"
  },
  {
    "id":"92e4d4fbc8091177b07c249b6d37d5ae85675b91bec3b9f0ad37339fbf223c48",
    "db_id":"pets_1",
    "question":"Find number of pets owned by students who are older than 20.",
    "query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.age > 20 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Predicate [ Age > 20 ] Output [ StuID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #1.StuID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Predicate [ Age > 20 ] Output [ StuID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #1.StuID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Age FROM pets_1.Student WHERE Age > 20 ), Join_3 AS ( SELECT Scan_1.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.age > 20"
  },
  {
    "id":"025e0f3fdad5dd9c427fe7336fda1a25861b44bd961230fd0d51ebfe02eae5d6",
    "db_id":"pets_1",
    "question":"How many pets are owned by students that have an age greater than 20?",
    "query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.age > 20 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Predicate [ Age > 20 ] Output [ StuID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #1.StuID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Predicate [ Age > 20 ] Output [ StuID , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #1.StuID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Age FROM pets_1.Student WHERE Age > 20 ), Join_3 AS ( SELECT Scan_1.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.age > 20"
  },
  {
    "id":"80c3435a30611055d27a8c5e7b6cb75d19f7ffd652eb663fe6b6cb388ab74697",
    "db_id":"pets_1",
    "question":"Find the number of dog pets that are raised by female students (with sex F).",
    "query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Predicate [ Sex = 'F' ] Output [ StuID , Sex ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #3.StuID ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Predicate [ Sex = 'F' ] Output [ StuID , Sex ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #3.StuID ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Sex FROM pets_1.Student WHERE Sex = 'F' ), Join_5 AS ( SELECT Join_3.StuID FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog'"
  },
  {
    "id":"d0add8ef7ebdb8bb0c8c3c4c33b8775c08dde1c736f9ad1398a7cbddcafa4776",
    "db_id":"pets_1",
    "question":"How many dog pets are raised by female students?",
    "query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Predicate [ Sex = 'F' ] Output [ StuID , Sex ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #3.StuID ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Predicate [ Sex = 'F' ] Output [ StuID , Sex ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #3.StuID ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Sex FROM pets_1.Student WHERE Sex = 'F' ), Join_5 AS ( SELECT Join_3.StuID FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T2.petid = T3.petid WHERE T1.sex = 'F' AND T3.pettype = 'dog'"
  },
  {
    "id":"2a006605914d62ef4da26c68c384d0d57d1cb62ea9722f1a6f3676efc0c57456",
    "db_id":"pets_1",
    "question":"Find the number of distinct type of pets.",
    "query":"SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Pets ] Distinct [ true ] Output [ PetType ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT PetType) AS Count_Dist_PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Distinct [ true ] Output [ PetType ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT PetType) AS Count_Dist_PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT COUNT(DISTINCT PetType) AS Count_Dist_PetType FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets"
  },
  {
    "id":"964ffeff8f8a7b60a06ed97e9100a6c16331a8a237ac29efec1b336be3eeca13",
    "db_id":"pets_1",
    "question":"How many different types of pet are there?",
    "query":"SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Pets ] Distinct [ true ] Output [ PetType ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT PetType) AS Count_Dist_PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Distinct [ true ] Output [ PetType ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT PetType) AS Count_Dist_PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT COUNT(DISTINCT PetType) AS Count_Dist_PetType FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT pettype ) AS Count_Dist_pettype FROM pets_1.pets"
  },
  {
    "id":"f188a37bade4eaee7d3ab43541a2979675922644d5338853df3bf004604a9d03",
    "db_id":"pets_1",
    "question":"Find the first name of students who have cat or dog pet.",
    "query":"SELECT DISTINCT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' OR PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' OR PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' OR PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog'"
  },
  {
    "id":"8257705ad9837960caf1153fa275f73bdb5e7c98cbbd9bd8f4d35ef3843d7e21",
    "db_id":"pets_1",
    "question":"What are the first names of every student who has a cat or dog as a pet?",
    "query":"SELECT DISTINCT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' OR PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' OR PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' OR PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OR T3.pettype = 'dog'"
  },
  {
    "id":"1e89d560ac01a52205cd8edb1ad7d22d0084f87bb2d16c76405f82f6eed14cf0",
    "db_id":"pets_1",
    "question":"Find the first name of students who have both cat and dog pets .",
    "query":"select t1.fname FROM pets_1.student AS t1 WITH (FORCESCAN) join pets_1.has_pet as t2 WITH (FORCESCAN) on t1.stuid = t2.stuid join pets_1.pets as t3 WITH (FORCESCAN) on t3.petid = t2.petid where t3.pettype = 'cat' intersect select t1.fname FROM pets_1.student AS t1 WITH (FORCESCAN) join pets_1.has_pet as t2 WITH (FORCESCAN) on t1.stuid = t2.stuid join pets_1.pets as t3 WITH (FORCESCAN) on t3.petid = t2.petid where t3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ] ; #6 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #7 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.PetID = #7.PetID ] Output [ #7.StuID ] ; #9 = Scan Table [ Student ] Output [ StuID , Fname ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.StuID = #9.StuID ] Output [ #9.Fname ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Fname = #10.Fname ] Output [ #5.Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ] ; #6 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #7 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.PetID = #7.PetID ] Output [ #7.StuID ] ; #9 = Scan Table [ Student ] Output [ StuID , Fname ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.StuID = #9.StuID ] Output [ #9.Fname ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Fname = #10.Fname ] Output [ #5.Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_7 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_8 AS ( SELECT Scan_7.StuID FROM Scan_6 JOIN Scan_7 ON Scan_6.PetID = Scan_7.PetID ), Scan_9 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_10 AS ( SELECT Scan_9.Fname FROM Join_8 JOIN Scan_9 ON Join_8.StuID = Scan_9.StuID ), Intersect_11 AS ( SELECT Join_5.Fname FROM Join_5 WHERE Fname IN (SELECT Fname FROM Join_10) ) SELECT * FROM Intersect_11",
    "clean_query":"select t1.fname FROM pets_1.student AS t1  join pets_1.has_pet as t2  on t1.stuid = t2.stuid join pets_1.pets as t3  on t3.petid = t2.petid where t3.pettype = 'cat' intersect select t1.fname FROM pets_1.student AS t1  join pets_1.has_pet as t2  on t1.stuid = t2.stuid join pets_1.pets as t3  on t3.petid = t2.petid where t3.pettype = 'dog'"
  },
  {
    "id":"18410d6eea9eaaa4ded15500a3cfd28e14e048a9c0b11d9c6c27f1ebd20ba32c",
    "db_id":"pets_1",
    "question":"What are the students' first names who have both cats and dogs as pets?",
    "query":"SELECT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' INTERSECT SELECT T1.Fname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'dog' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ] ; #6 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #7 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.PetID = #7.PetID ] Output [ #7.StuID ] ; #9 = Scan Table [ Student ] Output [ StuID , Fname ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.StuID = #9.StuID ] Output [ #9.Fname ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Fname = #10.Fname ] Output [ #5.Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Distinct [ true ] Output [ #4.Fname ] ; #6 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #7 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.PetID = #7.PetID ] Output [ #7.StuID ] ; #9 = Scan Table [ Student ] Output [ StuID , Fname ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.StuID = #9.StuID ] Output [ #9.Fname ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Fname = #10.Fname ] Output [ #5.Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_5 AS ( SELECT DISTINCT Scan_4.Fname FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_7 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_8 AS ( SELECT Scan_7.StuID FROM Scan_6 JOIN Scan_7 ON Scan_6.PetID = Scan_7.PetID ), Scan_9 AS ( SELECT StuID, Fname FROM pets_1.Student ), Join_10 AS ( SELECT Scan_9.Fname FROM Join_8 JOIN Scan_9 ON Join_8.StuID = Scan_9.StuID ), Intersect_11 AS ( SELECT Join_5.Fname FROM Join_5 WHERE Fname IN (SELECT Fname FROM Join_10) ) SELECT * FROM Intersect_11",
    "clean_query":"SELECT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' INTERSECT SELECT T1.Fname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'dog'"
  },
  {
    "id":"b231dc84cc5a3164c7790160a3d477c445f337f31d5eb74b92fa01a38341a47c",
    "db_id":"pets_1",
    "question":"Find the major and age of students who do not have a cat pet.",
    "query":"SELECT major , age FROM pets_1.student WITH (FORCESCAN) WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student ] Output [ StuID , Age , Major ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.Major , #1.Age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Age , Major ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.Major , #1.Age ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID, Age, Major FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.Major, Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT major , age FROM pets_1.student  WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )"
  },
  {
    "id":"8532df23cc7ba7610e55c027c11135e66dc3952524392a8ea9873a347c0e18b8",
    "db_id":"pets_1",
    "question":"What major is every student who does not own a cat as a pet, and also how old are they?",
    "query":"SELECT major , age FROM pets_1.student WITH (FORCESCAN) WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student ] Output [ StuID , Age , Major ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.Major , #1.Age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Age , Major ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.Major , #1.Age ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID, Age, Major FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.Major, Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT major , age FROM pets_1.student  WHERE stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )"
  },
  {
    "id":"2ae88df2c4162c1fe98dc4ae1452e2b0dfd06263c9a682b94df0f969d32a241f",
    "db_id":"pets_1",
    "question":"Find the id of students who do not have a cat pet.",
    "query":"SELECT stuid FROM pets_1.student WITH (FORCESCAN) EXCEPT SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Student ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.StuID ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.StuID ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.StuID FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT stuid FROM pets_1.student  EXCEPT SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat'"
  },
  {
    "id":"e24d36718f19f2c01300c0eb31b9ef1c7049290a48400f756e3898c3de1ba7cd",
    "db_id":"pets_1",
    "question":"What are the ids of the students who do not own cats as pets?",
    "query":"SELECT stuid FROM pets_1.student WITH (FORCESCAN) EXCEPT SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Student ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.StuID ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID ] ; #3 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #4 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.PetID = #4.PetID ] Output [ #4.StuID ] ; #6 = Intersect [ #2 , #5 ] Predicate [ #5.StuID = #2.StuID ] Output [ #2.StuID ] ; #7 = Except [ #1 , #6 ] Predicate [ #1.StuID = #6.StuID ] Output [ #1.StuID ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Student ), Scan_3 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_4 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_5 AS ( SELECT Scan_4.StuID FROM Scan_3 JOIN Scan_4 ON Scan_3.PetID = Scan_4.PetID ), Intersect_6 AS ( SELECT Scan_2.StuID FROM Scan_2 WHERE StuID IN (SELECT StuID FROM Join_5) ), Except_7 AS ( SELECT Scan_1.StuID FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Intersect_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT stuid FROM pets_1.student  EXCEPT SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat'"
  },
  {
    "id":"5c3b7fe9487dc73740aedb8cf7af43aa29068d1db0bd2ceb247e499df33f354c",
    "db_id":"pets_1",
    "question":"Find the first name and age of students who have a dog but do not have a cat as a pet.",
    "query":"SELECT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.Fname , #4.Age , #4.StuID ] ; #6 = Scan Table [ Student ] Output [ StuID ] ; #7 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #8 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.PetID = #8.PetID ] Output [ #8.StuID ] ; #10 = Intersect [ #6 , #9 ] Predicate [ #9.StuID = #6.StuID ] Output [ #6.StuID ] ; #11 = Except [ #5 , #10 ] Predicate [ #5.StuID = #10.StuID ] Output [ #5.Age , #5.Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.Fname , #4.Age , #4.StuID ] ; #6 = Scan Table [ Student ] Output [ StuID ] ; #7 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #8 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.PetID = #8.PetID ] Output [ #8.StuID ] ; #10 = Intersect [ #6 , #9 ] Predicate [ #9.StuID = #6.StuID ] Output [ #6.StuID ] ; #11 = Except [ #5 , #10 ] Predicate [ #5.StuID = #10.StuID ] Output [ #5.Age , #5.Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.Fname, Scan_4.Age, Scan_4.StuID FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT StuID FROM pets_1.Student ), Scan_7 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_8 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_9 AS ( SELECT Scan_8.StuID FROM Scan_7 JOIN Scan_8 ON Scan_7.PetID = Scan_8.PetID ), Intersect_10 AS ( SELECT Scan_6.StuID FROM Scan_6 WHERE StuID IN (SELECT StuID FROM Join_9) ), Except_11 AS ( SELECT Join_5.Age, Join_5.Fname FROM Join_5 WHERE StuID NOT IN (SELECT StuID FROM Intersect_10) ) SELECT * FROM Except_11",
    "clean_query":"SELECT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )"
  },
  {
    "id":"28003ee356dcce5bec7b0a6b0ac8b51f30bc4cfa2b0b8310e8dd3fb0007706b7",
    "db_id":"pets_1",
    "question":"What is the first name of every student who has a dog but does not have a cat?",
    "query":"SELECT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pettype = 'cat' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.Fname , #4.Age , #4.StuID ] ; #6 = Scan Table [ Student ] Output [ StuID ] ; #7 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #8 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.PetID = #8.PetID ] Output [ #8.StuID ] ; #10 = Intersect [ #6 , #9 ] Predicate [ #9.StuID = #6.StuID ] Output [ #6.StuID ] ; #11 = Except [ #5 , #10 ] Predicate [ #5.StuID = #10.StuID ] Output [ #5.Age , #5.Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ PetType = 'dog' ] Output [ PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.Fname , #4.Age , #4.StuID ] ; #6 = Scan Table [ Student ] Output [ StuID ] ; #7 = Scan Table [ Pets ] Predicate [ PetType = 'cat' ] Output [ PetID , PetType ] ; #8 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.PetID = #8.PetID ] Output [ #8.StuID ] ; #10 = Intersect [ #6 , #9 ] Predicate [ #9.StuID = #6.StuID ] Output [ #6.StuID ] ; #11 = Except [ #5 , #10 ] Predicate [ #5.StuID = #10.StuID ] Output [ #5.Age , #5.Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'dog' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.Fname, Scan_4.Age, Scan_4.StuID FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ), Scan_6 AS ( SELECT StuID FROM pets_1.Student ), Scan_7 AS ( SELECT PetID, PetType FROM pets_1.Pets WHERE PetType = 'cat' ), Scan_8 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_9 AS ( SELECT Scan_8.StuID FROM Scan_7 JOIN Scan_8 ON Scan_7.PetID = Scan_8.PetID ), Intersect_10 AS ( SELECT Scan_6.StuID FROM Scan_6 WHERE StuID IN (SELECT StuID FROM Join_9) ), Except_11 AS ( SELECT Join_5.Age, Join_5.Fname FROM Join_5 WHERE StuID NOT IN (SELECT StuID FROM Intersect_10) ) SELECT * FROM Except_11",
    "clean_query":"SELECT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'dog' AND T1.stuid NOT IN ( SELECT T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pettype = 'cat' )"
  },
  {
    "id":"fe924a806ef085407a4c416512b5a8145323d4427e751f280efeb70d1bc2c1cf",
    "db_id":"pets_1",
    "question":"Find the type and weight of the youngest pet.",
    "query":"SELECT TOP 1 pettype , weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , pet_age , PetType ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age , PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , pet_age , PetType ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age , PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, pet_age, PetType FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 weight, pet_age, PetType FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 pettype , weight FROM pets_1.pets  ORDER BY pet_age"
  },
  {
    "id":"4aaffeb328aed243160907dfc6c6886143ddfb519b5bdddd61990f46ad20f2a1",
    "db_id":"pets_1",
    "question":"What type of pet is the youngest animal, and how much does it weigh?",
    "query":"SELECT TOP 1 pettype , weight FROM pets_1.pets WITH (FORCESCAN) ORDER BY pet_age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , pet_age , PetType ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age , PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , pet_age , PetType ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ pet_age ASC ] Output [ weight , pet_age , PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, pet_age, PetType FROM pets_1.Pets ), TopSort_2 AS ( SELECT TOP 1 weight, pet_age, PetType FROM Scan_1 ORDER BY pet_age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 pettype , weight FROM pets_1.pets  ORDER BY pet_age"
  },
  {
    "id":"d8a40ee798a91a25e6fb481a445890439fc51d9a7674fac4b8bba65179b56c41",
    "db_id":"pets_1",
    "question":"Find the id and weight of all pets whose age is older than 1.",
    "query":"SELECT petid , weight FROM pets_1.pets WITH (FORCESCAN) WHERE pet_age > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ pet_age > 1 ] Output [ weight , pet_age , PetID ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age > 1 ] Output [ weight , pet_age , PetID ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, pet_age, PetID FROM pets_1.Pets WHERE pet_age > 1 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT petid , weight FROM pets_1.pets  WHERE pet_age > 1"
  },
  {
    "id":"d55de3ff73f29e284106d565743be9d15c6776d3c50766545ca8af24e2fff9e4",
    "db_id":"pets_1",
    "question":"What is the id and weight of every pet who is older than 1?",
    "query":"SELECT petid , weight FROM pets_1.pets WITH (FORCESCAN) WHERE pet_age > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ pet_age > 1 ] Output [ weight , pet_age , PetID ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age > 1 ] Output [ weight , pet_age , PetID ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, pet_age, PetID FROM pets_1.Pets WHERE pet_age > 1 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT petid , weight FROM pets_1.pets  WHERE pet_age > 1"
  },
  {
    "id":"14675f95b778f27a99a45c1da9ba1a4976478bf0be82d56d97978b9952346a78",
    "db_id":"pets_1",
    "question":"Find the average and maximum age for each type of pet.",
    "query":"SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ pet_age , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(pet_age) AS Max_pet_age , PetType , AVG(pet_age) AS Avg_pet_age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ pet_age , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(pet_age) AS Max_pet_age , PetType , AVG(pet_age) AS Avg_pet_age ]",
    "cte":"WITH Scan_1 AS ( SELECT pet_age, PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT MAX(pet_age) AS Max_pet_age, PetType, AVG(pet_age) AS Avg_pet_age FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets  GROUP BY pettype"
  },
  {
    "id":"e627d88639a10d9d3ab45b0ed4ded75eb7a6be53aa1884abb1b57143a09899af",
    "db_id":"pets_1",
    "question":"What is the average and maximum age for each pet type?",
    "query":"SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ pet_age , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(pet_age) AS Max_pet_age , PetType , AVG(pet_age) AS Avg_pet_age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ pet_age , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ MAX(pet_age) AS Max_pet_age , PetType , AVG(pet_age) AS Avg_pet_age ]",
    "cte":"WITH Scan_1 AS ( SELECT pet_age, PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT MAX(pet_age) AS Max_pet_age, PetType, AVG(pet_age) AS Avg_pet_age FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( pet_age ) AS Avg_pet_age , max ( pet_age ) AS Max_pet_age , pettype FROM pets_1.pets  GROUP BY pettype"
  },
  {
    "id":"1358270cfa743c906e3f59a8ee2e396a495b714ff53cab341c222aa87d9924c2",
    "db_id":"pets_1",
    "question":"Find the average weight for each pet type.",
    "query":"SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ AVG(weight) AS Avg_weight , PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ AVG(weight) AS Avg_weight , PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT AVG(weight) AS Avg_weight, PetType FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets  GROUP BY pettype"
  },
  {
    "id":"5481005a8259bb52b06468461cad920f76cbbd9d0c5d8f0b587715fe6a11b912",
    "db_id":"pets_1",
    "question":"What is the average weight for each type of pet?",
    "query":"SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets WITH (FORCESCAN) GROUP BY pettype OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ AVG(weight) AS Avg_weight , PetType ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Output [ weight , PetType ] ; #2 = Aggregate [ #1 ] GroupBy [ PetType ] Output [ AVG(weight) AS Avg_weight , PetType ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, PetType FROM pets_1.Pets ), Aggregate_2 AS ( SELECT AVG(weight) AS Avg_weight, PetType FROM Scan_1 GROUP BY PetType ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( weight ) AS Avg_weight , pettype FROM pets_1.pets  GROUP BY pettype"
  },
  {
    "id":"f169ba7a72e220db320e37e251c8cb9711d7acc0bee315013137bf2271abee10",
    "db_id":"pets_1",
    "question":"Find the first name and age of students who have a pet.",
    "query":"SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Distinct [ true ] Output [ #2.Fname , #2.Age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Distinct [ true ] Output [ #2.Fname , #2.Age ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_3 AS ( SELECT DISTINCT Scan_2.Fname, Scan_2.Age FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid"
  },
  {
    "id":"0e930a583ef614f6f0b41fb786e062d289fc26ba0edd412723f27bf935248a70",
    "db_id":"pets_1",
    "question":"What are the different first names and ages of the students who do have pets?",
    "query":"SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Distinct [ true ] Output [ #2.Fname , #2.Age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Scan Table [ Student ] Output [ StuID , Fname , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Distinct [ true ] Output [ #2.Fname , #2.Age ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Scan_2 AS ( SELECT StuID, Fname, Age FROM pets_1.Student ), Join_3 AS ( SELECT DISTINCT Scan_2.Fname, Scan_2.Age FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.fname , T1.age FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid"
  },
  {
    "id":"cd76c13283c015a462ca208c264fad22478847289cedf4d8ebcce4c92788c536",
    "db_id":"pets_1",
    "question":"Find the id of the pet owned by student whose last name is 'Smith'.",
    "query":"SELECT T2.petid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Student ] Predicate [ LName = 'Smith' ] Output [ StuID , LName ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #2.PetID ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Predicate [ LName = 'Smith' ] Output [ StuID , LName ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #2.PetID ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID, LName FROM pets_1.Student WHERE LName = 'Smith' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.PetID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.petid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith'"
  },
  {
    "id":"21558cf97f26dbb4214a9eae6e5df3b4c1b408de7847a6c459d57a3021c58c3b",
    "db_id":"pets_1",
    "question":"What is the id of the pet owned by the student whose last name is 'Smith'?",
    "query":"SELECT T2.petid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Student ] Predicate [ LName = 'Smith' ] Output [ StuID , LName ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #2.PetID ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Predicate [ LName = 'Smith' ] Output [ StuID , LName ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.StuID = #2.StuID ] Output [ #2.PetID ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID, LName FROM pets_1.Student WHERE LName = 'Smith' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.PetID FROM Scan_1 JOIN Scan_2 ON Scan_1.StuID = Scan_2.StuID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.petid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid WHERE T1.Lname = 'Smith'"
  },
  {
    "id":"ec8b526c55f9a125041bfebfcd2a771dfccddcf370f22042f6b1147afdcaafe4",
    "db_id":"pets_1",
    "question":"Find the number of pets for each student who has any pet and student id.",
    "query":"SELECT count ( * ) AS Count_Star , T1.stuid FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid GROUP BY T1.stuid OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.StuID , #2.Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.StuID , #2.Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT StuID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.StuID, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ) SELECT * FROM Join_4",
    "clean_query":"SELECT count ( * ) AS Count_Star , T1.stuid FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid GROUP BY T1.stuid"
  },
  {
    "id":"c3e439034b6fe1bfae33907fecac07de08ca1c6e4692dd9426bffe18b4777f26",
    "db_id":"pets_1",
    "question":"For students who have pets , how many pets does each student have ? list their ids instead of names .",
    "query":"select count ( * ) AS Count_Star , t1.stuid FROM pets_1.student AS t1 WITH (FORCESCAN) join pets_1.has_pet as t2 WITH (FORCESCAN) on t1.stuid = t2.stuid group by t1.stuid OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.StuID , #2.Count_Star ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.StuID , #2.Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT StuID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.StuID, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ) SELECT * FROM Join_4",
    "clean_query":"select count ( * ) AS Count_Star , t1.stuid FROM pets_1.student AS t1  join pets_1.has_pet as t2  on t1.stuid = t2.stuid group by t1.stuid"
  },
  {
    "id":"a7461adf7f778f867afb8fde575dd4680f7c8c40ac917ef8e354e11a8e01b73b",
    "db_id":"pets_1",
    "question":"Find the first name and gender of student who have more than one pet.",
    "query":"SELECT T1.fname , T1.sex FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID , Sex , Fname ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.Fname , #2.Count_Star , #3.Sex ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Sex , Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID , Sex , Fname ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.Fname , #2.Count_Star , #3.Sex ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Sex , Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT StuID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID, Sex, Fname FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.Fname, Aggregate_2.Count_Star, Scan_3.Sex FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ), Filter_5 AS ( SELECT Sex, Fname FROM Join_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.fname , T1.sex FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1"
  },
  {
    "id":"c07bf8a5269d2f7e7fb84ce9604b7842d48ec4c1986c122f1982a9ad675efea5",
    "db_id":"pets_1",
    "question":"What is the first name and gender of the all the students who have more than one pet?",
    "query":"SELECT T1.fname , T1.sex FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID , Sex , Fname ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.Fname , #2.Count_Star , #3.Sex ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Sex , Fname ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Has_Pet ] Output [ StuID ] ; #2 = Aggregate [ #1 ] GroupBy [ StuID ] Output [ StuID , countstar AS Count_Star ] ; #3 = Scan Table [ Student ] Output [ StuID , Sex , Fname ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.StuID = #3.StuID ] Output [ #3.Fname , #2.Count_Star , #3.Sex ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Sex , Fname ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID FROM pets_1.Has_Pet ), Aggregate_2 AS ( SELECT StuID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY StuID ), Scan_3 AS ( SELECT StuID, Sex, Fname FROM pets_1.Student ), Join_4 AS ( SELECT Scan_3.Fname, Aggregate_2.Count_Star, Scan_3.Sex FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.StuID = Scan_3.StuID ), Filter_5 AS ( SELECT Sex, Fname FROM Join_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.fname , T1.sex FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid GROUP BY T1.fname , T1.sex , T1.stuid HAVING count ( * ) > 1"
  },
  {
    "id":"6fe75339376762c506c994080ce1289b6391db7a92fe1aad3b3a7528e9c66869",
    "db_id":"pets_1",
    "question":"Find the last name of the student who has a cat that is age 3.",
    "query":"SELECT T1.lname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ pet_age = 3 AND PetType = 'cat' ] Output [ pet_age , PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , LName ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.LName ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age = 3 AND PetType = 'cat' ] Output [ pet_age , PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , LName ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.LName ]",
    "cte":"WITH Scan_1 AS ( SELECT pet_age, PetID, PetType FROM pets_1.Pets WHERE pet_age = 3 AND PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, LName FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.LName FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T1.lname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat'"
  },
  {
    "id":"546ff06611de4b3ac4065c402b00c84c621762013d5a957cafdab6b13860ac83",
    "db_id":"pets_1",
    "question":"What is the last name of the student who has a cat that is 3 years old?",
    "query":"SELECT T1.lname FROM pets_1.student AS T1 WITH (FORCESCAN) JOIN pets_1.has_pet AS T2 WITH (FORCESCAN) ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3 WITH (FORCESCAN) ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Pets ] Predicate [ pet_age = 3 AND PetType = 'cat' ] Output [ pet_age , PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , LName ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.LName ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Pets ] Predicate [ pet_age = 3 AND PetType = 'cat' ] Output [ pet_age , PetID , PetType ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID , PetID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.PetID = #2.PetID ] Output [ #2.StuID ] ; #4 = Scan Table [ Student ] Output [ StuID , LName ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.StuID = #4.StuID ] Output [ #4.LName ]",
    "cte":"WITH Scan_1 AS ( SELECT pet_age, PetID, PetType FROM pets_1.Pets WHERE pet_age = 3 AND PetType = 'cat' ), Scan_2 AS ( SELECT StuID, PetID FROM pets_1.Has_Pet ), Join_3 AS ( SELECT Scan_2.StuID FROM Scan_1 JOIN Scan_2 ON Scan_1.PetID = Scan_2.PetID ), Scan_4 AS ( SELECT StuID, LName FROM pets_1.Student ), Join_5 AS ( SELECT Scan_4.LName FROM Join_3 JOIN Scan_4 ON Join_3.StuID = Scan_4.StuID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T1.lname FROM pets_1.student AS T1  JOIN pets_1.has_pet AS T2  ON T1.stuid = T2.stuid JOIN pets_1.pets AS T3  ON T3.petid = T2.petid WHERE T3.pet_age = 3 AND T3.pettype = 'cat'"
  },
  {
    "id":"dbfcc50884c2d7e4346c3172892aa8910971ebcd3c46dba825586dd3347b9a24",
    "db_id":"pets_1",
    "question":"Find the average age of students who do not have any pet .",
    "query":"select avg ( age ) AS Avg_age FROM pets_1.student WITH (FORCESCAN) where stuid not in ( select stuid FROM pets_1.has_pet WITH (FORCESCAN) ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student ] Output [ StuID , Age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.StuID IS NULL OR #1.StuID = #2.StuID ] Output [ #1.Age ] ; #4 = Aggregate [ #3 ] Output [ AVG(Age) AS Avg_Age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.StuID IS NULL OR #1.StuID = #2.StuID ] Output [ #1.Age ] ; #4 = Aggregate [ #3 ] Output [ AVG(Age) AS Avg_Age ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID, Age FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Has_Pet ), Except_3 AS ( SELECT Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(Age) AS Avg_Age FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"select avg ( age ) AS Avg_age FROM pets_1.student  where stuid not in ( select stuid FROM pets_1.has_pet  )"
  },
  {
    "id":"ba1ee9f549168c44bb796a2bbdc8075e64e6df7ca595e5b4dd6c3ab0e7dc817c",
    "db_id":"pets_1",
    "question":"What is the average age for all students who do not own any pets ?",
    "query":"select avg ( age ) AS Avg_age FROM pets_1.student WITH (FORCESCAN) where stuid not in ( select stuid FROM pets_1.has_pet WITH (FORCESCAN) ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student ] Output [ StuID , Age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.StuID IS NULL OR #1.StuID = #2.StuID ] Output [ #1.Age ] ; #4 = Aggregate [ #3 ] Output [ AVG(Age) AS Avg_Age ]",
    "prefixed_qpl":"pets_1 | #1 = Scan Table [ Student ] Output [ StuID , Age ] ; #2 = Scan Table [ Has_Pet ] Output [ StuID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.StuID IS NULL OR #1.StuID = #2.StuID ] Output [ #1.Age ] ; #4 = Aggregate [ #3 ] Output [ AVG(Age) AS Avg_Age ]",
    "cte":"WITH Scan_1 AS ( SELECT StuID, Age FROM pets_1.Student ), Scan_2 AS ( SELECT StuID FROM pets_1.Has_Pet ), Except_3 AS ( SELECT Scan_1.Age FROM Scan_1 WHERE StuID NOT IN (SELECT StuID FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(Age) AS Avg_Age FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"select avg ( age ) AS Avg_age FROM pets_1.student  where stuid not in ( select stuid FROM pets_1.has_pet  )"
  },
  {
    "id":"473d7b41fadce5025b641f1cbfabfb4e0142a9cf4a859267322201b8fc5f9040",
    "db_id":"car_1",
    "question":"How many continents are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ continents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ continents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.continents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS"
  },
  {
    "id":"0d5508ac8b087357c9f03f1531347cce564d823440b751d59a250ecf04a7a379",
    "db_id":"car_1",
    "question":"What is the number of continents?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ continents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ continents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.continents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CONTINENTS"
  },
  {
    "id":"2914754a1a51a5b100d4ff75aff0952ddcad058096534f9be42de91ed54669db",
    "db_id":"car_1",
    "question":"How many countries does each continent have? List the continent id, continent name and the number of countries.",
    "query":"SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countries ] Output [ Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #3 = Scan Table [ continents ] Output [ Continent , ContId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Continent = #3.ContId ] Output [ #3.ContId , #2.Count_Star , #3.Continent ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Output [ Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #3 = Scan Table [ continents ] Output [ Continent , ContId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Continent = #3.ContId ] Output [ #3.ContId , #2.Count_Star , #3.Continent ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent FROM car_1.countries ), Aggregate_2 AS ( SELECT Continent, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Continent ), Scan_3 AS ( SELECT Continent, ContId FROM car_1.continents ), Join_4 AS ( SELECT Scan_3.ContId, Aggregate_2.Count_Star, Scan_3.Continent FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Continent = Scan_3.ContId ) SELECT * FROM Join_4",
    "clean_query":"SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent"
  },
  {
    "id":"be8751acd82b0091ce91e727267eb60c7b15c95c21bf3d8d9f7e241ed60fd7a3",
    "db_id":"car_1",
    "question":"For each continent, list its id, name, and how many countries it has?",
    "query":"SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countries ] Output [ Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #3 = Scan Table [ continents ] Output [ Continent , ContId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Continent = #3.ContId ] Output [ #3.ContId , #2.Count_Star , #3.Continent ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Output [ Continent ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #3 = Scan Table [ continents ] Output [ Continent , ContId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Continent = #3.ContId ] Output [ #3.ContId , #2.Count_Star , #3.Continent ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent FROM car_1.countries ), Aggregate_2 AS ( SELECT Continent, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Continent ), Scan_3 AS ( SELECT Continent, ContId FROM car_1.continents ), Join_4 AS ( SELECT Scan_3.ContId, Aggregate_2.Count_Star, Scan_3.Continent FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Continent = Scan_3.ContId ) SELECT * FROM Join_4",
    "clean_query":"SELECT T1.ContId , T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.Continent GROUP BY T1.ContId , T1.Continent"
  },
  {
    "id":"6c99977d3e70f4f90d745fa4f3116ae0f4423f66a5b9d7157fcf3fd8f13451ce",
    "db_id":"car_1",
    "question":"How many countries are listed?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ countries ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.countries ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES"
  },
  {
    "id":"b8e08896d0063efdc88fa6a6bffae66141b6086c3f792920f68aeffd8998b42f",
    "db_id":"car_1",
    "question":"How many countries exist?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ countries ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM car_1.countries ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.COUNTRIES"
  },
  {
    "id":"9185b99e6274a74f1074d9390674f68dc176f3bd9f95bc67ad3b09b878fccc3a",
    "db_id":"car_1",
    "question":"How many models does each car maker produce? List maker full name, id and the number.",
    "query":"SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT Maker, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Id, FullName FROM car_1.car_makers ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.FullName, Scan_3.Id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
    "clean_query":"SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id"
  },
  {
    "id":"1f4b6b8fe58168e372e3265b1dd9ea23b4530538ad134a2ffba2567cc80d9b8e",
    "db_id":"car_1",
    "question":"What is the full name of each car maker, along with its id and how many models it produces?",
    "query":"SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT Maker, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Id, FullName FROM car_1.car_makers ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.FullName, Scan_3.Id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
    "clean_query":"SELECT T1.FullName , T1.Id , count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id"
  },
  {
    "id":"ed11ccc0c371befb3ffe3ea94cf16a1727cea5fdbd0c2379b78d4891bcd8f1a9",
    "db_id":"car_1",
    "question":"Which model of the car has the minimum horsepower?",
    "query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Id , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower ASC ] Output [ Horsepower , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Id , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower ASC ] Output [ Horsepower , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Horsepower FROM car_1.cars_data ), Scan_2 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Model FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower ASC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC"
  },
  {
    "id":"4403cae911a936dae540f929868bd1cf333130dd770d1fd8be82c3244f48249c",
    "db_id":"car_1",
    "question":"What is the model of the car with the smallest amount of horsepower?",
    "query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Id , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower ASC ] Output [ Horsepower , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Id , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower ASC ] Output [ Horsepower , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Horsepower FROM car_1.cars_data ), Scan_2 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Model FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower ASC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id ORDER BY T2.horsepower ASC"
  },
  {
    "id":"08dc2bd47d43756549ebaa3fc4b93ef053b8ccb78cf36090fb8b63aa8b29c96f",
    "db_id":"car_1",
    "question":"Find the model of the car whose weight is below the average weight.",
    "query":"SELECT T1.model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA WITH (FORCESCAN) ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Weight ] ; #3 = Aggregate [ #2 ] Output [ AVG(Weight) AS Avg_Weight ] ; #4 = Scan Table [ cars_data ] Output [ Id , Weight ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Weight < #3.Avg_Weight ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Weight ] ; #3 = Aggregate [ #2 ] Output [ AVG(Weight) AS Avg_Weight ] ; #4 = Scan Table [ cars_data ] Output [ Id , Weight ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Weight < #3.Avg_Weight ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Model, MakeId FROM car_1.car_names ), Scan_2 AS ( SELECT Weight FROM car_1.cars_data ), Aggregate_3 AS ( SELECT AVG(Weight) AS Avg_Weight FROM Scan_2 ), Scan_4 AS ( SELECT Id, Weight FROM car_1.cars_data ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Weight < Aggregate_3.Avg_Weight ), Join_6 AS ( SELECT Scan_1.Model FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
    "clean_query":"SELECT T1.model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA  )"
  },
  {
    "id":"bd50cd3346fb9f7ff49fe956873de002222ca6019f59ecc9c76a1e5b989eb493",
    "db_id":"car_1",
    "question":"What is the model for the car with a weight smaller than the average?",
    "query":"SELECT T1.model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA WITH (FORCESCAN) ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Weight ] ; #3 = Aggregate [ #2 ] Output [ AVG(Weight) AS Avg_Weight ] ; #4 = Scan Table [ cars_data ] Output [ Id , Weight ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Weight < #3.Avg_Weight ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Weight ] ; #3 = Aggregate [ #2 ] Output [ AVG(Weight) AS Avg_Weight ] ; #4 = Scan Table [ cars_data ] Output [ Id , Weight ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Weight < #3.Avg_Weight ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Model, MakeId FROM car_1.car_names ), Scan_2 AS ( SELECT Weight FROM car_1.cars_data ), Aggregate_3 AS ( SELECT AVG(Weight) AS Avg_Weight FROM Scan_2 ), Scan_4 AS ( SELECT Id, Weight FROM car_1.cars_data ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Weight < Aggregate_3.Avg_Weight ), Join_6 AS ( SELECT Scan_1.Model FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
    "clean_query":"SELECT T1.model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Weight < ( SELECT avg ( Weight ) AS Avg_Weight FROM car_1.CARS_DATA  )"
  },
  {
    "id":"f13a210a276fb5976c3336f04458fd9194497a3627777813ef7e4bed4ddb8d7c",
    "db_id":"car_1",
    "question":"Find the name of the makers that produced some cars in the year of 1970?",
    "query":"SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3 WITH (FORCESCAN) ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T3.MakeId = T4.id WHERE T4.year = '1970'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Id , Maker ] ; #2 = Scan Table [ cars_data ] Predicate [ Year = 1970 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Scan Table [ model_list ] Output [ Maker , Model ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.Maker ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.Maker ] Distinct [ true ] Output [ #1.Maker ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Id , Maker ] ; #2 = Scan Table [ cars_data ] Predicate [ Year = 1970 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Scan Table [ model_list ] Output [ Maker , Model ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.Maker ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.Maker ] Distinct [ true ] Output [ #1.Maker ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Maker FROM car_1.car_makers ), Scan_2 AS ( SELECT Id, Year FROM car_1.cars_data WHERE Year = 1970 ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Scan_5 AS ( SELECT Maker, Model FROM car_1.model_list ), Join_6 AS ( SELECT Scan_5.Maker FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Scan_1.Maker FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.Maker ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3  ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4  ON T3.MakeId = T4.id WHERE T4.year = '1970'"
  },
  {
    "id":"d435cfadf939ca48c701dd06598c00e6e2ef5bc5c0d70ad308404adeb96b8b4e",
    "db_id":"car_1",
    "question":"What is the name of the different car makers who produced a car in 1970?",
    "query":"SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3 WITH (FORCESCAN) ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T3.MakeId = T4.id WHERE T4.year = '1970'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Id , Maker ] ; #2 = Scan Table [ cars_data ] Predicate [ Year = 1970 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Scan Table [ model_list ] Output [ Maker , Model ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.Maker ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.Maker ] Distinct [ true ] Output [ #1.Maker ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Id , Maker ] ; #2 = Scan Table [ cars_data ] Predicate [ Year = 1970 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Scan Table [ model_list ] Output [ Maker , Model ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.Maker ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.Maker ] Distinct [ true ] Output [ #1.Maker ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Maker FROM car_1.car_makers ), Scan_2 AS ( SELECT Id, Year FROM car_1.cars_data WHERE Year = 1970 ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Scan_5 AS ( SELECT Maker, Model FROM car_1.model_list ), Join_6 AS ( SELECT Scan_5.Maker FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Scan_1.Maker FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.Maker ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3  ON T2.model = T3.model JOIN car_1.CARS_DATA AS T4  ON T3.MakeId = T4.id WHERE T4.year = '1970'"
  },
  {
    "id":"ad21629f0a4e48341926c3e116c4f3ae3e68f41715b9f118146b1b81010b5be1",
    "db_id":"car_1",
    "question":"Find the make and production time of the cars that were produced in the earliest year?",
    "query":"SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) )  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Year) AS Min_Year ] ; #3 = Scan Table [ cars_data ] Output [ Id , Year ] ; #4 = Join [ #2, #3 ] Predicate [ #3.Year = #2.Min_Year ] Output [ #3.Id , #3.Year ] ; #5 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.MakeId = #4.Id ] Output [ #4.Year , #5.Make ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Year) AS Min_Year ] ; #3 = Scan Table [ cars_data ] Output [ Id , Year ] ; #4 = Join [ #2, #3 ] Predicate [ #3.Year = #2.Min_Year ] Output [ #3.Id , #3.Year ] ; #5 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.MakeId = #4.Id ] Output [ #4.Year , #5.Make ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MIN(Year) AS Min_Year FROM Scan_1 ), Scan_3 AS ( SELECT Id, Year FROM car_1.cars_data ), Join_4 AS ( SELECT Scan_3.Id, Scan_3.Year FROM Aggregate_2 JOIN Scan_3 ON Scan_3.Year = Aggregate_2.Min_Year ), Scan_5 AS ( SELECT Make, MakeId FROM car_1.car_names ), Join_6 AS ( SELECT Join_4.Year, Scan_5.Make FROM Join_4 JOIN Scan_5 ON Scan_5.MakeId = Join_4.Id ) SELECT * FROM Join_6",
    "clean_query":"SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA  )"
  },
  {
    "id":"71b8e3eee7e7618b7730a3dc215c5d838411a0a424df17b4823a8f1ed6b56062",
    "db_id":"car_1",
    "question":"What is the maker of the carr produced in the earliest year and what year was it?",
    "query":"SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) )  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Year) AS Min_Year ] ; #3 = Scan Table [ cars_data ] Output [ Id , Year ] ; #4 = Join [ #2, #3 ] Predicate [ #3.Year = #2.Min_Year ] Output [ #3.Id , #3.Year ] ; #5 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.MakeId = #4.Id ] Output [ #4.Year , #5.Make ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ MIN(Year) AS Min_Year ] ; #3 = Scan Table [ cars_data ] Output [ Id , Year ] ; #4 = Join [ #2, #3 ] Predicate [ #3.Year = #2.Min_Year ] Output [ #3.Id , #3.Year ] ; #5 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.MakeId = #4.Id ] Output [ #4.Year , #5.Make ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MIN(Year) AS Min_Year FROM Scan_1 ), Scan_3 AS ( SELECT Id, Year FROM car_1.cars_data ), Join_4 AS ( SELECT Scan_3.Id, Scan_3.Year FROM Aggregate_2 JOIN Scan_3 ON Scan_3.Year = Aggregate_2.Min_Year ), Scan_5 AS ( SELECT Make, MakeId FROM car_1.car_names ), Join_6 AS ( SELECT Join_4.Year, Scan_5.Make FROM Join_4 JOIN Scan_5 ON Scan_5.MakeId = Join_4.Id ) SELECT * FROM Join_6",
    "clean_query":"SELECT T2.Make , T1.Year FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T1.Year = ( SELECT min ( YEAR ) AS Min_YEAR FROM car_1.CARS_DATA  )"
  },
  {
    "id":"63184492d88ed5c4c27ba64d205fbe596fe665ec2cc7351381b9572871047832",
    "db_id":"car_1",
    "question":"Which distinct car models are the produced after 1980?",
    "query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.id WHERE T3.year > 1980  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Model ] ; #2 = Scan Table [ cars_data ] Predicate [ Year > 1980 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Model = #4.Model ] Distinct [ true ] Output [ #1.Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Model ] ; #2 = Scan Table [ cars_data ] Predicate [ Year > 1980 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Model = #4.Model ] Distinct [ true ] Output [ #1.Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Model FROM car_1.model_list ), Scan_2 AS ( SELECT Id, Year FROM car_1.cars_data WHERE Year > 1980 ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Join_5 AS ( SELECT DISTINCT Scan_1.Model FROM Scan_1 JOIN Join_4 ON Scan_1.Model = Join_4.Model ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.id WHERE T3.year > 1980"
  },
  {
    "id":"3060597756a5391c591fd7056a8c19f57f2d440c443ea414541bc487cacf96a2",
    "db_id":"car_1",
    "question":"What are the different models for the cards produced after 1980?",
    "query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.id WHERE T3.year > 1980  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Model ] ; #2 = Scan Table [ cars_data ] Predicate [ Year > 1980 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Model = #4.Model ] Distinct [ true ] Output [ #1.Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Model ] ; #2 = Scan Table [ cars_data ] Predicate [ Year > 1980 ] Output [ Id , Year ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.MakeId ] Output [ #3.Model ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Model = #4.Model ] Distinct [ true ] Output [ #1.Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Model FROM car_1.model_list ), Scan_2 AS ( SELECT Id, Year FROM car_1.cars_data WHERE Year > 1980 ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.MakeId ), Join_5 AS ( SELECT DISTINCT Scan_1.Model FROM Scan_1 JOIN Join_4 ON Scan_1.Model = Join_4.Model ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.model = T2.model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.id WHERE T3.year > 1980"
  },
  {
    "id":"1dd789dce8dca1a681e95be275697f6194aebfedc41b85f2d3c370144d719682",
    "db_id":"car_1",
    "question":"How many car makers are there in each continents? List the continent name and the count.",
    "query":"SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3 WITH (FORCESCAN) ON T2.CountryId = T3.Country GROUP BY T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ continents ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.Continent ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.ContId = #4.Continent ] Output [ #1.Continent ] ; #6 = Aggregate [ #5 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ continents ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.Continent ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.ContId = #4.Continent ] Output [ #1.Continent ] ; #6 = Aggregate [ #5 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, ContId FROM car_1.continents ), Scan_2 AS ( SELECT Continent, CountryId FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.Continent FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Join_5 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Join_4 ON Scan_1.ContId = Join_4.Continent ), Aggregate_6 AS ( SELECT Continent, COUNT(*) AS Count_Star FROM Join_5 GROUP BY Continent ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3  ON T2.CountryId = T3.Country GROUP BY T1.Continent"
  },
  {
    "id":"5bb4eec216228c8f823b9444d1035d1d7f90937c23381a3a303840923469d256",
    "db_id":"car_1",
    "question":"What is the name of each continent and how many car makers are there in each one?",
    "query":"SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3 WITH (FORCESCAN) ON T2.CountryId = T3.Country GROUP BY T1.Continent  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ continents ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.Continent ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.ContId = #4.Continent ] Output [ #1.Continent ] ; #6 = Aggregate [ #5 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ continents ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.Continent ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.ContId = #4.Continent ] Output [ #1.Continent ] ; #6 = Aggregate [ #5 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, ContId FROM car_1.continents ), Scan_2 AS ( SELECT Continent, CountryId FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.Continent FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Join_5 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Join_4 ON Scan_1.ContId = Join_4.Continent ), Aggregate_6 AS ( SELECT Continent, COUNT(*) AS Count_Star FROM Join_5 GROUP BY Continent ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT T1.Continent , count ( * ) AS Count_Star FROM car_1.CONTINENTS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.ContId = T2.continent JOIN car_1.car_makers AS T3  ON T2.CountryId = T3.Country GROUP BY T1.Continent"
  },
  {
    "id":"eb3cde0276a0fc8b1f8d2f8fafb35798919522c42a6092dd8e015b09b31af5f9",
    "db_id":"car_1",
    "question":"Which of the countries has the most car makers? List the country name.",
    "query":"SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), TopSort_5 AS ( SELECT TOP 1 Count_Star, CountryName FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC"
  },
  {
    "id":"1cc43d0dd4258523da70628365e645be9219fddc3472704ea11ef01afdc90b4d",
    "db_id":"car_1",
    "question":"What is the name of the country with the most car makers?",
    "query":"SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), TopSort_5 AS ( SELECT TOP 1 Count_Star, CountryName FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.CountryName FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId GROUP BY T2.CountryName , T1.Country ORDER BY Count ( * ) DESC"
  },
  {
    "id":"0f511d2d227935024ef20380b60fb30dd28ff843040398025d6c1cb4cff1ce93",
    "db_id":"car_1",
    "question":"How many car models are produced by each maker ? Only list the count and the maker full name .",
    "query":"select count ( * ) AS Count_Star , t2.fullname FROM car_1.model_list AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.maker = t2.id group by t2.fullname , t2.id  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT Maker, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Id, FullName FROM car_1.car_makers ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.FullName FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
    "clean_query":"select count ( * ) AS Count_Star , t2.fullname FROM car_1.model_list AS t1  join car_1.car_makers as t2  on t1.maker = t2.id group by t2.fullname , t2.id"
  },
  {
    "id":"587619e0bf6dca2cc715654f4d71bcfd092fea72301454feec993fd1010054e2",
    "db_id":"car_1",
    "question":"What is the number of car models that are produced by each maker and what is the id and full name of each maker?",
    "query":"SELECT Count ( * ) AS Count_Star , T2.FullName , T2.id FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.Maker = T2.Id GROUP BY T2.FullName , T2.id  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT Maker, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Id, FullName FROM car_1.car_makers ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.FullName, Scan_3.Id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ) SELECT * FROM Join_4",
    "clean_query":"SELECT Count ( * ) AS Count_Star , T2.FullName , T2.id FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.Maker = T2.Id GROUP BY T2.FullName , T2.id"
  },
  {
    "id":"6b4935ecf21e96347d09f914c1134d872dd90cea1d200906b8422cec79050abe",
    "db_id":"car_1",
    "question":"What is the accelerate of the car make amc hornet sportabout (sw)?",
    "query":"SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_names ] Predicate [ Make = 'amc hornet sportabout (sw)' ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Predicate [ Make = 'amc hornet sportabout (sw)' ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate ]",
    "cte":"WITH Scan_1 AS ( SELECT MakeId, Make FROM car_1.car_names WHERE Make = 'amc hornet sportabout (sw)' ), Scan_2 AS ( SELECT Accelerate, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Accelerate FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'"
  },
  {
    "id":"9f6ea46405112628df6ab798bc562f0bebb75f5ea0d962a455271e949a879db5",
    "db_id":"car_1",
    "question":"How much does the car accelerate that makes amc hornet sportabout (sw)?",
    "query":"SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_names ] Predicate [ Make = 'amc hornet sportabout (sw)' ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Predicate [ Make = 'amc hornet sportabout (sw)' ] Output [ MakeId , Make ] ; #2 = Scan Table [ cars_data ] Output [ Accelerate , Id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Accelerate ]",
    "cte":"WITH Scan_1 AS ( SELECT MakeId, Make FROM car_1.car_names WHERE Make = 'amc hornet sportabout (sw)' ), Scan_2 AS ( SELECT Accelerate, Id FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Accelerate FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Accelerate FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)'"
  },
  {
    "id":"7c03fdfb4bdd1f01de1be9c484bed41e27e47fc1fbfbf8b8c8258bc22293fd9e",
    "db_id":"car_1",
    "question":"How many car makers are there in france?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countries ] Predicate [ CountryName = 'france' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'france' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'france' ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'"
  },
  {
    "id":"0ed3028cce8847cc6d514f0cf58b7033f1af4dc410e9a4a107a33b12e6c7dcd6",
    "db_id":"car_1",
    "question":"What is the number of makers of care in France?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.COUNTRIES AS T2 WITH (FORCESCAN) ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countries ] Predicate [ CountryName = 'france' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'france' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'france' ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.COUNTRIES AS T2  ON T1.Country = T2.CountryId WHERE T2.CountryName = 'france'"
  },
  {
    "id":"04d01fafdfe0a2fc87f5e6a971770df71d346fe8153bd78a6c9fa41da7e500a4",
    "db_id":"car_1",
    "question":"How many car models are produced in the usa?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3 WITH (FORCESCAN) ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countries ] Predicate [ CountryName = 'usa' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Id , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #2.Id ] ; #4 = Scan Table [ model_list ] Output [ Maker ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Id = #4.Maker ] Output [ #3.Id ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'usa' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Id , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #2.Id ] ; #4 = Scan Table [ model_list ] Output [ Maker ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Id = #4.Maker ] Output [ #3.Id ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'usa' ), Scan_2 AS ( SELECT Id, Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_2.Id FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Scan_4 AS ( SELECT Maker FROM car_1.model_list ), Join_5 AS ( SELECT Join_3.Id FROM Join_3 JOIN Scan_4 ON Join_3.Id = Scan_4.Maker ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3  ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'"
  },
  {
    "id":"2686e428ed6dee19e01cd063666a64aeceba24051c34ee875917395fcb3c1cfb",
    "db_id":"car_1",
    "question":"What is the count of the car models produced in the United States?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3 WITH (FORCESCAN) ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countries ] Predicate [ CountryName = 'usa' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Id , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #2.Id ] ; #4 = Scan Table [ model_list ] Output [ Maker ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Id = #4.Maker ] Output [ #3.Id ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Predicate [ CountryName = 'usa' ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Id , Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #2.Id ] ; #4 = Scan Table [ model_list ] Output [ Maker ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Id = #4.Maker ] Output [ #3.Id ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries WHERE CountryName = 'usa' ), Scan_2 AS ( SELECT Id, Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_2.Id FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Scan_4 AS ( SELECT Maker FROM car_1.model_list ), Join_5 AS ( SELECT Join_3.Id FROM Join_3 JOIN Scan_4 ON Join_3.Id = Scan_4.Maker ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.Maker = T2.Id JOIN car_1.COUNTRIES AS T3  ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa'"
  },
  {
    "id":"d008496febb26c97a226a63cf4430e16490d2020d9a76a94f3440235c54a99f8",
    "db_id":"car_1",
    "question":"What is the average miles per gallon(mpg) of the cars with 4 cylinders?",
    "query":"SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders = 4  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ MPG , Cylinders ] ; #2 = Aggregate [ #1 ] Output [ AVG(MPG) AS Avg_MPG ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ MPG , Cylinders ] ; #2 = Aggregate [ #1 ] Output [ AVG(MPG) AS Avg_MPG ]",
    "cte":"WITH Scan_1 AS ( SELECT MPG, Cylinders FROM car_1.cars_data WHERE Cylinders = 4 ), Aggregate_2 AS ( SELECT AVG(MPG) AS Avg_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA  WHERE Cylinders = 4"
  },
  {
    "id":"30d1ee42433721023f9e094e933c912d93f73b99e7b74ebcee784b5b31fe5f57",
    "db_id":"car_1",
    "question":"What is the average miles per gallon of all the cards with 4 cylinders?",
    "query":"SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders = 4  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ MPG , Cylinders ] ; #2 = Aggregate [ #1 ] Output [ AVG(MPG) AS Avg_MPG ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ MPG , Cylinders ] ; #2 = Aggregate [ #1 ] Output [ AVG(MPG) AS Avg_MPG ]",
    "cte":"WITH Scan_1 AS ( SELECT MPG, Cylinders FROM car_1.cars_data WHERE Cylinders = 4 ), Aggregate_2 AS ( SELECT AVG(MPG) AS Avg_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( mpg ) AS Avg_mpg FROM car_1.CARS_DATA  WHERE Cylinders = 4"
  },
  {
    "id":"181a002a5e4f8fec27048244b795b5b3f13c9550a5947e3599925be1edb96f8a",
    "db_id":"car_1",
    "question":"What is the smallest weight of the car produced with 8 cylinders on 1974 ?",
    "query":"select min ( weight ) AS Min_weight FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 and year = 1974 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 AND Year = 1974 ] Output [ Year , Cylinders , Weight ] ; #2 = Aggregate [ #1 ] Output [ MIN(Weight) AS Min_Weight ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 AND Year = 1974 ] Output [ Year , Cylinders , Weight ] ; #2 = Aggregate [ #1 ] Output [ MIN(Weight) AS Min_Weight ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Cylinders, Weight FROM car_1.cars_data WHERE Cylinders = 8 AND Year = 1974 ), Aggregate_2 AS ( SELECT MIN(Weight) AS Min_Weight FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"select min ( weight ) AS Min_weight FROM car_1.cars_data  where cylinders = 8 and year = 1974"
  },
  {
    "id":"7724849737aab7b098851c89a0fd1ee146c0b00594fc5f0f2b2f6789ce855c51",
    "db_id":"car_1",
    "question":"What is the minimum weight of the car with 8 cylinders produced in 1974 ?",
    "query":"select min ( weight ) AS Min_weight FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 and year = 1974 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 AND Year = 1974 ] Output [ Year , Cylinders , Weight ] ; #2 = Aggregate [ #1 ] Output [ MIN(Weight) AS Min_Weight ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 AND Year = 1974 ] Output [ Year , Cylinders , Weight ] ; #2 = Aggregate [ #1 ] Output [ MIN(Weight) AS Min_Weight ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Cylinders, Weight FROM car_1.cars_data WHERE Cylinders = 8 AND Year = 1974 ), Aggregate_2 AS ( SELECT MIN(Weight) AS Min_Weight FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"select min ( weight ) AS Min_weight FROM car_1.cars_data  where cylinders = 8 and year = 1974"
  },
  {
    "id":"4a94a6a7efd98efae436bb2d28b838c67c042c12a753e7c5dd6189f43f8d246d",
    "db_id":"car_1",
    "question":"What are all the makers and models?",
    "query":"SELECT Maker , Model FROM car_1.MODEL_LIST WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker, Model FROM car_1.model_list ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Maker , Model FROM car_1.MODEL_LIST"
  },
  {
    "id":"9b93bef7838b4084eaaadeee2fb378c1b0abb129005052733376c12410782d8f",
    "db_id":"car_1",
    "question":"What are the makers and models?",
    "query":"SELECT Maker , Model FROM car_1.MODEL_LIST WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker, Model FROM car_1.model_list ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Maker , Model FROM car_1.MODEL_LIST"
  },
  {
    "id":"94d08d95b346a6cac868d8fad31eb0e5183488ba52e84f42ebb956b97efcf487",
    "db_id":"car_1",
    "question":"What are the countries having at least one car maker? List name and id.",
    "query":"SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #3.CountryId , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 1 ] Output [ CountryId , CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #3.CountryId , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 1 ] Output [ CountryId , CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Scan_3.CountryId, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT CountryId, CountryName FROM Join_4 WHERE Count_Star >= 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1"
  },
  {
    "id":"462c2d108962edbbd5ff717ecf50a4f519aa59429596a9368897cbebb5f5f36f",
    "db_id":"car_1",
    "question":"What are the names and ids of all countries with at least one car maker?",
    "query":"SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #3.CountryId , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 1 ] Output [ CountryId , CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #3.CountryName , #3.CountryId , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 1 ] Output [ CountryId , CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_4 AS ( SELECT Scan_3.CountryName, Scan_3.CountryId, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT CountryId, CountryName FROM Join_4 WHERE Count_Star >= 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.CountryName , T1.CountryId FROM car_1.COUNTRIES AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country GROUP BY T1.CountryName , T1.CountryId HAVING count ( * ) > = 1"
  },
  {
    "id":"59be649e519f17773648586a228606126215c8567bd97545d66fc8e90ecb75d5",
    "db_id":"car_1",
    "question":"What is the number of the cars with horsepower more than 150?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE horsepower > 150  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Horsepower > 150.0 ] Output [ Horsepower ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Horsepower > 150.0 ] Output [ Horsepower ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Horsepower FROM car_1.cars_data WHERE Horsepower > 150.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE horsepower > 150"
  },
  {
    "id":"fbac0a412afaaebdda79a93fc97de8b3c3e4f837db81219eb1e3f4c895f50186",
    "db_id":"car_1",
    "question":"What is the number of cars with a horsepower greater than 150?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE horsepower > 150  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Horsepower > 150.0 ] Output [ Horsepower ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Horsepower > 150.0 ] Output [ Horsepower ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Horsepower FROM car_1.cars_data WHERE Horsepower > 150.0 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE horsepower > 150"
  },
  {
    "id":"becf4ca70f8cd646140303dd9052c30e59cd6a3ef9f406a2c78bcfcddbac61ed",
    "db_id":"car_1",
    "question":"What is the average weight of cars each year?",
    "query":"SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY YEAR  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Year , Weight ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , AVG(Weight) AS Avg_Weight ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Year , Weight ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , AVG(Weight) AS Avg_Weight ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Weight FROM car_1.cars_data ), Aggregate_2 AS ( SELECT Year, AVG(Weight) AS Avg_Weight FROM Scan_1 GROUP BY Year ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA  GROUP BY YEAR"
  },
  {
    "id":"d007f7e960ee7114376f5b06337325a6a3415ddde9d9fc135cad7075ac451bb9",
    "db_id":"car_1",
    "question":"What is the average weight and year for each year?",
    "query":"SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY YEAR  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Year , Weight ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , AVG(Weight) AS Avg_Weight ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Year , Weight ] ; #2 = Aggregate [ #1 ] GroupBy [ Year ] Output [ Year , AVG(Weight) AS Avg_Weight ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Weight FROM car_1.cars_data ), Aggregate_2 AS ( SELECT Year, AVG(Weight) AS Avg_Weight FROM Scan_1 GROUP BY Year ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( Weight ) AS Avg_Weight , YEAR FROM car_1.CARS_DATA  GROUP BY YEAR"
  },
  {
    "id":"facbfa3fe4d0040431b7fdd4be746af38a6d427ca8d70f509c31b82ad1ae117b",
    "db_id":"car_1",
    "question":"Which countries in europe have at least 3 car manufacturers?",
    "query":"SELECT T1.CountryName FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CONTINENTS AS T2 WITH (FORCESCAN) ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ continents ] Predicate [ Continent = 'europe' ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId , CountryName ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ContId = #2.Continent ] Output [ #2.CountryName , #2.CountryId ] ; #4 = Scan Table [ car_makers ] Output [ Country ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryId = #4.Country ] Output [ #3.CountryName ] ; #6 = Aggregate [ #5 ] GroupBy [ CountryName ] Output [ CountryName , countstar AS Count_Star ] ; #7 = Filter [ #6 ] Predicate [ Count_Star >= 3 ] Output [ CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ continents ] Predicate [ Continent = 'europe' ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId , CountryName ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ContId = #2.Continent ] Output [ #2.CountryName , #2.CountryId ] ; #4 = Scan Table [ car_makers ] Output [ Country ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryId = #4.Country ] Output [ #3.CountryName ] ; #6 = Aggregate [ #5 ] GroupBy [ CountryName ] Output [ CountryName , countstar AS Count_Star ] ; #7 = Filter [ #6 ] Predicate [ Count_Star >= 3 ] Output [ CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, ContId FROM car_1.continents WHERE Continent = 'europe' ), Scan_2 AS ( SELECT Continent, CountryId, CountryName FROM car_1.countries ), Join_3 AS ( SELECT Scan_2.CountryName, Scan_2.CountryId FROM Scan_1 JOIN Scan_2 ON Scan_1.ContId = Scan_2.Continent ), Scan_4 AS ( SELECT Country FROM car_1.car_makers ), Join_5 AS ( SELECT Join_3.CountryName FROM Join_3 JOIN Scan_4 ON Join_3.CountryId = Scan_4.Country ), Aggregate_6 AS ( SELECT CountryName, COUNT(*) AS Count_Star FROM Join_5 GROUP BY CountryName ), Filter_7 AS ( SELECT CountryName FROM Aggregate_6 WHERE Count_Star >= 3 ) SELECT * FROM Filter_7",
    "clean_query":"SELECT T1.CountryName FROM car_1.COUNTRIES AS T1  JOIN car_1.CONTINENTS AS T2  ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3  ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3"
  },
  {
    "id":"df86c873292dcf609490b4289dedb15016c2b143c99e52d6908ecdb4262ae8c0",
    "db_id":"car_1",
    "question":"What are the names of all European countries with at least 3 manufacturers?",
    "query":"SELECT T1.CountryName FROM car_1.COUNTRIES AS T1 WITH (FORCESCAN) JOIN car_1.CONTINENTS AS T2 WITH (FORCESCAN) ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ continents ] Predicate [ Continent = 'europe' ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId , CountryName ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ContId = #2.Continent ] Output [ #2.CountryName , #2.CountryId ] ; #4 = Scan Table [ car_makers ] Output [ Country ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryId = #4.Country ] Output [ #3.CountryName ] ; #6 = Aggregate [ #5 ] GroupBy [ CountryName ] Output [ CountryName , countstar AS Count_Star ] ; #7 = Filter [ #6 ] Predicate [ Count_Star >= 3 ] Output [ CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ continents ] Predicate [ Continent = 'europe' ] Output [ Continent , ContId ] ; #2 = Scan Table [ countries ] Output [ Continent , CountryId , CountryName ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ContId = #2.Continent ] Output [ #2.CountryName , #2.CountryId ] ; #4 = Scan Table [ car_makers ] Output [ Country ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryId = #4.Country ] Output [ #3.CountryName ] ; #6 = Aggregate [ #5 ] GroupBy [ CountryName ] Output [ CountryName , countstar AS Count_Star ] ; #7 = Filter [ #6 ] Predicate [ Count_Star >= 3 ] Output [ CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, ContId FROM car_1.continents WHERE Continent = 'europe' ), Scan_2 AS ( SELECT Continent, CountryId, CountryName FROM car_1.countries ), Join_3 AS ( SELECT Scan_2.CountryName, Scan_2.CountryId FROM Scan_1 JOIN Scan_2 ON Scan_1.ContId = Scan_2.Continent ), Scan_4 AS ( SELECT Country FROM car_1.car_makers ), Join_5 AS ( SELECT Join_3.CountryName FROM Join_3 JOIN Scan_4 ON Join_3.CountryId = Scan_4.Country ), Aggregate_6 AS ( SELECT CountryName, COUNT(*) AS Count_Star FROM Join_5 GROUP BY CountryName ), Filter_7 AS ( SELECT CountryName FROM Aggregate_6 WHERE Count_Star >= 3 ) SELECT * FROM Filter_7",
    "clean_query":"SELECT T1.CountryName FROM car_1.COUNTRIES AS T1  JOIN car_1.CONTINENTS AS T2  ON T1.Continent = T2.ContId JOIN car_1.CAR_MAKERS AS T3  ON T1.CountryId = T3.Country WHERE T2.Continent = 'europe' GROUP BY T1.CountryName HAVING count ( * ) > = 3"
  },
  {
    "id":"b95a8aefa5bfc0f7d9606648e7afb9ffe2f3381c9f6147255b4f9af1b166c581",
    "db_id":"car_1",
    "question":"What is the maximum horsepower and the make of the car models with 3 cylinders?",
    "query":"SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 3 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Make ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Make ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 3 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Make ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Make ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Cylinders, Horsepower FROM car_1.cars_data WHERE Cylinders = 3 ), Scan_2 AS ( SELECT Make, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Make FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Make FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC"
  },
  {
    "id":"adefbd4e9ba07e8bb82a8588229dab1e6e1b09b92df70ea6bd801b28f5656147",
    "db_id":"car_1",
    "question":"What is the largest amount of horsepower for the models with 3 cylinders and what make is it?",
    "query":"SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 3 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Make ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Make ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 3 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Make ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Make ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Cylinders, Horsepower FROM car_1.cars_data WHERE Cylinders = 3 ), Scan_2 AS ( SELECT Make, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Make FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Make FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T2.horsepower , T1.Make FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.cylinders = 3 ORDER BY T2.horsepower DESC"
  },
  {
    "id":"ac7e3e3adfb4715eccfa332d41fb30d7348936c72be0b770bd95702e9377cd8e",
    "db_id":"car_1",
    "question":"Which model saves the most gasoline? That is to say, have the maximum miles per gallon.",
    "query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id ORDER BY T2.mpg DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Id , MPG ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.MPG , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ MPG DESC ] Output [ MPG , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Id , MPG ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.MPG , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ MPG DESC ] Output [ MPG , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, MPG FROM car_1.cars_data ), Scan_2 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.MPG, Scan_2.Model FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 MPG, Model FROM Join_3 ORDER BY MPG DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id ORDER BY T2.mpg DESC"
  },
  {
    "id":"a271ea14ee9ab5f826f8435851bff6696ec77d2382036bb6174344f6a211ff5c",
    "db_id":"car_1",
    "question":"What is the car model with the highest mpg ?",
    "query":"select TOP 1 t1.model FROM car_1.car_names AS t1 WITH (FORCESCAN) join car_1.cars_data as t2 WITH (FORCESCAN) on t1.makeid = t2.id order by t2.mpg desc  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Id , MPG ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.MPG , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ MPG DESC ] Output [ MPG , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Id , MPG ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.MPG , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ MPG DESC ] Output [ MPG , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, MPG FROM car_1.cars_data ), Scan_2 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.MPG, Scan_2.Model FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 MPG, Model FROM Join_3 ORDER BY MPG DESC ) SELECT * FROM TopSort_4",
    "clean_query":"select TOP 1 t1.model FROM car_1.car_names AS t1  join car_1.cars_data as t2  on t1.makeid = t2.id order by t2.mpg desc"
  },
  {
    "id":"5f3e14ec082234fc4bddff7754ddeef043a6e8f0f62b789c3def9fb2df884b1e",
    "db_id":"car_1",
    "question":"What is the average horsepower of the cars before 1980?",
    "query":"SELECT avg ( horsepower ) AS Avg_horsepower FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE YEAR < 1980  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Year < 1980 ] Output [ Year , Horsepower ] ; #2 = Aggregate [ #1 ] Output [ AVG(Horsepower) AS Avg_Horsepower ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year < 1980 ] Output [ Year , Horsepower ] ; #2 = Aggregate [ #1 ] Output [ AVG(Horsepower) AS Avg_Horsepower ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Horsepower FROM car_1.cars_data WHERE Year < 1980 ), Aggregate_2 AS ( SELECT AVG(Horsepower) AS Avg_Horsepower FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( horsepower ) AS Avg_horsepower FROM car_1.CARS_DATA  WHERE YEAR < 1980"
  },
  {
    "id":"47a6d2e06009bae4ce2b0899e83998340dd9d23146d200cab07b8592300f8254",
    "db_id":"car_1",
    "question":"What is the average horsepower for all cars produced before 1980 ?",
    "query":"select avg ( horsepower ) AS Avg_horsepower FROM car_1.cars_data WITH (FORCESCAN) where year < 1980  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Year < 1980 ] Output [ Year , Horsepower ] ; #2 = Aggregate [ #1 ] Output [ AVG(Horsepower) AS Avg_Horsepower ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year < 1980 ] Output [ Year , Horsepower ] ; #2 = Aggregate [ #1 ] Output [ AVG(Horsepower) AS Avg_Horsepower ]",
    "cte":"WITH Scan_1 AS ( SELECT Year, Horsepower FROM car_1.cars_data WHERE Year < 1980 ), Aggregate_2 AS ( SELECT AVG(Horsepower) AS Avg_Horsepower FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"select avg ( horsepower ) AS Avg_horsepower FROM car_1.cars_data  where year < 1980"
  },
  {
    "id":"c0c3b1cbaa2da81a562a00b83e42f0c9667e93d3156777f71ac2f1d636cfd4a6",
    "db_id":"car_1",
    "question":"What is the average edispl of the cars of model volvo?",
    "query":"SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Edispl ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Edispl ] ; #4 = Aggregate [ #3 ] Output [ AVG(Edispl) AS Avg_Edispl ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Edispl ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Edispl ] ; #4 = Aggregate [ #3 ] Output [ AVG(Edispl) AS Avg_Edispl ]",
    "cte":"WITH Scan_1 AS ( SELECT Model, MakeId FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Id, Edispl FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Edispl FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), Aggregate_4 AS ( SELECT AVG(Edispl) AS Avg_Edispl FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
  },
  {
    "id":"7150c07fb04ec364ebd00863c0abea6344eefeff62b6937753626258890e1907",
    "db_id":"car_1",
    "question":"What is the average edispl for all volvos?",
    "query":"SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Edispl ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Edispl ] ; #4 = Aggregate [ #3 ] Output [ AVG(Edispl) AS Avg_Edispl ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Edispl ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Edispl ] ; #4 = Aggregate [ #3 ] Output [ AVG(Edispl) AS Avg_Edispl ]",
    "cte":"WITH Scan_1 AS ( SELECT Model, MakeId FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Id, Edispl FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Edispl FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), Aggregate_4 AS ( SELECT AVG(Edispl) AS Avg_Edispl FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( T2.edispl ) AS Avg_edispl FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T1.Model = 'volvo'"
  },
  {
    "id":"245ef4bfa9b7661d4d74c480d37bfbbd1e0120f0ccb0f6c4f281bf958b53d2a7",
    "db_id":"car_1",
    "question":"What is the maximum accelerate for different number of cylinders?",
    "query":"SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY Cylinders  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Accelerate , Cylinders ] ; #2 = Aggregate [ #1 ] GroupBy [ Cylinders ] Output [ MAX(Accelerate) AS Max_Accelerate , Cylinders ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Cylinders ] ; #2 = Aggregate [ #1 ] GroupBy [ Cylinders ] Output [ MAX(Accelerate) AS Max_Accelerate , Cylinders ]",
    "cte":"WITH Scan_1 AS ( SELECT Accelerate, Cylinders FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MAX(Accelerate) AS Max_Accelerate, Cylinders FROM Scan_1 GROUP BY Cylinders ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA  GROUP BY Cylinders"
  },
  {
    "id":"4e2a3009bf1eeef36db8e5fde67079e87dc569572f0683cc2aa31d95e6f5b471",
    "db_id":"car_1",
    "question":"What is the maximum accelerate for all the different cylinders?",
    "query":"SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA WITH (FORCESCAN) GROUP BY Cylinders  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Accelerate , Cylinders ] ; #2 = Aggregate [ #1 ] GroupBy [ Cylinders ] Output [ MAX(Accelerate) AS Max_Accelerate , Cylinders ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Cylinders ] ; #2 = Aggregate [ #1 ] GroupBy [ Cylinders ] Output [ MAX(Accelerate) AS Max_Accelerate , Cylinders ]",
    "cte":"WITH Scan_1 AS ( SELECT Accelerate, Cylinders FROM car_1.cars_data ), Aggregate_2 AS ( SELECT MAX(Accelerate) AS Max_Accelerate, Cylinders FROM Scan_1 GROUP BY Cylinders ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( Accelerate ) AS Max_Accelerate , Cylinders FROM car_1.CARS_DATA  GROUP BY Cylinders"
  },
  {
    "id":"e630d361fd786cda956fb2025a82fdc0fa6c5815f9737403f9f381688f2661c1",
    "db_id":"car_1",
    "question":"Which model has the most version(make) of cars?",
    "query":"SELECT TOP 1 Model FROM car_1.CAR_NAMES WITH (FORCESCAN) GROUP BY Model ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ car_names ] Output [ Model ] ; #2 = Aggregate [ #1 ] GroupBy [ Model ] Output [ countstar AS Count_Star , Model ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Output [ Model ] ; #2 = Aggregate [ #1 ] GroupBy [ Model ] Output [ countstar AS Count_Star , Model ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Model FROM car_1.car_names ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Model FROM Scan_1 GROUP BY Model ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Model FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Model FROM car_1.CAR_NAMES  GROUP BY Model ORDER BY count ( * ) DESC"
  },
  {
    "id":"59affccbb588b409c985a1028b9e13bd2266620f0fdf99638a6fbb8439490855",
    "db_id":"car_1",
    "question":"What model has the most different versions?",
    "query":"SELECT TOP 1 Model FROM car_1.CAR_NAMES WITH (FORCESCAN) GROUP BY Model ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ car_names ] Output [ Model ] ; #2 = Aggregate [ #1 ] GroupBy [ Model ] Output [ countstar AS Count_Star , Model ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Output [ Model ] ; #2 = Aggregate [ #1 ] GroupBy [ Model ] Output [ countstar AS Count_Star , Model ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Model FROM car_1.car_names ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Model FROM Scan_1 GROUP BY Model ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Model FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Model FROM car_1.CAR_NAMES  GROUP BY Model ORDER BY count ( * ) DESC"
  },
  {
    "id":"1da527580c9c855544ac3513a1908359742acd8cd9962f04b70bd6599508a14b",
    "db_id":"car_1",
    "question":"How many cars have more than 4 cylinders?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 4  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders > 4 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 4 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 4 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 4"
  },
  {
    "id":"11df8747ba360172906df15c76c2aa949c4feade99a36210c6558fd502edde93",
    "db_id":"car_1",
    "question":"What is the number of cars with more than 4 cylinders?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 4  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders > 4 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 4 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 4 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 4"
  },
  {
    "id":"cf86a2583a04d0373d4ca4b2b0464985067d246fde2c58d8e2de54134a4528c4",
    "db_id":"car_1",
    "question":"how many cars were produced in 1980?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE YEAR = 1980  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Year = 1980 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year = 1980 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data WHERE Year = 1980 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE YEAR = 1980"
  },
  {
    "id":"d4a04c0e1753c6236ee149512841790fd345f9394462bbf66a484f68764d52ee",
    "db_id":"car_1",
    "question":"In 1980, how many cars were made?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE YEAR = 1980  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Year = 1980 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Year = 1980 ] Output [ Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Year FROM car_1.cars_data WHERE Year = 1980 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE YEAR = 1980"
  },
  {
    "id":"f30af95f9ee63fc7e4a5af67b0549b85c2b14a445a84b52ce75454c22eaaed7a",
    "db_id":"car_1",
    "question":"How many car models were produced by the maker with full name American Motor Company?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_makers ] Predicate [ FullName = 'American Motor Company' ] Output [ Id , FullName ] ; #2 = Scan Table [ model_list ] Output [ Maker ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.Maker ] Output [ #1.Id , #1.FullName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Predicate [ FullName = 'American Motor Company' ] Output [ Id , FullName ] ; #2 = Scan Table [ model_list ] Output [ Maker ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.Maker ] Output [ #1.Id , #1.FullName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, FullName FROM car_1.car_makers WHERE FullName = 'American Motor Company' ), Scan_2 AS ( SELECT Maker FROM car_1.model_list ), Join_3 AS ( SELECT Scan_1.Id, Scan_1.FullName FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.Maker ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'"
  },
  {
    "id":"00b406cd591e370b0ca414e76c4edb78d82b3c13b4b63b505216c99f888eb002",
    "db_id":"car_1",
    "question":"What is the number of car models created by the car maker American Motor Company?",
    "query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_makers ] Predicate [ FullName = 'American Motor Company' ] Output [ Id , FullName ] ; #2 = Scan Table [ model_list ] Output [ Maker ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.Maker ] Output [ #1.Id , #1.FullName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Predicate [ FullName = 'American Motor Company' ] Output [ Id , FullName ] ; #2 = Scan Table [ model_list ] Output [ Maker ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.Maker ] Output [ #1.Id , #1.FullName ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, FullName FROM car_1.car_makers WHERE FullName = 'American Motor Company' ), Scan_2 AS ( SELECT Maker FROM car_1.model_list ), Join_3 AS ( SELECT Scan_1.Id, Scan_1.FullName FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.Maker ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker WHERE T1.FullName = 'American Motor Company'"
  },
  {
    "id":"018da303b9516c988e9c24f88bd456d97adba3d25ba308c366e8eaa9027a509f",
    "db_id":"car_1",
    "question":"Which makers designed more than 3 car models? List full name and the id.",
    "query":"SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ Id , FullName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ Id , FullName ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT Maker, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Id, FullName FROM car_1.car_makers ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.FullName, Scan_3.Id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT Id, FullName FROM Join_4 WHERE Count_Star > 3 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3"
  },
  {
    "id":"532d1e15f99ebc54005a555098c494296d44412ee0fd0a417574833f09b82c13",
    "db_id":"car_1",
    "question":"What are the names and ids of all makers with more than 3 models?",
    "query":"SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ Id , FullName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ Maker , countstar AS Count_Star ] ; #3 = Scan Table [ car_makers ] Output [ Id , FullName ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #2.Count_Star , #3.FullName , #3.Id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ Id , FullName ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT Maker, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Id, FullName FROM car_1.car_makers ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.FullName, Scan_3.Id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT Id, FullName FROM Join_4 WHERE Count_Star > 3 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.FullName , T1.Id FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.FullName , T1.Id HAVING count ( * ) > 3"
  },
  {
    "id":"7e07965719bdc4b883c84663dcc9b66ffdf2d7e962e4fcf8cebbdc95bad61b70",
    "db_id":"car_1",
    "question":"Which distinctive models are produced by maker with the full name General Motors or weighing more than 3500?",
    "query":"SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Model , Maker ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Id = #3.MakeId ] Output [ #3.Model , #4.Weight ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.Model = #2.Model ] Output [ #2.Model , #2.Maker , #5.Weight ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.Maker = #1.Id ] Output [ #6.Model , #6.Weight , #1.FullName ] ; #8 = Filter [ #7 ] Predicate [ Weight > 3500 OR FullName = 'General Motors' ] Distinct [ true ] Output [ Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Model , Maker ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Id = #3.MakeId ] Output [ #3.Model , #4.Weight ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.Model = #2.Model ] Output [ #2.Model , #2.Maker , #5.Weight ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.Maker = #1.Id ] Output [ #6.Model , #6.Weight , #1.FullName ] ; #8 = Filter [ #7 ] Predicate [ Weight > 3500 OR FullName = 'General Motors' ] Distinct [ true ] Output [ Model ]",
    "cte":"WITH Scan_1 AS ( SELECT FullName, Id FROM car_1.car_makers ), Scan_2 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Scan_4 AS ( SELECT Weight, Id FROM car_1.cars_data ), Join_5 AS ( SELECT Scan_3.Model, Scan_4.Weight FROM Scan_3 JOIN Scan_4 ON Scan_4.Id = Scan_3.MakeId ), Join_6 AS ( SELECT Scan_2.Model, Scan_2.Maker, Join_5.Weight FROM Scan_2 JOIN Join_5 ON Join_5.Model = Scan_2.Model ), Join_7 AS ( SELECT Join_6.Model, Join_6.Weight, Scan_1.FullName FROM Scan_1 JOIN Join_6 ON Join_6.Maker = Scan_1.Id ), Filter_8 AS ( SELECT DISTINCT Model FROM Join_7 WHERE Weight > 3500 OR FullName = 'General Motors' ) SELECT * FROM Filter_8",
    "clean_query":"SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3  ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4  ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500"
  },
  {
    "id":"869d090908c20d389878b3c1a8c760b86d77771817c2396a1fe57ce4f1537348",
    "db_id":"car_1",
    "question":"What are the different models created by either the car maker General Motors or weighed more than 3500?",
    "query":"SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3 WITH (FORCESCAN) ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4 WITH (FORCESCAN) ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Model , Maker ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Id = #3.MakeId ] Output [ #3.Model , #4.Weight ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.Model = #2.Model ] Output [ #2.Model , #2.Maker , #5.Weight ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.Maker = #1.Id ] Output [ #6.Model , #6.Weight , #1.FullName ] ; #8 = Filter [ #7 ] Predicate [ Weight > 3500 OR FullName = 'General Motors' ] Distinct [ true ] Output [ Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ FullName , Id ] ; #2 = Scan Table [ model_list ] Output [ Model , Maker ] ; #3 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #4 = Scan Table [ cars_data ] Output [ Weight , Id ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Id = #3.MakeId ] Output [ #3.Model , #4.Weight ] ; #6 = Join [ #2 , #5 ] Predicate [ #5.Model = #2.Model ] Output [ #2.Model , #2.Maker , #5.Weight ] ; #7 = Join [ #1 , #6 ] Predicate [ #6.Maker = #1.Id ] Output [ #6.Model , #6.Weight , #1.FullName ] ; #8 = Filter [ #7 ] Predicate [ Weight > 3500 OR FullName = 'General Motors' ] Distinct [ true ] Output [ Model ]",
    "cte":"WITH Scan_1 AS ( SELECT FullName, Id FROM car_1.car_makers ), Scan_2 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_3 AS ( SELECT Model, MakeId FROM car_1.car_names ), Scan_4 AS ( SELECT Weight, Id FROM car_1.cars_data ), Join_5 AS ( SELECT Scan_3.Model, Scan_4.Weight FROM Scan_3 JOIN Scan_4 ON Scan_4.Id = Scan_3.MakeId ), Join_6 AS ( SELECT Scan_2.Model, Scan_2.Maker, Join_5.Weight FROM Scan_2 JOIN Join_5 ON Join_5.Model = Scan_2.Model ), Join_7 AS ( SELECT Join_6.Model, Join_6.Weight, Scan_1.FullName FROM Scan_1 JOIN Join_6 ON Join_6.Maker = Scan_1.Id ), Filter_8 AS ( SELECT DISTINCT Model FROM Join_7 WHERE Weight > 3500 OR FullName = 'General Motors' ) SELECT * FROM Filter_8",
    "clean_query":"SELECT DISTINCT T2.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Model = T2.Model JOIN car_1.CAR_MAKERS AS T3  ON T2.Maker = T3.Id JOIN car_1.CARS_DATA AS T4  ON T1.MakeId = T4.Id WHERE T3.FullName = 'General Motors' OR T4.weight > 3500"
  },
  {
    "id":"36c7b520f8030b3154a34e0448f53c05b97574743e8f106665ad05142e78acc2",
    "db_id":"car_1",
    "question":"In which years cars were produced weighing no less than 3000 and no more than 4000 ?",
    "query":"select distinct year FROM car_1.cars_data WITH (FORCESCAN) where weight between 3000 and 4000  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Weight >= 3000 AND Weight <= 4000 ] Distinct [ true ] Output [ Year ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight >= 3000 AND Weight <= 4000 ] Distinct [ true ] Output [ Year ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Year FROM car_1.cars_data WHERE Weight >= 3000 AND Weight <= 4000 ) SELECT * FROM Scan_1",
    "clean_query":"select distinct year FROM car_1.cars_data  where weight between 3000 and 4000"
  },
  {
    "id":"133810f0e3f5f4b7d84f4b9d31f3fc19932e5f2965fdb8a9d6f5ee92cc706dd9",
    "db_id":"car_1",
    "question":"What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?",
    "query":"select distinct year FROM car_1.cars_data WITH (FORCESCAN) where weight between 3000 and 4000  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Weight >= 3000 AND Weight <= 4000 ] Distinct [ true ] Output [ Year ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight >= 3000 AND Weight <= 4000 ] Distinct [ true ] Output [ Year ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Year FROM car_1.cars_data WHERE Weight >= 3000 AND Weight <= 4000 ) SELECT * FROM Scan_1",
    "clean_query":"select distinct year FROM car_1.cars_data  where weight between 3000 and 4000"
  },
  {
    "id":"34a29224cb1a2db69920126c04ee5270c88f451260a25f12974f6cb81799530a",
    "db_id":"car_1",
    "question":"What is the horsepower of the car with the largest accelerate?",
    "query":"SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) ORDER BY T1.accelerate DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Accelerate DESC ] Output [ Accelerate , Horsepower ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Accelerate DESC ] Output [ Accelerate , Horsepower ]",
    "cte":"WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Accelerate DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1  ORDER BY T1.accelerate DESC"
  },
  {
    "id":"8b218ce8c7ce351dc037f9bf3d576f76412eeef674548ace0b382309f73f1fbe",
    "db_id":"car_1",
    "question":"What is the horsepower of the car with the greatest accelerate?",
    "query":"SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) ORDER BY T1.accelerate DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Accelerate DESC ] Output [ Accelerate , Horsepower ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Accelerate DESC ] Output [ Accelerate , Horsepower ]",
    "cte":"WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Accelerate DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 T1.horsepower FROM car_1.CARS_DATA AS T1  ORDER BY T1.accelerate DESC"
  },
  {
    "id":"20aad5ec8be072a2fc801c6afcad66ba64d69ce743b9ab6f3f5237766dfde98f",
    "db_id":"car_1",
    "question":"For model volvo, how many cylinders does the car with the least accelerate have?",
    "query":"SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Cylinders , Accelerate ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Cylinders , #2.Accelerate ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Accelerate ASC ] Output [ Accelerate , Cylinders ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Cylinders , Accelerate ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Cylinders , #2.Accelerate ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Accelerate ASC ] Output [ Accelerate , Cylinders ]",
    "cte":"WITH Scan_1 AS ( SELECT Model, MakeId FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Id, Cylinders, Accelerate FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Cylinders, Scan_2.Accelerate FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), TopSort_4 AS ( SELECT TOP 1 Accelerate, Cylinders FROM Join_3 ORDER BY Accelerate ASC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC"
  },
  {
    "id":"a1e86640236a193701c725b90a1521cb34923dc534777912bbdc11ee29853b4b",
    "db_id":"car_1",
    "question":"For a volvo model, how many cylinders does the version with least accelerate have?",
    "query":"SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Cylinders , Accelerate ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Cylinders , #2.Accelerate ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Accelerate ASC ] Output [ Accelerate , Cylinders ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Predicate [ Model = 'volvo' ] Output [ Model , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Id , Cylinders , Accelerate ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.MakeId = #2.Id ] Output [ #2.Cylinders , #2.Accelerate ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Accelerate ASC ] Output [ Accelerate , Cylinders ]",
    "cte":"WITH Scan_1 AS ( SELECT Model, MakeId FROM car_1.car_names WHERE Model = 'volvo' ), Scan_2 AS ( SELECT Id, Cylinders, Accelerate FROM car_1.cars_data ), Join_3 AS ( SELECT Scan_2.Cylinders, Scan_2.Accelerate FROM Scan_1 JOIN Scan_2 ON Scan_1.MakeId = Scan_2.Id ), TopSort_4 AS ( SELECT TOP 1 Accelerate, Cylinders FROM Join_3 ORDER BY Accelerate ASC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.cylinders FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.accelerate ASC"
  },
  {
    "id":"48a734d28ac0d45d15214f304ffedb1c3b0821398f90f0c5e93a378f96bf9bfc",
    "db_id":"car_1",
    "question":"How many cars have a larger accelerate than the car with the largest horsepower?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA WITH (FORCESCAN) ORDER BY Horsepower DESC )  ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Accelerate , Horsepower ] ; #3 = Scan Table [ cars_data ] Output [ Accelerate ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Accelerate > #3.Accelerate ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Accelerate , Horsepower ] ; #3 = Scan Table [ cars_data ] Output [ Accelerate ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Accelerate > #3.Accelerate ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Horsepower DESC ), Scan_3 AS ( SELECT Accelerate FROM car_1.cars_data ), Join_4 AS ( SELECT 1 AS One FROM TopSort_2 CROSS JOIN Scan_3 WHERE Scan_3.Accelerate > TopSort_2.Accelerate ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA  ORDER BY Horsepower DESC )"
  },
  {
    "id":"5a89af6cde45af39529cde237524a39a4b5bf5f6e805cf069bc3fd29ad32b8c0",
    "db_id":"car_1",
    "question":"What is the number of cars with a greater accelerate than the one with the most horsepower?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA WITH (FORCESCAN) ORDER BY Horsepower DESC )  ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Accelerate , Horsepower ] ; #3 = Scan Table [ cars_data ] Output [ Accelerate ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Accelerate > #3.Accelerate ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Output [ Accelerate , Horsepower ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Accelerate , Horsepower ] ; #3 = Scan Table [ cars_data ] Output [ Accelerate ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Accelerate > #3.Accelerate ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Accelerate, Horsepower FROM car_1.cars_data ), TopSort_2 AS ( SELECT TOP 1 Accelerate, Horsepower FROM Scan_1 ORDER BY Horsepower DESC ), Scan_3 AS ( SELECT Accelerate FROM car_1.cars_data ), Join_4 AS ( SELECT 1 AS One FROM TopSort_2 CROSS JOIN Scan_3 WHERE Scan_3.Accelerate > TopSort_2.Accelerate ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Accelerate > ( SELECT TOP 1 Accelerate FROM car_1.CARS_DATA  ORDER BY Horsepower DESC )"
  },
  {
    "id":"c41addc8cbd0fa2c9fcc48cbd0054859755fe0a2789378a6df2c3208334df8e8",
    "db_id":"car_1",
    "question":"How many countries has more than 2 car makers ?",
    "query":"select count ( * ) AS Count_Star FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId FROM car_1.countries ), Join_4 AS ( SELECT Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT Count_Star FROM Join_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
    "clean_query":"select count ( * ) AS Count_Star FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2"
  },
  {
    "id":"8ae45237a4b14c518c470ccdb33ff70e8b3fdd9499e1d452bdde3806f222c183",
    "db_id":"car_1",
    "question":"What is the number of countries with more than 2 car makers ?",
    "query":"select count ( * ) AS Count_Star FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_makers ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = Scan Table [ countries ] Output [ CountryId ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Country = #3.CountryId ] Output [ #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM car_1.car_makers ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), Scan_3 AS ( SELECT CountryId FROM car_1.countries ), Join_4 AS ( SELECT Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Country = Scan_3.CountryId ), Filter_5 AS ( SELECT Count_Star FROM Join_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
    "clean_query":"select count ( * ) AS Count_Star FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country group by t1.countryid having count ( * ) > 2"
  },
  {
    "id":"4f5fe3262a45fa6129aae57814c7c9a3f1a980933296e4d19dd4e2edd73f005d",
    "db_id":"car_1",
    "question":"How many cars has over 6 cylinders?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 6  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders > 6 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 6 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 6 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 6"
  },
  {
    "id":"aa943ef5c6203ba597019088c094ed685eea371be148c25ce154a9b373dc2c15",
    "db_id":"car_1",
    "question":"What is the number of carsw ith over 6 cylinders?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA WITH (FORCESCAN) WHERE Cylinders > 6  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders > 6 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders > 6 ] Output [ Cylinders ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Cylinders FROM car_1.cars_data WHERE Cylinders > 6 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM car_1.CARS_DATA  WHERE Cylinders > 6"
  },
  {
    "id":"d62f00c18f52de786886bd8891a3d2bf89ffa4b15a55048cd99820de47c66fb2",
    "db_id":"car_1",
    "question":"For the cars with 4 cylinders, which model has the largest horsepower?",
    "query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Cylinders, Horsepower FROM car_1.cars_data WHERE Cylinders = 4 ), Scan_2 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Model FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC"
  },
  {
    "id":"2e4abbe3322902bb4a641597f938f81afeaba7aa81b1943b46b40b6db2d0f182",
    "db_id":"car_1",
    "question":"For all of the 4 cylinder cars, which model has the most horsepower?",
    "query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1 WITH (FORCESCAN) JOIN car_1.CARS_DATA AS T2 WITH (FORCESCAN) ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 4 ] Output [ Id , Cylinders , Horsepower ] ; #2 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Id = #2.MakeId ] Output [ #1.Horsepower , #2.Model ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Horsepower DESC ] Output [ Horsepower , Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Cylinders, Horsepower FROM car_1.cars_data WHERE Cylinders = 4 ), Scan_2 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_3 AS ( SELECT Scan_1.Horsepower, Scan_2.Model FROM Scan_1 JOIN Scan_2 ON Scan_1.Id = Scan_2.MakeId ), TopSort_4 AS ( SELECT TOP 1 Horsepower, Model FROM Join_3 ORDER BY Horsepower DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Model FROM car_1.CAR_NAMES AS T1  JOIN car_1.CARS_DATA AS T2  ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.horsepower DESC"
  },
  {
    "id":"f9daf85575404c5b449d54a8baa0724475494e972fe99743b94ee039c21ade56",
    "db_id":"car_1",
    "question":"Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.",
    "query":"SELECT T2.MakeId , T2.Make FROM car_1.CARS_DATA AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Id = T2.MakeId WHERE T1.Horsepower > ( SELECT min ( Horsepower ) AS Min_Horsepower FROM car_1.CARS_DATA WITH (FORCESCAN) ) AND T1.Cylinders < = 3  ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Horsepower ] ; #3 = Aggregate [ #2 ] Output [ MIN(Horsepower) AS Min_Horsepower ] ; #4 = Scan Table [ cars_data ] Predicate [ Cylinders <= 3 ] Output [ Id , Cylinders , Horsepower ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Horsepower > #3.Min_Horsepower ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.MakeId , #1.Make ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Horsepower ] ; #3 = Aggregate [ #2 ] Output [ MIN(Horsepower) AS Min_Horsepower ] ; #4 = Scan Table [ cars_data ] Predicate [ Cylinders <= 3 ] Output [ Id , Cylinders , Horsepower ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Horsepower > #3.Min_Horsepower ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.MakeId , #1.Make ]",
    "cte":"WITH Scan_1 AS ( SELECT Make, MakeId FROM car_1.car_names ), Scan_2 AS ( SELECT Horsepower FROM car_1.cars_data ), Aggregate_3 AS ( SELECT MIN(Horsepower) AS Min_Horsepower FROM Scan_2 ), Scan_4 AS ( SELECT Id, Cylinders, Horsepower FROM car_1.cars_data WHERE Cylinders <= 3 ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Horsepower > Aggregate_3.Min_Horsepower ), Join_6 AS ( SELECT Scan_1.MakeId, Scan_1.Make FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
    "clean_query":"SELECT T2.MakeId , T2.Make FROM car_1.CARS_DATA AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Id = T2.MakeId WHERE T1.Horsepower > ( SELECT min ( Horsepower ) AS Min_Horsepower FROM car_1.CARS_DATA  ) AND T1.Cylinders < = 3"
  },
  {
    "id":"0d767c181e12d55eb4c6543cc27fd975df0309e40c6def682cfc56597fc5faed",
    "db_id":"car_1",
    "question":"Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?",
    "query":"select t2.makeid , t2.make FROM car_1.cars_data AS t1 WITH (FORCESCAN) join car_1.car_names as t2 WITH (FORCESCAN) on t1.id = t2.makeid where t1.horsepower > ( select min ( horsepower ) AS Min_horsepower FROM car_1.cars_data WITH (FORCESCAN) ) and t1.cylinders < 4  ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Horsepower ] ; #3 = Aggregate [ #2 ] Output [ MIN(Horsepower) AS Min_Horsepower ] ; #4 = Scan Table [ cars_data ] Predicate [ Cylinders < 4 ] Output [ Id , Cylinders , Horsepower ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Horsepower > #3.Min_Horsepower ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.MakeId , #1.Make ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ car_names ] Output [ Make , MakeId ] ; #2 = Scan Table [ cars_data ] Output [ Horsepower ] ; #3 = Aggregate [ #2 ] Output [ MIN(Horsepower) AS Min_Horsepower ] ; #4 = Scan Table [ cars_data ] Predicate [ Cylinders < 4 ] Output [ Id , Cylinders , Horsepower ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.Horsepower > #3.Min_Horsepower ] Output [ #4.Id ] ; #6 = Join [ #1 , #5 ] Predicate [ #5.Id = #1.MakeId ] Output [ #1.MakeId , #1.Make ]",
    "cte":"WITH Scan_1 AS ( SELECT Make, MakeId FROM car_1.car_names ), Scan_2 AS ( SELECT Horsepower FROM car_1.cars_data ), Aggregate_3 AS ( SELECT MIN(Horsepower) AS Min_Horsepower FROM Scan_2 ), Scan_4 AS ( SELECT Id, Cylinders, Horsepower FROM car_1.cars_data WHERE Cylinders < 4 ), Join_5 AS ( SELECT Id FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.Horsepower > Aggregate_3.Min_Horsepower ), Join_6 AS ( SELECT Scan_1.MakeId, Scan_1.Make FROM Scan_1 JOIN Join_5 ON Join_5.Id = Scan_1.MakeId ) SELECT * FROM Join_6",
    "clean_query":"select t2.makeid , t2.make FROM car_1.cars_data AS t1  join car_1.car_names as t2  on t1.id = t2.makeid where t1.horsepower > ( select min ( horsepower ) AS Min_horsepower FROM car_1.cars_data  ) and t1.cylinders < 4"
  },
  {
    "id":"95886c213cb2f796b359970764254b64bbe0314263e65f9fbaea1c469021457b",
    "db_id":"car_1",
    "question":"What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?",
    "query":"select max ( mpg ) AS Max_mpg FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 or year < 1980 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 OR Year < 1980 ] Output [ MPG , Cylinders , Year ] ; #2 = Aggregate [ #1 ] Output [ MAX(MPG) AS Max_MPG ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 OR Year < 1980 ] Output [ MPG , Cylinders , Year ] ; #2 = Aggregate [ #1 ] Output [ MAX(MPG) AS Max_MPG ]",
    "cte":"WITH Scan_1 AS ( SELECT MPG, Cylinders, Year FROM car_1.cars_data WHERE Cylinders = 8 OR Year < 1980 ), Aggregate_2 AS ( SELECT MAX(MPG) AS Max_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"select max ( mpg ) AS Max_mpg FROM car_1.cars_data  where cylinders = 8 or year < 1980"
  },
  {
    "id":"d59fc2b348e4322ab55b3c0602d3c7281523c59e6cdc25eeba00a219ed306068",
    "db_id":"car_1",
    "question":"What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980 ?",
    "query":"select max ( mpg ) AS Max_mpg FROM car_1.cars_data WITH (FORCESCAN) where cylinders = 8 or year < 1980 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 OR Year < 1980 ] Output [ MPG , Cylinders , Year ] ; #2 = Aggregate [ #1 ] Output [ MAX(MPG) AS Max_MPG ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Cylinders = 8 OR Year < 1980 ] Output [ MPG , Cylinders , Year ] ; #2 = Aggregate [ #1 ] Output [ MAX(MPG) AS Max_MPG ]",
    "cte":"WITH Scan_1 AS ( SELECT MPG, Cylinders, Year FROM car_1.cars_data WHERE Cylinders = 8 OR Year < 1980 ), Aggregate_2 AS ( SELECT MAX(MPG) AS Max_MPG FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"select max ( mpg ) AS Max_mpg FROM car_1.cars_data  where cylinders = 8 or year < 1980"
  },
  {
    "id":"b502c155fba512cabb54000e371ee35e6737c6de75d89889c83254465c86e8c4",
    "db_id":"car_1",
    "question":"Which models are lighter than 3500 but not built by the 'Ford Motor Company'?",
    "query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4 WITH (FORCESCAN) ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Weight < 3500 ] Output [ Id , Weight ] ; #2 = Scan Table [ car_makers ] Predicate [ FullName <> 'Ford Motor Company' ] Output [ Id , FullName ] ; #3 = Scan Table [ model_list ] Output [ Maker , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.Maker ] Output [ #3.Model ] ; #5 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.MakeId , #4.Model ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.MakeId ] Distinct [ true ] Output [ #6.Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight < 3500 ] Output [ Id , Weight ] ; #2 = Scan Table [ car_makers ] Predicate [ FullName <> 'Ford Motor Company' ] Output [ Id , FullName ] ; #3 = Scan Table [ model_list ] Output [ Maker , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.Maker ] Output [ #3.Model ] ; #5 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.MakeId , #4.Model ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.MakeId ] Distinct [ true ] Output [ #6.Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Weight FROM car_1.cars_data WHERE Weight < 3500 ), Scan_2 AS ( SELECT Id, FullName FROM car_1.car_makers WHERE FullName <> 'Ford Motor Company' ), Scan_3 AS ( SELECT Maker, Model FROM car_1.model_list ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.Maker ), Scan_5 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_6 AS ( SELECT Scan_5.MakeId, Join_4.Model FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Join_6.Model FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.MakeId ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4  ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'"
  },
  {
    "id":"16757dcf685a956d81ea88dce3aeca959bb39b0e7f5823e1d244ec45b8dc1448",
    "db_id":"car_1",
    "question":"What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?",
    "query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1 WITH (FORCESCAN) JOIN car_1.CAR_NAMES AS T2 WITH (FORCESCAN) ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3 WITH (FORCESCAN) ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4 WITH (FORCESCAN) ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ cars_data ] Predicate [ Weight < 3500 ] Output [ Id , Weight ] ; #2 = Scan Table [ car_makers ] Predicate [ FullName <> 'Ford Motor Company' ] Output [ Id , FullName ] ; #3 = Scan Table [ model_list ] Output [ Maker , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.Maker ] Output [ #3.Model ] ; #5 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.MakeId , #4.Model ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.MakeId ] Distinct [ true ] Output [ #6.Model ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ cars_data ] Predicate [ Weight < 3500 ] Output [ Id , Weight ] ; #2 = Scan Table [ car_makers ] Predicate [ FullName <> 'Ford Motor Company' ] Output [ Id , FullName ] ; #3 = Scan Table [ model_list ] Output [ Maker , Model ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Id = #3.Maker ] Output [ #3.Model ] ; #5 = Scan Table [ car_names ] Output [ Model , MakeId ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Model = #5.Model ] Output [ #5.MakeId , #4.Model ] ; #7 = Join [ #1 , #6 ] Predicate [ #1.Id = #6.MakeId ] Distinct [ true ] Output [ #6.Model ]",
    "cte":"WITH Scan_1 AS ( SELECT Id, Weight FROM car_1.cars_data WHERE Weight < 3500 ), Scan_2 AS ( SELECT Id, FullName FROM car_1.car_makers WHERE FullName <> 'Ford Motor Company' ), Scan_3 AS ( SELECT Maker, Model FROM car_1.model_list ), Join_4 AS ( SELECT Scan_3.Model FROM Scan_2 JOIN Scan_3 ON Scan_2.Id = Scan_3.Maker ), Scan_5 AS ( SELECT Model, MakeId FROM car_1.car_names ), Join_6 AS ( SELECT Scan_5.MakeId, Join_4.Model FROM Join_4 JOIN Scan_5 ON Join_4.Model = Scan_5.Model ), Join_7 AS ( SELECT DISTINCT Join_6.Model FROM Scan_1 JOIN Join_6 ON Scan_1.Id = Join_6.MakeId ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T1.model FROM car_1.MODEL_LIST AS T1  JOIN car_1.CAR_NAMES AS T2  ON T1.Model = T2.Model JOIN car_1.CARS_DATA AS T3  ON T2.MakeId = T3.Id JOIN car_1.CAR_MAKERS AS T4  ON T1.Maker = T4.Id WHERE T3.weight < 3500 AND T4.FullName ! = 'Ford Motor Company'"
  },
  {
    "id":"1e4db4c4de408f4f9be2225ed03040fed5bf6e86f840d6f753669492df7ee562",
    "db_id":"car_1",
    "question":"What are the name of the countries where there is not a single car maker?",
    "query":"SELECT CountryName FROM car_1.countries WITH (FORCESCAN) EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.countryId = T2.Country  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countries ] Distinct [ true ] Output [ CountryName ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.CountryName ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.CountryName = #4.CountryName ] Output [ #1.CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Distinct [ true ] Output [ CountryName ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.CountryName ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.CountryName = #4.CountryName ] Output [ #1.CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT CountryName FROM car_1.countries ), Scan_2 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.CountryName FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Except_5 AS ( SELECT Scan_1.CountryName FROM Scan_1 WHERE CountryName NOT IN (SELECT CountryName FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT CountryName FROM car_1.countries  EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.countryId = T2.Country"
  },
  {
    "id":"db474200659b4d04abc94f233be2174f0b5d7bad40e32821c04983268be79774",
    "db_id":"car_1",
    "question":"What are the names of the countries with no car makers?",
    "query":"SELECT CountryName FROM car_1.countries WITH (FORCESCAN) EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.countryId = T2.Country  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countries ] Distinct [ true ] Output [ CountryName ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.CountryName ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.CountryName = #4.CountryName ] Output [ #1.CountryName ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Distinct [ true ] Output [ CountryName ] ; #2 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #3 = Scan Table [ car_makers ] Output [ Country ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryId = #3.Country ] Output [ #2.CountryName ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.CountryName = #4.CountryName ] Output [ #1.CountryName ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT CountryName FROM car_1.countries ), Scan_2 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_3 AS ( SELECT Country FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_2.CountryName FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryId = Scan_3.Country ), Except_5 AS ( SELECT Scan_1.CountryName FROM Scan_1 WHERE CountryName NOT IN (SELECT CountryName FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT CountryName FROM car_1.countries  EXCEPT SELECT T1.CountryName FROM car_1.countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.countryId = T2.Country"
  },
  {
    "id":"fefb38b1e47ce56411e8d791f7aff3e81d9c58f99f39beffa4c2b2146f8950a6",
    "db_id":"car_1",
    "question":"Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .",
    "query":"select t1.id , t1.maker FROM car_1.car_makers AS t1 WITH (FORCESCAN) join car_1.model_list as t2 WITH (FORCESCAN) on t1.id = t2.maker group by t1.id , t1.maker having count ( * ) >= 2 intersect select t1.id , t1.maker FROM car_1.car_makers AS t1 WITH (FORCESCAN) join car_1.model_list as t2 WITH (FORCESCAN) on t1.id = t2.maker join car_1.car_names as t3 WITH (FORCESCAN) on t2.model = t3.model group by t1.id , t1.maker having count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.Id , #2.Count_Star , #3.Maker ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Maker , Id ] ; #6 = Scan Table [ model_list ] Output [ Model , Maker ] ; #7 = Scan Table [ car_names ] Output [ Model ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Model = #7.Model ] Output [ #6.Maker ] ; #9 = Aggregate [ #8 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #10 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #11 = Join [ #9 , #10 ] Predicate [ #9.Maker = #10.Id ] Output [ #10.Maker , #10.Id , #9.Count_Star ] ; #12 = Filter [ #11 ] Predicate [ Count_Star > 3 ] Output [ Maker , Id ] ; #13 = Intersect [ #5 , #12 ] Predicate [ #5.Id = #12.Id ] Output [ #5.Maker , #5.Id ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.Id , #2.Count_Star , #3.Maker ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Maker , Id ] ; #6 = Scan Table [ model_list ] Output [ Model , Maker ] ; #7 = Scan Table [ car_names ] Output [ Model ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Model = #7.Model ] Output [ #6.Maker ] ; #9 = Aggregate [ #8 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #10 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #11 = Join [ #9 , #10 ] Predicate [ #9.Maker = #10.Id ] Output [ #10.Maker , #10.Id , #9.Count_Star ] ; #12 = Filter [ #11 ] Predicate [ Count_Star > 3 ] Output [ Maker , Id ] ; #13 = Intersect [ #5 , #12 ] Predicate [ #5.Id = #12.Id ] Output [ #5.Maker , #5.Id ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.Id, Aggregate_2.Count_Star, Scan_3.Maker FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT Maker, Id FROM Join_4 WHERE Count_Star >= 2 ), Scan_6 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_7 AS ( SELECT Model FROM car_1.car_names ), Join_8 AS ( SELECT Scan_6.Maker FROM Scan_6 JOIN Scan_7 ON Scan_6.Model = Scan_7.Model ), Aggregate_9 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Join_8 GROUP BY Maker ), Scan_10 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_11 AS ( SELECT Scan_10.Maker, Scan_10.Id, Aggregate_9.Count_Star FROM Aggregate_9 JOIN Scan_10 ON Aggregate_9.Maker = Scan_10.Id ), Filter_12 AS ( SELECT Maker, Id FROM Join_11 WHERE Count_Star > 3 ), Intersect_13 AS ( SELECT Filter_5.Maker, Filter_5.Id FROM Filter_5 WHERE Id IN (SELECT Id FROM Filter_12) ) SELECT * FROM Intersect_13",
    "clean_query":"select t1.id , t1.maker FROM car_1.car_makers AS t1  join car_1.model_list as t2  on t1.id = t2.maker group by t1.id , t1.maker having count ( * ) >= 2 intersect select t1.id , t1.maker FROM car_1.car_makers AS t1  join car_1.model_list as t2  on t1.id = t2.maker join car_1.car_names as t3  on t2.model = t3.model group by t1.id , t1.maker having count ( * ) > 3"
  },
  {
    "id":"29238520da091881c4e7a017b6177cb764df61f4b23ba7e2bdb8786955bd3ad8",
    "db_id":"car_1",
    "question":"What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?",
    "query":"SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker GROUP BY T1.Id , T1.Maker HAVING count ( * ) > = 2 INTERSECT SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1 WITH (FORCESCAN) JOIN car_1.MODEL_LIST AS T2 WITH (FORCESCAN) ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3 WITH (FORCESCAN) ON T2.model = T3.model GROUP BY T1.Id , T1.Maker HAVING count ( * ) > 3  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.Id , #2.Count_Star , #3.Maker ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Maker , Id ] ; #6 = Scan Table [ model_list ] Output [ Model , Maker ] ; #7 = Scan Table [ car_names ] Output [ Model ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Model = #7.Model ] Output [ #6.Maker ] ; #9 = Aggregate [ #8 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #10 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #11 = Join [ #9 , #10 ] Predicate [ #9.Maker = #10.Id ] Output [ #10.Maker , #10.Id , #9.Count_Star ] ; #12 = Filter [ #11 ] Predicate [ Count_Star > 3 ] Output [ Maker , Id ] ; #13 = Intersect [ #5 , #12 ] Predicate [ #5.Id = #12.Id ] Output [ #5.Maker , #5.Id ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ model_list ] Output [ Maker ] ; #2 = Aggregate [ #1 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #3 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Maker = #3.Id ] Output [ #3.Id , #2.Count_Star , #3.Maker ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Maker , Id ] ; #6 = Scan Table [ model_list ] Output [ Model , Maker ] ; #7 = Scan Table [ car_names ] Output [ Model ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Model = #7.Model ] Output [ #6.Maker ] ; #9 = Aggregate [ #8 ] GroupBy [ Maker ] Output [ countstar AS Count_Star , Maker ] ; #10 = Scan Table [ car_makers ] Output [ Maker , Id ] ; #11 = Join [ #9 , #10 ] Predicate [ #9.Maker = #10.Id ] Output [ #10.Maker , #10.Id , #9.Count_Star ] ; #12 = Filter [ #11 ] Predicate [ Count_Star > 3 ] Output [ Maker , Id ] ; #13 = Intersect [ #5 , #12 ] Predicate [ #5.Id = #12.Id ] Output [ #5.Maker , #5.Id ]",
    "cte":"WITH Scan_1 AS ( SELECT Maker FROM car_1.model_list ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Scan_1 GROUP BY Maker ), Scan_3 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_4 AS ( SELECT Scan_3.Id, Aggregate_2.Count_Star, Scan_3.Maker FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Maker = Scan_3.Id ), Filter_5 AS ( SELECT Maker, Id FROM Join_4 WHERE Count_Star >= 2 ), Scan_6 AS ( SELECT Model, Maker FROM car_1.model_list ), Scan_7 AS ( SELECT Model FROM car_1.car_names ), Join_8 AS ( SELECT Scan_6.Maker FROM Scan_6 JOIN Scan_7 ON Scan_6.Model = Scan_7.Model ), Aggregate_9 AS ( SELECT COUNT(*) AS Count_Star, Maker FROM Join_8 GROUP BY Maker ), Scan_10 AS ( SELECT Maker, Id FROM car_1.car_makers ), Join_11 AS ( SELECT Scan_10.Maker, Scan_10.Id, Aggregate_9.Count_Star FROM Aggregate_9 JOIN Scan_10 ON Aggregate_9.Maker = Scan_10.Id ), Filter_12 AS ( SELECT Maker, Id FROM Join_11 WHERE Count_Star > 3 ), Intersect_13 AS ( SELECT Filter_5.Maker, Filter_5.Id FROM Filter_5 WHERE Id IN (SELECT Id FROM Filter_12) ) SELECT * FROM Intersect_13",
    "clean_query":"SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker GROUP BY T1.Id , T1.Maker HAVING count ( * ) > = 2 INTERSECT SELECT T1.Id , T1.Maker FROM car_1.CAR_MAKERS AS T1  JOIN car_1.MODEL_LIST AS T2  ON T1.Id = T2.Maker JOIN car_1.CAR_NAMES AS T3  ON T2.model = T3.model GROUP BY T1.Id , T1.Maker HAVING count ( * ) > 3"
  },
  {
    "id":"f23d812f404ef6bef6297f48075b5a591f9c60c9f97f36861c9b5abce2350a5f",
    "db_id":"car_1",
    "question":"What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?",
    "query":"SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country GROUP BY T1.countryId , T1.CountryName HAVING count ( * ) > 3 UNION SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1 WITH (FORCESCAN) JOIN car_1.CAR_MAKERS AS T2 WITH (FORCESCAN) ON T1.CountryId = T2.Country JOIN car_1.MODEL_LIST AS T3 WITH (FORCESCAN) ON T2.Id = T3.Maker WHERE T3.Model = 'fiat'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] GroupBy [ CountryId ] Output [ countstar AS Count_Star , CountryId , CountryName ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ CountryId , CountryName ] ; #6 = Scan Table [ model_list ] Predicate [ Model = 'fiat' ] Output [ Maker , Model ] ; #7 = Scan Table [ car_makers ] Output [ Id , Country ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Maker = #7.Id ] Output [ #7.Country ] ; #9 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.Country = #9.CountryId ] Output [ #9.CountryName , #9.CountryId ] ; #11 = Union [ #5 , #10 ] Output [ #5.CountryName , #5.CountryId ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] GroupBy [ CountryId ] Output [ countstar AS Count_Star , CountryId , CountryName ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ CountryId , CountryName ] ; #6 = Scan Table [ model_list ] Predicate [ Model = 'fiat' ] Output [ Maker , Model ] ; #7 = Scan Table [ car_makers ] Output [ Id , Country ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Maker = #7.Id ] Output [ #7.Country ] ; #9 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.Country = #9.CountryId ] Output [ #9.CountryName , #9.CountryId ] ; #11 = Union [ #5 , #10 ] Output [ #5.CountryName , #5.CountryId ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, CountryId, CountryName FROM Join_3 GROUP BY CountryId, CountryName ), Filter_5 AS ( SELECT CountryId, CountryName FROM Aggregate_4 WHERE Count_Star > 3 ), Scan_6 AS ( SELECT Maker, Model FROM car_1.model_list WHERE Model = 'fiat' ), Scan_7 AS ( SELECT Id, Country FROM car_1.car_makers ), Join_8 AS ( SELECT Scan_7.Country FROM Scan_6 JOIN Scan_7 ON Scan_6.Maker = Scan_7.Id ), Scan_9 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_10 AS ( SELECT Scan_9.CountryName, Scan_9.CountryId FROM Join_8 JOIN Scan_9 ON Join_8.Country = Scan_9.CountryId ), Union_11 AS ( SELECT CountryName, CountryId FROM Filter_5 UNION SELECT CountryName, CountryId FROM Join_10 ) SELECT * FROM Union_11",
    "clean_query":"SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country GROUP BY T1.countryId , T1.CountryName HAVING count ( * ) > 3 UNION SELECT T1.countryId , T1.CountryName FROM car_1.Countries AS T1  JOIN car_1.CAR_MAKERS AS T2  ON T1.CountryId = T2.Country JOIN car_1.MODEL_LIST AS T3  ON T2.Id = T3.Maker WHERE T3.Model = 'fiat'"
  },
  {
    "id":"16a6e522cfd501f609c46856f658cfd95b8ef2517b7ad60ecc032807076c99ac",
    "db_id":"car_1",
    "question":"What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?",
    "query":"select t1.countryid , t1.countryname FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country group by t1.countryid , t1.countryname having count ( * ) > 3 union select t1.countryid , t1.countryname FROM car_1.countries AS t1 WITH (FORCESCAN) join car_1.car_makers as t2 WITH (FORCESCAN) on t1.countryid = t2.country join car_1.model_list as t3 WITH (FORCESCAN) on t2.id = t3.maker where t3.model = 'fiat'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] GroupBy [ CountryId ] Output [ countstar AS Count_Star , CountryId , CountryName ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ CountryId , CountryName ] ; #6 = Scan Table [ model_list ] Predicate [ Model = 'fiat' ] Output [ Maker , Model ] ; #7 = Scan Table [ car_makers ] Output [ Id , Country ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Maker = #7.Id ] Output [ #7.Country ] ; #9 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.Country = #9.CountryId ] Output [ #9.CountryName , #9.CountryId ] ; #11 = Union [ #5 , #10 ] Output [ #5.CountryName , #5.CountryId ]",
    "prefixed_qpl":"car_1 | #1 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #2 = Scan Table [ car_makers ] Output [ Country ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryId = #2.Country ] Output [ #1.CountryId , #1.CountryName ] ; #4 = Aggregate [ #3 ] GroupBy [ CountryId ] Output [ countstar AS Count_Star , CountryId , CountryName ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 3 ] Output [ CountryId , CountryName ] ; #6 = Scan Table [ model_list ] Predicate [ Model = 'fiat' ] Output [ Maker , Model ] ; #7 = Scan Table [ car_makers ] Output [ Id , Country ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Maker = #7.Id ] Output [ #7.Country ] ; #9 = Scan Table [ countries ] Output [ CountryId , CountryName ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.Country = #9.CountryId ] Output [ #9.CountryName , #9.CountryId ] ; #11 = Union [ #5 , #10 ] Output [ #5.CountryName , #5.CountryId ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Scan_2 AS ( SELECT Country FROM car_1.car_makers ), Join_3 AS ( SELECT Scan_1.CountryId, Scan_1.CountryName FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryId = Scan_2.Country ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, CountryId, CountryName FROM Join_3 GROUP BY CountryId, CountryName ), Filter_5 AS ( SELECT CountryId, CountryName FROM Aggregate_4 WHERE Count_Star > 3 ), Scan_6 AS ( SELECT Maker, Model FROM car_1.model_list WHERE Model = 'fiat' ), Scan_7 AS ( SELECT Id, Country FROM car_1.car_makers ), Join_8 AS ( SELECT Scan_7.Country FROM Scan_6 JOIN Scan_7 ON Scan_6.Maker = Scan_7.Id ), Scan_9 AS ( SELECT CountryId, CountryName FROM car_1.countries ), Join_10 AS ( SELECT Scan_9.CountryName, Scan_9.CountryId FROM Join_8 JOIN Scan_9 ON Join_8.Country = Scan_9.CountryId ), Union_11 AS ( SELECT CountryName, CountryId FROM Filter_5 UNION SELECT CountryName, CountryId FROM Join_10 ) SELECT * FROM Union_11",
    "clean_query":"select t1.countryid , t1.countryname FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country group by t1.countryid , t1.countryname having count ( * ) > 3 union select t1.countryid , t1.countryname FROM car_1.countries AS t1  join car_1.car_makers as t2  on t1.countryid = t2.country join car_1.model_list as t3  on t2.id = t3.maker where t3.model = 'fiat'"
  },
  {
    "id":"36a2157fcc813e6a8d142d9e19e8471df3c97f9c4b89b1093f70b6d30255a382",
    "db_id":"flight_2",
    "question":"Which country does Airline \"JetBlue Airways\" belong to?",
    "query":"SELECT Country FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Country ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Country ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Country FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Country FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'"
  },
  {
    "id":"5f4c7f4307ad324c6bd8b44a5c91d45d8fa3f854c9b23f17d5fae490193e1363",
    "db_id":"flight_2",
    "question":"What country is Jetblue Airways affiliated with?",
    "query":"SELECT Country FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Country ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Country ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Country FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Country FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'"
  },
  {
    "id":"7f56858bb93fce00274ad7fc93c7c106d09905596af081d93d544e02731db6c4",
    "db_id":"flight_2",
    "question":"What is the abbreviation of Airline \"JetBlue Airways\"?",
    "query":"SELECT Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Abbreviation FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'"
  },
  {
    "id":"b382a94261c2999cc724820561e70e7fc4fdab26b2e6c4e0a72ac715977e5ef4",
    "db_id":"flight_2",
    "question":"Which abbreviation corresponds to Jetblue Airways?",
    "query":"SELECT Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ Airline , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Abbreviation FROM flight_2.AIRLINES  WHERE Airline = 'JetBlue Airways'"
  },
  {
    "id":"f69a450ed479db5ca5b690ab618f69a33863fef823c823cb818121c200280fbd",
    "db_id":"flight_2",
    "question":"List all airline names and their abbreviations in \"USA\".",
    "query":"SELECT Airline , Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Airline , Country , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Airline , Country , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Country, Abbreviation FROM flight_2.airlines WHERE Country = 'USA' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Airline , Abbreviation FROM flight_2.AIRLINES  WHERE Country = 'USA'"
  },
  {
    "id":"daecf9f7334ab07a6861fe88b0db2d042b3d0baf22049a3c90c953ebd630e9a0",
    "db_id":"flight_2",
    "question":"What are the airline names and abbreviations for airlines in the USA?",
    "query":"SELECT Airline , Abbreviation FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Airline , Country , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Airline , Country , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Country, Abbreviation FROM flight_2.airlines WHERE Country = 'USA' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Airline , Abbreviation FROM flight_2.AIRLINES  WHERE Country = 'USA'"
  },
  {
    "id":"8fee41930419ed1b60bc8a03182d24c4aef408f9fe3d3042d5197c827080bfb9",
    "db_id":"flight_2",
    "question":"List the airport code and name in the city of Anthony.",
    "query":"SELECT AirportCode , AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE city = 'Anthony' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Anthony' ] Output [ City , AirportName , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Anthony' ] Output [ City , AirportName , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportName, AirportCode FROM flight_2.airports WHERE City = 'Anthony' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT AirportCode , AirportName FROM flight_2.AIRPORTS  WHERE city = 'Anthony'"
  },
  {
    "id":"5c334eae39a83d351071183963010a8ed84b530e462431cf43876e0ced4fed9a",
    "db_id":"flight_2",
    "question":"Give the airport code and airport name corresonding to the city Anthony.",
    "query":"SELECT AirportCode , AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE city = 'Anthony' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Anthony' ] Output [ City , AirportName , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Anthony' ] Output [ City , AirportName , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportName, AirportCode FROM flight_2.airports WHERE City = 'Anthony' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT AirportCode , AirportName FROM flight_2.AIRPORTS  WHERE city = 'Anthony'"
  },
  {
    "id":"369b5b7dbc8e97b2da310dc1ef97a060a3abec21242176afd9b5b8dcbcad5ff7",
    "db_id":"flight_2",
    "question":"How many airlines do we have?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airlines ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES"
  },
  {
    "id":"063b8bcdd6c9ad73b186d5c9b6447dec9581ac1841a4485b9badd7e27ae84b9b",
    "db_id":"flight_2",
    "question":"What is the total number of airlines?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airlines ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES"
  },
  {
    "id":"3e300a389805c802468ed78e0375595f808905a65d3a714dca27a4605afb5dde",
    "db_id":"flight_2",
    "question":"How many airports do we have?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airports ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airports ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS"
  },
  {
    "id":"4d65558cfbe559672e157d5e7ec80e6e78aebc27437ce33f926d48eb593f03c9",
    "db_id":"flight_2",
    "question":"Return the number of  airports.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airports ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.airports ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRPORTS"
  },
  {
    "id":"c1fd6f38135cfcb534461b08b25144826b8cbc55904aa39bf3f6cb55a584b206",
    "db_id":"flight_2",
    "question":"How many flights do we have?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS"
  },
  {
    "id":"279d2d1be85f34d2c0d188a4a33ed356a3ad63f477e61581ca597812edee5c28",
    "db_id":"flight_2",
    "question":"Return the number of flights.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM flight_2.flights ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS"
  },
  {
    "id":"fad45b9bc7573cd69e8c13a9273a0663dd75d1bbfa334582e5a7ec673bf88e6d",
    "db_id":"flight_2",
    "question":"Which airline has abbreviation 'UAL'?",
    "query":"SELECT Airline FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Abbreviation = 'UAL' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Abbreviation = 'UAL' ] Output [ Airline , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Abbreviation = 'UAL' ] Output [ Airline , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Abbreviation = 'UAL' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Airline FROM flight_2.AIRLINES  WHERE Abbreviation = 'UAL'"
  },
  {
    "id":"e2659b87d4a1e361b740b5e13188af89e0b4328076dd99f6a06de5b1b94b5523",
    "db_id":"flight_2",
    "question":"Give the airline with abbreviation 'UAL'.",
    "query":"SELECT Airline FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Abbreviation = 'UAL' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Abbreviation = 'UAL' ] Output [ Airline , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Abbreviation = 'UAL' ] Output [ Airline , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, Abbreviation FROM flight_2.airlines WHERE Abbreviation = 'UAL' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Airline FROM flight_2.AIRLINES  WHERE Abbreviation = 'UAL'"
  },
  {
    "id":"b8e73cdb60d918375ac05b729ae481ecc9d1efb4140ab54400235c695a03b096",
    "db_id":"flight_2",
    "question":"How many airlines are from USA?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Country ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Country ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM flight_2.airlines WHERE Country = 'USA' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES  WHERE Country = 'USA'"
  },
  {
    "id":"66b83582e021b8db08e2b4d08c135401f2b5f33950791e8cd6590d2f7ead0857",
    "db_id":"flight_2",
    "question":"Return the number of airlines in the USA.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES WITH (FORCESCAN) WHERE Country = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Country ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Country = 'USA' ] Output [ Country ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM flight_2.airlines WHERE Country = 'USA' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES  WHERE Country = 'USA'"
  },
  {
    "id":"ad9d7210fdfd7165816e6492d93dd1e6f8473cf6c35e401f46ded2de93952e94",
    "db_id":"flight_2",
    "question":"Which city and country is the Alton airport at?",
    "query":"SELECT City , Country FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportName = 'Alton' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ AirportName = 'Alton' ] Output [ City , AirportName , Country ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportName = 'Alton' ] Output [ City , AirportName , Country ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportName, Country FROM flight_2.airports WHERE AirportName = 'Alton' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT City , Country FROM flight_2.AIRPORTS  WHERE AirportName = 'Alton'"
  },
  {
    "id":"5f82ac520562e0e693c6f75f18091b5e35fc74ee85c8bff66446e0bc61cdf85c",
    "db_id":"flight_2",
    "question":"Give the city and country for the Alton airport.",
    "query":"SELECT City , Country FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportName = 'Alton' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ AirportName = 'Alton' ] Output [ City , AirportName , Country ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportName = 'Alton' ] Output [ City , AirportName , Country ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportName, Country FROM flight_2.airports WHERE AirportName = 'Alton' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT City , Country FROM flight_2.AIRPORTS  WHERE AirportName = 'Alton'"
  },
  {
    "id":"11e3dfccf0adfb124a6c25b1db3b111936b727842d24ab609fcd295a69fc760d",
    "db_id":"flight_2",
    "question":"What is the airport name for airport 'AKO'?",
    "query":"SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportCode = 'AKO' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ AirportCode = 'AKO' ] Output [ AirportName , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportCode = 'AKO' ] Output [ AirportName , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportName, AirportCode FROM flight_2.airports WHERE AirportCode = 'AKO' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT AirportName FROM flight_2.AIRPORTS  WHERE AirportCode = 'AKO'"
  },
  {
    "id":"0617e10465be92424cb8e6ad6c98682473571d33e1ce56d7ccc259123ce41d1d",
    "db_id":"flight_2",
    "question":"Return the name of the airport with code 'AKO'.",
    "query":"SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE AirportCode = 'AKO' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ AirportCode = 'AKO' ] Output [ AirportName , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ AirportCode = 'AKO' ] Output [ AirportName , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportName, AirportCode FROM flight_2.airports WHERE AirportCode = 'AKO' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT AirportName FROM flight_2.AIRPORTS  WHERE AirportCode = 'AKO'"
  },
  {
    "id":"ceb36e3b14327b223ca847535d4c11f45241bc16d511bf03380079252a63b090",
    "db_id":"flight_2",
    "question":"What are airport names at City 'Aberdeen'?",
    "query":"SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportName ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportName ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportName FROM flight_2.airports WHERE City = 'Aberdeen' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT AirportName FROM flight_2.AIRPORTS  WHERE City = 'Aberdeen'"
  },
  {
    "id":"40e1f4c8aa7834d57bb2f331fb09534635a3c5fdb5ad6f142eec15b1f995b7ea",
    "db_id":"flight_2",
    "question":"What are the names of airports in Aberdeen?",
    "query":"SELECT AirportName FROM flight_2.AIRPORTS WITH (FORCESCAN) WHERE City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportName ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportName ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportName FROM flight_2.airports WHERE City = 'Aberdeen' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT AirportName FROM flight_2.AIRPORTS  WHERE City = 'Aberdeen'"
  },
  {
    "id":"ec3405477794812934b51e5ea9d4aab5a905af1006960ad3d39101b5ccc2a6d4",
    "db_id":"flight_2",
    "question":"How many flights depart from 'APG'?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'"
  },
  {
    "id":"5d72b16fa2cfb69617732597bc76509ba7d67eb30a250fc04d538e1c037127ec",
    "db_id":"flight_2",
    "question":"Count the number of flights departing from 'APG'.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'"
  },
  {
    "id":"5ebbb73a6afdbdb2974b2656c82d7299272d0e92e8831f62b3bbdbf3c4f63d21",
    "db_id":"flight_2",
    "question":"How many flights have destination ATO?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'ATO' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ DestAirport = 'ATO' ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'ATO' ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights WHERE DestAirport = 'ATO' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE DestAirport = 'ATO'"
  },
  {
    "id":"856fdf46f76eb38b3c95693281ff5fed72655659ac9ba441d820e7ef6a1675dd",
    "db_id":"flight_2",
    "question":"Count the number of flights into ATO.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'ATO' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ DestAirport = 'ATO' ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'ATO' ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights WHERE DestAirport = 'ATO' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS  WHERE DestAirport = 'ATO'"
  },
  {
    "id":"4dfb9f3bd2fd30f32394562225b6b6d5eb3ec4532cc089f93fa37897071f826f",
    "db_id":"flight_2",
    "question":"How many flights depart from City Aberdeen?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"c642fd4df84252e3f94cc6a8622ebd176aac937469bde1ca03f02bb88852b44a",
    "db_id":"flight_2",
    "question":"Return the number of flights departing from Aberdeen.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"b77fa3b8526203bcd90c712fdbdee81795d22020a91667f2c3c3d49f348b347a",
    "db_id":"flight_2",
    "question":"How many flights arriving in Aberdeen city?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"596abcb0d56950837aea86f86897c9ec4d944f77fb56712c19b06aca08b5ab81",
    "db_id":"flight_2",
    "question":"Return the number of flights arriving in Aberdeen.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"a86a96d3e0f4b6052d11149f8f2da48ab46dbd0cc3e8d64f456496fb96dff6f4",
    "db_id":"flight_2",
    "question":"How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3 WITH (FORCESCAN) ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airports ] Predicate [ City = 'Ashley' ] Output [ City , AirportCode ] ; #3 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.AirportCode = #3.DestAirport ] Output [ #3.SourceAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airports ] Predicate [ City = 'Ashley' ] Output [ City , AirportCode ] ; #3 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.AirportCode = #3.DestAirport ] Output [ #3.SourceAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Ashley' ), Scan_3 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.SourceAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.AirportCode = Scan_3.DestAirport ), Join_5 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.SourceAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3  ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen'"
  },
  {
    "id":"de87fcf74f2799bbaa79f8e759e47daa3b68377e6f8715ad9ca101b761546bed",
    "db_id":"flight_2",
    "question":"How many flights fly from Aberdeen to Ashley?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3 WITH (FORCESCAN) ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airports ] Predicate [ City = 'Ashley' ] Output [ City , AirportCode ] ; #3 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.AirportCode = #3.DestAirport ] Output [ #3.SourceAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airports ] Predicate [ City = 'Ashley' ] Output [ City , AirportCode ] ; #3 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.AirportCode = #3.DestAirport ] Output [ #3.SourceAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.SourceAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Ashley' ), Scan_3 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.SourceAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.AirportCode = Scan_3.DestAirport ), Join_5 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.SourceAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRPORTS AS T3  ON T1.SourceAirport = T3.AirportCode WHERE T2.City = 'Ashley' AND T3.City = 'Aberdeen'"
  },
  {
    "id":"1f310f5bbbc32f27959b1948e0a2b55cc6d6ab439f95fa18d2a151873b24edf2",
    "db_id":"flight_2",
    "question":"How many flights does airline 'JetBlue Airways' have?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ uid ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ uid ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT uid FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
  },
  {
    "id":"b3a92bd00df018276c532ac506f498a4aab18fc78bd5e5c233593b3d0919d6e3",
    "db_id":"flight_2",
    "question":"Give the number of Jetblue Airways flights.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ uid ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'JetBlue Airways' ] Output [ uid ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT uid FROM flight_2.airlines WHERE Airline = 'JetBlue Airways' ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T1.Airline = T2.uid WHERE T2.Airline = 'JetBlue Airways'"
  },
  {
    "id":"e5944abdcf96b6c445082d7c73904e1a558fcf3e470659bf41d44f19d8842244",
    "db_id":"flight_2",
    "question":"How many 'United Airlines' flights go to Airport 'ASY'?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ DestAirport = 'ASY' ] Output [ Airline , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ DestAirport = 'ASY' ] Output [ Airline , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'ASY' ), Join_3 AS ( SELECT Scan_1.Airline, Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
  },
  {
    "id":"6fcf089875e01f63af8f84cf31cc2e94508fb7a057790cb893544b2c05054445",
    "db_id":"flight_2",
    "question":"Count the number of United Airlines flights arriving in ASY Airport.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ DestAirport = 'ASY' ] Output [ Airline , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ DestAirport = 'ASY' ] Output [ Airline , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'ASY' ), Join_3 AS ( SELECT Scan_1.Airline, Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.DestAirport = 'ASY'"
  },
  {
    "id":"d50de1020d3dcee5416196b209cf716fef84d0120bf108e9619ecbca20df62a3",
    "db_id":"flight_2",
    "question":"How many 'United Airlines' flights depart from Airport 'AHD'?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Join_3 AS ( SELECT Scan_1.Airline, Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD'"
  },
  {
    "id":"93c0a5389ccc0e73693c2bcf4e1766badd062d038814a9442c11b9dc37fda3bc",
    "db_id":"flight_2",
    "question":"Return the number of United Airlines flights leaving from AHD Airport.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #1.Airline , #1.uid ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Join_3 AS ( SELECT Scan_1.Airline, Scan_1.uid FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T2.Airline = T1.uid WHERE T1.Airline = 'United Airlines' AND T2.SourceAirport = 'AHD'"
  },
  {
    "id":"fc7d50c7b91da6ea233b30b07836fcf085ac0fcc1678f271d0c50c3ccb040ab8",
    "db_id":"flight_2",
    "question":"How many United Airlines flights go to City 'Aberdeen'?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3 WITH (FORCESCAN) ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #3 = Scan Table [ flights ] Output [ Airline , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.uid = #3.Airline ] Output [ #3.DestAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #3 = Scan Table [ flights ] Output [ Airline , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.uid = #3.Airline ] Output [ #3.DestAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_3 AS ( SELECT Airline, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.DestAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.uid = Scan_3.Airline ), Join_5 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.DestAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3  ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'"
  },
  {
    "id":"fb9f62e205b9bc6880b700da1dceb69b1975fb77e0c9ffce400ce0446e38b582",
    "db_id":"flight_2",
    "question":"Count the number of United Airlines flights that arrive in Aberdeen.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3 WITH (FORCESCAN) ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #3 = Scan Table [ flights ] Output [ Airline , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.uid = #3.Airline ] Output [ #3.DestAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #3 = Scan Table [ flights ] Output [ Airline , DestAirport ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.uid = #3.Airline ] Output [ #3.DestAirport ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.AirportCode = #4.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_3 AS ( SELECT Airline, DestAirport FROM flight_2.flights ), Join_4 AS ( SELECT Scan_3.DestAirport FROM Scan_2 JOIN Scan_3 ON Scan_2.uid = Scan_3.Airline ), Join_5 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Join_4 ON Scan_1.AirportCode = Join_4.DestAirport ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Join_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode JOIN flight_2.AIRLINES AS T3  ON T3.uid = T1.Airline WHERE T2.City = 'Aberdeen' AND T3.Airline = 'United Airlines'"
  },
  {
    "id":"ff0a82c65d3f97565126fcc5ac049f4dbc79566d8ab0540c9d7d74e49940a317",
    "db_id":"flight_2",
    "question":"Which city has most number of arriving flights?",
    "query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ DestAirport ] Output [ DestAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.DestAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ DestAirport ] Output [ DestAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.DestAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "cte":"WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT DestAirport, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY DestAirport ), Scan_3 AS ( SELECT City, AirportCode FROM flight_2.airports ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.City FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.DestAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT City, COUNT(*) AS Count_Star FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 Count_Star, City FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC"
  },
  {
    "id":"877a21ee7d3418d9490cef1dc4f37236ea50bc68c12059a9466e5e0e862ca059",
    "db_id":"flight_2",
    "question":"Which city has the most frequent destination airport?",
    "query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ DestAirport ] Output [ DestAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.DestAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ DestAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ DestAirport ] Output [ DestAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.DestAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "cte":"WITH Scan_1 AS ( SELECT DestAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT DestAirport, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY DestAirport ), Scan_3 AS ( SELECT City, AirportCode FROM flight_2.airports ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.City FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.DestAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT City, COUNT(*) AS Count_Star FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 Count_Star, City FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport GROUP BY T1.City ORDER BY count ( * ) DESC"
  },
  {
    "id":"ccad946be7d6d75013383b0a2dcc93dfd7c97d868dcafe7309b4e97793ad9e8c",
    "db_id":"flight_2",
    "question":"Which city has most number of departing flights?",
    "query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ SourceAirport ] Output [ SourceAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.SourceAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ SourceAirport ] Output [ SourceAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.SourceAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "cte":"WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT SourceAirport, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY SourceAirport ), Scan_3 AS ( SELECT City, AirportCode FROM flight_2.airports ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.City FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.SourceAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT City, COUNT(*) AS Count_Star FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 Count_Star, City FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC"
  },
  {
    "id":"512837d29318e63bfaec1474fb6fc4170733428b7d581c634116984533d750eb",
    "db_id":"flight_2",
    "question":"Which city is the most frequent source airport?",
    "query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ SourceAirport ] Output [ SourceAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.SourceAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ SourceAirport ] ; #2 = Aggregate [ #1 ] GroupBy [ SourceAirport ] Output [ SourceAirport , countstar AS Count_Star ] ; #3 = Scan Table [ airports ] Output [ City , AirportCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.SourceAirport = #3.AirportCode ] Output [ #2.Count_Star , #3.City ] ; #5 = Aggregate [ #4 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , City ]",
    "cte":"WITH Scan_1 AS ( SELECT SourceAirport FROM flight_2.flights ), Aggregate_2 AS ( SELECT SourceAirport, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY SourceAirport ), Scan_3 AS ( SELECT City, AirportCode FROM flight_2.airports ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.City FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.SourceAirport = Scan_3.AirportCode ), Aggregate_5 AS ( SELECT City, COUNT(*) AS Count_Star FROM Join_4 GROUP BY City ), TopSort_6 AS ( SELECT TOP 1 Count_Star, City FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.City FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.SourceAirport GROUP BY T1.City ORDER BY count ( * ) DESC"
  },
  {
    "id":"d03d7fcb88ff343e5ee83769b30e5f75cf398e639d6be0a1c20fe3f0a406f9aa",
    "db_id":"flight_2",
    "question":"What is the code of airport that has the highest number of flights?",
    "query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, AirportCode FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 Count_Star, AirportCode FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC"
  },
  {
    "id":"2836ab9eeb271d2e43877d422f9139f14d6978de0709568fc8068b36b8212e6f",
    "db_id":"flight_2",
    "question":"What is the airport code of the airport with the most flights?",
    "query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, AirportCode FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 Count_Star, AirportCode FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) DESC"
  },
  {
    "id":"0002168a04349f5ec8af3736caeba3db6f216aeec4b9c65dd78d1d1c4420b940",
    "db_id":"flight_2",
    "question":"What is the code of airport that has fewest number of flights?",
    "query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, AirportCode FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 Count_Star, AirportCode FROM Aggregate_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * )"
  },
  {
    "id":"00a3390111217a03d10cdfb556125b947a46a55fc5ea5458e593007a8cfc1702",
    "db_id":"flight_2",
    "question":"Give the code of the airport with the least flights.",
    "query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , AirportCode ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode ] ; #2 = Scan Table [ flights ] Output [ SourceAirport , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport OR #1.AirportCode = #2.SourceAirport ] Output [ #1.AirportCode ] ; #4 = Aggregate [ #3 ] GroupBy [ AirportCode ] Output [ countstar AS Count_Star , AirportCode ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , AirportCode ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportCode FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, AirportCode FROM Join_3 GROUP BY AirportCode ), TopSort_5 AS ( SELECT TOP 1 Count_Star, AirportCode FROM Aggregate_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.AirportCode FROM flight_2.AIRPORTS AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count ( * )"
  },
  {
    "id":"aeab2749108b0a4074f867008a9cbff20796f8cfc0aa1b851851074dc8dbfa2e",
    "db_id":"flight_2",
    "question":"Which airline has most number of flights?",
    "query":"SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Airline , Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Airline , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), TopSort_6 AS ( SELECT TOP 1 Airline, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC"
  },
  {
    "id":"0f7d42df7248364edf39effe13d7eba22fde164f27cd785a594e0fcd44cabce8",
    "db_id":"flight_2",
    "question":"What airline serves the most flights?",
    "query":"SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Airline , Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Airline , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), TopSort_6 AS ( SELECT TOP 1 Airline, Count_Star FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count ( * ) DESC"
  },
  {
    "id":"0ab456f2fbc7de30a54a57287745b5f8e8c5e3b734a5144f44b1265e347fc73e",
    "db_id":"flight_2",
    "question":"Find the abbreviation and country of the airline that has fewest number of flights?",
    "query":"SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , Country , uid , Abbreviation ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Abbreviation , #3.Country , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Abbreviation , Country , Airline ] Output [ Country , Abbreviation , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Country , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , Country , uid , Abbreviation ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Abbreviation , #3.Country , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Abbreviation , Country , Airline ] Output [ Country , Abbreviation , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Country , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, Country, uid, Abbreviation FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Abbreviation, Scan_3.Country, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Country, Abbreviation, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Abbreviation, Abbreviation , Country , Airline, Country ), TopSort_6 AS ( SELECT TOP 1 Count_Star, Country, Abbreviation FROM Aggregate_5 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * )"
  },
  {
    "id":"614838cd0b6d31a3440afa4fe30f7f7cbcdde3207859e06a773f1369c608adda",
    "db_id":"flight_2",
    "question":"What is the abbreviation of the airilne has the fewest flights and what country is it in?",
    "query":"SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , Country , uid , Abbreviation ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Abbreviation , #3.Country , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Abbreviation , Country , Airline ] Output [ Country , Abbreviation , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Country , Abbreviation ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , Country , uid , Abbreviation ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Abbreviation , #3.Country , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Abbreviation , Country , Airline ] Output [ Country , Abbreviation , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Country , Abbreviation ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, Country, uid, Abbreviation FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Abbreviation, Scan_3.Country, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Country, Abbreviation, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Abbreviation, Abbreviation , Country , Airline, Country ), TopSort_6 AS ( SELECT TOP 1 Count_Star, Country, Abbreviation FROM Aggregate_5 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T1.Abbreviation , T1.Country FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Abbreviation , T1.Country , T1.Airline ORDER BY count ( * )"
  },
  {
    "id":"50c40e6bc28069c3bcc0382be99a457edbe8ea4d10caa0cd645599f8e47f6379",
    "db_id":"flight_2",
    "question":"What are airlines that have some flight departing from airport 'AHD'?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'"
  },
  {
    "id":"59494964483df233275b18143af64420c0b7863a6e168ecb92028d30acc4c823",
    "db_id":"flight_2",
    "question":"Which airlines have a flight with source airport AHD?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'AHD' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'AHD'"
  },
  {
    "id":"c3998b7c1feeb87bae4cca7d360728a072f24c52445c2355240738d9e27063b6",
    "db_id":"flight_2",
    "question":"What are airlines that have flights arriving at airport 'AHD'?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ DestAirport = 'AHD' ] Output [ Airline , DestAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'AHD' ] Output [ Airline , DestAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
  },
  {
    "id":"1ccca59a2bf0612bea4c52b6b33f8bf1840d579cce726f4ad8b25b8342c718d6",
    "db_id":"flight_2",
    "question":"Which airlines have a flight with destination airport AHD?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ DestAirport = 'AHD' ] Output [ Airline , DestAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'AHD' ] Output [ Airline , DestAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Output [ #2.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, DestAirport FROM flight_2.flights WHERE DestAirport = 'AHD' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.DestAirport = 'AHD'"
  },
  {
    "id":"727d962436aa6dab57de5314949a51a9e99124c9086e4e950e58f7b3b425a9d1",
    "db_id":"flight_2",
    "question":"Find all airlines that have flights from both airports 'APG' and 'CVO'.",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Distinct [ true ] Output [ #2.Airline ] ; #4 = Scan Table [ airlines ] Output [ Airline , uid ] ; #5 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.uid = #5.Airline ] Output [ #4.Airline ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Distinct [ true ] Output [ #2.Airline ] ; #4 = Scan Table [ airlines ] Output [ Airline , uid ] ; #5 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.uid = #5.Airline ] Output [ #4.Airline ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT DISTINCT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ), Scan_4 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_5 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_6 AS ( SELECT Scan_4.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.uid = Scan_5.Airline ), Intersect_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline IN (SELECT Airline FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO'"
  },
  {
    "id":"698c94dd60832c69da326ce8bfa2f179b719248703b9e09aa653ebe78a3a67e6",
    "db_id":"flight_2",
    "question":"Which airlines have departing flights from both APG and CVO airports?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Distinct [ true ] Output [ #2.Airline ] ; #4 = Scan Table [ airlines ] Output [ Airline , uid ] ; #5 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.uid = #5.Airline ] Output [ #4.Airline ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #2 = Scan Table [ airlines ] Output [ Airline , uid ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Airline = #2.uid ] Distinct [ true ] Output [ #2.Airline ] ; #4 = Scan Table [ airlines ] Output [ Airline , uid ] ; #5 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.uid = #5.Airline ] Output [ #4.Airline ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_2 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_3 AS ( SELECT DISTINCT Scan_2.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.Airline = Scan_2.uid ), Scan_4 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_5 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_6 AS ( SELECT Scan_4.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.uid = Scan_5.Airline ), Intersect_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline IN (SELECT Airline FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' INTERSECT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO'"
  },
  {
    "id":"39ceb08b1483abd2fc6eb7e0c6288d9443225a383f6d319256bd830cc714cebc",
    "db_id":"flight_2",
    "question":"Find all airlines that have flights from airport 'CVO' but not from 'APG'.",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ airlines ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Distinct [ true ] Output [ #1.Airline ] ; #4 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #5 = Scan Table [ airlines ] Output [ Airline , uid ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Airline = #5.uid ] Output [ #5.Airline ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Distinct [ true ] Output [ #1.Airline ] ; #4 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #5 = Scan Table [ airlines ] Output [ Airline , uid ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Airline = #5.uid ] Output [ #5.Airline ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_3 AS ( SELECT DISTINCT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Scan_4 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_5 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_6 AS ( SELECT Scan_5.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.Airline = Scan_5.uid ), Except_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline NOT IN (SELECT Airline FROM Join_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG'"
  },
  {
    "id":"6632e3ca9157ea891f945858d65d51a7c21b4b3beac8b3d957f92610d775da20",
    "db_id":"flight_2",
    "question":"Which airlines have departures from CVO but not from APG airports?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ airlines ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Distinct [ true ] Output [ #1.Airline ] ; #4 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #5 = Scan Table [ airlines ] Output [ Airline , uid ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Airline = #5.uid ] Output [ #5.Airline ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Predicate [ SourceAirport = 'CVO' ] Output [ Airline , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Distinct [ true ] Output [ #1.Airline ] ; #4 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ Airline , SourceAirport ] ; #5 = Scan Table [ airlines ] Output [ Airline , uid ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Airline = #5.uid ] Output [ #5.Airline ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.Airline = #6.Airline ] Output [ #3.Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'CVO' ), Join_3 AS ( SELECT DISTINCT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ), Scan_4 AS ( SELECT Airline, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ), Scan_5 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_6 AS ( SELECT Scan_5.Airline FROM Scan_4 JOIN Scan_5 ON Scan_4.Airline = Scan_5.uid ), Except_7 AS ( SELECT Join_3.Airline FROM Join_3 WHERE Airline NOT IN (SELECT Airline FROM Join_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'CVO' EXCEPT SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline WHERE T2.SourceAirport = 'APG'"
  },
  {
    "id":"a9ff32fcd6bd92e2683cd5b35a991b73751f44afc13e6146cc8b4a68a61dcc1c",
    "db_id":"flight_2",
    "question":"Find all airlines that have at least 10 flights.",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Output [ uid , Airline ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Airline = #1.uid ] Output [ #1.Airline ] ; #4 = Aggregate [ #3 ] GroupBy [ Airline ] Output [ countstar AS Count_Star , Airline ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 10 ] Output [ Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Output [ uid , Airline ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Airline = #1.uid ] Output [ #1.Airline ] ; #4 = Aggregate [ #3 ] GroupBy [ Airline ] Output [ countstar AS Count_Star , Airline ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 10 ] Output [ Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT uid, Airline FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_2.Airline = Scan_1.uid ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, Airline FROM Join_3 GROUP BY Airline ), Filter_5 AS ( SELECT Airline FROM Aggregate_4 WHERE Count_Star > 10 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10"
  },
  {
    "id":"67367330d8de673f906ebfa5f90854abadcd59ec692acaadafbf1c0b0fcbd88b",
    "db_id":"flight_2",
    "question":"Which airlines have at least 10 flights?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Output [ uid , Airline ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Airline = #1.uid ] Output [ #1.Airline ] ; #4 = Aggregate [ #3 ] GroupBy [ Airline ] Output [ countstar AS Count_Star , Airline ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 10 ] Output [ Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Output [ uid , Airline ] ; #2 = Scan Table [ flights ] Output [ Airline ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Airline = #1.uid ] Output [ #1.Airline ] ; #4 = Aggregate [ #3 ] GroupBy [ Airline ] Output [ countstar AS Count_Star , Airline ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 10 ] Output [ Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT uid, Airline FROM flight_2.airlines ), Scan_2 AS ( SELECT Airline FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.Airline FROM Scan_1 JOIN Scan_2 ON Scan_2.Airline = Scan_1.uid ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, Airline FROM Join_3 GROUP BY Airline ), Filter_5 AS ( SELECT Airline FROM Aggregate_4 WHERE Count_Star > 10 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) > 10"
  },
  {
    "id":"14f44cbc77a573230a3ff8f32108865b84f1805f31fa964bc07357c949ae4d26",
    "db_id":"flight_2",
    "question":"Find all airlines that have fewer than 200 flights.",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star < 200 ] Output [ Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star < 200 ] Output [ Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), Filter_6 AS ( SELECT Airline FROM Aggregate_5 WHERE Count_Star < 200 ) SELECT * FROM Filter_6",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200"
  },
  {
    "id":"ec2e71aef485eb1901917a50f7e013ff97e143dfd5f84f5c8c6c198f9a69106c",
    "db_id":"flight_2",
    "question":"Which airlines have less than 200 flights?",
    "query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1 WITH (FORCESCAN) JOIN flight_2.FLIGHTS AS T2 WITH (FORCESCAN) ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star < 200 ] Output [ Airline ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Output [ Airline ] ; #2 = Aggregate [ #1 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #3 = Scan Table [ airlines ] Output [ Airline , uid ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Airline = #3.uid ] Output [ #2.Count_Star , #3.Airline ] ; #5 = Aggregate [ #4 ] GroupBy [ Airline ] Output [ Airline , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star < 200 ] Output [ Airline ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline FROM flight_2.flights ), Aggregate_2 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Airline ), Scan_3 AS ( SELECT Airline, uid FROM flight_2.airlines ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Airline FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Airline = Scan_3.uid ), Aggregate_5 AS ( SELECT Airline, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Airline ), Filter_6 AS ( SELECT Airline FROM Aggregate_5 WHERE Count_Star < 200 ) SELECT * FROM Filter_6",
    "clean_query":"SELECT T1.Airline FROM flight_2.AIRLINES AS T1  JOIN flight_2.FLIGHTS AS T2  ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count ( * ) < 200"
  },
  {
    "id":"84829bc37e43487777aad24bbb1d364ae6a732e03b5d67e19ee1a9885b5ed33d",
    "db_id":"flight_2",
    "question":"What are flight numbers of Airline \"United Airlines\"?",
    "query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Output [ Airline , FlightNo ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #2.FlightNo ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Output [ Airline , FlightNo ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #2.FlightNo ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, FlightNo FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'"
  },
  {
    "id":"2a3bb875beae5ee8230f21a90839bb7547486bd15cf8d6b567e659b137669342",
    "db_id":"flight_2",
    "question":"Which flight numbers correspond to United Airlines flights?",
    "query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRLINES AS T2 WITH (FORCESCAN) ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Output [ Airline , FlightNo ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #2.FlightNo ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airlines ] Predicate [ Airline = 'United Airlines' ] Output [ Airline , uid ] ; #2 = Scan Table [ flights ] Output [ Airline , FlightNo ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.uid = #2.Airline ] Output [ #2.FlightNo ]",
    "cte":"WITH Scan_1 AS ( SELECT Airline, uid FROM flight_2.airlines WHERE Airline = 'United Airlines' ), Scan_2 AS ( SELECT Airline, FlightNo FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.uid = Scan_2.Airline ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRLINES AS T2  ON T2.uid = T1.Airline WHERE T2.Airline = 'United Airlines'"
  },
  {
    "id":"8efd5f524fe11882fd054fbe9338eead2cd3fe81797f3704ed122a780f499367",
    "db_id":"flight_2",
    "question":"What are flight numbers of flights departing from Airport \"APG\"?",
    "query":"SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ FlightNo , SourceAirport ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ FlightNo , SourceAirport ]",
    "cte":"WITH Scan_1 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT FlightNo FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'"
  },
  {
    "id":"2968bd140b8f572b292b72b93f380074b261e095b014111d7e34b5be584a0735",
    "db_id":"flight_2",
    "question":"Give the flight numbers of flights leaving from APG.",
    "query":"SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE SourceAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ FlightNo , SourceAirport ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ SourceAirport = 'APG' ] Output [ FlightNo , SourceAirport ]",
    "cte":"WITH Scan_1 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights WHERE SourceAirport = 'APG' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT FlightNo FROM flight_2.FLIGHTS  WHERE SourceAirport = 'APG'"
  },
  {
    "id":"7ff01e405c8570255b3f1e0b8579237f1b2cda024aedefc247a6207d8bee48c6",
    "db_id":"flight_2",
    "question":"What are flight numbers of flights arriving at Airport \"APG\"?",
    "query":"SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ DestAirport = 'APG' ] Output [ FlightNo , DestAirport ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'APG' ] Output [ FlightNo , DestAirport ]",
    "cte":"WITH Scan_1 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights WHERE DestAirport = 'APG' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT FlightNo FROM flight_2.FLIGHTS  WHERE DestAirport = 'APG'"
  },
  {
    "id":"661e9a7253223a3ccb079a380550a1278fa81e2f92a8f848c1fe944b04d916e2",
    "db_id":"flight_2",
    "question":"Give the flight numbers of flights landing at APG.",
    "query":"SELECT FlightNo FROM flight_2.FLIGHTS WITH (FORCESCAN) WHERE DestAirport = 'APG' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ flights ] Predicate [ DestAirport = 'APG' ] Output [ FlightNo , DestAirport ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ flights ] Predicate [ DestAirport = 'APG' ] Output [ FlightNo , DestAirport ]",
    "cte":"WITH Scan_1 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights WHERE DestAirport = 'APG' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT FlightNo FROM flight_2.FLIGHTS  WHERE DestAirport = 'APG'"
  },
  {
    "id":"3e0018e4a77c7beccb7a8bd929b7232c2651929030a3b338803d131a009889a5",
    "db_id":"flight_2",
    "question":"What are flight numbers of flights departing from City \"Aberdeen \"?",
    "query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #2.FlightNo ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #2.FlightNo ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"e13407fb59cee2490a6ebbe85e83d8aaafad8412414e1deeca3ddd50c02be181",
    "db_id":"flight_2",
    "question":"Give the flight numbers of flights leaving from Aberdeen.",
    "query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #2.FlightNo ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , SourceAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.SourceAirport ] Output [ #2.FlightNo ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, SourceAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.SourceAirport ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.SourceAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"a53c60a49b1ef48137085af23de337bbc821e26eccb3bd759ba8ce5fcfc931ff",
    "db_id":"flight_2",
    "question":"What are flight numbers of flights arriving at City \"Aberdeen\"?",
    "query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #2.FlightNo ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #2.FlightNo ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"d86ceaccd1552a8dec247eb8118198684cfdf5be0ab450b672774656c4ac72a2",
    "db_id":"flight_2",
    "question":"Give the flight numbers of flights arriving in Aberdeen.",
    "query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1 WITH (FORCESCAN) JOIN flight_2.AIRPORTS AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #2.FlightNo ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ FlightNo , DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #2.FlightNo ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' ), Scan_2 AS ( SELECT FlightNo, DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_2.FlightNo FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.FlightNo FROM flight_2.FLIGHTS AS T1  JOIN flight_2.AIRPORTS AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.City = 'Aberdeen'"
  },
  {
    "id":"121668ef9aa1b21c6f90356eb200c8415c68d85e24e4277a59824c5dd5f9f785",
    "db_id":"flight_2",
    "question":"Find the number of flights landing in the city of Aberdeen or Abilene.",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1 WITH (FORCESCAN) JOIN flight_2.Airports AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' OR City = 'Abilene' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' OR City = 'Abilene' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' OR City = 'Abilene' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1  JOIN flight_2.Airports AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene'"
  },
  {
    "id":"d2374d59745c0e008a05a979d13f5c78e4b5039879a3a689dd950667f24dfdcc",
    "db_id":"flight_2",
    "question":"How many flights land in Aberdeen or Abilene?",
    "query":"SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1 WITH (FORCESCAN) JOIN flight_2.Airports AS T2 WITH (FORCESCAN) ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' OR City = 'Abilene' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Predicate [ City = 'Aberdeen' OR City = 'Abilene' ] Output [ City , AirportCode ] ; #2 = Scan Table [ flights ] Output [ DestAirport ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.AirportCode = #2.DestAirport ] Output [ #1.AirportCode , #1.City ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City, AirportCode FROM flight_2.airports WHERE City = 'Aberdeen' OR City = 'Abilene' ), Scan_2 AS ( SELECT DestAirport FROM flight_2.flights ), Join_3 AS ( SELECT Scan_1.AirportCode, Scan_1.City FROM Scan_1 JOIN Scan_2 ON Scan_1.AirportCode = Scan_2.DestAirport ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM flight_2.Flights AS T1  JOIN flight_2.Airports AS T2  ON T1.DestAirport = T2.AirportCode WHERE T2.city = 'Aberdeen' OR T2.city = 'Abilene'"
  },
  {
    "id":"9a73a6338b34f5e65b5cc27586bccdf5fe018eeda56c944a0b2b0b9f7e6ca09c",
    "db_id":"flight_2",
    "question":"Find the name of airports which do not have any flight in and out.",
    "query":"SELECT AirportName FROM flight_2.Airports WITH (FORCESCAN) WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights WITH (FORCESCAN) UNION SELECT DestAirport FROM flight_2.Flights WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Output [ AirportCode , AirportName ] ; #2 = Scan Table [ flights ] Output [ SourceAirport AS AirportCode ] ; #3 = Scan Table [ flights ] Output [ DestAirport AS AirportCode ] ; #4 = Union [ #2 , #3 ] Output [ #2.AirportCode ] ; #5 = Except [ #1 , #4 ] ExceptColumns [ #1.AirportCode ] Output [ #1.AirportName ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode , AirportName ] ; #2 = Scan Table [ flights ] Output [ SourceAirport AS AirportCode ] ; #3 = Scan Table [ flights ] Output [ DestAirport AS AirportCode ] ; #4 = Union [ #2 , #3 ] Output [ #2.AirportCode ] ; #5 = Except [ #1 , #4 ] ExceptColumns [ #1.AirportCode ] Output [ #1.AirportName ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportCode, AirportName FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport AS AirportCode FROM flight_2.flights ), Scan_3 AS ( SELECT DestAirport AS AirportCode FROM flight_2.flights ), Union_4 AS ( SELECT AirportCode FROM Scan_2 UNION SELECT AirportCode FROM Scan_3 ), Except_5 AS ( SELECT Scan_1.AirportName FROM Scan_1 WHERE NOT EXISTS (SELECT AirportCode FROM Union_4 WHERE Scan_1.AirportCode = Union_4.AirportCode) ) SELECT * FROM Except_5",
    "clean_query":"SELECT AirportName FROM flight_2.Airports  WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights  UNION SELECT DestAirport FROM flight_2.Flights  )"
  },
  {
    "id":"63bfffa86de5ddf9518ff92a308340dbf0884a3e273892bfb044d3f7c7fbe2a3",
    "db_id":"flight_2",
    "question":"Which airports do not have departing or arriving flights?",
    "query":"SELECT AirportName FROM flight_2.Airports WITH (FORCESCAN) WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights WITH (FORCESCAN) UNION SELECT DestAirport FROM flight_2.Flights WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ airports ] Output [ AirportCode , AirportName ] ; #2 = Scan Table [ flights ] Output [ SourceAirport AS AirportCode ] ; #3 = Scan Table [ flights ] Output [ DestAirport AS AirportCode ] ; #4 = Union [ #2 , #3 ] Output [ #2.AirportCode ] ; #5 = Except [ #1 , #4 ] ExceptColumns [ #1.AirportCode ] Output [ #1.AirportName ]",
    "prefixed_qpl":"flight_2 | #1 = Scan Table [ airports ] Output [ AirportCode , AirportName ] ; #2 = Scan Table [ flights ] Output [ SourceAirport AS AirportCode ] ; #3 = Scan Table [ flights ] Output [ DestAirport AS AirportCode ] ; #4 = Union [ #2 , #3 ] Output [ #2.AirportCode ] ; #5 = Except [ #1 , #4 ] ExceptColumns [ #1.AirportCode ] Output [ #1.AirportName ]",
    "cte":"WITH Scan_1 AS ( SELECT AirportCode, AirportName FROM flight_2.airports ), Scan_2 AS ( SELECT SourceAirport AS AirportCode FROM flight_2.flights ), Scan_3 AS ( SELECT DestAirport AS AirportCode FROM flight_2.flights ), Union_4 AS ( SELECT AirportCode FROM Scan_2 UNION SELECT AirportCode FROM Scan_3 ), Except_5 AS ( SELECT Scan_1.AirportName FROM Scan_1 WHERE NOT EXISTS (SELECT AirportCode FROM Union_4 WHERE Scan_1.AirportCode = Union_4.AirportCode) ) SELECT * FROM Except_5",
    "clean_query":"SELECT AirportName FROM flight_2.Airports  WHERE AirportCode NOT IN ( SELECT SourceAirport FROM flight_2.Flights  UNION SELECT DestAirport FROM flight_2.Flights  )"
  },
  {
    "id":"554a0b7814c3f16586c821c590d72c85fb6cd567bdaed14279d59e072644ed1f",
    "db_id":"employee_hire_evaluation",
    "question":"How many employees are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ employee ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee"
  },
  {
    "id":"b7ce7e96288841eb3415b871eb6a39d8aadabecb1b37a15b91b8309111d50ed1",
    "db_id":"employee_hire_evaluation",
    "question":"Count the number of employees",
    "query":"SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ employee ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM employee_hire_evaluation.employee"
  },
  {
    "id":"638f6f2ec73a8fdd72296c056dbd30a739b9d387584c4b01c28c97f413f3675c",
    "db_id":"employee_hire_evaluation",
    "question":"Sort employee names by their age in ascending order.",
    "query":"SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ employee ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM employee_hire_evaluation.employee ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
    "clean_query":"SELECT name FROM employee_hire_evaluation.employee  ORDER BY age"
  },
  {
    "id":"187a9dfd630ef2d10c685b291d0f05840d8d172803e5dede4b1dfcd226fa7f5e",
    "db_id":"employee_hire_evaluation",
    "question":"List the names of employees and sort in ascending order of age.",
    "query":"SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) ORDER BY age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ employee ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM employee_hire_evaluation.employee ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
    "clean_query":"SELECT name FROM employee_hire_evaluation.employee  ORDER BY age"
  },
  {
    "id":"3e0c05f363776d11348e6153e66cd5edbe0ef5a51c3a812ec2633d44e47352ee",
    "db_id":"employee_hire_evaluation",
    "question":"What is the number of employees from each city?",
    "query":"SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee WITH (FORCESCAN) GROUP BY city OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ employee ] Output [ City ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ City ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT City, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY City ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee  GROUP BY city"
  },
  {
    "id":"e81d18bcec18f6d352f79d2f159af0c55a5dc378dca8d9aa19e6d1a9d78f5a9e",
    "db_id":"employee_hire_evaluation",
    "question":"Count the number of employees for each city.",
    "query":"SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee WITH (FORCESCAN) GROUP BY city OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ employee ] Output [ City ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ City ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT City FROM employee_hire_evaluation.employee ), Aggregate_2 AS ( SELECT City, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY City ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , city FROM employee_hire_evaluation.employee  GROUP BY city"
  },
  {
    "id":"f290992f9d25245881047abb0c5a8fa75425fa9fa94cedc433334874825ed374",
    "db_id":"employee_hire_evaluation",
    "question":"Which cities do more than one employee under age 30 come from?",
    "query":"SELECT city FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE age < 30 GROUP BY city HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ employee ] Predicate [ Age < 30 ] Output [ City , Age ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ City ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Predicate [ Age < 30 ] Output [ City , Age ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ City ]",
    "cte":"WITH Scan_1 AS ( SELECT City, Age FROM employee_hire_evaluation.employee WHERE Age < 30 ), Aggregate_2 AS ( SELECT City, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY City ), Filter_3 AS ( SELECT City FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT city FROM employee_hire_evaluation.employee  WHERE age < 30 GROUP BY city HAVING count ( * ) > 1"
  },
  {
    "id":"335feb174905f95c58ecd6591d17c573f3b40baf343333f6bbeed83c02516e79",
    "db_id":"employee_hire_evaluation",
    "question":"Find the cities that have more than one employee under age 30.",
    "query":"SELECT city FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE age < 30 GROUP BY city HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ employee ] Predicate [ Age < 30 ] Output [ City , Age ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ City ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Predicate [ Age < 30 ] Output [ City , Age ] ; #2 = Aggregate [ #1 ] GroupBy [ City ] Output [ City , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ City ]",
    "cte":"WITH Scan_1 AS ( SELECT City, Age FROM employee_hire_evaluation.employee WHERE Age < 30 ), Aggregate_2 AS ( SELECT City, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY City ), Filter_3 AS ( SELECT City FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT city FROM employee_hire_evaluation.employee  WHERE age < 30 GROUP BY city HAVING count ( * ) > 1"
  },
  {
    "id":"a4b73ee60e1ed8de6d08edba00c1d94f1aed84d6660302a5970865956fdbdf1c",
    "db_id":"employee_hire_evaluation",
    "question":"Find the number of shops in each location.",
    "query":"SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) GROUP BY LOCATION OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ Location ] ; #2 = Aggregate [ #1 ] GroupBy [ Location ] Output [ countstar AS Count_Star , Location ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Location ] ; #2 = Aggregate [ #1 ] GroupBy [ Location ] Output [ countstar AS Count_Star , Location ]",
    "cte":"WITH Scan_1 AS ( SELECT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Location FROM Scan_1 GROUP BY Location ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop  GROUP BY LOCATION"
  },
  {
    "id":"0d4fb20a6fb3ba654d1369ba25a6a2a37e5ff5c8fdd5227b2a6e28aa7436fa5e",
    "db_id":"employee_hire_evaluation",
    "question":"How many shops are there in each location?",
    "query":"SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) GROUP BY LOCATION OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ Location ] ; #2 = Aggregate [ #1 ] GroupBy [ Location ] Output [ countstar AS Count_Star , Location ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Location ] ; #2 = Aggregate [ #1 ] GroupBy [ Location ] Output [ countstar AS Count_Star , Location ]",
    "cte":"WITH Scan_1 AS ( SELECT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Location FROM Scan_1 GROUP BY Location ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , LOCATION FROM employee_hire_evaluation.shop  GROUP BY LOCATION"
  },
  {
    "id":"4e203440b0f9a0aedc9e463d02382c9f59aab4bf42372c1411307a998ac33150",
    "db_id":"employee_hire_evaluation",
    "question":"Find the manager name and district of the shop whose number of products is the largest.",
    "query":"SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ District , Manager_name , Number_products ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Number_products DESC ] Output [ District , Manager_name , Number_products ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ District , Manager_name , Number_products ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Number_products DESC ] Output [ District , Manager_name , Number_products ]",
    "cte":"WITH Scan_1 AS ( SELECT District, Manager_name, Number_products FROM employee_hire_evaluation.shop ), TopSort_2 AS ( SELECT TOP 1 District, Manager_name, Number_products FROM Scan_1 ORDER BY Number_products DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC"
  },
  {
    "id":"7c4fa321a90c7351e476975b181c798ce83282484ff08fa81936504345c58670",
    "db_id":"employee_hire_evaluation",
    "question":"What are the manager name and district of the shop that sells the largest number of products?",
    "query":"SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ District , Manager_name , Number_products ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Number_products DESC ] Output [ District , Manager_name , Number_products ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ District , Manager_name , Number_products ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Number_products DESC ] Output [ District , Manager_name , Number_products ]",
    "cte":"WITH Scan_1 AS ( SELECT District, Manager_name, Number_products FROM employee_hire_evaluation.shop ), TopSort_2 AS ( SELECT TOP 1 District, Manager_name, Number_products FROM Scan_1 ORDER BY Number_products DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 manager_name , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC"
  },
  {
    "id":"6ae399e06f0727c2e17b66033a479df7c995fb6126ac67372fe9c15c6a115c23",
    "db_id":"employee_hire_evaluation",
    "question":"find the minimum and maximum number of products of all stores.",
    "query":"SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ MIN(Number_products) AS Min_Number_products , MAX(Number_products) AS Max_Number_products ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ MIN(Number_products) AS Min_Number_products , MAX(Number_products) AS Max_Number_products ]",
    "cte":"WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT MIN(Number_products) AS Min_Number_products, MAX(Number_products) AS Max_Number_products FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop"
  },
  {
    "id":"9e1d5ef6745da75269f01f2394f4be8f88a36f0f2f1760c4d6dd46ebc23dec81",
    "db_id":"employee_hire_evaluation",
    "question":"What are the minimum and maximum number of products across all the shops?",
    "query":"SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ MIN(Number_products) AS Min_Number_products , MAX(Number_products) AS Max_Number_products ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ MIN(Number_products) AS Min_Number_products , MAX(Number_products) AS Max_Number_products ]",
    "cte":"WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT MIN(Number_products) AS Min_Number_products, MAX(Number_products) AS Max_Number_products FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT min ( Number_products ) AS Min_Number_products , max ( Number_products ) AS Max_Number_products FROM employee_hire_evaluation.shop"
  },
  {
    "id":"f8a3282285f9259ebf76f900a07aac1703877f2df99a0034fa27e72907327cb5",
    "db_id":"employee_hire_evaluation",
    "question":"Return the name, location and district of all shops in descending order of number of products.",
    "query":"SELECT name , LOCATION , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ Name , District , Number_products , Location ] ; #2 = Sort [ #1 ] OrderBy [ Number_products DESC ] Output [ Name , District , Number_products , Location ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , District , Number_products , Location ] ; #2 = Sort [ #1 ] OrderBy [ Number_products DESC ] Output [ Name , District , Number_products , Location ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, District, Number_products, Location FROM employee_hire_evaluation.shop ) SELECT Name, District, Number_products, Location FROM Scan_1 ORDER BY Number_products DESC",
    "clean_query":"SELECT name , LOCATION , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC"
  },
  {
    "id":"b69843ef90777876c4360c78bd23ba71beb1e392bbf2540345f6709eb354d205",
    "db_id":"employee_hire_evaluation",
    "question":"Sort all the shops by number products in descending order, and return the name, location and district of each shop.",
    "query":"SELECT name , LOCATION , district FROM employee_hire_evaluation.shop WITH (FORCESCAN) ORDER BY number_products DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ shop ] Output [ Name , District , Number_products , Location ] ; #2 = Sort [ #1 ] OrderBy [ Number_products DESC ] Output [ Name , District , Number_products , Location ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , District , Number_products , Location ] ; #2 = Sort [ #1 ] OrderBy [ Number_products DESC ] Output [ Name , District , Number_products , Location ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, District, Number_products, Location FROM employee_hire_evaluation.shop ) SELECT Name, District, Number_products, Location FROM Scan_1 ORDER BY Number_products DESC",
    "clean_query":"SELECT name , LOCATION , district FROM employee_hire_evaluation.shop  ORDER BY number_products DESC"
  },
  {
    "id":"c7b79dc46ba1d29aaab498484888e38ee860e274eca99a6919829c054daf7d81",
    "db_id":"employee_hire_evaluation",
    "question":"Find the names of stores whose number products is more than the average number of products.",
    "query":"SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ AVG(Number_products) AS Avg_Number_products ] ; #3 = Scan Table [ shop ] Output [ Name , Number_products ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Number_products > #2.Avg_Number_products ] Output [ #3.Name ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ AVG(Number_products) AS Avg_Number_products ] ; #3 = Scan Table [ shop ] Output [ Name , Number_products ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Number_products > #2.Avg_Number_products ] Output [ #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT AVG(Number_products) AS Avg_Number_products FROM Scan_1 ), Scan_3 AS ( SELECT Name, Number_products FROM employee_hire_evaluation.shop ), Join_4 AS ( SELECT Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Number_products > Aggregate_2.Avg_Number_products ) SELECT * FROM Join_4",
    "clean_query":"SELECT name FROM employee_hire_evaluation.shop  WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop  )"
  },
  {
    "id":"6ea998f796ec30bffa8e18b93df295017492f935422901936d3cd25d3d8cb4b4",
    "db_id":"employee_hire_evaluation",
    "question":"Which shops' number products is above the average? Give me the shop names.",
    "query":"SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ AVG(Number_products) AS Avg_Number_products ] ; #3 = Scan Table [ shop ] Output [ Name , Number_products ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Number_products > #2.Avg_Number_products ] Output [ #3.Name ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Number_products ] ; #2 = Aggregate [ #1 ] Output [ AVG(Number_products) AS Avg_Number_products ] ; #3 = Scan Table [ shop ] Output [ Name , Number_products ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Number_products > #2.Avg_Number_products ] Output [ #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Number_products FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT AVG(Number_products) AS Avg_Number_products FROM Scan_1 ), Scan_3 AS ( SELECT Name, Number_products FROM employee_hire_evaluation.shop ), Join_4 AS ( SELECT Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Number_products > Aggregate_2.Avg_Number_products ) SELECT * FROM Join_4",
    "clean_query":"SELECT name FROM employee_hire_evaluation.shop  WHERE number_products > ( SELECT avg ( number_products ) AS Avg_number_products FROM employee_hire_evaluation.shop  )"
  },
  {
    "id":"0049599bd964edec86a7cd9e34a482b47430b2f6f3b2376013f90f446d7b20e0",
    "db_id":"employee_hire_evaluation",
    "question":"find the name of employee who was awarded the most times in the evaluation.",
    "query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Employee_ID ] Output [ Employee_ID , countstar AS Count_Star ] ; #3 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Employee_ID = #3.Employee_ID ] Output [ #2.Count_Star , #3.Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Employee_ID ] Output [ Employee_ID , countstar AS Count_Star ] ; #3 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Employee_ID = #3.Employee_ID ] Output [ #2.Count_Star , #3.Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT Employee_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Employee_ID ), Scan_3 AS ( SELECT Employee_ID, Name FROM employee_hire_evaluation.employee ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Employee_ID = Scan_3.Employee_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC"
  },
  {
    "id":"93b7ac35d94bcc7afc58e37c1555d4cd63f189511d09f623994cfda40291923d",
    "db_id":"employee_hire_evaluation",
    "question":"Which employee received the most awards in evaluations? Give me the employee name.",
    "query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Employee_ID ] Output [ Employee_ID , countstar AS Count_Star ] ; #3 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Employee_ID = #3.Employee_ID ] Output [ #2.Count_Star , #3.Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Employee_ID ] Output [ Employee_ID , countstar AS Count_Star ] ; #3 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Employee_ID = #3.Employee_ID ] Output [ #2.Count_Star , #3.Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT Employee_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Employee_ID ), Scan_3 AS ( SELECT Employee_ID, Name FROM employee_hire_evaluation.employee ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Employee_ID = Scan_3.Employee_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID GROUP BY t1.name , t2.Employee_ID ORDER BY count ( * ) DESC"
  },
  {
    "id":"3139aeb80c8cefdaf39826e2d00b9d3cd210caeef5fb2ead36207817e06f956c",
    "db_id":"employee_hire_evaluation",
    "question":"Find the name of the employee who got the highest one time bonus.",
    "query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ evaluation ] Output [ Employee_ID , Bonus ] ; #2 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Employee_ID = #2.Employee_ID ] Output [ #1.Bonus , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Bonus DESC ] Output [ Name , Bonus ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID , Bonus ] ; #2 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Employee_ID = #2.Employee_ID ] Output [ #1.Bonus , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Bonus DESC ] Output [ Name , Bonus ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID, Bonus FROM employee_hire_evaluation.evaluation ), Scan_2 AS ( SELECT Employee_ID, Name FROM employee_hire_evaluation.employee ), Join_3 AS ( SELECT Scan_1.Bonus, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Employee_ID = Scan_2.Employee_ID ), TopSort_4 AS ( SELECT TOP 1 Name, Bonus FROM Join_3 ORDER BY Bonus DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC"
  },
  {
    "id":"944f0b4d6ff267f7af127233f544a13a26d78eac3fd23869c146f15b97c3279f",
    "db_id":"employee_hire_evaluation",
    "question":"Which employee received the biggest bonus? Give me the employee name.",
    "query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.evaluation AS t2 WITH (FORCESCAN) ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ evaluation ] Output [ Employee_ID , Bonus ] ; #2 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Employee_ID = #2.Employee_ID ] Output [ #1.Bonus , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Bonus DESC ] Output [ Name , Bonus ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Employee_ID , Bonus ] ; #2 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Employee_ID = #2.Employee_ID ] Output [ #1.Bonus , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Bonus DESC ] Output [ Name , Bonus ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID, Bonus FROM employee_hire_evaluation.evaluation ), Scan_2 AS ( SELECT Employee_ID, Name FROM employee_hire_evaluation.employee ), Join_3 AS ( SELECT Scan_1.Bonus, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Employee_ID = Scan_2.Employee_ID ), TopSort_4 AS ( SELECT TOP 1 Name, Bonus FROM Join_3 ORDER BY Bonus DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 t1.name FROM employee_hire_evaluation.employee AS t1  JOIN employee_hire_evaluation.evaluation AS t2  ON t1.Employee_ID = t2.Employee_ID ORDER BY t2.bonus DESC"
  },
  {
    "id":"c850bd4e8300b6e5ba35a342efc45a3c8f2d8ed8a4ce4e92e01bc12f5688331c",
    "db_id":"employee_hire_evaluation",
    "question":"Find the names of employees who never won any award in the evaluation.",
    "query":"SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #2 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Employee_ID ] Output [ Employee_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Employee_ID = #1.Employee_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #2 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Employee_ID ] Output [ Employee_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Employee_ID = #1.Employee_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID, Name FROM employee_hire_evaluation.employee ), Scan_2 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_3 AS ( SELECT Employee_ID FROM Scan_2 GROUP BY Employee_ID ), Except_4 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Employee_ID NOT IN (SELECT Employee_ID FROM Aggregate_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT name FROM employee_hire_evaluation.employee  WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation  )"
  },
  {
    "id":"85aeac6085a45b42a3cb13e9a51a1238d1d7659f549c5d296e0bd0b85977b67f",
    "db_id":"employee_hire_evaluation",
    "question":"What are the names of the employees who never received any evaluation?",
    "query":"SELECT name FROM employee_hire_evaluation.employee WITH (FORCESCAN) WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #2 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Employee_ID ] Output [ Employee_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Employee_ID = #1.Employee_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ employee ] Output [ Employee_ID , Name ] ; #2 = Scan Table [ evaluation ] Output [ Employee_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Employee_ID ] Output [ Employee_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Employee_ID = #1.Employee_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID, Name FROM employee_hire_evaluation.employee ), Scan_2 AS ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation ), Aggregate_3 AS ( SELECT Employee_ID FROM Scan_2 GROUP BY Employee_ID ), Except_4 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Employee_ID NOT IN (SELECT Employee_ID FROM Aggregate_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT name FROM employee_hire_evaluation.employee  WHERE Employee_ID NOT IN ( SELECT Employee_ID FROM employee_hire_evaluation.evaluation  )"
  },
  {
    "id":"9c652b3b6b8008aeefd32407accb5c92e8b77e33db8255bf73373095371f09ac",
    "db_id":"employee_hire_evaluation",
    "question":"What is the name of the shop that is hiring the largest number of employees?",
    "query":"SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #1.Shop_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Shop_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #1.Shop_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Shop_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_1.Shop_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Shop_ID, Name ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"6a735b312c65119564c18fa7ea1b10ecb2e74b7449a429e88e93ecf303f8eeb5",
    "db_id":"employee_hire_evaluation",
    "question":"Which shop has the most employees? Give me the shop name.",
    "query":"SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #1.Shop_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Shop_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #1.Shop_ID , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Shop_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_1.Shop_ID, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Shop_ID, Name ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name , t1.shop_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"72cb3e5d56ab334b4eb7dbfbb1e6d8cac17ea9531d988f83da4a411ca5ed89a6",
    "db_id":"employee_hire_evaluation",
    "question":"Find the name of the shops that do not hire any employee.",
    "query":"SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #2 = Scan Table [ hiring ] Output [ Shop_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Shop_ID IS NULL OR #1.Shop_ID = #2.Shop_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #2 = Scan Table [ hiring ] Output [ Shop_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Shop_ID IS NULL OR #1.Shop_ID = #2.Shop_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Scan_2 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Shop_ID NOT IN (SELECT Shop_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT name FROM employee_hire_evaluation.shop  WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring  )"
  },
  {
    "id":"d080be18c27371378e9624a6372e8ba0e7e9f9cde4f841e863a6a2a3aa5ea890",
    "db_id":"employee_hire_evaluation",
    "question":"Which shops run with no employees? Find the shop names",
    "query":"SELECT name FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #2 = Scan Table [ hiring ] Output [ Shop_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Shop_ID IS NULL OR #1.Shop_ID = #2.Shop_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #2 = Scan Table [ hiring ] Output [ Shop_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Shop_ID IS NULL OR #1.Shop_ID = #2.Shop_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Scan_2 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Shop_ID NOT IN (SELECT Shop_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT name FROM employee_hire_evaluation.shop  WHERE shop_id NOT IN ( SELECT shop_id FROM employee_hire_evaluation.hiring  )"
  },
  {
    "id":"c645e766e0f936794bee7762b6bf8105d088753264597fd96793c738dd10dd91",
    "db_id":"employee_hire_evaluation",
    "question":"Find the number of employees hired in each shop; show the shop name as well.",
    "query":"SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name"
  },
  {
    "id":"d4a90c1eaa15edba9a6d3920f3e16b7bfa906ace797d675ad139dd1f1982ae08",
    "db_id":"employee_hire_evaluation",
    "question":"For each shop, return the number of employees working there and the name of the shop.",
    "query":"SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1 WITH (FORCESCAN) JOIN employee_hire_evaluation.shop AS t2 WITH (FORCESCAN) ON t1.shop_id = t2.shop_id GROUP BY t2.name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Shop_ID ] ; #2 = Scan Table [ shop ] Output [ Name , Shop_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Shop_ID = #2.Shop_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Shop_ID FROM employee_hire_evaluation.hiring ), Scan_2 AS ( SELECT Name, Shop_ID FROM employee_hire_evaluation.shop ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Shop_ID = Scan_2.Shop_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star , t2.name FROM employee_hire_evaluation.hiring AS t1  JOIN employee_hire_evaluation.shop AS t2  ON t1.shop_id = t2.shop_id GROUP BY t2.name"
  },
  {
    "id":"9d6035ad0ad42b2d785b043e82035e314bdf85d3fa4ae7d8d22cb7a8980c2c5b",
    "db_id":"employee_hire_evaluation",
    "question":"What is total bonus given in all evaluations?",
    "query":"SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ evaluation ] Output [ Bonus ] ; #2 = Aggregate [ #1 ] Output [ SUM(Bonus) AS Sum_Bonus ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Bonus ] ; #2 = Aggregate [ #1 ] Output [ SUM(Bonus) AS Sum_Bonus ]",
    "cte":"WITH Scan_1 AS ( SELECT Bonus FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT SUM(Bonus) AS Sum_Bonus FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation"
  },
  {
    "id":"542cbe30d5c93dbde2e5d22089c6766789949c24e1098ec81ef7fb28853ae1ff",
    "db_id":"employee_hire_evaluation",
    "question":"Find the total amount of bonus given in all the evaluations.",
    "query":"SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ evaluation ] Output [ Bonus ] ; #2 = Aggregate [ #1 ] Output [ SUM(Bonus) AS Sum_Bonus ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ evaluation ] Output [ Bonus ] ; #2 = Aggregate [ #1 ] Output [ SUM(Bonus) AS Sum_Bonus ]",
    "cte":"WITH Scan_1 AS ( SELECT Bonus FROM employee_hire_evaluation.evaluation ), Aggregate_2 AS ( SELECT SUM(Bonus) AS Sum_Bonus FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( bonus ) AS Sum_bonus FROM employee_hire_evaluation.evaluation"
  },
  {
    "id":"5c0de2f93c0a4a04d5e485de311035b20abd380bf6580f29e898c84ac4a90fc1",
    "db_id":"employee_hire_evaluation",
    "question":"Give me all the information about hiring.",
    "query":"SELECT * FROM employee_hire_evaluation.hiring WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ hiring ] Output [ Employee_ID , Is_full_time , Shop_ID , Start_from ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Employee_ID , Is_full_time , Shop_ID , Start_from ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID, Is_full_time, Shop_ID, Start_from FROM employee_hire_evaluation.hiring ) SELECT * FROM Scan_1",
    "clean_query":"SELECT * FROM employee_hire_evaluation.hiring"
  },
  {
    "id":"9a5c03af4b83ba7b55e93a138b9c8711e265ee47ca1a1ffa85059523cee22920",
    "db_id":"employee_hire_evaluation",
    "question":"What is all the information about hiring?",
    "query":"SELECT * FROM employee_hire_evaluation.hiring WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ hiring ] Output [ Employee_ID , Is_full_time , Shop_ID , Start_from ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ hiring ] Output [ Employee_ID , Is_full_time , Shop_ID , Start_from ]",
    "cte":"WITH Scan_1 AS ( SELECT Employee_ID, Is_full_time, Shop_ID, Start_from FROM employee_hire_evaluation.hiring ) SELECT * FROM Scan_1",
    "clean_query":"SELECT * FROM employee_hire_evaluation.hiring"
  },
  {
    "id":"41ac9ea02212af7c1d4afef475a1a3e7678709ec843720d39156c36445ceb7ae",
    "db_id":"employee_hire_evaluation",
    "question":"Which district has both stores with less than 3000 products and stores with more than 10000 products?",
    "query":"SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products > 10000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ shop ] Predicate [ Number_products < 3000 ] Distinct [ true ] Output [ District , Number_products ] ; #2 = Scan Table [ shop ] Predicate [ Number_products > 10000 ] Output [ District , Number_products ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.District = #2.District ] Output [ #1.District ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Predicate [ Number_products < 3000 ] Distinct [ true ] Output [ District , Number_products ] ; #2 = Scan Table [ shop ] Predicate [ Number_products > 10000 ] Output [ District , Number_products ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.District = #2.District ] Output [ #1.District ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT District, Number_products FROM employee_hire_evaluation.shop WHERE Number_products < 3000 ), Scan_2 AS ( SELECT District, Number_products FROM employee_hire_evaluation.shop WHERE Number_products > 10000 ), Intersect_3 AS ( SELECT Scan_1.District FROM Scan_1 WHERE District IN (SELECT District FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products > 10000"
  },
  {
    "id":"e0677381f837d83064d2983f6482252b89c6d6f8f0f60cad1d6fabe5917d5ec1",
    "db_id":"employee_hire_evaluation",
    "question":"Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.",
    "query":"SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop WITH (FORCESCAN) WHERE Number_products > 10000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ shop ] Predicate [ Number_products < 3000 ] Distinct [ true ] Output [ District , Number_products ] ; #2 = Scan Table [ shop ] Predicate [ Number_products > 10000 ] Output [ District , Number_products ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.District = #2.District ] Output [ #1.District ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Predicate [ Number_products < 3000 ] Distinct [ true ] Output [ District , Number_products ] ; #2 = Scan Table [ shop ] Predicate [ Number_products > 10000 ] Output [ District , Number_products ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.District = #2.District ] Output [ #1.District ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT District, Number_products FROM employee_hire_evaluation.shop WHERE Number_products < 3000 ), Scan_2 AS ( SELECT District, Number_products FROM employee_hire_evaluation.shop WHERE Number_products > 10000 ), Intersect_3 AS ( SELECT Scan_1.District FROM Scan_1 WHERE District IN (SELECT District FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products < 3000 INTERSECT SELECT district FROM employee_hire_evaluation.shop  WHERE Number_products > 10000"
  },
  {
    "id":"8f2fa5fd0ef79053cfaef4c8c5f35c04f052a81db289cbdc839fcf8309c7201c",
    "db_id":"employee_hire_evaluation",
    "question":"How many different store locations are there?",
    "query":"SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ shop ] Distinct [ true ] Output [ Location ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Location) AS Count_Dist_Location ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Distinct [ true ] Output [ Location ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Location) AS Count_Dist_Location ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Location) AS Count_Dist_Location FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop"
  },
  {
    "id":"819c2643bf90842bf8740422b759e856df9364f70dfae3b568f5dac7506e4c90",
    "db_id":"employee_hire_evaluation",
    "question":"Count the number of distinct store locations.",
    "query":"SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ shop ] Distinct [ true ] Output [ Location ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Location) AS Count_Dist_Location ]",
    "prefixed_qpl":"employee_hire_evaluation | #1 = Scan Table [ shop ] Distinct [ true ] Output [ Location ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Location) AS Count_Dist_Location ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Location FROM employee_hire_evaluation.shop ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Location) AS Count_Dist_Location FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT LOCATION ) AS Count_Dist_LOCATION FROM employee_hire_evaluation.shop"
  },
  {
    "id":"eab7bb94e7abc6a9e24b9ce9ebd085bd7718b6149dae5227d4158b83dc38b80a",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many documents do we have?",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Documents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"79abb4aa8ede602463ad0c23ef7d323059fd0942a2c077791c8902fa8a6b3c84",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of documents.",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Documents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"fce8efd12aefcfdc3f2e9ca07f4444e7f1865fffdd2bc1fc7ec53c0727a02f6a",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"List document IDs, document names, and document descriptions for all documents.",
    "query":"SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Document_ID , Document_Description , Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Document_ID , Document_Description , Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Description, Document_Name FROM cre_Doc_Template_Mgt.Documents ) SELECT * FROM Scan_1",
    "clean_query":"SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"adf96d93299f5428237c3f5812145f2761590bac2baec91d082aa82d0d2b0b84",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids, names, and descriptions for all documents?",
    "query":"SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Document_ID , Document_Description , Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Document_ID , Document_Description , Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Description, Document_Name FROM cre_Doc_Template_Mgt.Documents ) SELECT * FROM Scan_1",
    "clean_query":"SELECT document_id , document_name , document_description FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"7cfeeba3a17801aa0e5e8907ae3de3f7117164f2eac9624d4f86b7caed7ae112",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the document name and template id for document with description with the letter 'w' in it?",
    "query":"SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE Document_Description LIKE '%w%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Description like '%w%' ] Output [ Document_Description , Document_Name , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Description like '%w%' ] Output [ Document_Description , Document_Name , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_Description, Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Description like '%w%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents  WHERE Document_Description LIKE '%w%'"
  },
  {
    "id":"18df0d6d89d729ddddb63ab14a7b51091dcdaa8a024eb30d6fc2483580187d04",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the names and template ids for documents that contain the letter w in their description.",
    "query":"SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE Document_Description LIKE '%w%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Description like '%w%' ] Output [ Document_Description , Document_Name , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Description like '%w%' ] Output [ Document_Description , Document_Name , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_Description, Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Description like '%w%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT document_name , template_id FROM cre_Doc_Template_Mgt.Documents  WHERE Document_Description LIKE '%w%'"
  },
  {
    "id":"de7fe93e9fc34cbb4e48313cb3c9d1a8b89df8398f23bf0ed08a5dca217c31d4",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the document id, template id and description for document named \"Robbin CV\"?",
    "query":"SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE document_name = 'Robbin CV' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Robbin CV' ] Output [ Document_Name , Document_ID , Document_Description , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Robbin CV' ] Output [ Document_Name , Document_ID , Document_Description , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_Name, Document_ID, Document_Description, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Robbin CV' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents  WHERE document_name = 'Robbin CV'"
  },
  {
    "id":"7571db72eb5bba0f37d0be25e316684fb2c1e9f8c7b68a7a4d919a83bb7e09fa",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the document id, template id, and description for the document with the name Robbin CV.",
    "query":"SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) WHERE document_name = 'Robbin CV' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Robbin CV' ] Output [ Document_Name , Document_ID , Document_Description , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Robbin CV' ] Output [ Document_Name , Document_ID , Document_Description , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_Name, Document_ID, Document_Description, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Robbin CV' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT document_id , template_id , Document_Description FROM cre_Doc_Template_Mgt.Documents  WHERE document_name = 'Robbin CV'"
  },
  {
    "id":"725a0a1fc36a2853a3b3653227520372024a5dba8ae7bed03e06066dc689001d",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many different templates do all document use?",
    "query":"SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Documents ] Distinct [ true ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Distinct [ true ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"0fe435ff996ce5bd596ecf192de9539d0b672b65c46ad5ac0b30f3ae4de14179",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of different templates used for documents.",
    "query":"SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Documents ] Distinct [ true ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Distinct [ true ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Template_ID) AS Count_Dist_Template_ID FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT template_id ) AS Count_Dist_template_id FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"3d42cc6f33bbde3a7435930ec8087870981f004e3da7c98cf437a6de0a7d8d7a",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many documents are using the template with type code 'PPT'?",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #1.Template_ID , #1.Template_Type_Code ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #1.Template_ID , #1.Template_Type_Code ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PPT' ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_1.Template_ID, Scan_1.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT'"
  },
  {
    "id":"577492e72abb4721384a009437ef90d0efd51c4d0a2fac6c92e9cceed7781094",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of documents that use the PPT template type.",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #1.Template_ID , #1.Template_Type_Code ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #1.Template_ID , #1.Template_Type_Code ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PPT' ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_1.Template_ID, Scan_1.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.Template_ID = T2.Template_ID WHERE T2.Template_Type_Code = 'PPT'"
  },
  {
    "id":"c6bc5150c9983a750e71d9667f462c05d034560988d775220ae3b526e8e64abd",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all template ids and number of documents using each template.",
    "query":"SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT Template_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_ID ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id"
  },
  {
    "id":"21a326c50fe17acbb83d3c76d8ef9b391937207f1540f33c05c37f28ca6a7b67",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are all different template ids used for documents, and how many times were each of them used?",
    "query":"SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT Template_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_ID ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT template_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id"
  },
  {
    "id":"c3ef543a45f6e5e4f66daf47c8a178b75e697130dea996d32edb01489e7f2b0c",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the id and type code for the template used by the most documents?",
    "query":"SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code , #2.Count_Star , #2.Template_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code , #2.Count_Star , #2.Template_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT Template_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_ID ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code, Aggregate_2.Count_Star, Aggregate_2.Template_ID FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Template_ID = Scan_3.Template_ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Template_Type_Code, Template_ID FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC"
  },
  {
    "id":"66c3f98482a14280727e245d4aa8fb05ff84ec2ea3d5c2fc79ecd29f068dc541",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the id and type code of the template that is used for the greatest number of documents.",
    "query":"SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code , #2.Count_Star , #2.Template_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code , #2.Count_Star , #2.Template_ID ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT Template_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_ID ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code, Aggregate_2.Count_Star, Aggregate_2.Template_ID FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Template_ID = Scan_3.Template_ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Template_Type_Code, Template_ID FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.template_id , T2.Template_Type_Code FROM cre_Doc_Template_Mgt.Documents AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_id , T2.Template_Type_Code ORDER BY count ( * ) DESC"
  },
  {
    "id":"4af5f846a2c00cc1660bb52df528a97d9532d57a5546a57a7d2989a3df6518c8",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show ids for all templates that are used by more than one document.",
    "query":"SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT Template_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_ID ), Filter_3 AS ( SELECT Template_ID FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT template_id FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id HAVING count ( * ) > 1"
  },
  {
    "id":"e449e6f942e8de3c7125b40721a8e17af0e967438dc82614ca4da0cc044227c3",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the template ids of any templates used in more than a single document?",
    "query":"SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) GROUP BY template_id HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_ID ] Output [ Template_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 1 ] Output [ Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Aggregate_2 AS ( SELECT Template_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_ID ), Filter_3 AS ( SELECT Template_ID FROM Aggregate_2 WHERE Count_Star > 1 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT template_id FROM cre_Doc_Template_Mgt.Documents  GROUP BY template_id HAVING count ( * ) > 1"
  },
  {
    "id":"90709a58f713a9b610f22a044e73dd9540902fee65a49244b062b9344b9e1493",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show ids for all templates not used by any document.",
    "query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Template_ID = #1.Template_ID ] Output [ #1.Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Template_ID = #1.Template_ID ] Output [ #1.Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Except_3 AS ( SELECT Scan_1.Template_ID FROM Scan_1 WHERE Template_ID NOT IN (SELECT Template_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"653a2932fa46003787be8119d8beaab1ef997a5cf04809f7712481e7ffdecd2d",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids for templates that are not used in any documents?",
    "query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Template_ID = #1.Template_ID ] Output [ #1.Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Template_ID = #1.Template_ID ] Output [ #1.Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Except_3 AS ( SELECT Scan_1.Template_ID FROM Scan_1 WHERE Template_ID NOT IN (SELECT Template_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_id FROM cre_Doc_Template_Mgt.Documents"
  },
  {
    "id":"2d9d0cf37702e5dc6bca104899f8e9e4118cca15f96b64c53fa9158e1aec75f7",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many templates do we have?",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates"
  },
  {
    "id":"ba118082f2f696e0f2bc26b33b647f0029b62f4d0e51713ae5858279f600f595",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of templates.",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates"
  },
  {
    "id":"ba3f56f03b1943de5b7ddbd446cd90be44d8e731880028b4f9de9e873e1a5457",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show template ids, version numbers, and template type codes for all templates.",
    "query":"SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number, Template_ID FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates"
  },
  {
    "id":"64d97831731936fc8fa76d5d897530503fe24df345357db9599440a78381e569",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids, version numbers, and type codes for each template?",
    "query":"SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number, Template_ID FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_id , version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates"
  },
  {
    "id":"bdc760b10e114287a082d9d26269eaba08a7116ab333ba86922c908eee77b475",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all distinct template type codes for all templates.",
    "query":"SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates"
  },
  {
    "id":"5233ddd186d5ebb3489169e89600027c8bd742e7e796b95faebfacd2c2a6b3ea",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the different template type codes?",
    "query":"SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT template_type_code FROM cre_Doc_Template_Mgt.Templates"
  },
  {
    "id":"bee611719acb4d7633d62ac694f134c781ebbc780185efb12abf4c9f7ab521e9",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids of templates with template type code PP or PPT?",
    "query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'PP' OR template_type_code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'PP' OR template_type_code = 'PPT'"
  },
  {
    "id":"c8b3aede5aace8a4d0ece8d034f406ef98bd0e2a5d513ececdba72e3acb31d3e",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the ids of templates that have the code PP or PPT.",
    "query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'PP' OR template_type_code = 'PPT' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ] Output [ Template_Type_Code , Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'PP' OR Template_Type_Code = 'PPT' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_id FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'PP' OR template_type_code = 'PPT'"
  },
  {
    "id":"7677207c536eff1811ff521af6a0b89899e3c67b81b8c0af18b1a7ded10277b8",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many templates have template type code CV?",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'CV' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'CV' ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'CV' ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'CV' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'CV'"
  },
  {
    "id":"2889806e9f7d6a3170472334db0059bddb62f3b27c327d85fcbe1953a3a5bb12",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of templates of the type CV.",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE template_type_code = 'CV' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'CV' ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'CV' ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'CV' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  WHERE template_type_code = 'CV'"
  },
  {
    "id":"23f904d4bb657c2244387cda5a52f79e36b9bb5a5edd4ce0dc973805fe3d3e58",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the version number and template type code for the template with version number later than 5?",
    "query":"SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE version_number > 5 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Version_Number > 5 ] Output [ Template_Type_Code , Version_Number ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Version_Number > 5 ] Output [ Template_Type_Code , Version_Number ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates WHERE Version_Number > 5 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates  WHERE version_number > 5"
  },
  {
    "id":"35116c37e2ee06bd187013cda7d51a7b1c1c96f3da8bba25d01a181000644bbc",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the version numbers and template type codes of templates with a version number greater than 5.",
    "query":"SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) WHERE version_number > 5 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Version_Number > 5 ] Output [ Template_Type_Code , Version_Number ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Version_Number > 5 ] Output [ Template_Type_Code , Version_Number ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates WHERE Version_Number > 5 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT version_number , template_type_code FROM cre_Doc_Template_Mgt.Templates  WHERE version_number > 5"
  },
  {
    "id":"fd82a9f09b508e811cd8d7220707f1309008b4ff5a1aa9ad7873e7b2d54c7195",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all template type codes and number of templates for each.",
    "query":"SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code"
  },
  {
    "id":"3fad8c40ea6e872d9085dc84fbff9347ef1135d054e5f0ce599cb367400f65e7",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the different template type codes, and how many templates correspond to each?",
    "query":"SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code"
  },
  {
    "id":"f94680095338fe6d4fa0872710695fc16a03ebdefc4828a7282775e6eb1b5a6d",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Which template type code has most number of templates?",
    "query":"SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Template_Type_Code FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"d3f58202801fed06a5f97b5ad10641054333545fa7d15effc5c7fcc10bd721cb",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the type code of the template type that the most templates belong to.",
    "query":"SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Template_Type_Code FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"e90ca10d3b801905b62e731b28f241b782967b8d2548e1057d546192c2a51a80",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all template type codes with less than three templates.",
    "query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code HAVING count ( * ) < 3 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star < 3 ] Output [ Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star < 3 ] Output [ Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), Filter_3 AS ( SELECT Template_Type_Code FROM Aggregate_2 WHERE Count_Star < 3 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code HAVING count ( * ) < 3"
  },
  {
    "id":"80efc9528d926cc2970eaa5a22f5f4d008fa1a94b6050d71ae100ab15bca8ef7",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the codes of template types that have fewer than 3 templates?",
    "query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) GROUP BY template_type_code HAVING count ( * ) < 3 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star < 3 ] Output [ Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star < 3 ] Output [ Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Template_Type_Code ), Filter_3 AS ( SELECT Template_Type_Code FROM Aggregate_2 WHERE Count_Star < 3 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  GROUP BY template_type_code HAVING count ( * ) < 3"
  },
  {
    "id":"035659c5c5e07d718124ae4a3b4635423b78d35990d7ce6a1447c312966c2d8d",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What the smallest version number and its template type code?",
    "query":"SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , MIN(Version_Number) AS Min_Version_Number ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , MIN(Version_Number) AS Min_Version_Number ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, MIN(Version_Number) AS Min_Version_Number FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code"
  },
  {
    "id":"cce310591b81b5c42d2388e7d5f7462d4d15db56b4ec47479ff05f4b43ad2cfa",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the lowest version number, along with its corresponding template type code.",
    "query":"SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , MIN(Version_Number) AS Min_Version_Number ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Output [ Template_Type_Code , Version_Number ] ; #2 = Aggregate [ #1 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , MIN(Version_Number) AS Min_Version_Number ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Version_Number FROM cre_Doc_Template_Mgt.Templates ), Aggregate_2 AS ( SELECT Template_Type_Code, MIN(Version_Number) AS Min_Version_Number FROM Scan_1 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT min ( Version_Number ) AS Min_Version_Number , template_type_code FROM cre_Doc_Template_Mgt.Templates group by template_type_code"
  },
  {
    "id":"24951b727022323b841fa4837a8f3c39e5b669a8458b03cfc4f009b4d71d98b1",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the template type code of the template used by document with the name \"Data base\"?",
    "query":"SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Data base' ] Output [ Document_Name , Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Data base' ] Output [ Document_Name , Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Data base' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base'"
  },
  {
    "id":"7d4d00e09ba1ba6a1e7656c6ce0d5484581e271467b204aa8afa2c37ac010302",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the template type code of the template that is used by a document named Data base.",
    "query":"SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Data base' ] Output [ Document_Name , Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Data base' ] Output [ Document_Name , Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Data base' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T2.document_name = 'Data base'"
  },
  {
    "id":"aa8f4dc719d2148591f8ac649686e938d8fca15a61e0473dba4cde677c04eb35",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all document names using templates with template type code BK.",
    "query":"SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'BK' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Document_Name , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'BK' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Document_Name , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'BK' ), Scan_2 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_2.Document_Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK'"
  },
  {
    "id":"298d870bec392fa19b20b8832552e950629a8a216a48964ca01db204efba7167",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the names of documents that use templates with the code BK?",
    "query":"SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'BK' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Document_Name , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Predicate [ Template_Type_Code = 'BK' ] Output [ Template_Type_Code , Template_ID ] ; #2 = Scan Table [ Documents ] Output [ Document_Name , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates WHERE Template_Type_Code = 'BK' ), Scan_2 AS ( SELECT Document_Name, Template_ID FROM cre_Doc_Template_Mgt.Documents ), Join_3 AS ( SELECT Scan_2.Document_Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.document_name FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id WHERE T1.template_type_code = 'BK'"
  },
  {
    "id":"ba9ec7f64a81c18e5612e3c60bd1335237118276d50004d9341e44428f26a6b6",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all template type codes and the number of documents using each type.",
    "query":"SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code"
  },
  {
    "id":"021957d7439054583c88614742c82045301c5c4676dc72aef66e2b98ed986b63",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the different template type codes, and how many documents use each type?",
    "query":"SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T1.template_type_code , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code"
  },
  {
    "id":"4ef7c7e7cdfb5f345e3af0a619b2fb55d98588777a38c541dd047cdcc5f39cde",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Which template type code is used by most number of documents?",
    "query":"SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Template_Type_Code FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"847022cb66cc94760f125822895688d689431d8dd110319a78dea3ac54d8e390",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the code of the template type that is most commonly used in documents.",
    "query":"SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Output [ Template_ID ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_ID = #2.Template_ID ] Output [ #2.Template_Type_Code ] ; #4 = Aggregate [ #3 ] GroupBy [ Template_Type_Code ] Output [ Template_Type_Code , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_Type_Code FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_ID = Scan_2.Template_ID ), Aggregate_4 AS ( SELECT Template_Type_Code, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Template_Type_Code ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Template_Type_Code FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id GROUP BY T1.template_type_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"d22f2ff3f365ceb1b3d8479abfc5a1b892b0c5d4f31164f40f8a348e01319bb4",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all template type codes that are not used by any document.",
    "query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Output [ #1.Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Output [ #1.Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Except_5 AS ( SELECT Scan_1.Template_Type_Code FROM Scan_1 WHERE Template_Type_Code NOT IN (SELECT Template_Type_Code FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id"
  },
  {
    "id":"16c8b2f4d9463070faff9317b19b1c0ccb8c1c214ccc3d71f8e08fef7bb61dac",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the codes of template types that are not used for any document?",
    "query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates WITH (FORCESCAN) EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.template_id = T2.template_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Output [ #1.Template_Type_Code ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Templates ] Distinct [ true ] Output [ Template_Type_Code ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Output [ #1.Template_Type_Code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Template_Type_Code FROM cre_Doc_Template_Mgt.Templates ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Except_5 AS ( SELECT Scan_1.Template_Type_Code FROM Scan_1 WHERE Template_Type_Code NOT IN (SELECT Template_Type_Code FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates  EXCEPT SELECT template_type_code FROM cre_Doc_Template_Mgt.Templates AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.template_id = T2.template_id"
  },
  {
    "id":"a07879731338a04cef67baf9770bf287adb98fcd9c64d0ac6e36ecd3427e69ad",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all template type codes and descriptions.",
    "query":"SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types"
  },
  {
    "id":"293ca51746fc9d32a1dd66c427eca16fb5c854a5a331c121a91808f0c9fb49a7",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the type codes and descriptions for all template types?",
    "query":"SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_type_code , template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types"
  },
  {
    "id":"f8570300943103954805da5211d88f9110b2dfd81e138e50b0a6fa6285117742",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the template type descriptions for template type code \"AD\".",
    "query":"SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_code = 'AD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Code = 'AD' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Code = 'AD' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Code = 'AD' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_code = 'AD'"
  },
  {
    "id":"53552c392e22e333152e2693ed0474d4840881992fc15562e483b439b6782b5d",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the template type description of the template type with the code AD.",
    "query":"SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_code = 'AD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Code = 'AD' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Code = 'AD' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Code = 'AD' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_code = 'AD'"
  },
  {
    "id":"f2835d4663242f441aa3f03c81b9ec20269ac042793a9eca922c9cca3f737d5a",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the template type code for template type description \"Book\".",
    "query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_description = 'Book' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Book' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Book' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Book' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_description = 'Book'"
  },
  {
    "id":"79080aff1d071f0394c8b61de5cf2fff5f294694291ca094959f8b8e56a97e01",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the type code of the template type with the description \"Book\".",
    "query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types WITH (FORCESCAN) WHERE template_type_description = 'Book' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Book' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Book' ] Output [ Template_Type_Code , Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Book' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT template_type_code FROM cre_Doc_Template_Mgt.Ref_template_types  WHERE template_type_description = 'Book'"
  },
  {
    "id":"a5c6e42a1d24d3732f7b16dcde9891a5195f390875ae1f489359f2d7dccfb7a6",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the distinct template type descriptions for the templates ever used by any document?",
    "query":"SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3 WITH (FORCESCAN) ON T2.Template_ID = T3.template_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Distinct [ true ] Output [ #1.Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Distinct [ true ] Output [ #1.Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Join_5 AS ( SELECT DISTINCT Scan_1.Template_Type_Description FROM Scan_1 JOIN Join_4 ON Scan_1.Template_Type_Code = Join_4.Template_Type_Code ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3  ON T2.Template_ID = T3.template_ID"
  },
  {
    "id":"ae0670f297cf9b8c324a52dc99fc74755fa27bb442814673d6e095611d79886f",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the different descriptions for templates that have been used in a document.",
    "query":"SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3 WITH (FORCESCAN) ON T2.Template_ID = T3.template_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Distinct [ true ] Output [ #1.Template_Type_Description ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Documents ] Output [ Template_ID ] ; #3 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Template_ID = #3.Template_ID ] Output [ #3.Template_Type_Code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.Template_Type_Code = #4.Template_Type_Code ] Distinct [ true ] Output [ #1.Template_Type_Description ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types ), Scan_2 AS ( SELECT Template_ID FROM cre_Doc_Template_Mgt.Documents ), Scan_3 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_4 AS ( SELECT Scan_3.Template_Type_Code FROM Scan_2 JOIN Scan_3 ON Scan_2.Template_ID = Scan_3.Template_ID ), Join_5 AS ( SELECT DISTINCT Scan_1.Template_Type_Description FROM Scan_1 JOIN Join_4 ON Scan_1.Template_Type_Code = Join_4.Template_Type_Code ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.template_type_description FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code JOIN cre_Doc_Template_Mgt.Documents AS T3  ON T2.Template_ID = T3.template_ID"
  },
  {
    "id":"db21dc13f516c2d21d6b03dd40a463b7e9d28a54dd4951c763ef689c9ac77fb9",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the template ids with template type description \"Presentation\".",
    "query":"SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Presentation' ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_Type_Code = #2.Template_Type_Code ] Output [ #2.Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Presentation' ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_Type_Code = #2.Template_Type_Code ] Output [ #2.Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Presentation' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_Type_Code = Scan_2.Template_Type_Code ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation'"
  },
  {
    "id":"a1c640433ac0aa6246e93a4cb6c53dd0dfd6ea14e7528d4c9080d31beb9bc5db",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the ids corresponding to templates with the description 'Presentation'.",
    "query":"SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Templates AS T2 WITH (FORCESCAN) ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Presentation' ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_Type_Code = #2.Template_Type_Code ] Output [ #2.Template_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Ref_Template_Types ] Predicate [ Template_Type_Description = 'Presentation' ] Output [ Template_Type_Code , Template_Type_Description ] ; #2 = Scan Table [ Templates ] Output [ Template_Type_Code , Template_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Template_Type_Code = #2.Template_Type_Code ] Output [ #2.Template_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Template_Type_Code, Template_Type_Description FROM cre_Doc_Template_Mgt.Ref_Template_Types WHERE Template_Type_Description = 'Presentation' ), Scan_2 AS ( SELECT Template_Type_Code, Template_ID FROM cre_Doc_Template_Mgt.Templates ), Join_3 AS ( SELECT Scan_2.Template_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Template_Type_Code = Scan_2.Template_Type_Code ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.template_id FROM cre_Doc_Template_Mgt.Ref_template_types AS T1  JOIN cre_Doc_Template_Mgt.Templates AS T2  ON T1.template_type_code = T2.template_type_code WHERE T1.template_type_description = 'Presentation'"
  },
  {
    "id":"14759693b8e6ccb3b5373b3635e7c8d5e0763f8e3fd96765eeaf0cd318627e24",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many paragraphs in total?",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs"
  },
  {
    "id":"c68377e24e04a97ee2cb8d163fb6be38ae5e40a2f50c26dc500eeb8432ff76db",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of paragraphs.",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs"
  },
  {
    "id":"25606457dfeb99c81a178c71cf5dbdd5bc475297eaae4baba83c0b3f28a8b5d5",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"How many paragraphs for the document with name 'Summer Show'?",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Summer Show' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID , #1.Document_Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Summer Show' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID , #1.Document_Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Summer Show' ), Scan_2 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_1.Document_ID, Scan_1.Document_Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show'"
  },
  {
    "id":"48d4d88081a41b0892197a3c9aa93eac81e0a2158d60ea3843a175b0f2b053c0",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Count the number of paragraphs in the document named 'Summer Show'.",
    "query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Summer Show' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID , #1.Document_Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Summer Show' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID , #1.Document_Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Summer Show' ), Scan_2 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_1.Document_ID, Scan_1.Document_Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_ID = T2.document_ID WHERE T2.document_name = 'Summer Show'"
  },
  {
    "id":"d2502ee559df2f596143a49e800b73f835360ae66c3ddae79b9c43c55315a820",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show paragraph details for paragraph with text 'Korea ' .",
    "query":"select other_details FROM cre_Doc_Template_Mgt.paragraphs WITH (FORCESCAN) where paragraph_text like 'korea' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text like 'korea' ] Output [ Paragraph_Text , Other_Details ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text like 'korea' ] Output [ Paragraph_Text , Other_Details ]",
    "cte":"WITH Scan_1 AS ( SELECT Paragraph_Text, Other_Details FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text like 'korea' ) SELECT * FROM Scan_1",
    "clean_query":"select other_details FROM cre_Doc_Template_Mgt.paragraphs  where paragraph_text like 'korea'"
  },
  {
    "id":"121311c3b8547bc02036a7ee997148efc6a18552e09213becf9d418b8b66bdec",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the details for the paragraph that includes the text 'Korea ' ?",
    "query":"select other_details FROM cre_Doc_Template_Mgt.paragraphs WITH (FORCESCAN) where paragraph_text like 'korea' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text like 'korea' ] Output [ Paragraph_Text , Other_Details ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text like 'korea' ] Output [ Paragraph_Text , Other_Details ]",
    "cte":"WITH Scan_1 AS ( SELECT Paragraph_Text, Other_Details FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text like 'korea' ) SELECT * FROM Scan_1",
    "clean_query":"select other_details FROM cre_Doc_Template_Mgt.paragraphs  where paragraph_text like 'korea'"
  },
  {
    "id":"5c853eed095b6baf4df9f2f0070d754fac01d936f3136ee93d9295666ec32afc",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all paragraph ids and texts for the document with name 'Welcome to NY'.",
    "query":"SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Welcome to NY' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text , #2.Paragraph_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Welcome to NY' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text , #2.Paragraph_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Welcome to NY' ), Scan_2 AS ( SELECT Document_ID, Paragraph_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_Text, Scan_2.Paragraph_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY'"
  },
  {
    "id":"3d3eca8148eb50a89b259e7e52852f0bc74562a78e97347bc1fabc4ccd9f2592",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?",
    "query":"SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Welcome to NY' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text , #2.Paragraph_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Welcome to NY' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text , #2.Paragraph_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Welcome to NY' ), Scan_2 AS ( SELECT Document_ID, Paragraph_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_Text, Scan_2.Paragraph_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.paragraph_id , T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.Document_Name = 'Welcome to NY'"
  },
  {
    "id":"7b011cefaa29c94bcd921f109c6aba92f00feeee515a5c416047c8829261c99a",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all paragraph texts for the document \"Customer reviews\".",
    "query":"SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Customer reviews' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Customer reviews' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Customer reviews' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_Text FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews'"
  },
  {
    "id":"7d29cad1b4024d12284567661ef0e6588258cde70692d06347b87dcde5d31d9b",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the paragraph texts for the document with the name 'Customer reviews'?",
    "query":"SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Customer reviews' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Documents ] Predicate [ Document_Name = 'Customer reviews' ] Output [ Document_ID , Document_Name ] ; #2 = Scan Table [ Paragraphs ] Output [ Document_ID , Paragraph_Text ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #2.Paragraph_Text ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents WHERE Document_Name = 'Customer reviews' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs ), Join_3 AS ( SELECT Scan_2.Paragraph_Text FROM Scan_1 JOIN Scan_2 ON Scan_1.Document_ID = Scan_2.Document_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.paragraph_text FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id WHERE T2.document_name = 'Customer reviews'"
  },
  {
    "id":"a2cf4e35c9235fe7fe8b7f23cd46ecbf8798764d9afd5799468de4112f0a8b3d",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all document ids and the number of paragraphs in each document. Order by document id.",
    "query":"SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY document_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Document_ID ASC ] Output [ Document_ID , Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Document_ID ASC ] Output [ Document_ID , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ) SELECT Document_ID, Count_Star FROM Aggregate_2 ORDER BY Document_ID ASC",
    "clean_query":"SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY document_id"
  },
  {
    "id":"8b9d043a303b43c1a782650d2ce723fe3dcd74a534ba49ee19d1b194d80acc7b",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.",
    "query":"SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY document_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Document_ID ASC ] Output [ Document_ID , Count_Star ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Document_ID ASC ] Output [ Document_ID , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ) SELECT Document_ID, Count_Star FROM Aggregate_2 ORDER BY Document_ID ASC",
    "clean_query":"SELECT document_id , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY document_id"
  },
  {
    "id":"5ad21a316fc1e48c6d44ed5198b1070d3760ce48bfd31f752d8ed9e39bd2f980",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show all document ids, names and the number of paragraphs in each document.",
    "query":"SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ) SELECT * FROM Join_4",
    "clean_query":"SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name"
  },
  {
    "id":"a7a22869d73d48865b3babbf4cd9a658bca2148ab089e5178ccbfef3547536fb",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids and names of each document, as well as the number of paragraphs in each?",
    "query":"SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ) SELECT * FROM Join_4",
    "clean_query":"SELECT T1.document_id , T2.document_name , count ( * ) AS Count_Star FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name"
  },
  {
    "id":"00d2bfa30e9d1a0eeec54a5722b019f8d9c849abe3f18da1fd96dcc51e8ab2e6",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"List all document ids with at least two paragraphs.",
    "query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) > = 2"
  },
  {
    "id":"18b61f884d9b62c0631faab968c6bb3a753aafc3b726e3b5dbb62a9efe12b1b4",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids of documents that have 2 or more paragraphs?",
    "query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) > = 2"
  },
  {
    "id":"298a9f020337263ed5acf9bcfad40d6801fc573097ccc09cf57b97caf658b304",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the document id and name with greatest number of paragraphs?",
    "query":"SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Document_ID , Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Document_ID , Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Document_ID, Document_Name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"b3fbd3fffe1bdb198cce71e819e0cf49319e836a0ded36d695ce29110d2b43d3",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the id and name of the document with the most paragraphs.",
    "query":"SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1 WITH (FORCESCAN) JOIN cre_Doc_Template_Mgt.Documents AS T2 WITH (FORCESCAN) ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Document_ID , Document_Name ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Scan Table [ Documents ] Output [ Document_ID , Document_Name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Document_ID = #3.Document_ID ] Output [ #2.Count_Star , #2.Document_ID , #3.Document_Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Document_ID , Document_Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Scan_3 AS ( SELECT Document_ID, Document_Name FROM cre_Doc_Template_Mgt.Documents ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Document_ID, Scan_3.Document_Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Document_ID = Scan_3.Document_ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Document_ID, Document_Name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.document_id , T2.document_name FROM cre_Doc_Template_Mgt.Paragraphs AS T1  JOIN cre_Doc_Template_Mgt.Documents AS T2  ON T1.document_id = T2.document_id GROUP BY T1.document_id , T2.document_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"e4f3f3933094ccad96397a211a67ef8bd7f0009aa568a942929d5e84304ff8e5",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the document id with least number of paragraphs?",
    "query":"SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY count ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Document_ID FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY count ( * ) ASC"
  },
  {
    "id":"8e3aad50097526966d284fe425eed6f8ffe01c3dca9060ccd62b3d3ff562e4b9",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Return the id of the document with the fewest paragraphs.",
    "query":"SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id ORDER BY count ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Document_ID FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id ORDER BY count ( * ) ASC"
  },
  {
    "id":"111b103537318355b92ca659ac7eb2d1145d8a72756a47d2355826c9c51c0998",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What is the document id with 1 to 2 paragraphs?",
    "query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 1 AND Count_Star <= 2 ] Output [ Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 1 AND Count_Star <= 2 ] Output [ Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 1 AND Count_Star <= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2"
  },
  {
    "id":"593b02f02ed6283fc7f6f920d4f2c675dd951433acf861995146b5c3a0e90968",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Give the ids of documents that have between one and two paragraphs.",
    "query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 1 AND Count_Star <= 2 ] Output [ Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Output [ Document_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Document_ID ] Output [ Document_ID , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 1 AND Count_Star <= 2 ] Output [ Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Document_ID FROM cre_Doc_Template_Mgt.Paragraphs ), Aggregate_2 AS ( SELECT Document_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Document_ID ), Filter_3 AS ( SELECT Document_ID FROM Aggregate_2 WHERE Count_Star >= 1 AND Count_Star <= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  GROUP BY document_id HAVING count ( * ) BETWEEN 1 AND 2"
  },
  {
    "id":"12d76df65c31c361eba089ea8e44faefd069c74214a2ba2d4a8b0f5dc7ed7e26",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"Show the document id with paragraph text 'Brazil' and 'Ireland'.",
    "query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Ireland' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Brazil' ] Distinct [ true ] Output [ Document_ID , Paragraph_Text ] ; #2 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Ireland' ] Output [ Document_ID , Paragraph_Text ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Brazil' ] Distinct [ true ] Output [ Document_ID , Paragraph_Text ] ; #2 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Ireland' ] Output [ Document_ID , Paragraph_Text ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Brazil' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Ireland' ), Intersect_3 AS ( SELECT Scan_1.Document_ID FROM Scan_1 WHERE Document_ID IN (SELECT Document_ID FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Ireland'"
  },
  {
    "id":"527a89df62df5b27b7fecaaec5caaac757cd54ef07aacbae2576450a55d385b0",
    "db_id":"cre_Doc_Template_Mgt",
    "question":"What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?",
    "query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs WITH (FORCESCAN) WHERE paragraph_text = 'Ireland' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Brazil' ] Distinct [ true ] Output [ Document_ID , Paragraph_Text ] ; #2 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Ireland' ] Output [ Document_ID , Paragraph_Text ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID ]",
    "prefixed_qpl":"cre_Doc_Template_Mgt | #1 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Brazil' ] Distinct [ true ] Output [ Document_ID , Paragraph_Text ] ; #2 = Scan Table [ Paragraphs ] Predicate [ Paragraph_Text = 'Ireland' ] Output [ Document_ID , Paragraph_Text ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Document_ID = #2.Document_ID ] Output [ #1.Document_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Brazil' ), Scan_2 AS ( SELECT Document_ID, Paragraph_Text FROM cre_Doc_Template_Mgt.Paragraphs WHERE Paragraph_Text = 'Ireland' ), Intersect_3 AS ( SELECT Scan_1.Document_ID FROM Scan_1 WHERE Document_ID IN (SELECT Document_ID FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Brazil' INTERSECT SELECT document_id FROM cre_Doc_Template_Mgt.Paragraphs  WHERE paragraph_text = 'Ireland'"
  },
  {
    "id":"7bcee666dc61c24ef33d8f9dc8c2ce0f1d9fcc88e028a8ae269ea5507f2555d6",
    "db_id":"course_teach",
    "question":"How many teachers are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM course_teach.teacher"
  },
  {
    "id":"623537054e505047ae01d4aa98e12d75a8df926e1d7b3f51b1846adcd1990150",
    "db_id":"course_teach",
    "question":"What is the total count of teachers?",
    "query":"SELECT count ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM course_teach.teacher ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM course_teach.teacher"
  },
  {
    "id":"c14783a0953c100a8cdf5562d085bafac95385ffda14252282e3a01b1d41244d",
    "db_id":"course_teach",
    "question":"List the names of teachers in ascending order of age.",
    "query":"SELECT Name FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
    "clean_query":"SELECT Name FROM course_teach.teacher  ORDER BY Age ASC"
  },
  {
    "id":"58cef4c0076830335440dd933356d6eec64df763d1e4b8b8da20e69b4b7fb390",
    "db_id":"course_teach",
    "question":"What are the names of the teachers ordered by ascending age?",
    "query":"SELECT Name FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
    "clean_query":"SELECT Name FROM course_teach.teacher  ORDER BY Age ASC"
  },
  {
    "id":"58b54f5a3d2293d6e55a40e44757181a2c3aed9fb41e5bb4961202045ca48c6e",
    "db_id":"course_teach",
    "question":"What are the age and hometown of teachers?",
    "query":"SELECT Age , Hometown FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown, Age FROM course_teach.teacher ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Age , Hometown FROM course_teach.teacher"
  },
  {
    "id":"5fd9ccaae0c96c0dbd181367f13e8533d804eda56bffe6c9cf52d2aa5bf2997c",
    "db_id":"course_teach",
    "question":"What is the age and hometown of every teacher?",
    "query":"SELECT Age , Hometown FROM course_teach.teacher WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown, Age FROM course_teach.teacher ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Age , Hometown FROM course_teach.teacher"
  },
  {
    "id":"68a7c7be81a8bd9b48f9750cfc34bfa65110ac9eacce30055ad944d8300f8166",
    "db_id":"course_teach",
    "question":"List the name of teachers whose hometown is not `` Little Lever Urban District '' .",
    "query":"select name FROM course_teach.teacher WITH (FORCESCAN) where hometown != 'little lever urban district' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Predicate [ Hometown <> 'little lever urban district' ] Output [ Name , Hometown ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Predicate [ Hometown <> 'little lever urban district' ] Output [ Name , Hometown ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Hometown FROM course_teach.teacher WHERE Hometown <> 'little lever urban district' ) SELECT * FROM Scan_1",
    "clean_query":"select name FROM course_teach.teacher  where hometown != 'little lever urban district'"
  },
  {
    "id":"0af2de205b31198e6eca3d7b0b73802ad3764080025941cb66a392eda65a9e13",
    "db_id":"course_teach",
    "question":"What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?",
    "query":"select name FROM course_teach.teacher WITH (FORCESCAN) where hometown != 'little lever urban district' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Predicate [ Hometown <> 'little lever urban district' ] Output [ Name , Hometown ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Predicate [ Hometown <> 'little lever urban district' ] Output [ Name , Hometown ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Hometown FROM course_teach.teacher WHERE Hometown <> 'little lever urban district' ) SELECT * FROM Scan_1",
    "clean_query":"select name FROM course_teach.teacher  where hometown != 'little lever urban district'"
  },
  {
    "id":"874d7f27668df1183762770b3c6571180db780700251069053ba4401174165ef",
    "db_id":"course_teach",
    "question":"Show the name of teachers aged either 32 or 33?",
    "query":"SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Age = 32 OR Age = 33 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Predicate [ Age = 32 OR Age = 33 ] Output [ Name , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Predicate [ Age = 32 OR Age = 33 ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher WHERE Age = 32 OR Age = 33 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM course_teach.teacher  WHERE Age = 32 OR Age = 33"
  },
  {
    "id":"37c6344d0991afd89c9c159fc6a00dd71a4e656faeb14892c43cb3a1d63c0848",
    "db_id":"course_teach",
    "question":"What are the names of the teachers who are aged either 32 or 33?",
    "query":"SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Age = 32 OR Age = 33 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Predicate [ Age = 32 OR Age = 33 ] Output [ Name , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Predicate [ Age = 32 OR Age = 33 ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM course_teach.teacher WHERE Age = 32 OR Age = 33 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM course_teach.teacher  WHERE Age = 32 OR Age = 33"
  },
  {
    "id":"81ea1ebcc988a1d5cfb2f5eed7737cbd6d17b0cb15f16a9d08837af696997f07",
    "db_id":"course_teach",
    "question":"What is the hometown of the youngest teacher?",
    "query":"SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown , Age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Hometown , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown , Age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Hometown , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown, Age FROM course_teach.teacher ), TopSort_2 AS ( SELECT TOP 1 Hometown, Age FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Hometown FROM course_teach.teacher  ORDER BY Age ASC"
  },
  {
    "id":"3a98eaad53fc81c47f32a49cd7ec2e73520ec75e0536d99059050386a10ee590",
    "db_id":"course_teach",
    "question":"Where is the youngest teacher from?",
    "query":"SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown , Age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Hometown , Age ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown , Age ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Age ASC ] Output [ Hometown , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown, Age FROM course_teach.teacher ), TopSort_2 AS ( SELECT TOP 1 Hometown, Age FROM Scan_1 ORDER BY Age ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Hometown FROM course_teach.teacher  ORDER BY Age ASC"
  },
  {
    "id":"603bc70182ffde705ac9eac27f319a5aba32804cf32d8fb791f32b264dd03922",
    "db_id":"course_teach",
    "question":"Show different hometown of teachers and the number of teachers from each hometown.",
    "query":"SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT Hometown, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Hometown ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher  GROUP BY Hometown"
  },
  {
    "id":"e2b8750d45f4e92cca02f5e87e2becaf9a4b4744049c22ccedd4cfd3a3d0dfd7",
    "db_id":"course_teach",
    "question":"For each hometown, how many teachers are there?",
    "query":"SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT Hometown, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Hometown ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Hometown , COUNT ( * ) AS Count_Star FROM course_teach.teacher  GROUP BY Hometown"
  },
  {
    "id":"6b47ad0390ba5a23811643ceb795c832310e9b535c05f9d935d83a9fe79d8f85",
    "db_id":"course_teach",
    "question":"List the most common hometown of teachers.",
    "query":"SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Hometown , Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Hometown , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT Hometown, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Hometown ), TopSort_3 AS ( SELECT TOP 1 Hometown, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Hometown FROM course_teach.teacher  GROUP BY Hometown ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"4611a9d09e6d3dd627d95b6c315e97d00104bed81aa905e8c242ca35c0671678",
    "db_id":"course_teach",
    "question":"What is the most commmon hometowns for teachers?",
    "query":"SELECT TOP 1 Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Hometown , Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Hometown , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT Hometown, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Hometown ), TopSort_3 AS ( SELECT TOP 1 Hometown, Count_Star FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Hometown FROM course_teach.teacher  GROUP BY Hometown ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"6b280b59c701284ea7d360487270d2cdccc7b55f90b65e9d7e7484f4be0a3e78",
    "db_id":"course_teach",
    "question":"Show the hometowns shared by at least two teachers.",
    "query":"SELECT Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Hometown ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Hometown ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT Hometown, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Hometown ), Filter_3 AS ( SELECT Hometown FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT Hometown FROM course_teach.teacher  GROUP BY Hometown HAVING COUNT ( * ) > = 2"
  },
  {
    "id":"0e79c74a5610e5c303a789fad6b46b6a88e4328a1f400bf558be69eaac43af46",
    "db_id":"course_teach",
    "question":"What are the towns from which at least two teachers come from?",
    "query":"SELECT Hometown FROM course_teach.teacher WITH (FORCESCAN) GROUP BY Hometown HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Hometown ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Hometown ] ; #2 = Aggregate [ #1 ] GroupBy [ Hometown ] Output [ Hometown , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Hometown ]",
    "cte":"WITH Scan_1 AS ( SELECT Hometown FROM course_teach.teacher ), Aggregate_2 AS ( SELECT Hometown, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Hometown ), Filter_3 AS ( SELECT Hometown FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT Hometown FROM course_teach.teacher  GROUP BY Hometown HAVING COUNT ( * ) > = 2"
  },
  {
    "id":"8bdd139d26705091a90878940a67335d43bde42567b0dbcd021c9dd118a84d20",
    "db_id":"course_teach",
    "question":"Show names of teachers and the courses they are arranged to teach.",
    "query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Join_3.Course, Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID"
  },
  {
    "id":"e39c8aa6302e480ebe544ab36de4875b9b45d00eee51f4cc97c46be201830fa9",
    "db_id":"course_teach",
    "question":"What is the name of each teacher and what course they teach?",
    "query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Join_3.Course, Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID"
  },
  {
    "id":"9ae78bb93870f4f5e609eea4e7be9e17d17f90eedf2b3f5d801460325259aff7",
    "db_id":"course_teach",
    "question":"Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.",
    "query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ] ; #6 = Sort [ #5 ] OrderBy [ Name ASC ] Output [ Name , Course ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ] ; #6 = Sort [ #5 ] OrderBy [ Name ASC ] Output [ Name , Course ]",
    "cte":"WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Join_3.Course, Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT Name, Course FROM Join_5 ORDER BY Name ASC",
    "clean_query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name"
  },
  {
    "id":"02c89bd982dfca591b480780bb255fb46d9d7c0a268f6bb76ecdce5f1f7f6bf2",
    "db_id":"course_teach",
    "question":"What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?",
    "query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ] ; #6 = Sort [ #5 ] OrderBy [ Name ASC ] Output [ Name , Course ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #2 = Scan Table [ course ] Output [ Course_ID , Course ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Course , #1.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #3.Course , #4.Name ] ; #6 = Sort [ #5 ] OrderBy [ Name ASC ] Output [ Name , Course ]",
    "cte":"WITH Scan_1 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Course_ID, Course FROM course_teach.course ), Join_3 AS ( SELECT Scan_2.Course, Scan_1.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Join_3.Course, Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT Name, Course FROM Join_5 ORDER BY Name ASC",
    "clean_query":"SELECT T3.Name , T2.Course FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID ORDER BY T3.Name"
  },
  {
    "id":"2e8baf9e453be42a11b71337dbfa3196ce81ab88196a3965e5d9eaef85ff4a28",
    "db_id":"course_teach",
    "question":"Show the name of the teacher for the math course.",
    "query":"SELECT T3.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ course ] Predicate [ Course = 'Math' ] Output [ Course_ID , Course ] ; #2 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course ] Predicate [ Course = 'Math' ] Output [ Course_ID , Course ] ; #2 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Course_ID, Course FROM course_teach.course WHERE Course = 'Math' ), Scan_2 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Join_3 AS ( SELECT Scan_2.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T3.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math'"
  },
  {
    "id":"3bd79e8079339ca598e74c333c4128f10638b4de9de645b52185fcd23d3115a4",
    "db_id":"course_teach",
    "question":"What are the names of the people who teach math courses?",
    "query":"SELECT T3.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.course AS T2 WITH (FORCESCAN) ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3 WITH (FORCESCAN) ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ course ] Predicate [ Course = 'Math' ] Output [ Course_ID , Course ] ; #2 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course ] Predicate [ Course = 'Math' ] Output [ Course_ID , Course ] ; #2 = Scan Table [ course_arrange ] Output [ Course_ID , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Course_ID = #2.Course_ID ] Output [ #2.Teacher_ID ] ; #4 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.Teacher_ID = #4.Teacher_ID ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Course_ID, Course FROM course_teach.course WHERE Course = 'Math' ), Scan_2 AS ( SELECT Course_ID, Teacher_ID FROM course_teach.course_arrange ), Join_3 AS ( SELECT Scan_2.Teacher_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Course_ID = Scan_2.Course_ID ), Scan_4 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_5 AS ( SELECT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.Teacher_ID = Scan_4.Teacher_ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T3.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.course AS T2  ON T1.Course_ID = T2.Course_ID JOIN course_teach.teacher AS T3  ON T1.Teacher_ID = T3.Teacher_ID WHERE T2.Course = 'Math'"
  },
  {
    "id":"6b56664c45bbe45ade08c28a7892035d10283d0f493698f906bdc3a78a9ca431",
    "db_id":"course_teach",
    "question":"Show names of teachers and the number of courses they teach.",
    "query":"SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name"
  },
  {
    "id":"287c13b7cc426c370cd220879683109522739aad32877db06c470639a03a973a",
    "db_id":"course_teach",
    "question":"What are the names of the teachers and how many courses do they teach?",
    "query":"SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.Name , COUNT ( * ) AS Count_Star FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name"
  },
  {
    "id":"5a00e81d064799fc71f61f7eddc83f1fcad00988da1b787b02501bb425797671",
    "db_id":"course_teach",
    "question":"Show names of teachers that teach at least two courses.",
    "query":"SELECT T2.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2"
  },
  {
    "id":"402c83aa7e9857cd245b007d9858090ddba77f61656583eb61ff34afc92fa7b2",
    "db_id":"course_teach",
    "question":"What are the names of the teachers who teach at least two courses?",
    "query":"SELECT T2.Name FROM course_teach.course_arrange AS T1 WITH (FORCESCAN) JOIN course_teach.teacher AS T2 WITH (FORCESCAN) ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #2 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Teacher_ID = #2.Teacher_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Scan_2 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Teacher_ID = Scan_2.Teacher_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.Name FROM course_teach.course_arrange AS T1  JOIN course_teach.teacher AS T2  ON T1.Teacher_ID = T2.Teacher_ID GROUP BY T2.Name HAVING COUNT ( * ) > = 2"
  },
  {
    "id":"caa8cc9af95a5c1b20b0bf682fe3c0c874b0f7df744592b557c3a30bbd608e52",
    "db_id":"course_teach",
    "question":"List the names of teachers who have not been arranged to teach courses.",
    "query":"SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #2 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Teacher_ID = #1.Teacher_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #2 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Teacher_ID = #1.Teacher_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Scan_2 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Name FROM course_teach.teacher  WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange  )"
  },
  {
    "id":"ef3355a7fe3ce05cbe2e30e7a414c19cd64cc838a7d6cdb2e91aaea1f1811886",
    "db_id":"course_teach",
    "question":"What are the names of the teachers whose courses have not been arranged?",
    "query":"SELECT Name FROM course_teach.teacher WITH (FORCESCAN) WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #2 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Teacher_ID = #1.Teacher_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"course_teach | #1 = Scan Table [ teacher ] Output [ Name , Teacher_ID ] ; #2 = Scan Table [ course_arrange ] Output [ Teacher_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Teacher_ID = #1.Teacher_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Teacher_ID FROM course_teach.teacher ), Scan_2 AS ( SELECT Teacher_ID FROM course_teach.course_arrange ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Teacher_ID NOT IN (SELECT Teacher_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Name FROM course_teach.teacher  WHERE Teacher_id NOT IN ( SELECT Teacher_id FROM course_teach.course_arrange  )"
  },
  {
    "id":"ccf0a1234580e327589862c55c99a5568deaaa030d338a8f77d11c02036eab31",
    "db_id":"museum_visit",
    "question":"How many visitors below age 30 are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM museum_visit.visitor WITH (FORCESCAN) WHERE age < 30 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ visitor ] Predicate [ Age < 30 ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visitor ] Predicate [ Age < 30 ] Output [ Age ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Age FROM museum_visit.visitor WHERE Age < 30 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM museum_visit.visitor  WHERE age < 30"
  },
  {
    "id":"2b4311470404464d3aceb7aa1ee3fe0b8a84f764405a2eec8a7224e91344cc85",
    "db_id":"museum_visit",
    "question":"Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.",
    "query":"SELECT name FROM museum_visit.visitor WITH (FORCESCAN) WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ visitor ] Predicate [ Level_of_membership > 4 ] Output [ Name , Level_of_membership ] ; #2 = Sort [ #1 ] OrderBy [ Level_of_membership DESC ] Output [ Name , Level_of_membership ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership > 4 ] Output [ Name , Level_of_membership ] ; #2 = Sort [ #1 ] OrderBy [ Level_of_membership DESC ] Output [ Name , Level_of_membership ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Level_of_membership FROM museum_visit.visitor WHERE Level_of_membership > 4 ) SELECT Name, Level_of_membership FROM Scan_1 ORDER BY Level_of_membership DESC",
    "clean_query":"SELECT name FROM museum_visit.visitor  WHERE Level_of_membership > 4 ORDER BY Level_of_membership DESC"
  },
  {
    "id":"e55c321fe2277cb22a4cdb52e32820d830e29d08212b93e1f6ed54a5c0f64e43",
    "db_id":"museum_visit",
    "question":"What is the average age of the visitors whose membership level is not higher than 4?",
    "query":"SELECT avg ( age ) AS Avg_age FROM museum_visit.visitor WITH (FORCESCAN) WHERE Level_of_membership < = 4 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ visitor ] Predicate [ Level_of_membership <= 4 ] Output [ Age , Level_of_membership ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership <= 4 ] Output [ Age , Level_of_membership ] ; #2 = Aggregate [ #1 ] Output [ AVG(Age) AS Avg_Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Age, Level_of_membership FROM museum_visit.visitor WHERE Level_of_membership <= 4 ), Aggregate_2 AS ( SELECT AVG(Age) AS Avg_Age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( age ) AS Avg_age FROM museum_visit.visitor  WHERE Level_of_membership < = 4"
  },
  {
    "id":"c3bc8027a1635183c2a5ab079b6bd0b8d12076ab770b908c0ea6bfc617303969",
    "db_id":"museum_visit",
    "question":"Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.",
    "query":"SELECT name , Level_of_membership FROM museum_visit.visitor WITH (FORCESCAN) WHERE Level_of_membership > 4 ORDER BY age DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ visitor ] Predicate [ Level_of_membership > 4 ] Output [ Name , Age , Level_of_membership ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Age , Level_of_membership ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership > 4 ] Output [ Name , Age , Level_of_membership ] ; #2 = Sort [ #1 ] OrderBy [ Age DESC ] Output [ Name , Age , Level_of_membership ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age, Level_of_membership FROM museum_visit.visitor WHERE Level_of_membership > 4 ) SELECT Name, Age, Level_of_membership FROM Scan_1 ORDER BY Age DESC",
    "clean_query":"SELECT name , Level_of_membership FROM museum_visit.visitor  WHERE Level_of_membership > 4 ORDER BY age DESC"
  },
  {
    "id":"60e9a83821454bd3ff7a90d11440f1e090c22d5ce2e40674a210dd1189f47522",
    "db_id":"museum_visit",
    "question":"Find the id and name of the museum that has the most staff members?",
    "query":"SELECT TOP 1 museum_id , name FROM museum_visit.museum WITH (FORCESCAN) ORDER BY num_of_staff DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ museum ] Output [ Name , Num_of_Staff , Museum_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Num_of_Staff DESC ] Output [ Name , Num_of_Staff , Museum_ID ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Output [ Name , Num_of_Staff , Museum_ID ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Num_of_Staff DESC ] Output [ Name , Num_of_Staff , Museum_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Num_of_Staff, Museum_ID FROM museum_visit.museum ), TopSort_2 AS ( SELECT TOP 1 Name, Num_of_Staff, Museum_ID FROM Scan_1 ORDER BY Num_of_Staff DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 museum_id , name FROM museum_visit.museum  ORDER BY num_of_staff DESC"
  },
  {
    "id":"5c3c8a98e8d4b701ff4536883ed85090028f3f9d26cd21f026fd0d2664bc61c8",
    "db_id":"museum_visit",
    "question":"Find the average number of staff working for the museums that were open before 2009.",
    "query":"SELECT avg ( num_of_staff ) AS Avg_num_of_staff FROM museum_visit.museum WITH (FORCESCAN) WHERE open_year < 2009 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ museum ] Predicate [ Open_Year < 2009 ] Output [ Open_Year , Num_of_Staff ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_of_Staff) AS Avg_Num_of_Staff ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year < 2009 ] Output [ Open_Year , Num_of_Staff ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_of_Staff) AS Avg_Num_of_Staff ]",
    "cte":"WITH Scan_1 AS ( SELECT Open_Year, Num_of_Staff FROM museum_visit.museum WHERE Open_Year < 2009 ), Aggregate_2 AS ( SELECT AVG(Num_of_Staff) AS Avg_Num_of_Staff FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( num_of_staff ) AS Avg_num_of_staff FROM museum_visit.museum  WHERE open_year < 2009"
  },
  {
    "id":"de129d84d27db6a0fb572077f40706c07205c6e5de0feaa6dda6ccf452c57217",
    "db_id":"museum_visit",
    "question":"What are the opening year and staff number of the museum named Plaza Museum?",
    "query":"SELECT Num_of_Staff , Open_Year FROM museum_visit.museum WITH (FORCESCAN) WHERE name = 'Plaza Museum' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ museum ] Predicate [ Name = 'Plaza Museum' ] Output [ Open_Year , Num_of_Staff , Name ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Predicate [ Name = 'Plaza Museum' ] Output [ Open_Year , Num_of_Staff , Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Open_Year, Num_of_Staff, Name FROM museum_visit.museum WHERE Name = 'Plaza Museum' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Num_of_Staff , Open_Year FROM museum_visit.museum  WHERE name = 'Plaza Museum'"
  },
  {
    "id":"179c60a2a7a0834d0afcd9c0c07b9051c8adb59bea2837c5aef588b199ee14dd",
    "db_id":"museum_visit",
    "question":"find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.",
    "query":"SELECT name FROM museum_visit.museum WITH (FORCESCAN) WHERE num_of_staff > ( SELECT min ( num_of_staff ) AS Min_num_of_staff FROM museum_visit.museum WITH (FORCESCAN) WHERE open_year > 2010 ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ museum ] Predicate [ Open_Year > 2010 ] Output [ Open_Year , Num_of_Staff ] ; #2 = Aggregate [ #1 ] Output [ MIN(Num_of_Staff) AS Min_Num_of_Staff ] ; #3 = Scan Table [ museum ] Output [ Name , Num_of_Staff ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Num_of_Staff > #2.Min_Num_of_Staff ] Output [ #3.Name ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year > 2010 ] Output [ Open_Year , Num_of_Staff ] ; #2 = Aggregate [ #1 ] Output [ MIN(Num_of_Staff) AS Min_Num_of_Staff ] ; #3 = Scan Table [ museum ] Output [ Name , Num_of_Staff ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Num_of_Staff > #2.Min_Num_of_Staff ] Output [ #3.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Open_Year, Num_of_Staff FROM museum_visit.museum WHERE Open_Year > 2010 ), Aggregate_2 AS ( SELECT MIN(Num_of_Staff) AS Min_Num_of_Staff FROM Scan_1 ), Scan_3 AS ( SELECT Name, Num_of_Staff FROM museum_visit.museum ), Join_4 AS ( SELECT Name FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Num_of_Staff > Aggregate_2.Min_Num_of_Staff ) SELECT * FROM Join_4",
    "clean_query":"SELECT name FROM museum_visit.museum  WHERE num_of_staff > ( SELECT min ( num_of_staff ) AS Min_num_of_staff FROM museum_visit.museum  WHERE open_year > 2010 )"
  },
  {
    "id":"0a0317dc30dddb0490383d219a1b1f2002d1ff2a27e96ed69090c468a73e9bcb",
    "db_id":"museum_visit",
    "question":"find the id, name and age for visitors who visited some museums more than once.",
    "query":"SELECT t1.id , t1.name , t1.age FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id GROUP BY t1.id , t1.name , t1.age HAVING count ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ visit ] Output [ visitor_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ visitor_ID ] Output [ visitor_ID , countstar AS Count_Star ] ; #3 = Scan Table [ visitor ] Output [ ID , Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.visitor_ID = #3.ID ] Output [ #3.Age , #3.Name , #3.ID , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ ID , Name , Age ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visit ] Output [ visitor_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ visitor_ID ] Output [ visitor_ID , countstar AS Count_Star ] ; #3 = Scan Table [ visitor ] Output [ ID , Name , Age ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.visitor_ID = #3.ID ] Output [ #3.Age , #3.Name , #3.ID , #2.Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ ID , Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT visitor_ID FROM museum_visit.visit ), Aggregate_2 AS ( SELECT visitor_ID, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY visitor_ID ), Scan_3 AS ( SELECT ID, Name, Age FROM museum_visit.visitor ), Join_4 AS ( SELECT Scan_3.Age, Scan_3.Name, Scan_3.ID, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.visitor_ID = Scan_3.ID ), Filter_5 AS ( SELECT ID, Name, Age FROM Join_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT t1.id , t1.name , t1.age FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id GROUP BY t1.id , t1.name , t1.age HAVING count ( * ) > 1"
  },
  {
    "id":"35123af8dc9b9ee62fb89c900e54cbc078224381186a88392dae10e50a7427b8",
    "db_id":"museum_visit",
    "question":"What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?",
    "query":"SELECT TOP 1 t2.visitor_id , t1.name , t1.Level_of_membership FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id GROUP BY t2.visitor_id , t1.name , t1.Level_of_membership ORDER BY sum ( t2.Total_spent ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ visit ] Output [ Total_spent , visitor_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ visitor_ID ] Output [ visitor_ID , SUM(Total_spent) AS Sum_Total_spent ] ; #3 = Scan Table [ visitor ] Output [ ID , Name , Level_of_membership ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.visitor_ID = #3.ID ] Output [ #2.visitor_ID , #3.Name , #3.Level_of_membership , #2.Sum_Total_spent ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_Total_spent DESC ] Output [ Name , Sum_Total_spent , visitor_ID , Level_of_membership ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visit ] Output [ Total_spent , visitor_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ visitor_ID ] Output [ visitor_ID , SUM(Total_spent) AS Sum_Total_spent ] ; #3 = Scan Table [ visitor ] Output [ ID , Name , Level_of_membership ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.visitor_ID = #3.ID ] Output [ #2.visitor_ID , #3.Name , #3.Level_of_membership , #2.Sum_Total_spent ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_Total_spent DESC ] Output [ Name , Sum_Total_spent , visitor_ID , Level_of_membership ]",
    "cte":"WITH Scan_1 AS ( SELECT Total_spent, visitor_ID FROM museum_visit.visit ), Aggregate_2 AS ( SELECT visitor_ID, SUM(Total_spent) AS Sum_Total_spent FROM Scan_1 GROUP BY visitor_ID ), Scan_3 AS ( SELECT ID, Name, Level_of_membership FROM museum_visit.visitor ), Join_4 AS ( SELECT Aggregate_2.visitor_ID, Scan_3.Name, Scan_3.Level_of_membership, Aggregate_2.Sum_Total_spent FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.visitor_ID = Scan_3.ID ), TopSort_5 AS ( SELECT TOP 1 Name, Sum_Total_spent, visitor_ID, Level_of_membership FROM Join_4 ORDER BY Sum_Total_spent DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 t2.visitor_id , t1.name , t1.Level_of_membership FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id GROUP BY t2.visitor_id , t1.name , t1.Level_of_membership ORDER BY sum ( t2.Total_spent ) DESC"
  },
  {
    "id":"9904b062c563102b86314357314958e0648753b448df996620cdf9be065e0f0e",
    "db_id":"museum_visit",
    "question":"What are the id and name of the museum visited most times?",
    "query":"SELECT TOP 1 t2.Museum_ID , t1.name FROM museum_visit.museum AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.Museum_ID = t2.Museum_ID GROUP BY t2.Museum_ID , t1.name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ visit ] Output [ Museum_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Museum_ID ] Output [ countstar AS Count_Star , Museum_ID ] ; #3 = Scan Table [ museum ] Output [ Name , Museum_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Museum_ID = #3.Museum_ID ] Output [ #2.Count_Star , #2.Museum_ID , #3.Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star , Museum_ID ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visit ] Output [ Museum_ID ] ; #2 = Aggregate [ #1 ] GroupBy [ Museum_ID ] Output [ countstar AS Count_Star , Museum_ID ] ; #3 = Scan Table [ museum ] Output [ Name , Museum_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Museum_ID = #3.Museum_ID ] Output [ #2.Count_Star , #2.Museum_ID , #3.Name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star , Museum_ID ]",
    "cte":"WITH Scan_1 AS ( SELECT Museum_ID FROM museum_visit.visit ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, Museum_ID FROM Scan_1 GROUP BY Museum_ID ), Scan_3 AS ( SELECT Name, Museum_ID FROM museum_visit.museum ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.Museum_ID, Scan_3.Name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.Museum_ID = Scan_3.Museum_ID ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star, Museum_ID FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 t2.Museum_ID , t1.name FROM museum_visit.museum AS t1  JOIN museum_visit.visit AS t2  ON t1.Museum_ID = t2.Museum_ID GROUP BY t2.Museum_ID , t1.name ORDER BY count ( * ) DESC"
  },
  {
    "id":"8ae2a94a239d725b450e3f2319fccfc633f24c3e2b702c94b1e3933c301ff2ea",
    "db_id":"museum_visit",
    "question":"What is the name of the museum that had no visitor yet?",
    "query":"SELECT name FROM museum_visit.museum WITH (FORCESCAN) WHERE Museum_ID NOT IN ( SELECT museum_id FROM museum_visit.visit WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ museum ] Output [ Name , Museum_ID ] ; #2 = Scan Table [ visit ] Output [ Museum_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Museum_ID ] Output [ Museum_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Museum_ID = #1.Museum_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Output [ Name , Museum_ID ] ; #2 = Scan Table [ visit ] Output [ Museum_ID ] ; #3 = Aggregate [ #2 ] GroupBy [ Museum_ID ] Output [ Museum_ID ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.Museum_ID = #1.Museum_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Museum_ID FROM museum_visit.museum ), Scan_2 AS ( SELECT Museum_ID FROM museum_visit.visit ), Aggregate_3 AS ( SELECT Museum_ID FROM Scan_2 GROUP BY Museum_ID ), Except_4 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Museum_ID NOT IN (SELECT Museum_ID FROM Aggregate_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT name FROM museum_visit.museum  WHERE Museum_ID NOT IN ( SELECT museum_id FROM museum_visit.visit  )"
  },
  {
    "id":"f00fb87bd37e2b2945ed497ba5ea69eac0f7d33f744a55657896bdbfc31dd036",
    "db_id":"museum_visit",
    "question":"Find the name and age of the visitor who bought the most tickets at once.",
    "query":"SELECT TOP 1 t1.name , t1.age FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id ORDER BY t2.num_of_ticket DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ visit ] Output [ visitor_ID , Num_of_Ticket ] ; #2 = Scan Table [ visitor ] Output [ ID , Name , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.visitor_ID = #2.ID ] Output [ #2.Age , #1.Num_of_Ticket , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Num_of_Ticket DESC ] Output [ Name , Age , Num_of_Ticket ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visit ] Output [ visitor_ID , Num_of_Ticket ] ; #2 = Scan Table [ visitor ] Output [ ID , Name , Age ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.visitor_ID = #2.ID ] Output [ #2.Age , #1.Num_of_Ticket , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Num_of_Ticket DESC ] Output [ Name , Age , Num_of_Ticket ]",
    "cte":"WITH Scan_1 AS ( SELECT visitor_ID, Num_of_Ticket FROM museum_visit.visit ), Scan_2 AS ( SELECT ID, Name, Age FROM museum_visit.visitor ), Join_3 AS ( SELECT Scan_2.Age, Scan_1.Num_of_Ticket, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.visitor_ID = Scan_2.ID ), TopSort_4 AS ( SELECT TOP 1 Name, Age, Num_of_Ticket FROM Join_3 ORDER BY Num_of_Ticket DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 t1.name , t1.age FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id ORDER BY t2.num_of_ticket DESC"
  },
  {
    "id":"50a9673efed62eae22b4c202df67633cef3c1493a63dcfa415e75c65c29580f2",
    "db_id":"museum_visit",
    "question":"What are the average and maximum number of tickets bought in all visits?",
    "query":"SELECT avg ( num_of_ticket ) AS Avg_num_of_ticket , max ( num_of_ticket ) AS Max_num_of_ticket FROM museum_visit.visit WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ visit ] Output [ Num_of_Ticket ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_of_Ticket) AS Avg_Num_of_Ticket , MAX(Num_of_Ticket) AS Max_Num_of_Ticket ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visit ] Output [ Num_of_Ticket ] ; #2 = Aggregate [ #1 ] Output [ AVG(Num_of_Ticket) AS Avg_Num_of_Ticket , MAX(Num_of_Ticket) AS Max_Num_of_Ticket ]",
    "cte":"WITH Scan_1 AS ( SELECT Num_of_Ticket FROM museum_visit.visit ), Aggregate_2 AS ( SELECT AVG(Num_of_Ticket) AS Avg_Num_of_Ticket, MAX(Num_of_Ticket) AS Max_Num_of_Ticket FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( num_of_ticket ) AS Avg_num_of_ticket , max ( num_of_ticket ) AS Max_num_of_ticket FROM museum_visit.visit"
  },
  {
    "id":"61bb655bcee5c11242e7ae7ad2bb18245dcaaad4ade6d8d621789af648b98cd6",
    "db_id":"museum_visit",
    "question":"What is the total ticket expense of the visitors whose membership level is 1?",
    "query":"SELECT sum ( t2.Total_spent ) AS Sum_Total_spent FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id WHERE t1.Level_of_membership = 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ visitor ] Predicate [ Level_of_membership = 1 ] Output [ ID , Level_of_membership ] ; #2 = Scan Table [ visit ] Output [ Total_spent , visitor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.visitor_ID ] Output [ #2.Total_spent ] ; #4 = Aggregate [ #3 ] Output [ SUM(Total_spent) AS Sum_Total_spent ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visitor ] Predicate [ Level_of_membership = 1 ] Output [ ID , Level_of_membership ] ; #2 = Scan Table [ visit ] Output [ Total_spent , visitor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.visitor_ID ] Output [ #2.Total_spent ] ; #4 = Aggregate [ #3 ] Output [ SUM(Total_spent) AS Sum_Total_spent ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, Level_of_membership FROM museum_visit.visitor WHERE Level_of_membership = 1 ), Scan_2 AS ( SELECT Total_spent, visitor_ID FROM museum_visit.visit ), Join_3 AS ( SELECT Scan_2.Total_spent FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.visitor_ID ), Aggregate_4 AS ( SELECT SUM(Total_spent) AS Sum_Total_spent FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT sum ( t2.Total_spent ) AS Sum_Total_spent FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id WHERE t1.Level_of_membership = 1"
  },
  {
    "id":"524c108e3bf0acdbbb82209403f005db8b11506bdae75cbd4850a8235c714cf5",
    "db_id":"museum_visit",
    "question":"What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?",
    "query":"SELECT t1.name FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3 WITH (FORCESCAN) ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year < 2009 INTERSECT SELECT t1.name FROM museum_visit.visitor AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3 WITH (FORCESCAN) ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year > 2011 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ museum ] Predicate [ Open_Year < 2009 ] Output [ Open_Year , Museum_ID ] ; #2 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Museum_ID = #2.Museum_ID ] Output [ #2.visitor_ID ] ; #4 = Scan Table [ visitor ] Output [ ID , Name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.visitor_ID = #4.ID ] Distinct [ true ] Output [ #4.Name ] ; #6 = Scan Table [ museum ] Predicate [ Open_Year > 2011 ] Output [ Open_Year , Museum_ID ] ; #7 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Museum_ID = #7.Museum_ID ] Output [ #7.visitor_ID ] ; #9 = Scan Table [ visitor ] Output [ ID , Name ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.visitor_ID = #9.ID ] Output [ #9.Name ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Name = #10.Name ] Output [ #5.Name ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year < 2009 ] Output [ Open_Year , Museum_ID ] ; #2 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Museum_ID = #2.Museum_ID ] Output [ #2.visitor_ID ] ; #4 = Scan Table [ visitor ] Output [ ID , Name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.visitor_ID = #4.ID ] Distinct [ true ] Output [ #4.Name ] ; #6 = Scan Table [ museum ] Predicate [ Open_Year > 2011 ] Output [ Open_Year , Museum_ID ] ; #7 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.Museum_ID = #7.Museum_ID ] Output [ #7.visitor_ID ] ; #9 = Scan Table [ visitor ] Output [ ID , Name ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.visitor_ID = #9.ID ] Output [ #9.Name ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.Name = #10.Name ] Output [ #5.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Open_Year, Museum_ID FROM museum_visit.museum WHERE Open_Year < 2009 ), Scan_2 AS ( SELECT visitor_ID, Museum_ID FROM museum_visit.visit ), Join_3 AS ( SELECT Scan_2.visitor_ID FROM Scan_1 JOIN Scan_2 ON Scan_1.Museum_ID = Scan_2.Museum_ID ), Scan_4 AS ( SELECT ID, Name FROM museum_visit.visitor ), Join_5 AS ( SELECT DISTINCT Scan_4.Name FROM Join_3 JOIN Scan_4 ON Join_3.visitor_ID = Scan_4.ID ), Scan_6 AS ( SELECT Open_Year, Museum_ID FROM museum_visit.museum WHERE Open_Year > 2011 ), Scan_7 AS ( SELECT visitor_ID, Museum_ID FROM museum_visit.visit ), Join_8 AS ( SELECT Scan_7.visitor_ID FROM Scan_6 JOIN Scan_7 ON Scan_6.Museum_ID = Scan_7.Museum_ID ), Scan_9 AS ( SELECT ID, Name FROM museum_visit.visitor ), Join_10 AS ( SELECT Scan_9.Name FROM Join_8 JOIN Scan_9 ON Join_8.visitor_ID = Scan_9.ID ), Intersect_11 AS ( SELECT Join_5.Name FROM Join_5 WHERE Name IN (SELECT Name FROM Join_10) ) SELECT * FROM Intersect_11",
    "clean_query":"SELECT t1.name FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3  ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year < 2009 INTERSECT SELECT t1.name FROM museum_visit.visitor AS t1  JOIN museum_visit.visit AS t2  ON t1.id = t2.visitor_id JOIN museum_visit.museum AS t3  ON t3.Museum_ID = t2.Museum_ID WHERE t3.open_year > 2011"
  },
  {
    "id":"ae181dcca46228f38a78aa5acf558f35f920c5e4bdb8b56ce47a9945cfb18458",
    "db_id":"museum_visit",
    "question":"Find the number of visitors who did not visit any museum opened after 2010.",
    "query":"SELECT count ( * ) AS Count_Star FROM museum_visit.visitor WITH (FORCESCAN) WHERE id NOT IN ( SELECT t2.visitor_id FROM museum_visit.museum AS t1 WITH (FORCESCAN) JOIN museum_visit.visit AS t2 WITH (FORCESCAN) ON t1.Museum_ID = t2.Museum_ID WHERE t1.open_year > 2010 ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ visitor ] Output [ ID ] ; #2 = Scan Table [ museum ] Predicate [ Open_Year > 2010 ] Output [ Open_Year , Museum_ID ] ; #3 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Museum_ID = #3.Museum_ID ] Output [ #3.visitor_ID ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.visitor_ID = #1.ID ] Output [ 1 AS One ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ visitor ] Output [ ID ] ; #2 = Scan Table [ museum ] Predicate [ Open_Year > 2010 ] Output [ Open_Year , Museum_ID ] ; #3 = Scan Table [ visit ] Output [ visitor_ID , Museum_ID ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Museum_ID = #3.Museum_ID ] Output [ #3.visitor_ID ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.visitor_ID = #1.ID ] Output [ 1 AS One ] ; #6 = Aggregate [ #5 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID FROM museum_visit.visitor ), Scan_2 AS ( SELECT Open_Year, Museum_ID FROM museum_visit.museum WHERE Open_Year > 2010 ), Scan_3 AS ( SELECT visitor_ID, Museum_ID FROM museum_visit.visit ), Join_4 AS ( SELECT Scan_3.visitor_ID FROM Scan_2 JOIN Scan_3 ON Scan_2.Museum_ID = Scan_3.Museum_ID ), Except_5 AS ( SELECT 1 AS One FROM Scan_1 WHERE ID NOT IN (SELECT visitor_ID FROM Join_4) ), Aggregate_6 AS ( SELECT COUNT(*) AS Count_Star FROM Except_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM museum_visit.visitor  WHERE id NOT IN ( SELECT t2.visitor_id FROM museum_visit.museum AS t1  JOIN museum_visit.visit AS t2  ON t1.Museum_ID = t2.Museum_ID WHERE t1.open_year > 2010 )"
  },
  {
    "id":"ea13f16bad44cab1f5519ae833248e98e84d09409acf52956eae0675e9cf159e",
    "db_id":"museum_visit",
    "question":"How many museums were opened after 2013 or before 2008?",
    "query":"SELECT count ( * ) AS Count_Star FROM museum_visit.museum WITH (FORCESCAN) WHERE open_year > 2013 OR open_year < 2008 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ museum ] Predicate [ Open_Year > 2013 OR Open_Year < 2008 ] Output [ Open_Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"museum_visit | #1 = Scan Table [ museum ] Predicate [ Open_Year > 2013 OR Open_Year < 2008 ] Output [ Open_Year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Open_Year FROM museum_visit.museum WHERE Open_Year > 2013 OR Open_Year < 2008 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM museum_visit.museum  WHERE open_year > 2013 OR open_year < 2008"
  },
  {
    "id":"4631e248fadb782ac6922779f4289d6c953b3c5d345b58dc7b86b67be4b17b1f",
    "db_id":"wta_1",
    "question":"Find the total number of players.",
    "query":"SELECT count ( * ) AS Count_Star FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ players ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM wta_1.players"
  },
  {
    "id":"b89f7b5db1f8857f0713223621e84ae4f40ed97b45e2b2ba79a26641c096d8ed",
    "db_id":"wta_1",
    "question":"How many players are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ players ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM wta_1.players"
  },
  {
    "id":"a138de21c6fb3c215e42c91746c2e9841522ae6a2bf1e80bde7978850e711477",
    "db_id":"wta_1",
    "question":"Find the total number of matches.",
    "query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches"
  },
  {
    "id":"2d1ff3bdc9e4e167beb08971a10a8d8d149cc138b1bf5491f2dfdeb69f47e4d2",
    "db_id":"wta_1",
    "question":"Count the number of matches.",
    "query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches"
  },
  {
    "id":"d612319015bf64e8590a72838cdd91e35aaaaaa0b6c436634cc43acf73848f15",
    "db_id":"wta_1",
    "question":"List the first name and birth date of all players from the country with code USA.",
    "query":"SELECT first_name , birth_date FROM wta_1.players WITH (FORCESCAN) WHERE country_code = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Predicate [ country_code = 'USA' ] Output [ first_name , country_code , birth_date ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Predicate [ country_code = 'USA' ] Output [ first_name , country_code , birth_date ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, country_code, birth_date FROM wta_1.players WHERE country_code = 'USA' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT first_name , birth_date FROM wta_1.players  WHERE country_code = 'USA'"
  },
  {
    "id":"c6eaf80201ad8d7f85db0df294c33fed7080cd547a81a9a164d9c2ef59b662e3",
    "db_id":"wta_1",
    "question":"What are the first names and birth dates of players from the USA?",
    "query":"SELECT first_name , birth_date FROM wta_1.players WITH (FORCESCAN) WHERE country_code = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Predicate [ country_code = 'USA' ] Output [ first_name , country_code , birth_date ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Predicate [ country_code = 'USA' ] Output [ first_name , country_code , birth_date ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, country_code, birth_date FROM wta_1.players WHERE country_code = 'USA' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT first_name , birth_date FROM wta_1.players  WHERE country_code = 'USA'"
  },
  {
    "id":"2ae1a5a8d079e1ddb3c830c69f555e616cc82ca7a5d386879eb5085591970c7c",
    "db_id":"wta_1",
    "question":"Find the average age of losers and winners of all matches.",
    "query":"SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Output [ loser_age , winner_age ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_age) AS Avg_winner_age , AVG(loser_age) AS Avg_loser_age ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ loser_age , winner_age ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_age) AS Avg_winner_age , AVG(loser_age) AS Avg_loser_age ]",
    "cte":"WITH Scan_1 AS ( SELECT loser_age, winner_age FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_age) AS Avg_winner_age, AVG(loser_age) AS Avg_loser_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches"
  },
  {
    "id":"b3db64365a68c90a44de3089b599cbb27ffa0e6a1d83bc09344beac1c5cfaa6b",
    "db_id":"wta_1",
    "question":"What are the average ages of losers and winners across matches?",
    "query":"SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Output [ loser_age , winner_age ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_age) AS Avg_winner_age , AVG(loser_age) AS Avg_loser_age ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ loser_age , winner_age ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_age) AS Avg_winner_age , AVG(loser_age) AS Avg_loser_age ]",
    "cte":"WITH Scan_1 AS ( SELECT loser_age, winner_age FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_age) AS Avg_winner_age, AVG(loser_age) AS Avg_loser_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( loser_age ) AS Avg_loser_age , avg ( winner_age ) AS Avg_winner_age FROM wta_1.matches"
  },
  {
    "id":"139fe90e20205c170d6167b71f0e43f1bc29925a7d457c55605f62f830b59678",
    "db_id":"wta_1",
    "question":"Find the average rank of winners in all matches.",
    "query":"SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ winner_rank ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_rank) AS Avg_winner_rank ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_rank) AS Avg_winner_rank ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_rank) AS Avg_winner_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches"
  },
  {
    "id":"d6d0dc5db8b689d4c0ac7ea1f9baae2fc6d0363c22531ceab894610838fbd534",
    "db_id":"wta_1",
    "question":"What is the average rank for winners in all matches?",
    "query":"SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ winner_rank ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_rank) AS Avg_winner_rank ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank ] ; #2 = Aggregate [ #1 ] Output [ AVG(winner_rank) AS Avg_winner_rank ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT AVG(winner_rank) AS Avg_winner_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( winner_rank ) AS Avg_winner_rank FROM wta_1.matches"
  },
  {
    "id":"a64d6f482d2ebdc30710080c6687dabf2623b14791148768a43369e54265ec45",
    "db_id":"wta_1",
    "question":"Find the highest rank of losers in all matches.",
    "query":"SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ loser_rank ] ; #2 = Aggregate [ #1 ] Output [ MIN(loser_rank) AS Min_loser_rank ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ loser_rank ] ; #2 = Aggregate [ #1 ] Output [ MIN(loser_rank) AS Min_loser_rank ]",
    "cte":"WITH Scan_1 AS ( SELECT loser_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT MIN(loser_rank) AS Min_loser_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches"
  },
  {
    "id":"a17adb01c205ee4acecf59e8282753026f4bcbfac86be64aba1ac37290f2415c",
    "db_id":"wta_1",
    "question":"What is the best rank of losers across all matches?",
    "query":"SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ loser_rank ] ; #2 = Aggregate [ #1 ] Output [ MIN(loser_rank) AS Min_loser_rank ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ loser_rank ] ; #2 = Aggregate [ #1 ] Output [ MIN(loser_rank) AS Min_loser_rank ]",
    "cte":"WITH Scan_1 AS ( SELECT loser_rank FROM wta_1.matches ), Aggregate_2 AS ( SELECT MIN(loser_rank) AS Min_loser_rank FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT min ( loser_rank ) AS Min_loser_rank FROM wta_1.matches"
  },
  {
    "id":"8376e9086290a914bac06f17b3d831a833daedaa3449dbcbb5c6881a573673e1",
    "db_id":"wta_1",
    "question":"find the number of distinct country codes of all players.",
    "query":"SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ players ] Distinct [ true ] Output [ country_code ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT country_code) AS Count_Dist_country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Distinct [ true ] Output [ country_code ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT country_code) AS Count_Dist_country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(DISTINCT country_code) AS Count_Dist_country_code FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players"
  },
  {
    "id":"7d0952affa592f943383d85f82a3cdbae6b653e87a16d0198cd69070d06cd9ab",
    "db_id":"wta_1",
    "question":"How many distinct countries do players come from?",
    "query":"SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ players ] Distinct [ true ] Output [ country_code ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT country_code) AS Count_Dist_country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Distinct [ true ] Output [ country_code ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT country_code) AS Count_Dist_country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT COUNT(DISTINCT country_code) AS Count_Dist_country_code FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT country_code ) AS Count_Dist_country_code FROM wta_1.players"
  },
  {
    "id":"456cfce7f4f9a1bf5059801519fd02ec3ef4b74df8dd9289c623633591d50cce",
    "db_id":"wta_1",
    "question":"Find the number of distinct name of losers.",
    "query":"SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Distinct [ true ] Output [ loser_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT loser_name) AS Count_Dist_loser_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ loser_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT loser_name) AS Count_Dist_loser_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT loser_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(DISTINCT loser_name) AS Count_Dist_loser_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches"
  },
  {
    "id":"180b86428841fc7e75e3b1a8d8a95e2bf8b8b3b4b445be82d19fc0c34bf51e2f",
    "db_id":"wta_1",
    "question":"How many different loser names are there?",
    "query":"SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Distinct [ true ] Output [ loser_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT loser_name) AS Count_Dist_loser_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ loser_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT loser_name) AS Count_Dist_loser_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT loser_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT COUNT(DISTINCT loser_name) AS Count_Dist_loser_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT loser_name ) AS Count_Dist_loser_name FROM wta_1.matches"
  },
  {
    "id":"f0a3396077268cb93b9b22bee78d31feaf8e636a88216d5d2f568ffd491ea915",
    "db_id":"wta_1",
    "question":"Find the name of tourney that has more than 10 matches.",
    "query":"SELECT tourney_name FROM wta_1.matches WITH (FORCESCAN) GROUP BY tourney_name HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ tourney_name ] ; #2 = Aggregate [ #1 ] GroupBy [ tourney_name ] Output [ tourney_name , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 10 ] Output [ tourney_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ tourney_name ] ; #2 = Aggregate [ #1 ] GroupBy [ tourney_name ] Output [ tourney_name , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 10 ] Output [ tourney_name ]",
    "cte":"WITH Scan_1 AS ( SELECT tourney_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT tourney_name, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY tourney_name ), Filter_3 AS ( SELECT tourney_name FROM Aggregate_2 WHERE Count_Star > 10 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT tourney_name FROM wta_1.matches  GROUP BY tourney_name HAVING count ( * ) > 10"
  },
  {
    "id":"6c2fcf353449efb9231d6c798d779d0168d424c399c9c362f5a6da5654716338",
    "db_id":"wta_1",
    "question":"What are the names of tournaments that have more than 10 matches?",
    "query":"SELECT tourney_name FROM wta_1.matches WITH (FORCESCAN) GROUP BY tourney_name HAVING count ( * ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ matches ] Output [ tourney_name ] ; #2 = Aggregate [ #1 ] GroupBy [ tourney_name ] Output [ tourney_name , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 10 ] Output [ tourney_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ tourney_name ] ; #2 = Aggregate [ #1 ] GroupBy [ tourney_name ] Output [ tourney_name , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 10 ] Output [ tourney_name ]",
    "cte":"WITH Scan_1 AS ( SELECT tourney_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT tourney_name, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY tourney_name ), Filter_3 AS ( SELECT tourney_name FROM Aggregate_2 WHERE Count_Star > 10 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT tourney_name FROM wta_1.matches  GROUP BY tourney_name HAVING count ( * ) > 10"
  },
  {
    "id":"e173f111341c71e2a837c8c0f18342105c3339de0e08e545b831d9f159845ed3",
    "db_id":"wta_1",
    "question":"List the names of all winners who played in both 2013 and 2016.",
    "query":"SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ year = 2013 ] Distinct [ true ] Output [ year , winner_name ] ; #2 = Scan Table [ matches ] Predicate [ year = 2016 ] Output [ year , winner_name ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.winner_name = #2.winner_name ] Output [ #1.winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 ] Distinct [ true ] Output [ year , winner_name ] ; #2 = Scan Table [ matches ] Predicate [ year = 2016 ] Output [ year , winner_name ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.winner_name = #2.winner_name ] Output [ #1.winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT year, winner_name FROM wta_1.matches WHERE year = 2013 ), Scan_2 AS ( SELECT year, winner_name FROM wta_1.matches WHERE year = 2016 ), Intersect_3 AS ( SELECT Scan_1.winner_name FROM Scan_1 WHERE winner_name IN (SELECT winner_name FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2016"
  },
  {
    "id":"ed32d95c06b758a201d5b6a501e55481c633acf085ca4187edd64f37741a20c1",
    "db_id":"wta_1",
    "question":"What are the names of players who won in both 2013 and 2016?",
    "query":"SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ year = 2013 ] Distinct [ true ] Output [ year , winner_name ] ; #2 = Scan Table [ matches ] Predicate [ year = 2016 ] Output [ year , winner_name ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.winner_name = #2.winner_name ] Output [ #1.winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 ] Distinct [ true ] Output [ year , winner_name ] ; #2 = Scan Table [ matches ] Predicate [ year = 2016 ] Output [ year , winner_name ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.winner_name = #2.winner_name ] Output [ #1.winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT year, winner_name FROM wta_1.matches WHERE year = 2013 ), Scan_2 AS ( SELECT year, winner_name FROM wta_1.matches WHERE year = 2016 ), Intersect_3 AS ( SELECT Scan_1.winner_name FROM Scan_1 WHERE winner_name IN (SELECT winner_name FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2013 INTERSECT SELECT winner_name FROM wta_1.matches  WHERE YEAR = 2016"
  },
  {
    "id":"560524f03cef0b0c2248599274a33d9621b0f01f721c71d46382408e6c0e6f56",
    "db_id":"wta_1",
    "question":"List the number of all matches who played in years of 2013 or 2016.",
    "query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 OR YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ year = 2013 OR year = 2016 ] Output [ year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 OR year = 2016 ] Output [ year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT year FROM wta_1.matches WHERE year = 2013 OR year = 2016 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches  WHERE YEAR = 2013 OR YEAR = 2016"
  },
  {
    "id":"0e52fbec4158ca7c3cfba053e57807319098341d3583da7d1076f728ea86df2b",
    "db_id":"wta_1",
    "question":"How many matches were played in 2013 or 2016?",
    "query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches WITH (FORCESCAN) WHERE YEAR = 2013 OR YEAR = 2016 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ year = 2013 OR year = 2016 ] Output [ year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ year = 2013 OR year = 2016 ] Output [ year ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT year FROM wta_1.matches WHERE year = 2013 OR year = 2016 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM wta_1.matches  WHERE YEAR = 2013 OR YEAR = 2016"
  },
  {
    "id":"4e761a9127f36296f20021c44a8cadca031a57c3bb317ef82e3f9b28cfc2fee5",
    "db_id":"wta_1",
    "question":"What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?",
    "query":"SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' ] Output [ winner_id , tourney_name ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Distinct [ true ] Output [ #2.first_name , #2.country_code ] ; #4 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ winner_id , tourney_name ] ; #5 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.winner_id = #5.player_id ] Output [ #5.country_code , #5.first_name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.country_code = #6.country_code ] Output [ #3.country_code , #3.first_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' ] Output [ winner_id , tourney_name ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Distinct [ true ] Output [ #2.first_name , #2.country_code ] ; #4 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ winner_id , tourney_name ] ; #5 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.winner_id = #5.player_id ] Output [ #5.country_code , #5.first_name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.country_code = #6.country_code ] Output [ #3.country_code , #3.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_id, tourney_name FROM wta_1.matches WHERE tourney_name = 'WTA Championships' ), Scan_2 AS ( SELECT first_name, country_code, player_id FROM wta_1.players ), Join_3 AS ( SELECT DISTINCT Scan_2.first_name, Scan_2.country_code FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), Scan_4 AS ( SELECT winner_id, tourney_name FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), Scan_5 AS ( SELECT first_name, country_code, player_id FROM wta_1.players ), Join_6 AS ( SELECT Scan_5.country_code, Scan_5.first_name FROM Scan_4 JOIN Scan_5 ON Scan_4.winner_id = Scan_5.player_id ), Intersect_7 AS ( SELECT Join_3.country_code, Join_3.first_name FROM Join_3 WHERE country_code IN (SELECT country_code FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open'"
  },
  {
    "id":"2a4a5e75c0774a24355f23685b6e1e35bf529fbe6c142f94efbf6a9f24a57f6d",
    "db_id":"wta_1",
    "question":"What are the first names and country codes for players who won both the WTA Championships and the Australian Open?",
    "query":"SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' ] Output [ winner_id , tourney_name ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Distinct [ true ] Output [ #2.first_name , #2.country_code ] ; #4 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ winner_id , tourney_name ] ; #5 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.winner_id = #5.player_id ] Output [ #5.country_code , #5.first_name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.country_code = #6.country_code ] Output [ #3.country_code , #3.first_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' ] Output [ winner_id , tourney_name ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Distinct [ true ] Output [ #2.first_name , #2.country_code ] ; #4 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ winner_id , tourney_name ] ; #5 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.winner_id = #5.player_id ] Output [ #5.country_code , #5.first_name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.country_code = #6.country_code ] Output [ #3.country_code , #3.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_id, tourney_name FROM wta_1.matches WHERE tourney_name = 'WTA Championships' ), Scan_2 AS ( SELECT first_name, country_code, player_id FROM wta_1.players ), Join_3 AS ( SELECT DISTINCT Scan_2.first_name, Scan_2.country_code FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), Scan_4 AS ( SELECT winner_id, tourney_name FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), Scan_5 AS ( SELECT first_name, country_code, player_id FROM wta_1.players ), Join_6 AS ( SELECT Scan_5.country_code, Scan_5.first_name FROM Scan_4 JOIN Scan_5 ON Scan_4.winner_id = Scan_5.player_id ), Intersect_7 AS ( SELECT Join_3.country_code, Join_3.first_name FROM Join_3 WHERE country_code IN (SELECT country_code FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'WTA Championships' INTERSECT SELECT T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id WHERE T2.tourney_name = 'Australian Open'"
  },
  {
    "id":"d48e7fe6972cb8e21a3c6394d53980bdf7e37fc28a78f91f9fb7230c24136dae",
    "db_id":"wta_1",
    "question":"Find the first name and country code of the oldest player.",
    "query":"SELECT TOP 1 first_name , country_code FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ first_name , country_code , birth_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ birth_date ASC ] Output [ first_name , country_code , birth_date ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ first_name , country_code , birth_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ birth_date ASC ] Output [ first_name , country_code , birth_date ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, country_code, birth_date FROM wta_1.players ), TopSort_2 AS ( SELECT TOP 1 first_name, country_code, birth_date FROM Scan_1 ORDER BY birth_date ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 first_name , country_code FROM wta_1.players  ORDER BY birth_date"
  },
  {
    "id":"baa9a1483242a0a237f97714d50d97a1b5a523b10b592594eae08f5e9e0280e6",
    "db_id":"wta_1",
    "question":"What is the first name and country code of the oldest player?",
    "query":"SELECT TOP 1 first_name , country_code FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ first_name , country_code , birth_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ birth_date ASC ] Output [ first_name , country_code , birth_date ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ first_name , country_code , birth_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ birth_date ASC ] Output [ first_name , country_code , birth_date ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, country_code, birth_date FROM wta_1.players ), TopSort_2 AS ( SELECT TOP 1 first_name, country_code, birth_date FROM Scan_1 ORDER BY birth_date ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 first_name , country_code FROM wta_1.players  ORDER BY birth_date"
  },
  {
    "id":"6e5a3955c039c7de8941e2b20560eb004bf6273531145bbe4f9433d229b66a37",
    "db_id":"wta_1",
    "question":"List the first and last name of all players in the order of birth date.",
    "query":"SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ first_name , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ first_name , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, birth_date, last_name FROM wta_1.players ) SELECT first_name, birth_date, last_name FROM Scan_1 ORDER BY birth_date ASC",
    "clean_query":"SELECT first_name , last_name FROM wta_1.players  ORDER BY birth_date"
  },
  {
    "id":"2cccadad4927cf8f0d910ca98ba5bd58effcdffa734554dc162d4da321a9f158",
    "db_id":"wta_1",
    "question":"What are the full names of all players, sorted by birth date?",
    "query":"SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ first_name , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ first_name , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, birth_date, last_name FROM wta_1.players ) SELECT first_name, birth_date, last_name FROM Scan_1 ORDER BY birth_date ASC",
    "clean_query":"SELECT first_name , last_name FROM wta_1.players  ORDER BY birth_date"
  },
  {
    "id":"da1dbbcc0a1c8a817f65ae6ee6fce3dabc45b38d66111fc4c7bee9adec5000cb",
    "db_id":"wta_1",
    "question":"List the first and last name of all players who are left \/ L hand in the order of birth date.",
    "query":"SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) WHERE hand = 'L' ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Predicate [ hand = 'L' ] Output [ first_name , hand , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Predicate [ hand = 'L' ] Output [ first_name , hand , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, hand, birth_date, last_name FROM wta_1.players WHERE hand = 'L' ) SELECT first_name, birth_date, last_name FROM Scan_1 ORDER BY birth_date ASC",
    "clean_query":"SELECT first_name , last_name FROM wta_1.players  WHERE hand = 'L' ORDER BY birth_date"
  },
  {
    "id":"295988b244a1dd78a84417dd6e2054e99798ab87f1f153e3cae281c302e1c32e",
    "db_id":"wta_1",
    "question":"What are the full names of all left handed players, in order of birth date?",
    "query":"SELECT first_name , last_name FROM wta_1.players WITH (FORCESCAN) WHERE hand = 'L' ORDER BY birth_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Predicate [ hand = 'L' ] Output [ first_name , hand , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Predicate [ hand = 'L' ] Output [ first_name , hand , birth_date , last_name ] ; #2 = Sort [ #1 ] OrderBy [ birth_date ASC ] Output [ first_name , birth_date , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, hand, birth_date, last_name FROM wta_1.players WHERE hand = 'L' ) SELECT first_name, birth_date, last_name FROM Scan_1 ORDER BY birth_date ASC",
    "clean_query":"SELECT first_name , last_name FROM wta_1.players  WHERE hand = 'L' ORDER BY birth_date"
  },
  {
    "id":"8a97b1f2dce33f93402760747b78c771827c6f87f26cd8b79c78e074a69bf916",
    "db_id":"wta_1",
    "question":"Find the first name and country code of the player who did the most number of tours.",
    "query":"SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id ORDER BY T2.tours DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #2 = Scan Table [ rankings ] Output [ tours , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #1.country_code , #1.first_name , #2.tours ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ tours DESC ] Output [ first_name , tours , country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #2 = Scan Table [ rankings ] Output [ tours , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #1.country_code , #1.first_name , #2.tours ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ tours DESC ] Output [ first_name , tours , country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, country_code, player_id FROM wta_1.players ), Scan_2 AS ( SELECT tours, player_id FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_1.country_code, Scan_1.first_name, Scan_2.tours FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 first_name, tours, country_code FROM Join_3 ORDER BY tours DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id ORDER BY T2.tours DESC"
  },
  {
    "id":"108ae9411be5efb3b8c13a863ccd27c25db8bb6f388e077086e5a293dfcddf27",
    "db_id":"wta_1",
    "question":"What is the first name and country code of the player with the most tours?",
    "query":"SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id ORDER BY T2.tours DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #2 = Scan Table [ rankings ] Output [ tours , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #1.country_code , #1.first_name , #2.tours ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ tours DESC ] Output [ first_name , tours , country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ first_name , country_code , player_id ] ; #2 = Scan Table [ rankings ] Output [ tours , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #1.country_code , #1.first_name , #2.tours ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ tours DESC ] Output [ first_name , tours , country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, country_code, player_id FROM wta_1.players ), Scan_2 AS ( SELECT tours, player_id FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_1.country_code, Scan_1.first_name, Scan_2.tours FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 first_name, tours, country_code FROM Join_3 ORDER BY tours DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.country_code , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id ORDER BY T2.tours DESC"
  },
  {
    "id":"72e0cde1414ecaa5cdc66b35b9cd074f48422ec83080c25ee226bf95fe4a35d4",
    "db_id":"wta_1",
    "question":"Find the year that has the most number of matches.",
    "query":"SELECT TOP 1 YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , year ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , year ]",
    "cte":"WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY year ), TopSort_3 AS ( SELECT TOP 1 Count_Star, year FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 YEAR FROM wta_1.matches  GROUP BY YEAR ORDER BY count ( * ) DESC"
  },
  {
    "id":"ea75910ba3afc10a0d59dae128d0c75acb7487d6b9222ffa99e6fdc28fa60845",
    "db_id":"wta_1",
    "question":"Which year had the most matches?",
    "query":"SELECT TOP 1 YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , year ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , year ]",
    "cte":"WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY year ), TopSort_3 AS ( SELECT TOP 1 Count_Star, year FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 YEAR FROM wta_1.matches  GROUP BY YEAR ORDER BY count ( * ) DESC"
  },
  {
    "id":"141841cbe0cbd647aee9c2aafc35639203dbf2df3604e6c80a0c387bb04ceae0",
    "db_id":"wta_1",
    "question":"Find the name and rank points of the winner who won the most times.",
    "query":"SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches WITH (FORCESCAN) GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Output [ winner_rank_points , winner_name ] ; #2 = Aggregate [ #1 ] GroupBy [ winner_rank_points , winner_name ] Output [ winner_rank_points , winner_name , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , winner_rank_points , winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank_points , winner_name ] ; #2 = Aggregate [ #1 ] GroupBy [ winner_rank_points , winner_name ] Output [ winner_rank_points , winner_name , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , winner_rank_points , winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_rank_points, winner_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT winner_rank_points, winner_name, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY winner_rank_points, winner_name, winner_rank_points , winner_name ), TopSort_3 AS ( SELECT TOP 1 Count_Star, winner_rank_points, winner_name FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches  GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC"
  },
  {
    "id":"ee837d790c1052adcb9de495cfc9af05e217e5ad8839eeddf75d4cadfbd199fd",
    "db_id":"wta_1",
    "question":"What is the name of the winner who has won the most matches, and how many rank points does this player have?",
    "query":"SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches WITH (FORCESCAN) GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Output [ winner_rank_points , winner_name ] ; #2 = Aggregate [ #1 ] GroupBy [ winner_rank_points , winner_name ] Output [ winner_rank_points , winner_name , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , winner_rank_points , winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ winner_rank_points , winner_name ] ; #2 = Aggregate [ #1 ] GroupBy [ winner_rank_points , winner_name ] Output [ winner_rank_points , winner_name , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , winner_rank_points , winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_rank_points, winner_name FROM wta_1.matches ), Aggregate_2 AS ( SELECT winner_rank_points, winner_name, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY winner_rank_points, winner_name, winner_rank_points , winner_name ), TopSort_3 AS ( SELECT TOP 1 Count_Star, winner_rank_points, winner_name FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 winner_name , winner_rank_points FROM wta_1.matches  GROUP BY winner_name , winner_rank_points ORDER BY count ( * ) DESC"
  },
  {
    "id":"c501736c887bf86ce56b90e4db34439faacb5416059971b688fd5830afa86a07",
    "db_id":"wta_1",
    "question":"Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.",
    "query":"SELECT TOP 1 winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ tourney_name , winner_rank_points , winner_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ tourney_name , winner_rank_points , winner_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT tourney_name, winner_rank_points, winner_name FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), TopSort_2 AS ( SELECT TOP 1 winner_rank_points, winner_name FROM Scan_1 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 winner_name FROM wta_1.matches  WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC"
  },
  {
    "id":"d8dfc34cdbedc21a0d90ad298cde344397edb67285973cccaf4929b8f06682d8",
    "db_id":"wta_1",
    "question":"What is the name of the winner with the most rank points who participated in the Australian Open tournament?",
    "query":"SELECT TOP 1 winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ tourney_name , winner_rank_points , winner_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'Australian Open' ] Output [ tourney_name , winner_rank_points , winner_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ winner_rank_points , winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT tourney_name, winner_rank_points, winner_name FROM wta_1.matches WHERE tourney_name = 'Australian Open' ), TopSort_2 AS ( SELECT TOP 1 winner_rank_points, winner_name FROM Scan_1 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 winner_name FROM wta_1.matches  WHERE tourney_name = 'Australian Open' ORDER BY winner_rank_points DESC"
  },
  {
    "id":"1a52ea66e61e79d0c7556af1d81db30038d734dc4d84fcc7157edcb76b0e0f84",
    "db_id":"wta_1",
    "question":"find the names of loser and winner who played in the match with greatest number of minutes.",
    "query":"SELECT TOP 1 winner_name , loser_name FROM wta_1.matches WITH (FORCESCAN) ORDER BY minutes DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Output [ loser_name , winner_name , minutes ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ minutes DESC ] Output [ loser_name , winner_name , minutes ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ loser_name , winner_name , minutes ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ minutes DESC ] Output [ loser_name , winner_name , minutes ]",
    "cte":"WITH Scan_1 AS ( SELECT loser_name, winner_name, minutes FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 1 loser_name, winner_name, minutes FROM Scan_1 ORDER BY minutes DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 winner_name , loser_name FROM wta_1.matches  ORDER BY minutes DESC"
  },
  {
    "id":"f1c050489e77aa36a4a6916315d9101c4fc31dd87f4c21d1a86f6de09e54aa1b",
    "db_id":"wta_1",
    "question":"What are the names of the winner and loser who played in the longest match?",
    "query":"SELECT TOP 1 winner_name , loser_name FROM wta_1.matches WITH (FORCESCAN) ORDER BY minutes DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Output [ loser_name , winner_name , minutes ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ minutes DESC ] Output [ loser_name , winner_name , minutes ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ loser_name , winner_name , minutes ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ minutes DESC ] Output [ loser_name , winner_name , minutes ]",
    "cte":"WITH Scan_1 AS ( SELECT loser_name, winner_name, minutes FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 1 loser_name, winner_name, minutes FROM Scan_1 ORDER BY minutes DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 winner_name , loser_name FROM wta_1.matches  ORDER BY minutes DESC"
  },
  {
    "id":"086087399d35549efbe7ca776ed64b5eb84b62ea11f7dc4585b96c2c26eb7d5a",
    "db_id":"wta_1",
    "question":"Find the average ranking for each player and their first name.",
    "query":"SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ AVG(ranking) AS Avg_ranking , first_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ AVG(ranking) AS Avg_ranking , first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT AVG(ranking) AS Avg_ranking, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name"
  },
  {
    "id":"c21404f628622b0b31a04806e09664651daff826371944fb1be63ecf5b1627a7",
    "db_id":"wta_1",
    "question":"What are the first names of all players, and their average rankings?",
    "query":"SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ AVG(ranking) AS Avg_ranking , first_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ AVG(ranking) AS Avg_ranking , first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT AVG(ranking) AS Avg_ranking, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( ranking ) AS Avg_ranking , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name"
  },
  {
    "id":"fc6edbd3e37d50acc7d2b3f1a3c6d66eccec37a36afcf02f8f6a14bfc7f951bc",
    "db_id":"wta_1",
    "question":"Find the total ranking points for each player and their first name.",
    "query":"SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking_points ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking_points , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ SUM(ranking_points) AS Sum_ranking_points , first_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking_points ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking_points , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ SUM(ranking_points) AS Sum_ranking_points , first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking_points FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking_points, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT SUM(ranking_points) AS Sum_ranking_points, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name"
  },
  {
    "id":"78180afbb85c0ff5153d14edb5060ddbd3cc213bd221da87adef21a8d4c73e41",
    "db_id":"wta_1",
    "question":"What are the first names of all players, and their total ranking points?",
    "query":"SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.rankings AS T2 WITH (FORCESCAN) ON T1.player_id = T2.player_id GROUP BY T1.first_name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking_points ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking_points , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ SUM(ranking_points) AS Sum_ranking_points , first_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ player_id , first_name ] ; #2 = Scan Table [ rankings ] Output [ player_id , ranking_points ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.player_id = #2.player_id ] Output [ #2.ranking_points , #1.first_name ] ; #4 = Aggregate [ #3 ] GroupBy [ first_name ] Output [ SUM(ranking_points) AS Sum_ranking_points , first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT player_id, first_name FROM wta_1.players ), Scan_2 AS ( SELECT player_id, ranking_points FROM wta_1.rankings ), Join_3 AS ( SELECT Scan_2.ranking_points, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.player_id = Scan_2.player_id ), Aggregate_4 AS ( SELECT SUM(ranking_points) AS Sum_ranking_points, first_name FROM Join_3 GROUP BY first_name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT sum ( ranking_points ) AS Sum_ranking_points , T1.first_name FROM wta_1.players AS T1  JOIN wta_1.rankings AS T2  ON T1.player_id = T2.player_id GROUP BY T1.first_name"
  },
  {
    "id":"277b5c8f864f36802e3bf5a4fdb43007f4b02f4575e48575970786bce9af05ee",
    "db_id":"wta_1",
    "question":"find the number of players for each country.",
    "query":"SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT country_code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY country_code ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players  GROUP BY country_code"
  },
  {
    "id":"e14b091525b0605611e8ca7329ecc05141580545c11b68d81e0d40d9b9eed55f",
    "db_id":"wta_1",
    "question":"How many players are from each country?",
    "query":"SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT country_code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY country_code ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , country_code FROM wta_1.players  GROUP BY country_code"
  },
  {
    "id":"01647ae7e0cf6d752409dfd6fdd41d79bc9a878d51fe2a086123887c87b38554",
    "db_id":"wta_1",
    "question":"find the code of the country where has the greatest number of players.",
    "query":"SELECT TOP 1 country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT country_code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY country_code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, country_code FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 country_code FROM wta_1.players  GROUP BY country_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"bf536a5accf17fc5f50fe4a88831ffb0eddf2c053cfd010f4e496faec5a26fbc",
    "db_id":"wta_1",
    "question":"What is the code of the country with the most players?",
    "query":"SELECT TOP 1 country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT country_code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY country_code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, country_code FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 country_code FROM wta_1.players  GROUP BY country_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"425bff2bfebdbee3e9137540cf2239f10e3986898173aa49e7bbbba2d55064a9",
    "db_id":"wta_1",
    "question":"Find the codes of countries that have more than 50 players.",
    "query":"SELECT country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code HAVING count ( * ) > 50 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 50 ] Output [ country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 50 ] Output [ country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT country_code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY country_code ), Filter_3 AS ( SELECT country_code FROM Aggregate_2 WHERE Count_Star > 50 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT country_code FROM wta_1.players  GROUP BY country_code HAVING count ( * ) > 50"
  },
  {
    "id":"5322a644022dbc15036fe0c0099125fa375687c8e4eeb4917d45d70c1b33f836",
    "db_id":"wta_1",
    "question":"What are the codes of countries with more than 50 players?",
    "query":"SELECT country_code FROM wta_1.players WITH (FORCESCAN) GROUP BY country_code HAVING count ( * ) > 50 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 50 ] Output [ country_code ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ country_code ] ; #2 = Aggregate [ #1 ] GroupBy [ country_code ] Output [ country_code , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 50 ] Output [ country_code ]",
    "cte":"WITH Scan_1 AS ( SELECT country_code FROM wta_1.players ), Aggregate_2 AS ( SELECT country_code, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY country_code ), Filter_3 AS ( SELECT country_code FROM Aggregate_2 WHERE Count_Star > 50 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT country_code FROM wta_1.players  GROUP BY country_code HAVING count ( * ) > 50"
  },
  {
    "id":"4defbf0359c1037bfe89c5403c7cdb8c67b0f82ae96d81d003691e8e0500a564",
    "db_id":"wta_1",
    "question":"Find the total number of tours for each ranking date.",
    "query":"SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings WITH (FORCESCAN) GROUP BY ranking_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ rankings ] Output [ tours , ranking_date ] ; #2 = Aggregate [ #1 ] GroupBy [ ranking_date ] Output [ SUM(tours) AS Sum_tours , ranking_date ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ rankings ] Output [ tours , ranking_date ] ; #2 = Aggregate [ #1 ] GroupBy [ ranking_date ] Output [ SUM(tours) AS Sum_tours , ranking_date ]",
    "cte":"WITH Scan_1 AS ( SELECT tours, ranking_date FROM wta_1.rankings ), Aggregate_2 AS ( SELECT SUM(tours) AS Sum_tours, ranking_date FROM Scan_1 GROUP BY ranking_date ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings  GROUP BY ranking_date"
  },
  {
    "id":"1355c0cdad34ed6843f0c7be4c8311e7c04c5e47498de15c69206fb41203297b",
    "db_id":"wta_1",
    "question":"How many total tours were there for each ranking date?",
    "query":"SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings WITH (FORCESCAN) GROUP BY ranking_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ rankings ] Output [ tours , ranking_date ] ; #2 = Aggregate [ #1 ] GroupBy [ ranking_date ] Output [ SUM(tours) AS Sum_tours , ranking_date ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ rankings ] Output [ tours , ranking_date ] ; #2 = Aggregate [ #1 ] GroupBy [ ranking_date ] Output [ SUM(tours) AS Sum_tours , ranking_date ]",
    "cte":"WITH Scan_1 AS ( SELECT tours, ranking_date FROM wta_1.rankings ), Aggregate_2 AS ( SELECT SUM(tours) AS Sum_tours, ranking_date FROM Scan_1 GROUP BY ranking_date ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( tours ) AS Sum_tours , ranking_date FROM wta_1.rankings  GROUP BY ranking_date"
  },
  {
    "id":"620308662187c344a0e108bb40e62440d3db5e674d02984ac1edc18328782d6e",
    "db_id":"wta_1",
    "question":"Find the number of matches happened in each year.",
    "query":"SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY year ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches  GROUP BY YEAR"
  },
  {
    "id":"14d7ca6040f3fd88253dc36d52a5dc3f8c9fddca5527843daae9a68e3513cdfd",
    "db_id":"wta_1",
    "question":"How many matches were played in each year?",
    "query":"SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches WITH (FORCESCAN) GROUP BY YEAR OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ year ] ; #2 = Aggregate [ #1 ] GroupBy [ year ] Output [ year , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT year FROM wta_1.matches ), Aggregate_2 AS ( SELECT year, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY year ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , YEAR FROM wta_1.matches  GROUP BY YEAR"
  },
  {
    "id":"5f825d0ca7aab228d5c0ae6793b47a6d6044a166df89612088071c3bbdf4a22e",
    "db_id":"wta_1",
    "question":"Find the name and rank of the 3 youngest winners across all matches.",
    "query":"SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches WITH (FORCESCAN) ORDER BY winner_age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Distinct [ true ] Output [ winner_rank , winner_name , winner_age ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ winner_age ASC , winner_name ASC , winner_rank ASC ] Output [ winner_rank , winner_name , winner_age ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ winner_rank , winner_name , winner_age ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ winner_age ASC , winner_name ASC , winner_rank ASC ] Output [ winner_rank , winner_name , winner_age ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT winner_rank, winner_name, winner_age FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 3 winner_rank, winner_name, winner_age FROM Scan_1 ORDER BY winner_age ASC , winner_name ASC , winner_rank ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches  ORDER BY winner_age"
  },
  {
    "id":"1d475eb098ce0ad96f35972c2d26c617cfcc6e15efde805ae7ee5dbca0616181",
    "db_id":"wta_1",
    "question":"What are the names and ranks of the three youngest winners across all matches?",
    "query":"SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches WITH (FORCESCAN) ORDER BY winner_age OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Distinct [ true ] Output [ winner_rank , winner_name , winner_age ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ winner_age ASC , winner_name ASC , winner_rank ASC ] Output [ winner_rank , winner_name , winner_age ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Distinct [ true ] Output [ winner_rank , winner_name , winner_age ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ winner_age ASC , winner_name ASC , winner_rank ASC ] Output [ winner_rank , winner_name , winner_age ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT winner_rank, winner_name, winner_age FROM wta_1.matches ), TopSort_2 AS ( SELECT TOP 3 winner_rank, winner_name, winner_age FROM Scan_1 ORDER BY winner_age ASC , winner_name ASC , winner_rank ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT DISTINCT TOP 3 winner_age , winner_name , winner_rank FROM wta_1.matches  ORDER BY winner_age"
  },
  {
    "id":"1b4a7a6a4a6edbd99f288bea34b33440647837c357c6aaea4af04799805c576e",
    "db_id":"wta_1",
    "question":"How many different winners both participated in the WTA Championships and were left handed?",
    "query":"SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' AND winner_hand = 'L' ] Distinct [ true ] Output [ winner_hand , tourney_name , winner_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT winner_name) AS Count_Dist_winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' AND winner_hand = 'L' ] Distinct [ true ] Output [ winner_hand , tourney_name , winner_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT winner_name) AS Count_Dist_winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT winner_hand, tourney_name, winner_name FROM wta_1.matches WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' ), Aggregate_2 AS ( SELECT COUNT(DISTINCT winner_name) AS Count_Dist_winner_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches  WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L'"
  },
  {
    "id":"08b917ef83c5cde81cdece7e98cfef78e82f1bd17c0dc8b77e8759f9fa88485a",
    "db_id":"wta_1",
    "question":"Find the number of left handed winners who participated in the WTA Championships.",
    "query":"SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches WITH (FORCESCAN) WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' AND winner_hand = 'L' ] Distinct [ true ] Output [ winner_hand , tourney_name , winner_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT winner_name) AS Count_Dist_winner_name ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Predicate [ tourney_name = 'WTA Championships' AND winner_hand = 'L' ] Distinct [ true ] Output [ winner_hand , tourney_name , winner_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT winner_name) AS Count_Dist_winner_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT winner_hand, tourney_name, winner_name FROM wta_1.matches WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L' ), Aggregate_2 AS ( SELECT COUNT(DISTINCT winner_name) AS Count_Dist_winner_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT winner_name ) AS Count_Dist_winner_name FROM wta_1.matches  WHERE tourney_name = 'WTA Championships' AND winner_hand = 'L'"
  },
  {
    "id":"867cde5170a26741ae4655d22fca0ab3bb8617a3498fc46fe257463dea794d20",
    "db_id":"wta_1",
    "question":"Find the first name, country code and birth date of the winner who has the highest rank points in all matches.",
    "query":"SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Output [ winner_id , winner_rank_points ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , birth_date , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Output [ #2.birth_date , #2.first_name , #2.country_code , #1.winner_rank_points ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ first_name , country_code , birth_date , winner_rank_points ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ winner_id , winner_rank_points ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , birth_date , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Output [ #2.birth_date , #2.first_name , #2.country_code , #1.winner_rank_points ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ first_name , country_code , birth_date , winner_rank_points ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_id, winner_rank_points FROM wta_1.matches ), Scan_2 AS ( SELECT first_name, country_code, birth_date, player_id FROM wta_1.players ), Join_3 AS ( SELECT Scan_2.birth_date, Scan_2.first_name, Scan_2.country_code, Scan_1.winner_rank_points FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 first_name, country_code, birth_date, winner_rank_points FROM Join_3 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC"
  },
  {
    "id":"1a6d7284f609f767a7d2bbc05f7e125020d7b13ecf4c7f2f2de8e63338e8f6fe",
    "db_id":"wta_1",
    "question":"What is the first name, country code, and birth date of the player with the most winner rank points across all matches?",
    "query":"SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1 WITH (FORCESCAN) JOIN wta_1.matches AS T2 WITH (FORCESCAN) ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ matches ] Output [ winner_id , winner_rank_points ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , birth_date , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Output [ #2.birth_date , #2.first_name , #2.country_code , #1.winner_rank_points ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ first_name , country_code , birth_date , winner_rank_points ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ matches ] Output [ winner_id , winner_rank_points ] ; #2 = Scan Table [ players ] Output [ first_name , country_code , birth_date , player_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.winner_id = #2.player_id ] Output [ #2.birth_date , #2.first_name , #2.country_code , #1.winner_rank_points ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ winner_rank_points DESC ] Output [ first_name , country_code , birth_date , winner_rank_points ]",
    "cte":"WITH Scan_1 AS ( SELECT winner_id, winner_rank_points FROM wta_1.matches ), Scan_2 AS ( SELECT first_name, country_code, birth_date, player_id FROM wta_1.players ), Join_3 AS ( SELECT Scan_2.birth_date, Scan_2.first_name, Scan_2.country_code, Scan_1.winner_rank_points FROM Scan_1 JOIN Scan_2 ON Scan_1.winner_id = Scan_2.player_id ), TopSort_4 AS ( SELECT TOP 1 first_name, country_code, birth_date, winner_rank_points FROM Join_3 ORDER BY winner_rank_points DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.first_name , T1.country_code , T1.birth_date FROM wta_1.players AS T1  JOIN wta_1.matches AS T2  ON T1.player_id = T2.winner_id ORDER BY T2.winner_rank_points DESC"
  },
  {
    "id":"e5bb7493553ebb3687bf1cdb55d5edfc06663219cc39e255956981437ab3d826",
    "db_id":"wta_1",
    "question":"Find the number of players for each hand type.",
    "query":"SELECT count ( * ) AS Count_Star , hand FROM wta_1.players WITH (FORCESCAN) GROUP BY hand OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ hand ] ; #2 = Aggregate [ #1 ] GroupBy [ hand ] Output [ hand , countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ hand ] ; #2 = Aggregate [ #1 ] GroupBy [ hand ] Output [ hand , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT hand FROM wta_1.players ), Aggregate_2 AS ( SELECT hand, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY hand ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , hand FROM wta_1.players  GROUP BY hand"
  },
  {
    "id":"fcffebd3ff6c929d806e7b4ea91b3ad91aa2d65799cc8b9af47caed7c6fb1f68",
    "db_id":"wta_1",
    "question":"How many players are there for each hand type?",
    "query":"SELECT count ( * ) AS Count_Star , hand FROM wta_1.players WITH (FORCESCAN) GROUP BY hand OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ players ] Output [ hand ] ; #2 = Aggregate [ #1 ] GroupBy [ hand ] Output [ hand , countstar AS Count_Star ]",
    "prefixed_qpl":"wta_1 | #1 = Scan Table [ players ] Output [ hand ] ; #2 = Aggregate [ #1 ] GroupBy [ hand ] Output [ hand , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT hand FROM wta_1.players ), Aggregate_2 AS ( SELECT hand, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY hand ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , hand FROM wta_1.players  GROUP BY hand"
  },
  {
    "id":"65eeff6ba62debfd324c1369719ec178496b3f06a7b1df6fc9760d2bd4d00bc0",
    "db_id":"battle_death",
    "question":"How many ships ended up being 'Captured'?",
    "query":"SELECT count ( * ) AS Count_Star FROM battle_death.ship WITH (FORCESCAN) WHERE disposition_of_ship = 'Captured' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ ship ] Predicate [ disposition_of_ship = 'Captured' ] Output [ disposition_of_ship ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ ship ] Predicate [ disposition_of_ship = 'Captured' ] Output [ disposition_of_ship ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT disposition_of_ship FROM battle_death.ship WHERE disposition_of_ship = 'Captured' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM battle_death.ship  WHERE disposition_of_ship = 'Captured'"
  },
  {
    "id":"2ccd32ac0d180b828be858b0bf0735ce6f91ee1507751a8ac74b2614fb9dda0e",
    "db_id":"battle_death",
    "question":"List the name and tonnage ordered by in descending alphaetical order for the names.",
    "query":"SELECT name , tonnage FROM battle_death.ship WITH (FORCESCAN) ORDER BY name DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ ship ] Output [ tonnage , name ] ; #2 = Sort [ #1 ] OrderBy [ name DESC ] Output [ tonnage , name ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ ship ] Output [ tonnage , name ] ; #2 = Sort [ #1 ] OrderBy [ name DESC ] Output [ tonnage , name ]",
    "cte":"WITH Scan_1 AS ( SELECT tonnage, name FROM battle_death.ship ) SELECT tonnage, name FROM Scan_1 ORDER BY name DESC",
    "clean_query":"SELECT name , tonnage FROM battle_death.ship  ORDER BY name DESC"
  },
  {
    "id":"3356268778a1d181ee966ca9d917f094aa438755a17a6c70463309f229a4dcff",
    "db_id":"battle_death",
    "question":"List the name, date and result of each battle.",
    "query":"SELECT name , date FROM battle_death.battle WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ battle ] Output [ name , date ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Output [ name , date ]",
    "cte":"WITH Scan_1 AS ( SELECT name, date FROM battle_death.battle ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , date FROM battle_death.battle"
  },
  {
    "id":"efc3d6b583061fdac5b1192e6644f9c76d5ae824ba2e041fabcadee05b13cb63",
    "db_id":"battle_death",
    "question":"What is maximum and minimum death toll caused each time?",
    "query":"SELECT max ( killed ) AS Max_killed , min ( killed ) AS Min_killed FROM battle_death.death WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ death ] Output [ killed ] ; #2 = Aggregate [ #1 ] Output [ MAX(killed) AS Max_killed , MIN(killed) AS Min_killed ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ death ] Output [ killed ] ; #2 = Aggregate [ #1 ] Output [ MAX(killed) AS Max_killed , MIN(killed) AS Min_killed ]",
    "cte":"WITH Scan_1 AS ( SELECT killed FROM battle_death.death ), Aggregate_2 AS ( SELECT MAX(killed) AS Max_killed, MIN(killed) AS Min_killed FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( killed ) AS Max_killed , min ( killed ) AS Min_killed FROM battle_death.death"
  },
  {
    "id":"0ee950e67cdbf2bef9cf54225445cebf182b136e6592005c3991f6b2a08a2d9e",
    "db_id":"battle_death",
    "question":"What is the average number of injuries caused each time?",
    "query":"SELECT avg ( injured ) AS Avg_injured FROM battle_death.death WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ death ] Output [ injured ] ; #2 = Aggregate [ #1 ] Output [ AVG(injured) AS Avg_injured ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ death ] Output [ injured ] ; #2 = Aggregate [ #1 ] Output [ AVG(injured) AS Avg_injured ]",
    "cte":"WITH Scan_1 AS ( SELECT injured FROM battle_death.death ), Aggregate_2 AS ( SELECT AVG(injured) AS Avg_injured FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( injured ) AS Avg_injured FROM battle_death.death"
  },
  {
    "id":"b1386d93c89b01508f84c2462d3dcc0f4f8ecec266f8b78d947bbe90436733a8",
    "db_id":"battle_death",
    "question":"What are the death and injury situations caused by the ship with tonnage 't'?",
    "query":"SELECT T1.killed , T1.injured FROM battle_death.death AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS t2 WITH (FORCESCAN) ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ ship ] Predicate [ tonnage = 't' ] Output [ tonnage , id ] ; #2 = Scan Table [ death ] Output [ injured , caused_by_ship_id , killed ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.caused_by_ship_id ] Output [ #2.injured , #2.killed ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ ship ] Predicate [ tonnage = 't' ] Output [ tonnage , id ] ; #2 = Scan Table [ death ] Output [ injured , caused_by_ship_id , killed ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.caused_by_ship_id ] Output [ #2.injured , #2.killed ]",
    "cte":"WITH Scan_1 AS ( SELECT tonnage, id FROM battle_death.ship WHERE tonnage = 't' ), Scan_2 AS ( SELECT injured, caused_by_ship_id, killed FROM battle_death.death ), Join_3 AS ( SELECT Scan_2.injured, Scan_2.killed FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.caused_by_ship_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.killed , T1.injured FROM battle_death.death AS T1  JOIN battle_death.ship AS t2  ON T1.caused_by_ship_id = T2.id WHERE T2.tonnage = 't'"
  },
  {
    "id":"55ed9a583e8099eef15899b28809eab0db5d06e127a724e4cc65ad722df4beed",
    "db_id":"battle_death",
    "question":"What are the name and results of the battles when the bulgarian commander is not 'Boril'",
    "query":"SELECT name , RESULT FROM battle_death.battle WITH (FORCESCAN) WHERE bulgarian_commander ! = 'Boril' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ battle ] Predicate [ bulgarian_commander <> 'Boril' ] Output [ bulgarian_commander , name , result ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Predicate [ bulgarian_commander <> 'Boril' ] Output [ bulgarian_commander , name , result ]",
    "cte":"WITH Scan_1 AS ( SELECT bulgarian_commander, name, result FROM battle_death.battle WHERE bulgarian_commander <> 'Boril' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , RESULT FROM battle_death.battle  WHERE bulgarian_commander ! = 'Boril'"
  },
  {
    "id":"3f394f24a9ffba65e83de378069abbc3c6dc21d0e6858fd28bcaf8a4c44c069c",
    "db_id":"battle_death",
    "question":"What are the different ids and names of the battles that lost any 'Brig' type shipes?",
    "query":"SELECT DISTINCT T1.id , T1.name FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.ship_type = 'Brig' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ battle ] Output [ name , id ] ; #2 = Scan Table [ ship ] Predicate [ ship_type = 'Brig' ] Output [ lost_in_battle , ship_type ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.lost_in_battle = #1.id ] Output [ #1.name , #1.id ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Output [ name , id ] ; #2 = Scan Table [ ship ] Predicate [ ship_type = 'Brig' ] Output [ lost_in_battle , ship_type ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.lost_in_battle = #1.id ] Output [ #1.name , #1.id ]",
    "cte":"WITH Scan_1 AS ( SELECT name, id FROM battle_death.battle ), Scan_2 AS ( SELECT lost_in_battle, ship_type FROM battle_death.ship WHERE ship_type = 'Brig' ), Intersect_3 AS ( SELECT Scan_1.name, Scan_1.id FROM Scan_1 WHERE id IN (SELECT lost_in_battle FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT DISTINCT T1.id , T1.name FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.ship_type = 'Brig'"
  },
  {
    "id":"c08c23e7cc708242ee88a3d2b2b77fcc6eba87f51093769a204df2c410d443ae",
    "db_id":"battle_death",
    "question":"What are the ids and names of the battles that led to more than 10 people killed in total.",
    "query":"SELECT T1.id , T1.name FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle JOIN battle_death.death AS T3 WITH (FORCESCAN) ON T2.id = T3.caused_by_ship_id GROUP BY T1.id , T1.name HAVING sum ( T3.killed ) > 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ ship ] Output [ lost_in_battle , id ] ; #2 = Scan Table [ battle ] Output [ name , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.lost_in_battle = #2.id ] Output [ #1.id , #2.name ] ; #4 = Scan Table [ death ] Output [ caused_by_ship_id , killed ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.id = #4.caused_by_ship_id ] Output [ #3.id , #3.name , #4.killed ] ; #6 = Aggregate [ #5 ] GroupBy [ id ] Output [ SUM(killed) AS Sum_killed , name , id ] ; #7 = Filter [ #6 ] Predicate [ Sum_killed > 10 ] Output [ name , id ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ ship ] Output [ lost_in_battle , id ] ; #2 = Scan Table [ battle ] Output [ name , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.lost_in_battle = #2.id ] Output [ #1.id , #2.name ] ; #4 = Scan Table [ death ] Output [ caused_by_ship_id , killed ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.id = #4.caused_by_ship_id ] Output [ #3.id , #3.name , #4.killed ] ; #6 = Aggregate [ #5 ] GroupBy [ id ] Output [ SUM(killed) AS Sum_killed , name , id ] ; #7 = Filter [ #6 ] Predicate [ Sum_killed > 10 ] Output [ name , id ]",
    "cte":"WITH Scan_1 AS ( SELECT lost_in_battle, id FROM battle_death.ship ), Scan_2 AS ( SELECT name, id FROM battle_death.battle ), Join_3 AS ( SELECT Scan_2.id, Scan_2.name, Scan_1.id as ship_id FROM Scan_1 JOIN Scan_2 ON Scan_1.lost_in_battle = Scan_2.id ), Scan_4 AS ( SELECT caused_by_ship_id, killed FROM battle_death.death ), Join_5 AS ( SELECT Join_3.id, Join_3.name, Scan_4.killed FROM Join_3 JOIN Scan_4 ON Join_3.ship_id = Scan_4.caused_by_ship_id ), Aggregate_6 AS ( SELECT SUM(killed) AS Sum_killed, name, id FROM Join_5 GROUP BY name, id ), Filter_7 AS ( SELECT name, id FROM Aggregate_6 WHERE Sum_killed > 10 ) SELECT * FROM Filter_7",
    "clean_query":"SELECT T1.id , T1.name FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle JOIN battle_death.death AS T3  ON T2.id = T3.caused_by_ship_id GROUP BY T1.id , T1.name HAVING sum ( T3.killed ) > 10"
  },
  {
    "id":"1d303a4c9be0e889f0579981273206eb3953935055b14be901616cc6fc92ba5f",
    "db_id":"battle_death",
    "question":"What is the ship id and name that caused most total injuries?",
    "query":"SELECT TOP 1 T2.id , T2.name FROM battle_death.death AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS t2 WITH (FORCESCAN) ON T1.caused_by_ship_id = T2.id GROUP BY T2.id , T2.name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ death ] Output [ caused_by_ship_id ] ; #2 = Aggregate [ #1 ] GroupBy [ caused_by_ship_id ] Output [ caused_by_ship_id , countstar AS Count_Star ] ; #3 = Scan Table [ ship ] Output [ name , id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.caused_by_ship_id = #3.id ] Output [ #3.name , #2.Count_Star , #3.id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name , id ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ death ] Output [ caused_by_ship_id ] ; #2 = Aggregate [ #1 ] GroupBy [ caused_by_ship_id ] Output [ caused_by_ship_id , countstar AS Count_Star ] ; #3 = Scan Table [ ship ] Output [ name , id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.caused_by_ship_id = #3.id ] Output [ #3.name , #2.Count_Star , #3.id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name , id ]",
    "cte":"WITH Scan_1 AS ( SELECT caused_by_ship_id FROM battle_death.death ), Aggregate_2 AS ( SELECT caused_by_ship_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY caused_by_ship_id ), Scan_3 AS ( SELECT name, id FROM battle_death.ship ), Join_4 AS ( SELECT Scan_3.name, Aggregate_2.Count_Star, Scan_3.id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.caused_by_ship_id = Scan_3.id ), TopSort_5 AS ( SELECT TOP 1 Count_Star, name, id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.id , T2.name FROM battle_death.death AS T1  JOIN battle_death.ship AS t2  ON T1.caused_by_ship_id = T2.id GROUP BY T2.id , T2.name ORDER BY count ( * ) DESC"
  },
  {
    "id":"03a299a92f3839f2c0bb5e82bfe834b731538003186dcd06f7dea307ba81cee7",
    "db_id":"battle_death",
    "question":"What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?",
    "query":"SELECT name FROM battle_death.battle WITH (FORCESCAN) WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ battle ] Predicate [ bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' ] Output [ bulgarian_commander , name , latin_commander ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Predicate [ bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' ] Output [ bulgarian_commander , name , latin_commander ]",
    "cte":"WITH Scan_1 AS ( SELECT bulgarian_commander, name, latin_commander FROM battle_death.battle WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name FROM battle_death.battle  WHERE bulgarian_commander = 'Kaloyan' AND latin_commander = 'Baldwin I'"
  },
  {
    "id":"fe556df1566300f7d867bf85a0acea81c1ec223b682d1513e1b388040c727efe",
    "db_id":"battle_death",
    "question":"How many different results are there for the battles?",
    "query":"SELECT count ( DISTINCT RESULT ) AS Count_Dist_RESULT FROM battle_death.battle WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ battle ] Distinct [ true ] Output [ result ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT result) AS Count_Dist_result ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Distinct [ true ] Output [ result ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT result) AS Count_Dist_result ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT result FROM battle_death.battle ), Aggregate_2 AS ( SELECT COUNT(DISTINCT result) AS Count_Dist_result FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT RESULT ) AS Count_Dist_RESULT FROM battle_death.battle"
  },
  {
    "id":"efc2abfda824f8537f7433476f8c634f1afe5c44f1e47895e62966073e995993",
    "db_id":"battle_death",
    "question":"How many battles did not lose any ship with tonnage '225'?",
    "query":"SELECT count ( * ) AS Count_Star FROM battle_death.battle WITH (FORCESCAN) WHERE id NOT IN ( SELECT lost_in_battle FROM battle_death.ship WITH (FORCESCAN) WHERE tonnage = '225' )  ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ battle ] Output [ id ] ; #2 = Scan Table [ ship ] Predicate [ tonnage = '225' ] Output [ tonnage , lost_in_battle ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.lost_in_battle IS NULL OR #1.id = #2.lost_in_battle ] Output [ #1.id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Output [ id ] ; #2 = Scan Table [ ship ] Predicate [ tonnage = '225' ] Output [ tonnage , lost_in_battle ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.lost_in_battle IS NULL OR #1.id = #2.lost_in_battle ] Output [ #1.id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT id FROM battle_death.battle ), Scan_2 AS ( SELECT tonnage, lost_in_battle FROM battle_death.ship WHERE tonnage = '225' ), Except_3 AS ( SELECT Scan_1.id FROM Scan_1 WHERE id NOT IN (SELECT lost_in_battle FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM battle_death.battle  WHERE id NOT IN ( SELECT lost_in_battle FROM battle_death.ship  WHERE tonnage = '225' )"
  },
  {
    "id":"bd21f664a846bc1fe7d88e638adb44527375b28722a48eb0c8675360b6696489",
    "db_id":"battle_death",
    "question":"List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta'",
    "query":"SELECT T1.name , T1.date FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.name = 'Lettice' INTERSECT SELECT T1.name , T1.date FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.name = 'HMS Atalanta' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ ship ] Predicate [ name = 'Lettice' ] Output [ name , lost_in_battle ] ; #2 = Scan Table [ battle ] Output [ name , id , date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.lost_in_battle = #2.id ] Distinct [ true ] Output [ #2.name , #2.date ] ; #4 = Scan Table [ ship ] Predicate [ name = 'HMS Atalanta' ] Output [ name , lost_in_battle ] ; #5 = Scan Table [ battle ] Output [ name , id , date ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.lost_in_battle = #5.id ] Output [ #5.date , #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name , #3.date ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ ship ] Predicate [ name = 'Lettice' ] Output [ name , lost_in_battle ] ; #2 = Scan Table [ battle ] Output [ name , id , date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.lost_in_battle = #2.id ] Distinct [ true ] Output [ #2.name , #2.date ] ; #4 = Scan Table [ ship ] Predicate [ name = 'HMS Atalanta' ] Output [ name , lost_in_battle ] ; #5 = Scan Table [ battle ] Output [ name , id , date ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.lost_in_battle = #5.id ] Output [ #5.date , #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name , #3.date ]",
    "cte":"WITH Scan_1 AS ( SELECT name, lost_in_battle FROM battle_death.ship WHERE name = 'Lettice' ), Scan_2 AS ( SELECT name, id, date FROM battle_death.battle ), Join_3 AS ( SELECT DISTINCT Scan_2.name, Scan_2.date FROM Scan_1 JOIN Scan_2 ON Scan_1.lost_in_battle = Scan_2.id ), Scan_4 AS ( SELECT name, lost_in_battle FROM battle_death.ship WHERE name = 'HMS Atalanta' ), Scan_5 AS ( SELECT name, id, date FROM battle_death.battle ), Join_6 AS ( SELECT Scan_5.date, Scan_5.name FROM Scan_4 JOIN Scan_5 ON Scan_4.lost_in_battle = Scan_5.id ), Intersect_7 AS ( SELECT Join_3.name, Join_3.date FROM Join_3 WHERE name IN (SELECT name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.name , T1.date FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.name = 'Lettice' INTERSECT SELECT T1.name , T1.date FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.name = 'HMS Atalanta'"
  },
  {
    "id":"2ff92e902d385f0d3c7c7ac8839232b8f21877f00a5e4efad288d1204c1383cd",
    "db_id":"battle_death",
    "question":"Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.",
    "query":"SELECT name , RESULT , bulgarian_commander FROM battle_death.battle WITH (FORCESCAN) EXCEPT SELECT T1.name , T1.result , T1.bulgarian_commander FROM battle_death.battle AS T1 WITH (FORCESCAN) JOIN battle_death.ship AS T2 WITH (FORCESCAN) ON T1.id = T2.lost_in_battle WHERE T2.location = 'English Channel' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ battle ] Distinct [ true ] Output [ bulgarian_commander , name , result ] ; #2 = Scan Table [ ship ] Predicate [ location = 'English Channel' ] Output [ location , lost_in_battle ] ; #3 = Scan Table [ battle ] Output [ bulgarian_commander , name , id , result ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.lost_in_battle = #3.id ] Output [ #3.name , #3.result , #3.bulgarian_commander ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name , #1.result , #1.bulgarian_commander ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ battle ] Distinct [ true ] Output [ bulgarian_commander , name , result ] ; #2 = Scan Table [ ship ] Predicate [ location = 'English Channel' ] Output [ location , lost_in_battle ] ; #3 = Scan Table [ battle ] Output [ bulgarian_commander , name , id , result ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.lost_in_battle = #3.id ] Output [ #3.name , #3.result , #3.bulgarian_commander ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name , #1.result , #1.bulgarian_commander ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT bulgarian_commander, name, result FROM battle_death.battle ), Scan_2 AS ( SELECT location, lost_in_battle FROM battle_death.ship WHERE location = 'English Channel' ), Scan_3 AS ( SELECT bulgarian_commander, name, id, result FROM battle_death.battle ), Join_4 AS ( SELECT Scan_3.name, Scan_3.result, Scan_3.bulgarian_commander FROM Scan_2 JOIN Scan_3 ON Scan_2.lost_in_battle = Scan_3.id ), Except_5 AS ( SELECT Scan_1.name, Scan_1.result, Scan_1.bulgarian_commander FROM Scan_1 WHERE name NOT IN (SELECT name FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT name , RESULT , bulgarian_commander FROM battle_death.battle  EXCEPT SELECT T1.name , T1.result , T1.bulgarian_commander FROM battle_death.battle AS T1  JOIN battle_death.ship AS T2  ON T1.id = T2.lost_in_battle WHERE T2.location = 'English Channel'"
  },
  {
    "id":"1b35f7d7b149e16fedff1f5ae56a8bb5a21a6a4e93ab8f12af0f265c757d44bd",
    "db_id":"battle_death",
    "question":"What are the notes of the death events which has substring 'East'?",
    "query":"SELECT note FROM battle_death.death WITH (FORCESCAN) WHERE note LIKE '%East%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ death ] Predicate [ note like '%East%' ] Output [ note ]",
    "prefixed_qpl":"battle_death | #1 = Scan Table [ death ] Predicate [ note like '%East%' ] Output [ note ]",
    "cte":"WITH Scan_1 AS ( SELECT note FROM battle_death.death WHERE note like '%East%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT note FROM battle_death.death  WHERE note LIKE '%East%'"
  },
  {
    "id":"2ac1015ed0642af90685a98b50fb7c5ab2fd9c6dc918f84b974bfc879d519cfe",
    "db_id":"student_transcripts_tracking",
    "question":"what are all the addresses including line 1 and line 2?",
    "query":"SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Addresses ] Output [ line_1 , line_2 ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ line_1 , line_2 ]",
    "cte":"WITH Scan_1 AS ( SELECT line_1, line_2 FROM student_transcripts_tracking.Addresses ) SELECT * FROM Scan_1",
    "clean_query":"SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses"
  },
  {
    "id":"db4fbaa64e0ce68cfcc60c590b0bb1bff812a2a61390293307fba0d9cf1d1be2",
    "db_id":"student_transcripts_tracking",
    "question":"What is the first and second line for all addresses?",
    "query":"SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Addresses ] Output [ line_1 , line_2 ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ line_1 , line_2 ]",
    "cte":"WITH Scan_1 AS ( SELECT line_1, line_2 FROM student_transcripts_tracking.Addresses ) SELECT * FROM Scan_1",
    "clean_query":"SELECT line_1 , line_2 FROM student_transcripts_tracking.addresses"
  },
  {
    "id":"c54e9172bd8c8469719531b90d2bcd9a3ae3a106a373164fcaa4f4b968821e42",
    "db_id":"student_transcripts_tracking",
    "question":"How many courses in total are listed?",
    "query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Courses ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Courses ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Courses ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses"
  },
  {
    "id":"b53627579d8711d98990593ed80847023e92dbca50b1ca0ac0b92653554ca0c9",
    "db_id":"student_transcripts_tracking",
    "question":"How many courses are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Courses ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Courses ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Courses ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Courses"
  },
  {
    "id":"c799c2d3a69ce74de70092294fcae7075d54975ef156b0e53763fecc34b61ff3",
    "db_id":"student_transcripts_tracking",
    "question":"How is the math course described?",
    "query":"SELECT course_description FROM student_transcripts_tracking.Courses WITH (FORCESCAN) WHERE course_name = 'math' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Courses ] Predicate [ course_name = 'math' ] Output [ course_description , course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Courses ] Predicate [ course_name = 'math' ] Output [ course_description , course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_description, course_name FROM student_transcripts_tracking.Courses WHERE course_name = 'math' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT course_description FROM student_transcripts_tracking.Courses  WHERE course_name = 'math'"
  },
  {
    "id":"e5bc7ae30bf83fb8eed96dab217d730ef7479ca2974ab899b2c5de3a57b5d83f",
    "db_id":"student_transcripts_tracking",
    "question":"What are the descriptions for all the math courses?",
    "query":"SELECT course_description FROM student_transcripts_tracking.Courses WITH (FORCESCAN) WHERE course_name = 'math' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Courses ] Predicate [ course_name = 'math' ] Output [ course_description , course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Courses ] Predicate [ course_name = 'math' ] Output [ course_description , course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_description, course_name FROM student_transcripts_tracking.Courses WHERE course_name = 'math' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT course_description FROM student_transcripts_tracking.Courses  WHERE course_name = 'math'"
  },
  {
    "id":"a96906121bf8107ed5d7287ea51641686047ef0e777391884145b07db87baad4",
    "db_id":"student_transcripts_tracking",
    "question":"What is the zip code of the address in the city Port Chelsea?",
    "query":"SELECT zip_postcode FROM student_transcripts_tracking.Addresses WITH (FORCESCAN) WHERE city = 'Port Chelsea' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Addresses ] Predicate [ city = 'Port Chelsea' ] Output [ zip_postcode , city ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ city = 'Port Chelsea' ] Output [ zip_postcode , city ]",
    "cte":"WITH Scan_1 AS ( SELECT zip_postcode, city FROM student_transcripts_tracking.Addresses WHERE city = 'Port Chelsea' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT zip_postcode FROM student_transcripts_tracking.Addresses  WHERE city = 'Port Chelsea'"
  },
  {
    "id":"99902bf465647b9de71fa5b3a255675bf1cf550f6095bced50a1103e60932e10",
    "db_id":"student_transcripts_tracking",
    "question":"What is the zip code for Port Chelsea?",
    "query":"SELECT zip_postcode FROM student_transcripts_tracking.Addresses WITH (FORCESCAN) WHERE city = 'Port Chelsea' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Addresses ] Predicate [ city = 'Port Chelsea' ] Output [ zip_postcode , city ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ city = 'Port Chelsea' ] Output [ zip_postcode , city ]",
    "cte":"WITH Scan_1 AS ( SELECT zip_postcode, city FROM student_transcripts_tracking.Addresses WHERE city = 'Port Chelsea' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT zip_postcode FROM student_transcripts_tracking.Addresses  WHERE city = 'Port Chelsea'"
  },
  {
    "id":"594047a3f87d0aa4e97ebf98f5d3e84a42a74422b787725d5ca6a6f0d75c94fb",
    "db_id":"student_transcripts_tracking",
    "question":"Which department offers the most number of degrees? List department name and id.",
    "query":"SELECT TOP 1 T2.department_name , T1.department_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Departments AS T2 WITH (FORCESCAN) ON T1.department_id = T2.department_id GROUP BY T2.department_name , T1.department_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #2 = Aggregate [ #1 ] GroupBy [ department_id ] Output [ department_id , countstar AS Count_Star ] ; #3 = Scan Table [ Departments ] Output [ department_name , department_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.department_id = #3.department_id ] Output [ #2.Count_Star , #2.department_id , #3.department_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ department_name , Count_Star , department_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #2 = Aggregate [ #1 ] GroupBy [ department_id ] Output [ department_id , countstar AS Count_Star ] ; #3 = Scan Table [ Departments ] Output [ department_name , department_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.department_id = #3.department_id ] Output [ #2.Count_Star , #2.department_id , #3.department_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ department_name , Count_Star , department_id ]",
    "cte":"WITH Scan_1 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT department_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY department_id ), Scan_3 AS ( SELECT department_name, department_id FROM student_transcripts_tracking.Departments ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.department_id, Scan_3.department_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.department_id = Scan_3.department_id ), TopSort_5 AS ( SELECT TOP 1 department_name, Count_Star, department_id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.department_name , T1.department_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Departments AS T2  ON T1.department_id = T2.department_id GROUP BY T2.department_name , T1.department_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"b81b808b3e493817e0147dc7b225dd4243187c2fcb355ad2bced48ea5131cc90",
    "db_id":"student_transcripts_tracking",
    "question":"What is the name and id of the department with the most number of degrees ?",
    "query":"select TOP 1 t2.department_name , t1.department_id FROM student_transcripts_tracking.degree_programs AS t1 WITH (FORCESCAN) join student_transcripts_tracking.departments as t2 WITH (FORCESCAN) on t1.department_id = t2.department_id group by t2.department_name , t1.department_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #2 = Aggregate [ #1 ] GroupBy [ department_id ] Output [ department_id , countstar AS Count_Star ] ; #3 = Scan Table [ Departments ] Output [ department_name , department_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.department_id = #3.department_id ] Output [ #2.Count_Star , #2.department_id , #3.department_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ department_name , Count_Star , department_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #2 = Aggregate [ #1 ] GroupBy [ department_id ] Output [ department_id , countstar AS Count_Star ] ; #3 = Scan Table [ Departments ] Output [ department_name , department_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.department_id = #3.department_id ] Output [ #2.Count_Star , #2.department_id , #3.department_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ department_name , Count_Star , department_id ]",
    "cte":"WITH Scan_1 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT department_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY department_id ), Scan_3 AS ( SELECT department_name, department_id FROM student_transcripts_tracking.Departments ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.department_id, Scan_3.department_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.department_id = Scan_3.department_id ), TopSort_5 AS ( SELECT TOP 1 department_name, Count_Star, department_id FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 t2.department_name , t1.department_id FROM student_transcripts_tracking.degree_programs AS t1  join student_transcripts_tracking.departments as t2  on t1.department_id = t2.department_id group by t2.department_name , t1.department_id order by count ( * ) desc"
  },
  {
    "id":"8dd28dfa3877846461c9ca5ff24f1cf529cd5aa35599c46a87fbe88ad5a40e83",
    "db_id":"student_transcripts_tracking",
    "question":"How many departments offer any degree?",
    "query":"SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ department_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ department_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs"
  },
  {
    "id":"6b818bfc5b7ecb4ae741d03d4ff61323fd33d7453db6ca50c0b0a72664470020",
    "db_id":"student_transcripts_tracking",
    "question":"How many different departments offer degrees?",
    "query":"SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ department_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ department_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT department_id FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT department_id ) AS Count_Dist_department_id FROM student_transcripts_tracking.Degree_Programs"
  },
  {
    "id":"40bb6ce78af5916e027bb54942e97bb6cf361c0fd77103510be85af50772caa2",
    "db_id":"student_transcripts_tracking",
    "question":"How many different degree names are offered?",
    "query":"SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ degree_summary_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ degree_summary_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs"
  },
  {
    "id":"898c347eb5c12469a2246087c9e41c6d25d26c018c7d1456e41bcc557448867e",
    "db_id":"student_transcripts_tracking",
    "question":"How many different degrees are offered?",
    "query":"SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ degree_summary_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Distinct [ true ] Output [ degree_summary_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Aggregate_2 AS ( SELECT COUNT(DISTINCT degree_summary_name) AS Count_Dist_degree_summary_name FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT degree_summary_name ) AS Count_Dist_degree_summary_name FROM student_transcripts_tracking.Degree_Programs"
  },
  {
    "id":"e2a8016205c76a65594123511298f5a3b3c80cdcda2a34b2d5958b3b76357407",
    "db_id":"student_transcripts_tracking",
    "question":"How many degrees does the engineering department offer?",
    "query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Degree_Programs AS T2 WITH (FORCESCAN) ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Departments ] Predicate [ department_name = 'engineer' ] Output [ department_name , department_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.department_id = #2.department_id ] Output [ #1.department_name , #1.department_id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name = 'engineer' ] Output [ department_name , department_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.department_id = #2.department_id ] Output [ #1.department_name , #1.department_id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT department_name, department_id FROM student_transcripts_tracking.Departments WHERE department_name = 'engineer' ), Scan_2 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_1.department_name, Scan_1.department_id FROM Scan_1 JOIN Scan_2 ON Scan_1.department_id = Scan_2.department_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1  JOIN student_transcripts_tracking.Degree_Programs AS T2  ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer'"
  },
  {
    "id":"6c0f1803add8e16276df518874b943504f46798a505b30fcd496ca3f2a5ef9e3",
    "db_id":"student_transcripts_tracking",
    "question":"How many degrees does the engineering department have?",
    "query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Degree_Programs AS T2 WITH (FORCESCAN) ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Departments ] Predicate [ department_name = 'engineer' ] Output [ department_name , department_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.department_id = #2.department_id ] Output [ #1.department_name , #1.department_id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name = 'engineer' ] Output [ department_name , department_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ department_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.department_id = #2.department_id ] Output [ #1.department_name , #1.department_id ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT department_name, department_id FROM student_transcripts_tracking.Departments WHERE department_name = 'engineer' ), Scan_2 AS ( SELECT department_id FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_1.department_name, Scan_1.department_id FROM Scan_1 JOIN Scan_2 ON Scan_1.department_id = Scan_2.department_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Departments AS T1  JOIN student_transcripts_tracking.Degree_Programs AS T2  ON T1.department_id = T2.department_id WHERE T1.department_name = 'engineer'"
  },
  {
    "id":"9dfedf1ed380083968565ef5a9823ced768e51cfdfa1f398b7cfde5337d6a06d",
    "db_id":"student_transcripts_tracking",
    "question":"What are the names and descriptions of all the sections?",
    "query":"SELECT section_name , section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Sections ] Output [ section_description , section_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_description , section_name ]",
    "cte":"WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections ) SELECT * FROM Scan_1",
    "clean_query":"SELECT section_name , section_description FROM student_transcripts_tracking.Sections"
  },
  {
    "id":"4a4ef13b7b975976a31902cf7be1396d6d291bb928fecc469235c9d646f33b5d",
    "db_id":"student_transcripts_tracking",
    "question":"What are the names and descriptions for all the sections?",
    "query":"SELECT section_name , section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Sections ] Output [ section_description , section_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_description , section_name ]",
    "cte":"WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections ) SELECT * FROM Scan_1",
    "clean_query":"SELECT section_name , section_description FROM student_transcripts_tracking.Sections"
  },
  {
    "id":"57a37b0501428222f4c8034672ee226bc3ec6d001972e5e1b7a7218189e3276c",
    "db_id":"student_transcripts_tracking",
    "question":"What are the names and id of courses having at most 2 sections?",
    "query":"SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Sections AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Sections ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name , #2.course_id ] ; #4 = Aggregate [ #3 ] GroupBy [ course_id ] Output [ course_id , course_name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star <= 2 ] Output [ course_id , course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name , #2.course_id ] ; #4 = Aggregate [ #3 ] GroupBy [ course_id ] Output [ course_id , course_name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star <= 2 ] Output [ course_id , course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Sections ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name, Scan_2.course_id FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT course_id, course_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY course_name, course_id ), Filter_5 AS ( SELECT course_id, course_name FROM Aggregate_4 WHERE Count_Star <= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Sections AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2"
  },
  {
    "id":"3941c44dd86826e64780268e4986fd9beabdcb24cc002665fe4249303f2d9fd1",
    "db_id":"student_transcripts_tracking",
    "question":"What are the names and ids of every course with less than 2 sections?",
    "query":"SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Sections AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Sections ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name , #2.course_id ] ; #4 = Aggregate [ #3 ] GroupBy [ course_id ] Output [ course_id , course_name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star <= 2 ] Output [ course_id , course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name , #2.course_id ] ; #4 = Aggregate [ #3 ] GroupBy [ course_id ] Output [ course_id , course_name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star <= 2 ] Output [ course_id , course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Sections ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name, Scan_2.course_id FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT course_id, course_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY course_name, course_id ), Filter_5 AS ( SELECT course_id, course_name FROM Aggregate_4 WHERE Count_Star <= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.course_name , T1.course_id FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Sections AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name , T1.course_id HAVING count ( * ) < = 2"
  },
  {
    "id":"0d4d196cc026090096873dca60f9f9112235e305878c0d7bab7b6fd404e4a148",
    "db_id":"student_transcripts_tracking",
    "question":"List the section_name in reversed lexicographical order.",
    "query":"SELECT section_name FROM student_transcripts_tracking.Sections WITH (FORCESCAN) ORDER BY section_name DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Sections ] Output [ section_name ] ; #2 = Sort [ #1 ] OrderBy [ section_name DESC ] Output [ section_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_name ] ; #2 = Sort [ #1 ] OrderBy [ section_name DESC ] Output [ section_name ]",
    "cte":"WITH Scan_1 AS ( SELECT section_name FROM student_transcripts_tracking.Sections ) SELECT section_name FROM Scan_1 ORDER BY section_name DESC",
    "clean_query":"SELECT section_name FROM student_transcripts_tracking.Sections  ORDER BY section_name DESC"
  },
  {
    "id":"84e29240b001575ac46e8f3eebcf206cf49d7fc7fb2a26cca0199b1123c01bdd",
    "db_id":"student_transcripts_tracking",
    "question":"What are the names of the sections in reverse alphabetical order?",
    "query":"SELECT section_name FROM student_transcripts_tracking.Sections WITH (FORCESCAN) ORDER BY section_name DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Sections ] Output [ section_name ] ; #2 = Sort [ #1 ] OrderBy [ section_name DESC ] Output [ section_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Output [ section_name ] ; #2 = Sort [ #1 ] OrderBy [ section_name DESC ] Output [ section_name ]",
    "cte":"WITH Scan_1 AS ( SELECT section_name FROM student_transcripts_tracking.Sections ) SELECT section_name FROM Scan_1 ORDER BY section_name DESC",
    "clean_query":"SELECT section_name FROM student_transcripts_tracking.Sections  ORDER BY section_name DESC"
  },
  {
    "id":"4ee8e06d6ea0494afddda0a73ba51a5f3c93bfded92d39d8fef5436b57c0689b",
    "db_id":"student_transcripts_tracking",
    "question":"What is the semester which most student registered in? Show both the name and the id.",
    "query":"SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #2 = Aggregate [ #1 ] GroupBy [ semester_id ] Output [ semester_id , countstar AS Count_Star ] ; #3 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.semester_id = #3.semester_id ] Output [ #3.semester_name , #2.Count_Star , #3.semester_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ semester_id , Count_Star , semester_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #2 = Aggregate [ #1 ] GroupBy [ semester_id ] Output [ semester_id , countstar AS Count_Star ] ; #3 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.semester_id = #3.semester_id ] Output [ #3.semester_name , #2.Count_Star , #3.semester_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ semester_id , Count_Star , semester_name ]",
    "cte":"WITH Scan_1 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT semester_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY semester_id ), Scan_3 AS ( SELECT semester_id, semester_name FROM student_transcripts_tracking.Semesters ), Join_4 AS ( SELECT Scan_3.semester_name, Aggregate_2.Count_Star, Scan_3.semester_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.semester_id = Scan_3.semester_id ), TopSort_5 AS ( SELECT TOP 1 semester_id, Count_Star, semester_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"fd3ab86c1726ff82dfae3f950d230250d8b8d89f8ebb0146cad28b2fb7ba5ecb",
    "db_id":"student_transcripts_tracking",
    "question":"For each semester, what is the name and id of the one with the most students registered?",
    "query":"SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #2 = Aggregate [ #1 ] GroupBy [ semester_id ] Output [ semester_id , countstar AS Count_Star ] ; #3 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.semester_id = #3.semester_id ] Output [ #3.semester_name , #2.Count_Star , #3.semester_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ semester_id , Count_Star , semester_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #2 = Aggregate [ #1 ] GroupBy [ semester_id ] Output [ semester_id , countstar AS Count_Star ] ; #3 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.semester_id = #3.semester_id ] Output [ #3.semester_name , #2.Count_Star , #3.semester_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ semester_id , Count_Star , semester_name ]",
    "cte":"WITH Scan_1 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT semester_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY semester_id ), Scan_3 AS ( SELECT semester_id, semester_name FROM student_transcripts_tracking.Semesters ), Join_4 AS ( SELECT Scan_3.semester_name, Aggregate_2.Count_Star, Scan_3.semester_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.semester_id = Scan_3.semester_id ), TopSort_5 AS ( SELECT TOP 1 semester_id, Count_Star, semester_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.semester_name , T1.semester_id FROM student_transcripts_tracking.Semesters AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.semester_id = T2.semester_id GROUP BY T1.semester_name , T1.semester_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"e213cd4fec20daef85edf43f959e494d49e9cfc209bf8d906ddc0e163d0b7736",
    "db_id":"student_transcripts_tracking",
    "question":"What is the description of the department whose name has the substring the computer?",
    "query":"SELECT department_description FROM student_transcripts_tracking.Departments WITH (FORCESCAN) WHERE department_name LIKE '%computer%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Departments ] Predicate [ department_name like '%computer%' ] Output [ department_name , department_description ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name like '%computer%' ] Output [ department_name , department_description ]",
    "cte":"WITH Scan_1 AS ( SELECT department_name, department_description FROM student_transcripts_tracking.Departments WHERE department_name like '%computer%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT department_description FROM student_transcripts_tracking.Departments  WHERE department_name LIKE '%computer%'"
  },
  {
    "id":"edd55d4ed905a820d6ca16947655a80dec3a03568e863d01d3c67c42ddaac344",
    "db_id":"student_transcripts_tracking",
    "question":"What is the department description for the one whose name has the word computer?",
    "query":"SELECT department_description FROM student_transcripts_tracking.Departments WITH (FORCESCAN) WHERE department_name LIKE '%computer%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Departments ] Predicate [ department_name like '%computer%' ] Output [ department_name , department_description ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Departments ] Predicate [ department_name like '%computer%' ] Output [ department_name , department_description ]",
    "cte":"WITH Scan_1 AS ( SELECT department_name, department_description FROM student_transcripts_tracking.Departments WHERE department_name like '%computer%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT department_description FROM student_transcripts_tracking.Departments  WHERE department_name LIKE '%computer%'"
  },
  {
    "id":"728498cf775875068b9bab8aa842056887ff0d7f89672525110cc65529a4fbef",
    "db_id":"student_transcripts_tracking",
    "question":"Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.",
    "query":"SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 2 ] Output [ first_name , student_id , last_name , middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 2 ] Output [ first_name , student_id , last_name , middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT first_name, student_id, last_name, middle_name FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.middle_name, Scan_3.student_id, Aggregate_2.Count_Star, Scan_3.last_name, Scan_3.first_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), Filter_5 AS ( SELECT first_name, student_id, last_name, middle_name FROM Join_4 WHERE Count_Star = 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2"
  },
  {
    "id":"f85c2f09f4eae3cc1aaf881656ac6d56ca396023118851906c9efa64f26e905d",
    "db_id":"student_transcripts_tracking",
    "question":"What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?",
    "query":"SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 2 ] Output [ first_name , student_id , last_name , middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 2 ] Output [ first_name , student_id , last_name , middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT first_name, student_id, last_name, middle_name FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.middle_name, Scan_3.student_id, Aggregate_2.Count_Star, Scan_3.last_name, Scan_3.first_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), Filter_5 AS ( SELECT first_name, student_id, last_name, middle_name FROM Join_4 WHERE Count_Star = 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.first_name , T1.middle_name , T1.last_name , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.first_name , T1.middle_name , T1.last_name , T1.student_id HAVING count ( * ) = 2"
  },
  {
    "id":"154ade6ec7a46682d047b9181ae3c0a84374232035fcf506874a2219cdd09599",
    "db_id":"student_transcripts_tracking",
    "question":"Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.",
    "query":"SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3 WITH (FORCESCAN) ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ student_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.student_id ] ; #4 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.student_id = #4.student_id ] Distinct [ true ] Output [ #4.first_name , #4.last_name , #4.middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ student_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.student_id ] ; #4 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.student_id = #4.student_id ] Distinct [ true ] Output [ #4.first_name , #4.last_name , #4.middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_2 AS ( SELECT student_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT first_name, student_id, last_name, middle_name FROM student_transcripts_tracking.Students ), Join_5 AS ( SELECT DISTINCT Scan_4.first_name, Scan_4.last_name, Scan_4.middle_name FROM Join_3 JOIN Scan_4 ON Join_3.student_id = Scan_4.student_id ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3  ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'"
  },
  {
    "id":"2302a1b8bb2111d71497b49f79a57e7db73f1de39aa54c60c1bab8fae0217a10",
    "db_id":"student_transcripts_tracking",
    "question":"What are the first, middle, and last names for everybody enrolled in a Bachelors program?",
    "query":"SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3 WITH (FORCESCAN) ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ student_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.student_id ] ; #4 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.student_id = #4.student_id ] Distinct [ true ] Output [ #4.first_name , #4.last_name , #4.middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ student_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.student_id ] ; #4 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.student_id = #4.student_id ] Distinct [ true ] Output [ #4.first_name , #4.last_name , #4.middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_2 AS ( SELECT student_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT first_name, student_id, last_name, middle_name FROM student_transcripts_tracking.Students ), Join_5 AS ( SELECT DISTINCT Scan_4.first_name, Scan_4.last_name, Scan_4.middle_name FROM Join_3 JOIN Scan_4 ON Join_3.student_id = Scan_4.student_id ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.first_name , T1.middle_name , T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id JOIN student_transcripts_tracking.Degree_Programs AS T3  ON T2.degree_program_id = T3.degree_program_id WHERE T3.degree_summary_name = 'Bachelor'"
  },
  {
    "id":"a10ef1dc84070e92c63477211ea1738d364aca09cd140fdcb5d8d7685285a26d",
    "db_id":"student_transcripts_tracking",
    "question":"Find the kind of program which most number of students are enrolled in?",
    "query":"SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.degree_summary_name ] ; #4 = Aggregate [ #3 ] GroupBy [ degree_summary_name ] Output [ degree_summary_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_summary_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.degree_summary_name ] ; #4 = Aggregate [ #3 ] GroupBy [ degree_summary_name ] Output [ degree_summary_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_summary_name ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_2 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_2.degree_summary_name FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Aggregate_4 AS ( SELECT degree_summary_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY degree_summary_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, degree_summary_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"d25d036afc69baf9a3904e24917c7343ef491033d06727dec986ad7c1acc8f97",
    "db_id":"student_transcripts_tracking",
    "question":"What is the degree summary name that has the most number of students enrolled?",
    "query":"SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.degree_summary_name ] ; #4 = Aggregate [ #3 ] GroupBy [ degree_summary_name ] Output [ degree_summary_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_summary_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Output [ #2.degree_summary_name ] ; #4 = Aggregate [ #3 ] GroupBy [ degree_summary_name ] Output [ degree_summary_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_summary_name ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_2 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Join_3 AS ( SELECT Scan_2.degree_summary_name FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Aggregate_4 AS ( SELECT degree_summary_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY degree_summary_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, degree_summary_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"d0a296f1837c86b98749f120148d725826c46b39b052aeb796e95d08240be359",
    "db_id":"student_transcripts_tracking",
    "question":"Find the program which most number of students are enrolled in. List both the id and the summary.",
    "query":"SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Aggregate [ #1 ] GroupBy [ degree_program_id ] Output [ degree_program_id , countstar AS Count_Star ] ; #3 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.degree_program_id = #3.degree_program_id ] Output [ #3.degree_program_id , #3.degree_summary_name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_program_id , degree_summary_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Aggregate [ #1 ] GroupBy [ degree_program_id ] Output [ degree_program_id , countstar AS Count_Star ] ; #3 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.degree_program_id = #3.degree_program_id ] Output [ #3.degree_program_id , #3.degree_summary_name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_program_id , degree_summary_name ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT degree_program_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY degree_program_id ), Scan_3 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Join_4 AS ( SELECT Scan_3.degree_program_id, Scan_3.degree_summary_name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.degree_program_id = Scan_3.degree_program_id ), TopSort_5 AS ( SELECT TOP 1 Count_Star, degree_program_id, degree_summary_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"34572d6690f52e3ae8b1930d673e5bb162d889950786a5123cf119a1dab9cc1e",
    "db_id":"student_transcripts_tracking",
    "question":"What is the program id and the summary of the degree that has the most students enrolled?",
    "query":"SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Aggregate [ #1 ] GroupBy [ degree_program_id ] Output [ degree_program_id , countstar AS Count_Star ] ; #3 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.degree_program_id = #3.degree_program_id ] Output [ #3.degree_program_id , #3.degree_summary_name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_program_id , degree_summary_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ degree_program_id ] ; #2 = Aggregate [ #1 ] GroupBy [ degree_program_id ] Output [ degree_program_id , countstar AS Count_Star ] ; #3 = Scan Table [ Degree_Programs ] Output [ degree_program_id , degree_summary_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.degree_program_id = #3.degree_program_id ] Output [ #3.degree_program_id , #3.degree_summary_name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , degree_program_id , degree_summary_name ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT degree_program_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY degree_program_id ), Scan_3 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs ), Join_4 AS ( SELECT Scan_3.degree_program_id, Scan_3.degree_summary_name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.degree_program_id = Scan_3.degree_program_id ), TopSort_5 AS ( SELECT TOP 1 Count_Star, degree_program_id, degree_summary_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.degree_program_id , T1.degree_summary_name FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id , T1.degree_summary_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"25e6219ead2bf27a2598b9113dc3d3af8c1960671ba08542f364e3d1cf519404",
    "db_id":"student_transcripts_tracking",
    "question":"Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.",
    "query":"SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , middle_name , student_id , last_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , middle_name , student_id , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT first_name, student_id, last_name, middle_name FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.middle_name, Scan_3.student_id, Aggregate_2.Count_Star, Scan_3.last_name, Scan_3.first_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), TopSort_5 AS ( SELECT TOP 1 first_name, Count_Star, middle_name, student_id, last_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"24a2b7acc32937966d07d1265d8dc136e4be76b7cfe7bf73b2ac90793d0c310b",
    "db_id":"student_transcripts_tracking",
    "question":"What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?",
    "query":"SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , middle_name , student_id , last_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Students ] Output [ first_name , student_id , last_name , middle_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.student_id ] Output [ #3.middle_name , #3.student_id , #2.Count_Star , #3.last_name , #3.first_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , middle_name , student_id , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT first_name, student_id, last_name, middle_name FROM student_transcripts_tracking.Students ), Join_4 AS ( SELECT Scan_3.middle_name, Scan_3.student_id, Aggregate_2.Count_Star, Scan_3.last_name, Scan_3.first_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.student_id ), TopSort_5 AS ( SELECT TOP 1 first_name, Count_Star, middle_name, student_id, last_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.student_id , T1.first_name , T1.middle_name , T1.last_name , count ( * ) AS Count_Star , T1.student_id FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.student_id = T2.student_id GROUP BY T1.student_id , T1.first_name , T1.middle_name , T1.last_name , T1.student_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"8f8dd95299a63e06a826543a636d943555a7b97b7b1a3fae24cebc48ce2f8de4",
    "db_id":"student_transcripts_tracking",
    "question":"Which semesters do not have any student enrolled? List the semester name.",
    "query":"SELECT semester_name FROM student_transcripts_tracking.Semesters WITH (FORCESCAN) WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.semester_id = #1.semester_id ] Output [ #1.semester_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.semester_id = #1.semester_id ] Output [ #1.semester_name ]",
    "cte":"WITH Scan_1 AS ( SELECT semester_id, semester_name FROM student_transcripts_tracking.Semesters ), Scan_2 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Except_3 AS ( SELECT Scan_1.semester_name FROM Scan_1 WHERE semester_id NOT IN (SELECT semester_id FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT semester_name FROM student_transcripts_tracking.Semesters  WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment  )"
  },
  {
    "id":"9fd7819b14bde9ee74ec0e3209b223ce84e293f99d29e2ac8a51f4ac4e6a787c",
    "db_id":"student_transcripts_tracking",
    "question":"What is the name of the semester with no students enrolled?",
    "query":"SELECT semester_name FROM student_transcripts_tracking.Semesters WITH (FORCESCAN) WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.semester_id = #1.semester_id ] Output [ #1.semester_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Semesters ] Output [ semester_id , semester_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.semester_id = #1.semester_id ] Output [ #1.semester_name ]",
    "cte":"WITH Scan_1 AS ( SELECT semester_id, semester_name FROM student_transcripts_tracking.Semesters ), Scan_2 AS ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment ), Except_3 AS ( SELECT Scan_1.semester_name FROM Scan_1 WHERE semester_id NOT IN (SELECT semester_id FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT semester_name FROM student_transcripts_tracking.Semesters  WHERE semester_id NOT IN ( SELECT semester_id FROM student_transcripts_tracking.Student_Enrolment  )"
  },
  {
    "id":"ca275588e6a1888e3ee9ac925a1f679efdc98638946b70168e6eb08bd0b42247",
    "db_id":"student_transcripts_tracking",
    "question":"What are all the course names of the courses which ever have students enrolled in?",
    "query":"SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Distinct [ true ] Output [ #2.course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Distinct [ true ] Output [ #2.course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT DISTINCT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id"
  },
  {
    "id":"c3c0c78ed6a2f30afcfd3f309300640fd3f03dc8619ee2ab43d1b39f24566e90",
    "db_id":"student_transcripts_tracking",
    "question":"What are the names of all courses that have some students enrolled?",
    "query":"SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Distinct [ true ] Output [ #2.course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Distinct [ true ] Output [ #2.course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT DISTINCT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id"
  },
  {
    "id":"1bd94e2f18aa0acb7fb193440870a60c58d392889f7f5282908b639d56d1d35e",
    "db_id":"student_transcripts_tracking",
    "question":"What's the name of the course with most number of enrollments?",
    "query":"SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name ] ; #4 = Aggregate [ #3 ] GroupBy [ course_name ] Output [ course_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name ] ; #4 = Aggregate [ #3 ] GroupBy [ course_name ] Output [ course_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT course_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY course_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, course_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"8d8d7be0915ab938d82fc0dc6b68687fa8a87c94b363531168932afc2034e978",
    "db_id":"student_transcripts_tracking",
    "question":"What is the name of the course with the most students enrolled?",
    "query":"SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2 WITH (FORCESCAN) ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name ] ; #4 = Aggregate [ #3 ] GroupBy [ course_name ] Output [ course_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , course_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Student_Enrolment_Courses ] Output [ course_id ] ; #2 = Scan Table [ Courses ] Output [ course_id , course_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.course_id = #2.course_id ] Output [ #2.course_name ] ; #4 = Aggregate [ #3 ] GroupBy [ course_name ] Output [ course_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , course_name ]",
    "cte":"WITH Scan_1 AS ( SELECT course_id FROM student_transcripts_tracking.Student_Enrolment_Courses ), Scan_2 AS ( SELECT course_id, course_name FROM student_transcripts_tracking.Courses ), Join_3 AS ( SELECT Scan_2.course_name FROM Scan_1 JOIN Scan_2 ON Scan_1.course_id = Scan_2.course_id ), Aggregate_4 AS ( SELECT course_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY course_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, course_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.course_name FROM student_transcripts_tracking.Courses AS T1  JOIN student_transcripts_tracking.Student_Enrolment_Courses AS T2  ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"90fe37982799391287e4f0d346699f1b44e07bfa60c82d7570607cd1983a3094",
    "db_id":"student_transcripts_tracking",
    "question":"Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.",
    "query":"SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Addresses AS T2 WITH (FORCESCAN) ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T4 WITH (FORCESCAN) ON T3.student_id = T4.student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Addresses ] Predicate [ state_province_county = 'NorthCarolina' ] Output [ state_province_county , address_id ] ; #2 = Scan Table [ Students ] Output [ current_address_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.address_id = #2.current_address_id ] Distinct [ true ] Output [ #2.last_name ] ; #4 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #5 = Scan Table [ Students ] Output [ student_id , last_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.student_id = #5.student_id ] Distinct [ true ] Output [ #5.last_name ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.last_name = #6.last_name ] Output [ #3.last_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ state_province_county = 'NorthCarolina' ] Output [ state_province_county , address_id ] ; #2 = Scan Table [ Students ] Output [ current_address_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.address_id = #2.current_address_id ] Distinct [ true ] Output [ #2.last_name ] ; #4 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #5 = Scan Table [ Students ] Output [ student_id , last_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.student_id = #5.student_id ] Distinct [ true ] Output [ #5.last_name ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.last_name = #6.last_name ] Output [ #3.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT state_province_county, address_id FROM student_transcripts_tracking.Addresses WHERE state_province_county = 'NorthCarolina' ), Scan_2 AS ( SELECT current_address_id, last_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT DISTINCT Scan_2.last_name FROM Scan_1 JOIN Scan_2 ON Scan_1.address_id = Scan_2.current_address_id ), Scan_4 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_5 AS ( SELECT student_id, last_name FROM student_transcripts_tracking.Students ), Join_6 AS ( SELECT DISTINCT Scan_5.last_name FROM Scan_4 JOIN Scan_5 ON Scan_4.student_id = Scan_5.student_id ), Except_7 AS ( SELECT Join_3.last_name FROM Join_3 WHERE last_name NOT IN (SELECT last_name FROM Join_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Addresses AS T2  ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3  JOIN student_transcripts_tracking.Student_Enrolment AS T4  ON T3.student_id = T4.student_id"
  },
  {
    "id":"c0a96b9f9d0925f4b25d2753c394e50199efd3b2e713af2553e63e9a993cd92f",
    "db_id":"student_transcripts_tracking",
    "question":"What are the last name of the students who live in North Carolina but have not registered in any degree programs?",
    "query":"SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Addresses AS T2 WITH (FORCESCAN) ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T4 WITH (FORCESCAN) ON T3.student_id = T4.student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Addresses ] Predicate [ state_province_county = 'NorthCarolina' ] Output [ state_province_county , address_id ] ; #2 = Scan Table [ Students ] Output [ current_address_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.address_id = #2.current_address_id ] Distinct [ true ] Output [ #2.last_name ] ; #4 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #5 = Scan Table [ Students ] Output [ student_id , last_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.student_id = #5.student_id ] Distinct [ true ] Output [ #5.last_name ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.last_name = #6.last_name ] Output [ #3.last_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Predicate [ state_province_county = 'NorthCarolina' ] Output [ state_province_county , address_id ] ; #2 = Scan Table [ Students ] Output [ current_address_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.address_id = #2.current_address_id ] Distinct [ true ] Output [ #2.last_name ] ; #4 = Scan Table [ Student_Enrolment ] Output [ student_id ] ; #5 = Scan Table [ Students ] Output [ student_id , last_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.student_id = #5.student_id ] Distinct [ true ] Output [ #5.last_name ] ; #7 = Except [ #3 , #6 ] Predicate [ #3.last_name = #6.last_name ] Output [ #3.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT state_province_county, address_id FROM student_transcripts_tracking.Addresses WHERE state_province_county = 'NorthCarolina' ), Scan_2 AS ( SELECT current_address_id, last_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT DISTINCT Scan_2.last_name FROM Scan_1 JOIN Scan_2 ON Scan_1.address_id = Scan_2.current_address_id ), Scan_4 AS ( SELECT student_id FROM student_transcripts_tracking.Student_Enrolment ), Scan_5 AS ( SELECT student_id, last_name FROM student_transcripts_tracking.Students ), Join_6 AS ( SELECT DISTINCT Scan_5.last_name FROM Scan_4 JOIN Scan_5 ON Scan_4.student_id = Scan_5.student_id ), Except_7 AS ( SELECT Join_3.last_name FROM Join_3 WHERE last_name NOT IN (SELECT last_name FROM Join_6) ) SELECT * FROM Except_7",
    "clean_query":"SELECT T1.last_name FROM student_transcripts_tracking.Students AS T1  JOIN student_transcripts_tracking.Addresses AS T2  ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM student_transcripts_tracking.Students AS T3  JOIN student_transcripts_tracking.Student_Enrolment AS T4  ON T3.student_id = T4.student_id"
  },
  {
    "id":"681cf03b6d36068143ee1116a534b9ea3ea9ab0b38428280e350f80987598ba7",
    "db_id":"student_transcripts_tracking",
    "question":"Show the date and id of the transcript with at least 2 course results.",
    "query":"SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Transcripts AS T2 WITH (FORCESCAN) ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #2 = Aggregate [ #1 ] GroupBy [ transcript_id ] Output [ transcript_id , countstar AS Count_Star ] ; #3 = Scan Table [ Transcripts ] Output [ transcript_date , transcript_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.transcript_id = #3.transcript_id ] Output [ #2.Count_Star , #2.transcript_id , #3.transcript_date ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ transcript_date , transcript_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #2 = Aggregate [ #1 ] GroupBy [ transcript_id ] Output [ transcript_id , countstar AS Count_Star ] ; #3 = Scan Table [ Transcripts ] Output [ transcript_date , transcript_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.transcript_id = #3.transcript_id ] Output [ #2.Count_Star , #2.transcript_id , #3.transcript_date ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ transcript_date , transcript_id ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT transcript_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY transcript_id ), Scan_3 AS ( SELECT transcript_date, transcript_id FROM student_transcripts_tracking.Transcripts ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.transcript_id, Scan_3.transcript_date FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.transcript_id = Scan_3.transcript_id ), Filter_5 AS ( SELECT transcript_date, transcript_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  JOIN student_transcripts_tracking.Transcripts AS T2  ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2"
  },
  {
    "id":"f354038a754fe4726aab53423b47fd7259de7b16d4e90b949c9f3f0fe7c097a5",
    "db_id":"student_transcripts_tracking",
    "question":"What is the date and id of the transcript with at least 2 courses listed?",
    "query":"SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Transcripts AS T2 WITH (FORCESCAN) ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #2 = Aggregate [ #1 ] GroupBy [ transcript_id ] Output [ transcript_id , countstar AS Count_Star ] ; #3 = Scan Table [ Transcripts ] Output [ transcript_date , transcript_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.transcript_id = #3.transcript_id ] Output [ #2.Count_Star , #2.transcript_id , #3.transcript_date ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ transcript_date , transcript_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #2 = Aggregate [ #1 ] GroupBy [ transcript_id ] Output [ transcript_id , countstar AS Count_Star ] ; #3 = Scan Table [ Transcripts ] Output [ transcript_date , transcript_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.transcript_id = #3.transcript_id ] Output [ #2.Count_Star , #2.transcript_id , #3.transcript_date ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ transcript_date , transcript_id ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT transcript_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY transcript_id ), Scan_3 AS ( SELECT transcript_date, transcript_id FROM student_transcripts_tracking.Transcripts ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Aggregate_2.transcript_id, Scan_3.transcript_date FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.transcript_id = Scan_3.transcript_id ), Filter_5 AS ( SELECT transcript_date, transcript_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.transcript_date , T1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  JOIN student_transcripts_tracking.Transcripts AS T2  ON T1.transcript_id = T2.transcript_id GROUP BY T2.transcript_date , T1.transcript_id HAVING count ( * ) > = 2"
  },
  {
    "id":"12f83d872b4996b26a5511d6910db085bcd48e6656dcaef27eb62b3424a06ca9",
    "db_id":"student_transcripts_tracking",
    "question":"What is the phone number of the man with the first name Timmothy and the last name Ward?",
    "query":"SELECT cell_mobile_number FROM student_transcripts_tracking.Students WITH (FORCESCAN) WHERE first_name = 'Timmothy' AND last_name = 'Ward' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Students ] Predicate [ first_name = 'Timmothy' AND last_name = 'Ward' ] Output [ first_name , cell_mobile_number , last_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ first_name = 'Timmothy' AND last_name = 'Ward' ] Output [ first_name , cell_mobile_number , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, cell_mobile_number, last_name FROM student_transcripts_tracking.Students WHERE first_name = 'Timmothy' AND last_name = 'Ward' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT cell_mobile_number FROM student_transcripts_tracking.Students  WHERE first_name = 'Timmothy' AND last_name = 'Ward'"
  },
  {
    "id":"6e07e3442e971836451c6b5d8270702979d958da915172bf10e273487e3e254d",
    "db_id":"student_transcripts_tracking",
    "question":"What is the mobile phone number of the student named Timmothy Ward ?",
    "query":"select cell_mobile_number FROM student_transcripts_tracking.students WITH (FORCESCAN) where first_name = 'timmothy' and last_name = 'ward' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Students ] Predicate [ first_name = 'timmothy' AND last_name = 'ward' ] Output [ first_name , cell_mobile_number , last_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ first_name = 'timmothy' AND last_name = 'ward' ] Output [ first_name , cell_mobile_number , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, cell_mobile_number, last_name FROM student_transcripts_tracking.Students WHERE first_name = 'timmothy' AND last_name = 'ward' ) SELECT * FROM Scan_1",
    "clean_query":"select cell_mobile_number FROM student_transcripts_tracking.students  where first_name = 'timmothy' and last_name = 'ward'"
  },
  {
    "id":"13402275c28ea205994823c1db8e3dc7acb229431deaad3cb2954b8df3778978",
    "db_id":"student_transcripts_tracking",
    "question":"Who is the first student to register? List the first name, middle name and last name.",
    "query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_first_registered ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Students ] Output [ first_name , date_first_registered , last_name , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_first_registered ASC ] Output [ first_name , date_first_registered , last_name , middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ first_name , date_first_registered , last_name , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_first_registered ASC ] Output [ first_name , date_first_registered , last_name , middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, date_first_registered, last_name, middle_name FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 first_name, date_first_registered, last_name, middle_name FROM Scan_1 ORDER BY date_first_registered ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_first_registered ASC"
  },
  {
    "id":"c072e76619b9b9ee950cec35cf5f953243537d799f59ec4fca100dcca366c081",
    "db_id":"student_transcripts_tracking",
    "question":"What is the first, middle, and last name of the first student to register?",
    "query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_first_registered ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Students ] Output [ first_name , date_first_registered , last_name , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_first_registered ASC ] Output [ first_name , date_first_registered , last_name , middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ first_name , date_first_registered , last_name , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_first_registered ASC ] Output [ first_name , date_first_registered , last_name , middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, date_first_registered, last_name, middle_name FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 first_name, date_first_registered, last_name, middle_name FROM Scan_1 ORDER BY date_first_registered ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_first_registered ASC"
  },
  {
    "id":"e7e55a8fa3c545c49218fac804bb17a8f183588046d59a33f56a1e69d025ff83",
    "db_id":"student_transcripts_tracking",
    "question":"Who is the earliest graduate of the school? List the first name, middle name and last name.",
    "query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_left ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Students ] Output [ first_name , last_name , date_left , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_left ASC ] Output [ first_name , last_name , date_left , middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ first_name , last_name , date_left , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_left ASC ] Output [ first_name , last_name , date_left , middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, last_name, date_left, middle_name FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 first_name, last_name, date_left, middle_name FROM Scan_1 ORDER BY date_left ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_left ASC"
  },
  {
    "id":"9eb49aca2584d05d0366be17ba34ccfb07f238dffed751db48a4e86346eb6789",
    "db_id":"student_transcripts_tracking",
    "question":"What is the first, middle, and last name of the earliest school graduate?",
    "query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY date_left ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Students ] Output [ first_name , last_name , date_left , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_left ASC ] Output [ first_name , last_name , date_left , middle_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ first_name , last_name , date_left , middle_name ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_left ASC ] Output [ first_name , last_name , date_left , middle_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, last_name, date_left, middle_name FROM student_transcripts_tracking.Students ), TopSort_2 AS ( SELECT TOP 1 first_name, last_name, date_left, middle_name FROM Scan_1 ORDER BY date_left ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 first_name , middle_name , last_name FROM student_transcripts_tracking.Students  ORDER BY date_left ASC"
  },
  {
    "id":"621f50d37306c6e356a4de3df6e3793856ee7f9d9ab9b053e9890cfa5db56c89",
    "db_id":"student_transcripts_tracking",
    "question":"Whose permanent address is different from his or her current address? List his or her first name.",
    "query":"SELECT first_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) WHERE current_address_id ! = permanent_address_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Students ] Predicate [ current_address_id <> permanent_address_id ] Output [ first_name , permanent_address_id , current_address_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ current_address_id <> permanent_address_id ] Output [ first_name , permanent_address_id , current_address_id ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, permanent_address_id, current_address_id FROM student_transcripts_tracking.Students WHERE current_address_id <> permanent_address_id ) SELECT * FROM Scan_1",
    "clean_query":"SELECT first_name FROM student_transcripts_tracking.Students  WHERE current_address_id ! = permanent_address_id"
  },
  {
    "id":"73c8b1da8ff7be1c1d0af01653242378ba5b079a8bde31662382b9a99834ae05",
    "db_id":"student_transcripts_tracking",
    "question":"What is the first name of the student whose permanent address is different from his or her current one?",
    "query":"SELECT first_name FROM student_transcripts_tracking.Students WITH (FORCESCAN) WHERE current_address_id ! = permanent_address_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Students ] Predicate [ current_address_id <> permanent_address_id ] Output [ first_name , permanent_address_id , current_address_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Predicate [ current_address_id <> permanent_address_id ] Output [ first_name , permanent_address_id , current_address_id ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, permanent_address_id, current_address_id FROM student_transcripts_tracking.Students WHERE current_address_id <> permanent_address_id ) SELECT * FROM Scan_1",
    "clean_query":"SELECT first_name FROM student_transcripts_tracking.Students  WHERE current_address_id ! = permanent_address_id"
  },
  {
    "id":"5a1add434252fa8ef88afe242d0e6f6da6ebe21eab7ebb70940db2d4060acb6e",
    "db_id":"student_transcripts_tracking",
    "question":"Which address holds the most number of students currently? List the address id and all lines.",
    "query":"SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Students AS T2 WITH (FORCESCAN) ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Students ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] GroupBy [ current_address_id ] Output [ current_address_id , countstar AS Count_Star ] ; #3 = Scan Table [ Addresses ] Output [ line_1 , address_id , line_2 ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.current_address_id = #3.address_id ] Output [ #2.Count_Star , #3.line_2 , #3.line_1 , #3.address_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , line_1 , address_id , line_2 ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] GroupBy [ current_address_id ] Output [ current_address_id , countstar AS Count_Star ] ; #3 = Scan Table [ Addresses ] Output [ line_1 , address_id , line_2 ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.current_address_id = #3.address_id ] Output [ #2.Count_Star , #3.line_2 , #3.line_1 , #3.address_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , line_1 , address_id , line_2 ]",
    "cte":"WITH Scan_1 AS ( SELECT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT current_address_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY current_address_id ), Scan_3 AS ( SELECT line_1, address_id, line_2 FROM student_transcripts_tracking.Addresses ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.line_2, Scan_3.line_1, Scan_3.address_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.current_address_id = Scan_3.address_id ), TopSort_5 AS ( SELECT TOP 1 Count_Star, line_1, address_id, line_2 FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1  JOIN student_transcripts_tracking.Students AS T2  ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC"
  },
  {
    "id":"c61132133c0884369b3656e64742fefba5bafb269a5d2e9604eed2bd4d7792f7",
    "db_id":"student_transcripts_tracking",
    "question":"What is the id, line 1, and line 2 of the address with the most students?",
    "query":"SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Students AS T2 WITH (FORCESCAN) ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Students ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] GroupBy [ current_address_id ] Output [ current_address_id , countstar AS Count_Star ] ; #3 = Scan Table [ Addresses ] Output [ line_1 , address_id , line_2 ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.current_address_id = #3.address_id ] Output [ #2.Count_Star , #3.line_2 , #3.line_1 , #3.address_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , line_1 , address_id , line_2 ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] GroupBy [ current_address_id ] Output [ current_address_id , countstar AS Count_Star ] ; #3 = Scan Table [ Addresses ] Output [ line_1 , address_id , line_2 ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.current_address_id = #3.address_id ] Output [ #2.Count_Star , #3.line_2 , #3.line_1 , #3.address_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , line_1 , address_id , line_2 ]",
    "cte":"WITH Scan_1 AS ( SELECT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT current_address_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY current_address_id ), Scan_3 AS ( SELECT line_1, address_id, line_2 FROM student_transcripts_tracking.Addresses ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.line_2, Scan_3.line_1, Scan_3.address_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.current_address_id = Scan_3.address_id ), TopSort_5 AS ( SELECT TOP 1 Count_Star, line_1, address_id, line_2 FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.address_id , T1.line_1 , T1.line_2 FROM student_transcripts_tracking.Addresses AS T1  JOIN student_transcripts_tracking.Students AS T2  ON T1.address_id = T2.current_address_id GROUP BY T1.address_id , T1.line_1 , T1.line_2 ORDER BY count ( * ) DESC"
  },
  {
    "id":"8671937b8fca85e18cd7d84da33377f4105cc302be5b0d30e884478c99e61450",
    "db_id":"student_transcripts_tracking",
    "question":"On average, when were the transcripts printed?",
    "query":"SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = Aggregate [ #1 ] Output [ AVG(transcript_date) AS Avg_transcript_date ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = Aggregate [ #1 ] Output [ AVG(transcript_date) AS Avg_transcript_date ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT AVG(transcript_date) AS Avg_transcript_date FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts"
  },
  {
    "id":"c3597c57608e6709f8aa5590f37792720cf006026f950415914855999b49a2dc",
    "db_id":"student_transcripts_tracking",
    "question":"What is the average transcript date?",
    "query":"SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = Aggregate [ #1 ] Output [ AVG(transcript_date) AS Avg_transcript_date ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = Aggregate [ #1 ] Output [ AVG(transcript_date) AS Avg_transcript_date ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT AVG(transcript_date) AS Avg_transcript_date FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( transcript_date ) AS Avg_transcript_date FROM student_transcripts_tracking.Transcripts"
  },
  {
    "id":"d381b46013f0591ed9f55bae1c24b89d012b6cca147b787e06954fb2f9f1d091",
    "db_id":"student_transcripts_tracking",
    "question":"When is the first transcript released? List the date and details.",
    "query":"SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_date , other_details ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date ASC ] Output [ transcript_date , other_details ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date , other_details ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date ASC ] Output [ transcript_date , other_details ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_date, other_details FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 transcript_date, other_details FROM Scan_1 ORDER BY transcript_date ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date ASC"
  },
  {
    "id":"f120ceebe63b91cf7d8ec2153a05da63c2f6a2cb3b1402da0f1772c73a21307e",
    "db_id":"student_transcripts_tracking",
    "question":"What is the earliest date of a transcript release, and what details can you tell me?",
    "query":"SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_date , other_details ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date ASC ] Output [ transcript_date , other_details ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date , other_details ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date ASC ] Output [ transcript_date , other_details ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_date, other_details FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 transcript_date, other_details FROM Scan_1 ORDER BY transcript_date ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 transcript_date , other_details FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date ASC"
  },
  {
    "id":"4d616fdb35747a6d6392a417df2d25850f46e59e5970a943e380befec0675e3a",
    "db_id":"student_transcripts_tracking",
    "question":"How many transcripts are released?",
    "query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts"
  },
  {
    "id":"523fbe361abc1311f6b3f07e9edf236519a70dbd66130b8dce011bcb8d76bd5e",
    "db_id":"student_transcripts_tracking",
    "question":"How many transcripts are listed?",
    "query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM student_transcripts_tracking.Transcripts ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM student_transcripts_tracking.Transcripts"
  },
  {
    "id":"ce82a2bc66cd458fd38b1b6325e2c841b5eb71ebe89e613ef8d2356e65d99a3b",
    "db_id":"student_transcripts_tracking",
    "question":"What is the last transcript release date?",
    "query":"SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date DESC ] Output [ transcript_date ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date DESC ] Output [ transcript_date ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 transcript_date FROM Scan_1 ORDER BY transcript_date DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date DESC"
  },
  {
    "id":"e3cd6248e6e7f1dba56b3d1440d38872d8d0c60b3c205be143bf0e682bee3268",
    "db_id":"student_transcripts_tracking",
    "question":"When was the last transcript released?",
    "query":"SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts WITH (FORCESCAN) ORDER BY transcript_date DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date DESC ] Output [ transcript_date ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_date ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ transcript_date DESC ] Output [ transcript_date ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_date FROM student_transcripts_tracking.Transcripts ), TopSort_2 AS ( SELECT TOP 1 transcript_date FROM Scan_1 ORDER BY transcript_date DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 transcript_date FROM student_transcripts_tracking.Transcripts  ORDER BY transcript_date DESC"
  },
  {
    "id":"73eb7b4c3f37bf11cedc8f329393c4d8a8e8cfe20fd3345a5a445897b86fa329",
    "db_id":"student_transcripts_tracking",
    "question":"How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.",
    "query":"SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents WITH (FORCESCAN) GROUP BY student_course_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Transcript_Contents ] Output [ student_course_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_course_id ] Output [ student_course_id , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , student_course_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ student_course_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_course_id ] Output [ student_course_id , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , student_course_id ]",
    "cte":"WITH Scan_1 AS ( SELECT student_course_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT student_course_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_course_id ), TopSort_3 AS ( SELECT TOP 1 Count_Star, student_course_id FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents  GROUP BY student_course_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"3a3c210329f066c16ae725a134bcf591f4cb70fa224a580ef0a2c17a0f9f0c2a",
    "db_id":"student_transcripts_tracking",
    "question":"What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?",
    "query":"SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents WITH (FORCESCAN) GROUP BY student_course_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Transcript_Contents ] Output [ student_course_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_course_id ] Output [ student_course_id , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , student_course_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcript_Contents ] Output [ student_course_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_course_id ] Output [ student_course_id , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , student_course_id ]",
    "cte":"WITH Scan_1 AS ( SELECT student_course_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_2 AS ( SELECT student_course_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_course_id ), TopSort_3 AS ( SELECT TOP 1 Count_Star, student_course_id FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 count ( * ) AS Count_Star , student_course_id FROM student_transcripts_tracking.Transcript_Contents  GROUP BY student_course_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"bd844dd1bbe595ee1aa0d5da9010030323680dc2b4a5b47d15a2dd2bd4796d8b",
    "db_id":"student_transcripts_tracking",
    "question":"Show the date of the transcript which shows the least number of results, also list the id.",
    "query":"select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) join student_transcripts_tracking.transcripts as t2 WITH (FORCESCAN) ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #2 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #3 = Aggregate [ #2 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.transcript_id = #1.transcript_id ] Output [ #1.transcript_date , #3.Count_Star , #3.transcript_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ transcript_id , transcript_date ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #2 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #3 = Aggregate [ #2 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.transcript_id = #1.transcript_id ] Output [ #1.transcript_date , #3.Count_Star , #3.transcript_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ transcript_id , transcript_date ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_id, transcript_date FROM student_transcripts_tracking.Transcripts ), Scan_2 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star, transcript_id FROM Scan_2 GROUP BY transcript_id ), Join_4 AS ( SELECT Scan_1.transcript_date, Aggregate_3.Count_Star, Aggregate_3.transcript_id FROM Scan_1 JOIN Aggregate_3 ON Aggregate_3.transcript_id = Scan_1.transcript_id ), TopSort_5 AS ( SELECT TOP 1 WITH TIES transcript_id, transcript_date FROM Join_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  join student_transcripts_tracking.transcripts as t2  ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc"
  },
  {
    "id":"b4b4ae10d25e46d7369817827ed4141e9c701e7046aefa27d6f88b73baff0a32",
    "db_id":"student_transcripts_tracking",
    "question":"What is the date and id of the transcript with the least number of results?",
    "query":"select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1 WITH (FORCESCAN) join student_transcripts_tracking.transcripts as t2 WITH (FORCESCAN) ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #2 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #3 = Aggregate [ #2 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.transcript_id = #1.transcript_id ] Output [ #1.transcript_date , #3.Count_Star , #3.transcript_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ transcript_id , transcript_date ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Transcripts ] Output [ transcript_id , transcript_date ] ; #2 = Scan Table [ Transcript_Contents ] Output [ transcript_id ] ; #3 = Aggregate [ #2 ] GroupBy [ transcript_id ] Output [ countstar AS Count_Star , transcript_id ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.transcript_id = #1.transcript_id ] Output [ #1.transcript_date , #3.Count_Star , #3.transcript_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ transcript_id , transcript_date ]",
    "cte":"WITH Scan_1 AS ( SELECT transcript_id, transcript_date FROM student_transcripts_tracking.Transcripts ), Scan_2 AS ( SELECT transcript_id FROM student_transcripts_tracking.Transcript_Contents ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star, transcript_id FROM Scan_2 GROUP BY transcript_id ), Join_4 AS ( SELECT Scan_1.transcript_date, Aggregate_3.Count_Star, Aggregate_3.transcript_id FROM Scan_1 JOIN Aggregate_3 ON Aggregate_3.transcript_id = Scan_1.transcript_id ), TopSort_5 AS ( SELECT TOP 1 WITH TIES transcript_id, transcript_date FROM Join_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 WITH TIES t2.transcript_date , t1.transcript_id FROM student_transcripts_tracking.Transcript_Contents AS T1  join student_transcripts_tracking.transcripts as t2  ON t1.transcript_id = t2.transcript_id group by t2.transcript_date , t1.transcript_id order by count ( * ) asc"
  },
  {
    "id":"ab348f161bbbba695ed592adb3a2971ae4a97acac0250ed0130c2c730c9403f5",
    "db_id":"student_transcripts_tracking",
    "question":"Find the semester when both Master students and Bachelor students got enrolled in.",
    "query":"SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Master' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Distinct [ true ] Output [ #2.semester_id ] ; #4 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #5 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.degree_program_id = #5.degree_program_id ] Distinct [ true ] Output [ #5.semester_id ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.semester_id = #6.semester_id ] Distinct [ true ] Output [ #3.semester_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Master' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Distinct [ true ] Output [ #2.semester_id ] ; #4 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #5 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.degree_program_id = #5.degree_program_id ] Distinct [ true ] Output [ #5.semester_id ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.semester_id = #6.semester_id ] Distinct [ true ] Output [ #3.semester_id ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Master' ), Scan_2 AS ( SELECT semester_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT DISTINCT Scan_2.semester_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_5 AS ( SELECT semester_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_6 AS ( SELECT DISTINCT Scan_5.semester_id FROM Scan_4 JOIN Scan_5 ON Scan_4.degree_program_id = Scan_5.degree_program_id ), Join_7 AS ( SELECT DISTINCT Join_3.semester_id FROM Join_3 JOIN Join_6 ON Join_3.semester_id = Join_6.semester_id ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor'"
  },
  {
    "id":"51f9a9d3a8314bf9ecb1b1a87c9575af07e01bf2c3ca056692feb0849a94c29f",
    "db_id":"student_transcripts_tracking",
    "question":"What is the id of the semester that had both Masters and Bachelors students enrolled?",
    "query":"SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1 WITH (FORCESCAN) JOIN student_transcripts_tracking.Student_Enrolment AS T2 WITH (FORCESCAN) ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Master' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Distinct [ true ] Output [ #2.semester_id ] ; #4 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #5 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.degree_program_id = #5.degree_program_id ] Distinct [ true ] Output [ #5.semester_id ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.semester_id = #6.semester_id ] Distinct [ true ] Output [ #3.semester_id ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Master' ] Output [ degree_program_id , degree_summary_name ] ; #2 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.degree_program_id = #2.degree_program_id ] Distinct [ true ] Output [ #2.semester_id ] ; #4 = Scan Table [ Degree_Programs ] Predicate [ degree_summary_name = 'Bachelor' ] Output [ degree_program_id , degree_summary_name ] ; #5 = Scan Table [ Student_Enrolment ] Output [ semester_id , degree_program_id ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.degree_program_id = #5.degree_program_id ] Distinct [ true ] Output [ #5.semester_id ] ; #7 = Join [ #3 , #6 ] Predicate [ #3.semester_id = #6.semester_id ] Distinct [ true ] Output [ #3.semester_id ]",
    "cte":"WITH Scan_1 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Master' ), Scan_2 AS ( SELECT semester_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_3 AS ( SELECT DISTINCT Scan_2.semester_id FROM Scan_1 JOIN Scan_2 ON Scan_1.degree_program_id = Scan_2.degree_program_id ), Scan_4 AS ( SELECT degree_program_id, degree_summary_name FROM student_transcripts_tracking.Degree_Programs WHERE degree_summary_name = 'Bachelor' ), Scan_5 AS ( SELECT semester_id, degree_program_id FROM student_transcripts_tracking.Student_Enrolment ), Join_6 AS ( SELECT DISTINCT Scan_5.semester_id FROM Scan_4 JOIN Scan_5 ON Scan_4.degree_program_id = Scan_5.degree_program_id ), Join_7 AS ( SELECT DISTINCT Join_3.semester_id FROM Join_3 JOIN Join_6 ON Join_3.semester_id = Join_6.semester_id ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM student_transcripts_tracking.Degree_Programs AS T1  JOIN student_transcripts_tracking.Student_Enrolment AS T2  ON T1.degree_program_id = T2.degree_program_id WHERE degree_summary_name = 'Bachelor'"
  },
  {
    "id":"6269b3c79bb884695b183d76877a2391ef7ff843fd60ae69ef86d1a04074438f",
    "db_id":"student_transcripts_tracking",
    "question":"How many different addresses do the students currently live?",
    "query":"SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Students ] Distinct [ true ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Distinct [ true ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students"
  },
  {
    "id":"94c692894c8dd9304581db7b6d26ff3423973cb28e3474fb0a4dc1d552bbfe43",
    "db_id":"student_transcripts_tracking",
    "question":"What are the different addresses that have students living there?",
    "query":"SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Students ] Distinct [ true ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Distinct [ true ] Output [ current_address_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT current_address_id FROM student_transcripts_tracking.Students ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT current_address_id ) AS Count_Dist_current_address_id FROM student_transcripts_tracking.Students"
  },
  {
    "id":"57ea74cc58d20b8ed0db92d1be3dd10e1fe48807fd6ec9ac1060e4fd1c7553be",
    "db_id":"student_transcripts_tracking",
    "question":"List all the student details in reversed lexicographical order.",
    "query":"SELECT other_student_details FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY other_student_details DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Students ] Output [ other_student_details ] ; #2 = Sort [ #1 ] OrderBy [ other_student_details DESC ] Output [ other_student_details ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ other_student_details ] ; #2 = Sort [ #1 ] OrderBy [ other_student_details DESC ] Output [ other_student_details ]",
    "cte":"WITH Scan_1 AS ( SELECT other_student_details FROM student_transcripts_tracking.Students ) SELECT other_student_details FROM Scan_1 ORDER BY other_student_details DESC",
    "clean_query":"SELECT other_student_details FROM student_transcripts_tracking.Students  ORDER BY other_student_details DESC"
  },
  {
    "id":"dbbfb1513b82391695d42babdf470c3cde68b3f2eb3e972fc216e917ea6f1c48",
    "db_id":"student_transcripts_tracking",
    "question":"What other details can you tell me about students in reverse alphabetical order?",
    "query":"SELECT other_student_details FROM student_transcripts_tracking.Students WITH (FORCESCAN) ORDER BY other_student_details DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Students ] Output [ other_student_details ] ; #2 = Sort [ #1 ] OrderBy [ other_student_details DESC ] Output [ other_student_details ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Students ] Output [ other_student_details ] ; #2 = Sort [ #1 ] OrderBy [ other_student_details DESC ] Output [ other_student_details ]",
    "cte":"WITH Scan_1 AS ( SELECT other_student_details FROM student_transcripts_tracking.Students ) SELECT other_student_details FROM Scan_1 ORDER BY other_student_details DESC",
    "clean_query":"SELECT other_student_details FROM student_transcripts_tracking.Students  ORDER BY other_student_details DESC"
  },
  {
    "id":"b969e259f189aeb41d02cf9f2331af01a76604299a70247de3c91c3b863f3aa9",
    "db_id":"student_transcripts_tracking",
    "question":"Describe the section h.",
    "query":"SELECT section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) WHERE section_name = 'h' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Sections ] Predicate [ section_name = 'h' ] Output [ section_description , section_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Predicate [ section_name = 'h' ] Output [ section_description , section_name ]",
    "cte":"WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections WHERE section_name = 'h' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT section_description FROM student_transcripts_tracking.Sections  WHERE section_name = 'h'"
  },
  {
    "id":"e8521737692fde7573e1b72b45538c2b1f7ff3b663744abb8012787667193b91",
    "db_id":"student_transcripts_tracking",
    "question":"What is the description for the section named h?",
    "query":"SELECT section_description FROM student_transcripts_tracking.Sections WITH (FORCESCAN) WHERE section_name = 'h' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Sections ] Predicate [ section_name = 'h' ] Output [ section_description , section_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Sections ] Predicate [ section_name = 'h' ] Output [ section_description , section_name ]",
    "cte":"WITH Scan_1 AS ( SELECT section_description, section_name FROM student_transcripts_tracking.Sections WHERE section_name = 'h' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT section_description FROM student_transcripts_tracking.Sections  WHERE section_name = 'h'"
  },
  {
    "id":"a6c5ac5f34c3767df7ecfa7d8e8fa26d6aa081e9ae9a06b31887b21badbbe39f",
    "db_id":"student_transcripts_tracking",
    "question":"Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .",
    "query":"select t1.first_name FROM student_transcripts_tracking.students AS t1 WITH (FORCESCAN) join student_transcripts_tracking.addresses as t2 WITH (FORCESCAN) on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Addresses ] Output [ address_id , country ] ; #2 = Scan Table [ Students ] Output [ cell_mobile_number , permanent_address_id , first_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.permanent_address_id = #1.address_id ] Output [ #2.first_name , #2.cell_mobile_number , #1.country ] ; #4 = Filter [ #3 ] Predicate [ country = 'haiti' OR cell_mobile_number = '09700166582' ] Output [ first_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ address_id , country ] ; #2 = Scan Table [ Students ] Output [ cell_mobile_number , permanent_address_id , first_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.permanent_address_id = #1.address_id ] Output [ #2.first_name , #2.cell_mobile_number , #1.country ] ; #4 = Filter [ #3 ] Predicate [ country = 'haiti' OR cell_mobile_number = '09700166582' ] Output [ first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT address_id, country FROM student_transcripts_tracking.Addresses ), Scan_2 AS ( SELECT cell_mobile_number, permanent_address_id, first_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT Scan_2.first_name, Scan_2.cell_mobile_number, Scan_1.country FROM Scan_1 JOIN Scan_2 ON Scan_2.permanent_address_id = Scan_1.address_id ), Filter_4 AS ( SELECT first_name FROM Join_3 WHERE country = 'haiti' OR cell_mobile_number = '09700166582' ) SELECT * FROM Filter_4",
    "clean_query":"select t1.first_name FROM student_transcripts_tracking.students AS t1  join student_transcripts_tracking.addresses as t2  on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582'"
  },
  {
    "id":"d405cd0b531fc7126168977471c87d89140774601d8b1779ff31df5e3fee25af",
    "db_id":"student_transcripts_tracking",
    "question":"What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?",
    "query":"select t1.first_name FROM student_transcripts_tracking.students AS t1 WITH (FORCESCAN) join student_transcripts_tracking.addresses as t2 WITH (FORCESCAN) on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Addresses ] Output [ address_id , country ] ; #2 = Scan Table [ Students ] Output [ cell_mobile_number , permanent_address_id , first_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.permanent_address_id = #1.address_id ] Output [ #2.first_name , #2.cell_mobile_number , #1.country ] ; #4 = Filter [ #3 ] Predicate [ country = 'haiti' OR cell_mobile_number = '09700166582' ] Output [ first_name ]",
    "prefixed_qpl":"student_transcripts_tracking | #1 = Scan Table [ Addresses ] Output [ address_id , country ] ; #2 = Scan Table [ Students ] Output [ cell_mobile_number , permanent_address_id , first_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.permanent_address_id = #1.address_id ] Output [ #2.first_name , #2.cell_mobile_number , #1.country ] ; #4 = Filter [ #3 ] Predicate [ country = 'haiti' OR cell_mobile_number = '09700166582' ] Output [ first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT address_id, country FROM student_transcripts_tracking.Addresses ), Scan_2 AS ( SELECT cell_mobile_number, permanent_address_id, first_name FROM student_transcripts_tracking.Students ), Join_3 AS ( SELECT Scan_2.first_name, Scan_2.cell_mobile_number, Scan_1.country FROM Scan_1 JOIN Scan_2 ON Scan_2.permanent_address_id = Scan_1.address_id ), Filter_4 AS ( SELECT first_name FROM Join_3 WHERE country = 'haiti' OR cell_mobile_number = '09700166582' ) SELECT * FROM Filter_4",
    "clean_query":"select t1.first_name FROM student_transcripts_tracking.students AS t1  join student_transcripts_tracking.addresses as t2  on t1.permanent_address_id = t2.address_id where t2.country = 'haiti' or t1.cell_mobile_number = '09700166582'"
  },
  {
    "id":"83393630216ab26b6fab91f2a2babda82dc85c460b21671995a86dfb3b40b45c",
    "db_id":"tvshow",
    "question":"List the title of all cartoons in alphabetical order.",
    "query":"SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY title OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Title ] ; #2 = Sort [ #1 ] OrderBy [ Title ASC ] Output [ Title ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Title ] ; #2 = Sort [ #1 ] OrderBy [ Title ASC ] Output [ Title ]",
    "cte":"WITH Scan_1 AS ( SELECT Title FROM tvshow.Cartoon ) SELECT Title FROM Scan_1 ORDER BY Title ASC",
    "clean_query":"SELECT Title FROM tvshow.Cartoon  ORDER BY title"
  },
  {
    "id":"a43b9140724231649b4ddbab7229b1aa922a38418117b56994c953b9d5eaa96c",
    "db_id":"tvshow",
    "question":"What are the titles of the cartoons sorted alphabetically?",
    "query":"SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY title OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Title ] ; #2 = Sort [ #1 ] OrderBy [ Title ASC ] Output [ Title ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Title ] ; #2 = Sort [ #1 ] OrderBy [ Title ASC ] Output [ Title ]",
    "cte":"WITH Scan_1 AS ( SELECT Title FROM tvshow.Cartoon ) SELECT Title FROM Scan_1 ORDER BY Title ASC",
    "clean_query":"SELECT Title FROM tvshow.Cartoon  ORDER BY title"
  },
  {
    "id":"dbbbe82c51d0aeb8bf96cdb30d579d6edc0ac34004b3f04fcea2e9b6f8fdb3c1",
    "db_id":"tvshow",
    "question":"List all cartoon directed by \"Ben Jones\".",
    "query":"SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Title , Directed_by ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Title , Directed_by ]",
    "cte":"WITH Scan_1 AS ( SELECT Title, Directed_by FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones'"
  },
  {
    "id":"bc01be7fce4867f664d6814ae240bfc097023a0d8bcc6196449757b046ef01a3",
    "db_id":"tvshow",
    "question":"What are the names of all cartoons directed by Ben Jones?",
    "query":"SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Title , Directed_by ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Title , Directed_by ]",
    "cte":"WITH Scan_1 AS ( SELECT Title, Directed_by FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones'"
  },
  {
    "id":"916a509f0948cff8af77cf3a8a8905ca4e5a6dafdc6ddb386cc27f529e15253e",
    "db_id":"tvshow",
    "question":"How many cartoons were written by \"Joseph Kuhr\"?",
    "query":"SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Written_by = 'Joseph Kuhr'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Joseph Kuhr' ] Output [ Written_by ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Joseph Kuhr' ] Output [ Written_by ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Written_by FROM tvshow.Cartoon WHERE Written_by = 'Joseph Kuhr' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon  WHERE Written_by = 'Joseph Kuhr'"
  },
  {
    "id":"4fc046eaa05a69a8810508b57112267cd85a6423220b08115f978f1ece9484c9",
    "db_id":"tvshow",
    "question":"What is the number of cartoones written by Joseph Kuhr?",
    "query":"SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Written_by = 'Joseph Kuhr'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Joseph Kuhr' ] Output [ Written_by ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Joseph Kuhr' ] Output [ Written_by ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Written_by FROM tvshow.Cartoon WHERE Written_by = 'Joseph Kuhr' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM tvshow.Cartoon  WHERE Written_by = 'Joseph Kuhr'"
  },
  {
    "id":"7a5f7faeae28debe426151c8e824472857dbcfafd49de540e5824d750266034f",
    "db_id":"tvshow",
    "question":"list all cartoon titles and their directors ordered by their air date",
    "query":"SELECT title , Directed_by FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY Original_air_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Title , Directed_by , Original_air_date ] ; #2 = Sort [ #1 ] OrderBy [ Original_air_date ASC ] Output [ Title , Directed_by , Original_air_date ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Title , Directed_by , Original_air_date ] ; #2 = Sort [ #1 ] OrderBy [ Original_air_date ASC ] Output [ Title , Directed_by , Original_air_date ]",
    "cte":"WITH Scan_1 AS ( SELECT Title, Directed_by, Original_air_date FROM tvshow.Cartoon ) SELECT Title, Directed_by, Original_air_date FROM Scan_1 ORDER BY Original_air_date ASC",
    "clean_query":"SELECT title , Directed_by FROM tvshow.Cartoon  ORDER BY Original_air_date"
  },
  {
    "id":"fb9cbfdceb6a3362120b75015476a3bdc879639245debb86984e0edc8b39b35e",
    "db_id":"tvshow",
    "question":"What is the name and directors of all the cartoons that are ordered by air date?",
    "query":"SELECT title , Directed_by FROM tvshow.Cartoon WITH (FORCESCAN) ORDER BY Original_air_date OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Title , Directed_by , Original_air_date ] ; #2 = Sort [ #1 ] OrderBy [ Original_air_date ASC ] Output [ Title , Directed_by , Original_air_date ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Title , Directed_by , Original_air_date ] ; #2 = Sort [ #1 ] OrderBy [ Original_air_date ASC ] Output [ Title , Directed_by , Original_air_date ]",
    "cte":"WITH Scan_1 AS ( SELECT Title, Directed_by, Original_air_date FROM tvshow.Cartoon ) SELECT Title, Directed_by, Original_air_date FROM Scan_1 ORDER BY Original_air_date ASC",
    "clean_query":"SELECT title , Directed_by FROM tvshow.Cartoon  ORDER BY Original_air_date"
  },
  {
    "id":"8c22247b347d4e3a016d6cf1c8b13a1bf4dc34f953f590d860f9f4901eaf98fd",
    "db_id":"tvshow",
    "question":"List the title of all cartoon directed by \"Ben Jones\" or \"Brandon Vietti\".",
    "query":"SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ] Output [ Title , Directed_by ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ] Output [ Title , Directed_by ]",
    "cte":"WITH Scan_1 AS ( SELECT Title, Directed_by FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'"
  },
  {
    "id":"845de45b965c3b3970089c390863ec33e835ecd3505b2b6734403f82f9483f47",
    "db_id":"tvshow",
    "question":"What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?",
    "query":"SELECT Title FROM tvshow.Cartoon WITH (FORCESCAN) WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ] Output [ Title , Directed_by ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ] Output [ Title , Directed_by ]",
    "cte":"WITH Scan_1 AS ( SELECT Title, Directed_by FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Title FROM tvshow.Cartoon  WHERE Directed_by = 'Ben Jones' OR Directed_by = 'Brandon Vietti'"
  },
  {
    "id":"da8cd4bbfc74b3388a037e8ca179f7adc6b22bbe197285d40fb33fa0f18b6fb2",
    "db_id":"tvshow",
    "question":"Which country has the most of TV Channels? List the country and number of TV Channels it has.",
    "query":"SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY Country ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Country ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Country ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Country FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY Country ORDER BY count ( * ) DESC"
  },
  {
    "id":"95a64f969855e9817719f0ec18278eba85b5e86a4c520343b59cce05a0f425e1",
    "db_id":"tvshow",
    "question":"What is the country with the most number of TV Channels and how many does it have?",
    "query":"SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY Country ORDER BY count ( * ) DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Country ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Country ] ; #2 = Aggregate [ #1 ] GroupBy [ Country ] Output [ Country , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Country ]",
    "cte":"WITH Scan_1 AS ( SELECT Country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Country, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Country ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Country FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Country , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY Country ORDER BY count ( * ) DESC"
  },
  {
    "id":"48aba4e97ed55fd23a7b7f378e185c1043acaaacc7cc04191774930eac1a2559",
    "db_id":"tvshow",
    "question":"List the number of different series names and contents in the TV Channel table.",
    "query":"SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel WITH (FORCESCAN)  ",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ series_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT series_name) AS Count_Dist_series_name ] ; #3 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Content ] ; #4 = Aggregate [ #3 ] Output [ COUNT(DISTINCT Content) AS Count_Dist_Content ] ; #5 = Join [ #2 , #4 ] Output [ #4.Count_Dist_Content , #2.Count_Dist_series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ series_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT series_name) AS Count_Dist_series_name ] ; #3 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Content ] ; #4 = Aggregate [ #3 ] Output [ COUNT(DISTINCT Content) AS Count_Dist_Content ] ; #5 = Join [ #2 , #4 ] Output [ #4.Count_Dist_Content , #2.Count_Dist_series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT series_name FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(DISTINCT series_name) AS Count_Dist_series_name FROM Scan_1 ), Scan_3 AS ( SELECT DISTINCT Content FROM tvshow.TV_Channel ), Aggregate_4 AS ( SELECT COUNT(DISTINCT Content) AS Count_Dist_Content FROM Scan_3 ), Join_5 AS ( SELECT Aggregate_4.Count_Dist_Content, Aggregate_2.Count_Dist_series_name FROM Aggregate_2 CROSS JOIN Aggregate_4 ) SELECT * FROM Join_5",
    "clean_query":"SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel"
  },
  {
    "id":"083277424cc72b24b52d3e290a538f559469a57cd0a48ed24160555273b717de",
    "db_id":"tvshow",
    "question":"How many different series and contents are listed in the TV Channel table?",
    "query":"SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel WITH (FORCESCAN)  ",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ series_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT series_name) AS Count_Dist_series_name ] ; #3 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Content ] ; #4 = Aggregate [ #3 ] Output [ COUNT(DISTINCT Content) AS Count_Dist_Content ] ; #5 = Join [ #2 , #4 ] Output [ #4.Count_Dist_Content , #2.Count_Dist_series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ series_name ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT series_name) AS Count_Dist_series_name ] ; #3 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Content ] ; #4 = Aggregate [ #3 ] Output [ COUNT(DISTINCT Content) AS Count_Dist_Content ] ; #5 = Join [ #2 , #4 ] Output [ #4.Count_Dist_Content , #2.Count_Dist_series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT series_name FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(DISTINCT series_name) AS Count_Dist_series_name FROM Scan_1 ), Scan_3 AS ( SELECT DISTINCT Content FROM tvshow.TV_Channel ), Aggregate_4 AS ( SELECT COUNT(DISTINCT Content) AS Count_Dist_Content FROM Scan_3 ), Join_5 AS ( SELECT Aggregate_4.Count_Dist_Content, Aggregate_2.Count_Dist_series_name FROM Aggregate_2 CROSS JOIN Aggregate_4 ) SELECT * FROM Join_5",
    "clean_query":"SELECT count ( DISTINCT series_name ) AS Count_Dist_series_name , count ( DISTINCT content ) AS Count_Dist_content FROM tvshow.TV_Channel"
  },
  {
    "id":"2ecd289b6fa8307e7eaee7f29ec9f80701fd8cde59870b09aa00e307ff7ad0f0",
    "db_id":"tvshow",
    "question":"What is the content of TV Channel with serial name \"Sky Radio\"?",
    "query":"SELECT Content FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Content , series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Content , series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Content, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Content FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'"
  },
  {
    "id":"d0c1275920417bc3e083a6ffa3814d5dbd98e9791189c35e9c83e797092aa2c2",
    "db_id":"tvshow",
    "question":"What is the content of the series Sky Radio?",
    "query":"SELECT Content FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Content , series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Content , series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Content, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Content FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'"
  },
  {
    "id":"c88891737613a4d053e155f72e36d99af9f1e6c24735c66f1070319dacf69229",
    "db_id":"tvshow",
    "question":"What is the Package Option of TV Channel with serial name \"Sky Radio\"?",
    "query":"SELECT Package_Option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Package_Option , series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Package_Option , series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Package_Option, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Package_Option FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'"
  },
  {
    "id":"5cc42c682b5f85b204d17a77cab55f313f590e22ca5b0bdcd9e04dc092cfa830",
    "db_id":"tvshow",
    "question":"What are the Package Options of the TV Channels whose series names are Sky Radio?",
    "query":"SELECT Package_Option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Package_Option , series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ Package_Option , series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Package_Option, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Package_Option FROM tvshow.TV_Channel  WHERE series_name = 'Sky Radio'"
  },
  {
    "id":"42c58734b7b2117d31f7c8ae5a8fcb3ee80e9712f2b48d534c7896cc0edf9681",
    "db_id":"tvshow",
    "question":"How many TV Channel using language English?",
    "query":"SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE LANGUAGE = 'English'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ Language = 'English' ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language = 'English' ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel WHERE Language = 'English' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel  WHERE LANGUAGE = 'English'"
  },
  {
    "id":"a44b097d3f024e039d7a10d6b30bd8c5732316000159a260fef28e3ea1b0471c",
    "db_id":"tvshow",
    "question":"How many TV Channels use the English language?",
    "query":"SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE LANGUAGE = 'English'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ Language = 'English' ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language = 'English' ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel WHERE Language = 'English' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM tvshow.TV_Channel  WHERE LANGUAGE = 'English'"
  },
  {
    "id":"37e62b783f69df48aa3ec8d6e649c65292819d95b61eac824d791d914bc56cf0",
    "db_id":"tvshow",
    "question":"List the language used least number of TV Channel. List language and number of TV Channel.",
    "query":"SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) ASC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Language ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Language FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE ORDER BY count ( * ) ASC"
  },
  {
    "id":"b4bf1579616f30d8191511ad0538c28b203ba0c36abbed3cf7d6fb7af1590c25",
    "db_id":"tvshow",
    "question":"What are the languages used by the least number of TV Channels and how many channels use it?",
    "query":"SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) ASC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Language ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Language FROM Aggregate_2 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE ORDER BY count ( * ) ASC"
  },
  {
    "id":"3020ddb5623bc3540cb9939da3f22bd066bc0e6679425deaf65e0faadfecbd31",
    "db_id":"tvshow",
    "question":"List each language and the number of TV Channels using it.",
    "query":"SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE"
  },
  {
    "id":"ab86e3891f95a394dbe0237a414d25eb65194fc3e353b440873e332010727c71",
    "db_id":"tvshow",
    "question":"For each language, list the number of TV Channels that use it.",
    "query":"SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY LANGUAGE OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT LANGUAGE , count ( * ) AS Count_Star FROM tvshow.TV_Channel  GROUP BY LANGUAGE"
  },
  {
    "id":"312ecca6914f2c420ffd5f838287d2bd37e5588d4adca8b138affdbf865a7f5c",
    "db_id":"tvshow",
    "question":"What is the TV Channel that shows the cartoon \"The Rise of the Blue Beetle!\"? List the TV Channel's series name.",
    "query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Title = 'The Rise of the Blue Beetle!' ] Output [ Channel , Title ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Title = 'The Rise of the Blue Beetle!' ] Output [ Channel , Title ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Channel, Title FROM tvshow.Cartoon WHERE Title = 'The Rise of the Blue Beetle!' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'"
  },
  {
    "id":"cbabb0f4acf5348df82086edafeb33e346d67ddb5ecf5f10dedfd657044434a3",
    "db_id":"tvshow",
    "question":"What is the series name of the TV Channel that shows the cartoon \"The Rise of the Blue Beetle\"?",
    "query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Title = 'The Rise of the Blue Beetle!' ] Output [ Channel , Title ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Title = 'The Rise of the Blue Beetle!' ] Output [ Channel , Title ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Channel, Title FROM tvshow.Cartoon WHERE Title = 'The Rise of the Blue Beetle!' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T2.Title = 'The Rise of the Blue Beetle!'"
  },
  {
    "id":"67ad6ffc709d3e44ff5f84c9af0a4d2e16a89919d6c6f723b770165a6314e930",
    "db_id":"tvshow",
    "question":"List the title of all  Cartoons showed on TV Channel with series name \"Sky Radio\".",
    "query":"SELECT T2.Title FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ Cartoon ] Output [ Title , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Title ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ Cartoon ] Output [ Title , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Title ]",
    "cte":"WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Title, Channel FROM tvshow.Cartoon ), Join_3 AS ( SELECT Scan_2.Title FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.Title FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
  },
  {
    "id":"cc65ca5065252da2020bf5040dd74af587bed02d69e4980d862e8216f0a767b3",
    "db_id":"tvshow",
    "question":"What is the title of all the cartools that are on the TV Channel with the series name \"Sky Radio\"?",
    "query":"SELECT T2.Title FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.Cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ Cartoon ] Output [ Title , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Title ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ Cartoon ] Output [ Title , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Title ]",
    "cte":"WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Title, Channel FROM tvshow.Cartoon ), Join_3 AS ( SELECT Scan_2.Title FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.Title FROM tvshow.TV_Channel AS T1  JOIN tvshow.Cartoon AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
  },
  {
    "id":"4af53503bdc21b5142677ed8df8d47ab8618267cae7b31f47a0953918d948d2a",
    "db_id":"tvshow",
    "question":"List the Episode of all TV series sorted by rating.",
    "query":"SELECT Episode FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY rating OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = Sort [ #1 ] OrderBy [ Rating ASC ] Output [ Rating , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = Sort [ #1 ] OrderBy [ Rating ASC ] Output [ Rating , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ) SELECT Rating, Episode FROM Scan_1 ORDER BY Rating ASC",
    "clean_query":"SELECT Episode FROM tvshow.TV_series  ORDER BY rating"
  },
  {
    "id":"4b0a022ab96f7a4a516115996f72cb33a909184ac542d5a74415bce23b7c24a8",
    "db_id":"tvshow",
    "question":"What are all of the episodes ordered by ratings?",
    "query":"SELECT Episode FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY rating OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = Sort [ #1 ] OrderBy [ Rating ASC ] Output [ Rating , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = Sort [ #1 ] OrderBy [ Rating ASC ] Output [ Rating , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ) SELECT Rating, Episode FROM Scan_1 ORDER BY Rating ASC",
    "clean_query":"SELECT Episode FROM tvshow.TV_series  ORDER BY rating"
  },
  {
    "id":"3b9f0f36bbd855cfee9bb2d646369dc4a8280d0621cd411f99915cdaaac6739a",
    "db_id":"tvshow",
    "question":"List top 3 highest Rating  TV series. List the TV series's Episode and Rating.",
    "query":"SELECT TOP 3 Episode , Rating FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY Rating DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Rating DESC ] Output [ Rating , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Rating DESC ] Output [ Rating , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ), TopSort_2 AS ( SELECT TOP 3 Rating, Episode FROM Scan_1 ORDER BY Rating DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 3 Episode , Rating FROM tvshow.TV_series  ORDER BY Rating DESC"
  },
  {
    "id":"680ba48e48448ad6bc596a4098af77b8f44684a2676f89ea8faf15035aa7e516",
    "db_id":"tvshow",
    "question":"What are 3 most highly rated episodes in the TV series table and what were those ratings?",
    "query":"SELECT TOP 3 Episode , Rating FROM tvshow.TV_series WITH (FORCESCAN) ORDER BY Rating DESC  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Rating DESC ] Output [ Rating , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Output [ Rating , Episode ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Rating DESC ] Output [ Rating , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Rating, Episode FROM tvshow.TV_series ), TopSort_2 AS ( SELECT TOP 3 Rating, Episode FROM Scan_1 ORDER BY Rating DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 3 Episode , Rating FROM tvshow.TV_series  ORDER BY Rating DESC"
  },
  {
    "id":"2e383ebce0c62942782b4210e6a1afa87716bc51cd92d0f5cdb21c1209ef2847",
    "db_id":"tvshow",
    "question":"What is minimum and maximum share of TV series?",
    "query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_series ] Output [ Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Output [ Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "cte":"WITH Scan_1 AS ( SELECT Share FROM tvshow.TV_series ), Aggregate_2 AS ( SELECT MIN(Share) AS Min_Share, MAX(Share) AS Max_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series"
  },
  {
    "id":"0d0142deb8de8f5219172ede8c642c91ddae82dd31bf4d779468a6fd3c876d10",
    "db_id":"tvshow",
    "question":"What is the maximum and minimum share for the TV series?",
    "query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series WITH (FORCESCAN)  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_series ] Output [ Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Output [ Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "cte":"WITH Scan_1 AS ( SELECT Share FROM tvshow.TV_series ), Aggregate_2 AS ( SELECT MIN(Share) AS Min_Share, MAX(Share) AS Max_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM tvshow.TV_series"
  },
  {
    "id":"3c6d87c1ae7bbff92689d133bff4b619478545457a0610d9ed0e01a8819082c3",
    "db_id":"tvshow",
    "question":"What is the air date of TV series with Episode \"A Love of a Lifetime\"?",
    "query":"SELECT Air_Date FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Air_Date , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Air_Date , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Air_Date, Episode FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Air_Date FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'"
  },
  {
    "id":"e76fdac7b3d43bfbb98970b3914f8afa9705c4d943431cbb16e627f0c60ee527",
    "db_id":"tvshow",
    "question":"When did the episode \"A Love of a Lifetime\" air?",
    "query":"SELECT Air_Date FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Air_Date , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Air_Date , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Air_Date, Episode FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Air_Date FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'"
  },
  {
    "id":"e0000e04d7b1f0b4787cee1a9cad5012af99c9d21b96a02abe5b69467345fa8b",
    "db_id":"tvshow",
    "question":"What is Weekly Rank of TV series with Episode \"A Love of a Lifetime\"?",
    "query":"SELECT Weekly_Rank FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Weekly_Rank , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Weekly_Rank , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Weekly_Rank, Episode FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Weekly_Rank FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'"
  },
  {
    "id":"73165e09ea1c7c3e8c2058b4d3ae9211344a042bda319db31c06871c272683e2",
    "db_id":"tvshow",
    "question":"What is the weekly rank for the episode \"A Love of a Lifetime\"?",
    "query":"SELECT Weekly_Rank FROM tvshow.TV_series WITH (FORCESCAN) WHERE Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Weekly_Rank , Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Weekly_Rank , Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT Weekly_Rank, Episode FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Weekly_Rank FROM tvshow.TV_series  WHERE Episode = 'A Love of a Lifetime'"
  },
  {
    "id":"c8b3f1ae55f0334741eb68f99155ba70466e54b6e14fdf47419475fbf841cada",
    "db_id":"tvshow",
    "question":"What is the TV Channel of TV series with Episode \"A Love of a Lifetime\"? List the TV Channel's series name.",
    "query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Episode, Channel FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
  },
  {
    "id":"dce5580fa604cef1b7013efde88ea414c1480828f0c15e0c53b05b4ef6ff025b",
    "db_id":"tvshow",
    "question":"What is the name of the series that has the episode \"A Love of a Lifetime\"?",
    "query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_series ] Predicate [ Episode = 'A Love of a Lifetime' ] Output [ Episode , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Episode, Channel FROM tvshow.TV_series WHERE Episode = 'A Love of a Lifetime' ), Scan_2 AS ( SELECT id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.series_name FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T2.Episode = 'A Love of a Lifetime'"
  },
  {
    "id":"e75fca8acdfc313eda670c300d1d3931ee4ab7bc8f3ae5fd929fe9f48b3b1e4e",
    "db_id":"tvshow",
    "question":"List the Episode of all  TV series showed on TV Channel with series name \"Sky Radio\".",
    "query":"SELECT T2.Episode FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ TV_series ] Output [ Episode , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ TV_series ] Output [ Episode , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Episode, Channel FROM tvshow.TV_series ), Join_3 AS ( SELECT Scan_2.Episode FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.Episode FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
  },
  {
    "id":"61b6eaccc94d6d2900ca8a1d8163d9c358c6a9d2034e1abc1e0f04df540300a6",
    "db_id":"tvshow",
    "question":"What is the episode for the TV series named \"Sky Radio\"?",
    "query":"SELECT T2.Episode FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.TV_series AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'  OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ TV_series ] Output [ Episode , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Episode ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ series_name = 'Sky Radio' ] Output [ id , series_name ] ; #2 = Scan Table [ TV_series ] Output [ Episode , Channel ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.id = #2.Channel ] Output [ #2.Episode ]",
    "cte":"WITH Scan_1 AS ( SELECT id, series_name FROM tvshow.TV_Channel WHERE series_name = 'Sky Radio' ), Scan_2 AS ( SELECT Episode, Channel FROM tvshow.TV_series ), Join_3 AS ( SELECT Scan_2.Episode FROM Scan_1 JOIN Scan_2 ON Scan_1.id = Scan_2.Channel ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.Episode FROM tvshow.TV_Channel AS T1  JOIN tvshow.TV_series AS T2  ON T1.id = T2.Channel WHERE T1.series_name = 'Sky Radio'"
  },
  {
    "id":"4ab4d8bcc47a07a29ea3496adc3b48879e72fe4cfc5f8a0a2d496c8918645efc",
    "db_id":"tvshow",
    "question":"Find the number of cartoons directed by each of the listed directors.",
    "query":"SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon WITH (FORCESCAN) GROUP BY Directed_by OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Directed_by ] ; #2 = Aggregate [ #1 ] GroupBy [ Directed_by ] Output [ Directed_by , countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Directed_by ] ; #2 = Aggregate [ #1 ] GroupBy [ Directed_by ] Output [ Directed_by , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Directed_by FROM tvshow.Cartoon ), Aggregate_2 AS ( SELECT Directed_by, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Directed_by ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon  GROUP BY Directed_by"
  },
  {
    "id":"e835c56211f4c9c6c4b47bb293e2ebc043d28551a4456f405a8473f234ffbbfa",
    "db_id":"tvshow",
    "question":"How many cartoons did each director create?",
    "query":"SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon WITH (FORCESCAN) GROUP BY Directed_by OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Directed_by ] ; #2 = Aggregate [ #1 ] GroupBy [ Directed_by ] Output [ Directed_by , countstar AS Count_Star ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Directed_by ] ; #2 = Aggregate [ #1 ] GroupBy [ Directed_by ] Output [ Directed_by , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Directed_by FROM tvshow.Cartoon ), Aggregate_2 AS ( SELECT Directed_by, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Directed_by ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , Directed_by FROM tvshow.cartoon  GROUP BY Directed_by"
  },
  {
    "id":"6cb24d73bd9d6854c0c145accf850e49e98a77696072a3e9f52e58a90d56a1ae",
    "db_id":"tvshow",
    "question":"Find the production code and channel of the most recently aired cartoon .",
    "query":"select TOP 1 production_code , channel FROM tvshow.cartoon WITH (FORCESCAN) order by original_air_date desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Original_air_date , Production_code , Channel ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Original_air_date DESC ] Output [ Original_air_date , Production_code , Channel ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Original_air_date , Production_code , Channel ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Original_air_date DESC ] Output [ Original_air_date , Production_code , Channel ]",
    "cte":"WITH Scan_1 AS ( SELECT Original_air_date, Production_code, Channel FROM tvshow.Cartoon ), TopSort_2 AS ( SELECT TOP 1 Original_air_date, Production_code, Channel FROM Scan_1 ORDER BY Original_air_date DESC ) SELECT * FROM TopSort_2",
    "clean_query":"select TOP 1 production_code , channel FROM tvshow.cartoon  order by original_air_date desc"
  },
  {
    "id":"bd73120de1d8750d59209a5ddee60a05cb1e802dcf56822cc36df4a5c48897a2",
    "db_id":"tvshow",
    "question":"What is the produdction code and channel of the most recent cartoon ?",
    "query":"select TOP 1 production_code , channel FROM tvshow.cartoon WITH (FORCESCAN) order by original_air_date desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Output [ Original_air_date , Production_code , Channel ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Original_air_date DESC ] Output [ Original_air_date , Production_code , Channel ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Output [ Original_air_date , Production_code , Channel ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Original_air_date DESC ] Output [ Original_air_date , Production_code , Channel ]",
    "cte":"WITH Scan_1 AS ( SELECT Original_air_date, Production_code, Channel FROM tvshow.Cartoon ), TopSort_2 AS ( SELECT TOP 1 Original_air_date, Production_code, Channel FROM Scan_1 ORDER BY Original_air_date DESC ) SELECT * FROM TopSort_2",
    "clean_query":"select TOP 1 production_code , channel FROM tvshow.cartoon  order by original_air_date desc"
  },
  {
    "id":"bf9ddbd285a985059dab1d4b5e14d0f1eb5b056a7d8547bf2194f977af1ee913",
    "db_id":"tvshow",
    "question":"Find the package choice and series name of the TV channel that has high definition TV.",
    "query":"SELECT package_option , series_name FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE hight_definition_TV = 'yes' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ Hight_definition_TV = 'yes' ] Output [ Package_Option , Hight_definition_TV , series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Hight_definition_TV = 'yes' ] Output [ Package_Option , Hight_definition_TV , series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Package_Option, Hight_definition_TV, series_name FROM tvshow.TV_Channel WHERE Hight_definition_TV = 'yes' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT package_option , series_name FROM tvshow.TV_Channel  WHERE hight_definition_TV = 'yes'"
  },
  {
    "id":"f0e91e76e174c126de5c9c0d6245a9120aaa03ae0ff59b30f94247798be5350f",
    "db_id":"tvshow",
    "question":"What are the package options and the name of the series for the TV Channel that supports high definition TV?",
    "query":"SELECT package_option , series_name FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE hight_definition_TV = 'yes' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ Hight_definition_TV = 'yes' ] Output [ Package_Option , Hight_definition_TV , series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Hight_definition_TV = 'yes' ] Output [ Package_Option , Hight_definition_TV , series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Package_Option, Hight_definition_TV, series_name FROM tvshow.TV_Channel WHERE Hight_definition_TV = 'yes' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT package_option , series_name FROM tvshow.TV_Channel  WHERE hight_definition_TV = 'yes'"
  },
  {
    "id":"64753597dc7d6d2a32db6eda3baa31e7ee2d2fb6ecd4b920fe5b970040457805",
    "db_id":"tvshow",
    "question":"which countries' tv channels are playing some cartoon written by Todd Casey?",
    "query":"SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.Country ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.Country ]",
    "cte":"WITH Scan_1 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_2 AS ( SELECT Country, id FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.Country FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'"
  },
  {
    "id":"0c75ccfe4d4b0ec47c5677e32113c1b28aaf51d4a93834a03fe8f1674d1f650d",
    "db_id":"tvshow",
    "question":"What are the countries that have cartoons on TV that were written by Todd Casey?",
    "query":"SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.Country ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Output [ #2.Country ]",
    "cte":"WITH Scan_1 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_2 AS ( SELECT Country, id FROM tvshow.TV_Channel ), Join_3 AS ( SELECT Scan_2.Country FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'"
  },
  {
    "id":"dc9fa93cafe7bbc0200c3ea1a4db537478df1395d50ebeb37cca2c2cf91f79c6",
    "db_id":"tvshow",
    "question":"which countries' tv channels are not playing any cartoon written by Todd Casey?",
    "query":"SELECT country FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Country ] ; #2 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #3 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Channel = #3.id ] Output [ #3.Country ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Country = #4.Country ] Output [ #1.Country ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Country ] ; #2 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #3 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Channel = #3.id ] Output [ #3.Country ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Country = #4.Country ] Output [ #1.Country ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Country FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_3 AS ( SELECT Country, id FROM tvshow.TV_Channel ), Join_4 AS ( SELECT Scan_3.Country FROM Scan_2 JOIN Scan_3 ON Scan_2.Channel = Scan_3.id ), Except_5 AS ( SELECT Scan_1.Country FROM Scan_1 WHERE Country NOT IN (SELECT Country FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT country FROM tvshow.TV_Channel  EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'"
  },
  {
    "id":"e544df3d47b4c732fba6bbe69959eb06d71a4b9701f1c2d772f07a2bd1a3e3b4",
    "db_id":"tvshow",
    "question":"What are the countries that are not playing cartoons written by Todd Casey?",
    "query":"SELECT country FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Country ] ; #2 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #3 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Channel = #3.id ] Output [ #3.Country ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Country = #4.Country ] Output [ #1.Country ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Distinct [ true ] Output [ Country ] ; #2 = Scan Table [ Cartoon ] Predicate [ Written_by = 'Todd Casey' ] Output [ Written_by , Channel ] ; #3 = Scan Table [ TV_Channel ] Output [ Country , id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Channel = #3.id ] Output [ #3.Country ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Country = #4.Country ] Output [ #1.Country ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Country FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Written_by, Channel FROM tvshow.Cartoon WHERE Written_by = 'Todd Casey' ), Scan_3 AS ( SELECT Country, id FROM tvshow.TV_Channel ), Join_4 AS ( SELECT Scan_3.Country FROM Scan_2 JOIN Scan_3 ON Scan_2.Channel = Scan_3.id ), Except_5 AS ( SELECT Scan_1.Country FROM Scan_1 WHERE Country NOT IN (SELECT Country FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT country FROM tvshow.TV_Channel  EXCEPT SELECT T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.written_by = 'Todd Casey'"
  },
  {
    "id":"1e794a6002b4eb201d69fd387733237b9ee039ee07e7e045ed7bcba1df37db8f",
    "db_id":"tvshow",
    "question":"Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?",
    "query":"SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Michael Chang' ] Output [ Directed_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Distinct [ true ] Output [ #2.Country , #2.series_name ] ; #4 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #5 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Channel = #5.id ] Output [ #5.series_name , #5.Country ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.series_name = #6.series_name ] Output [ #3.Country , #3.series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Michael Chang' ] Output [ Directed_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Distinct [ true ] Output [ #2.Country , #2.series_name ] ; #4 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #5 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Channel = #5.id ] Output [ #5.series_name , #5.Country ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.series_name = #6.series_name ] Output [ #3.Country , #3.series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Michael Chang' ), Scan_2 AS ( SELECT Country, id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT DISTINCT Scan_2.Country, Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ), Scan_4 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Scan_5 AS ( SELECT Country, id, series_name FROM tvshow.TV_Channel ), Join_6 AS ( SELECT Scan_5.series_name, Scan_5.Country FROM Scan_4 JOIN Scan_5 ON Scan_4.Channel = Scan_5.id ), Intersect_7 AS ( SELECT Join_3.Country, Join_3.series_name FROM Join_3 WHERE series_name IN (SELECT series_name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones'"
  },
  {
    "id":"e6393c117f414da854c082eff60f93bd0300723381b35c6e2b65aaba840d0ea0",
    "db_id":"tvshow",
    "question":"What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?",
    "query":"SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1 WITH (FORCESCAN) JOIN tvshow.cartoon AS T2 WITH (FORCESCAN) ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Michael Chang' ] Output [ Directed_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Distinct [ true ] Output [ #2.Country , #2.series_name ] ; #4 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #5 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Channel = #5.id ] Output [ #5.series_name , #5.Country ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.series_name = #6.series_name ] Output [ #3.Country , #3.series_name ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Michael Chang' ] Output [ Directed_by , Channel ] ; #2 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Channel = #2.id ] Distinct [ true ] Output [ #2.Country , #2.series_name ] ; #4 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #5 = Scan Table [ TV_Channel ] Output [ Country , id , series_name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.Channel = #5.id ] Output [ #5.series_name , #5.Country ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.series_name = #6.series_name ] Output [ #3.Country , #3.series_name ]",
    "cte":"WITH Scan_1 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Michael Chang' ), Scan_2 AS ( SELECT Country, id, series_name FROM tvshow.TV_Channel ), Join_3 AS ( SELECT DISTINCT Scan_2.Country, Scan_2.series_name FROM Scan_1 JOIN Scan_2 ON Scan_1.Channel = Scan_2.id ), Scan_4 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Scan_5 AS ( SELECT Country, id, series_name FROM tvshow.TV_Channel ), Join_6 AS ( SELECT Scan_5.series_name, Scan_5.Country FROM Scan_4 JOIN Scan_5 ON Scan_4.Channel = Scan_5.id ), Intersect_7 AS ( SELECT Join_3.Country, Join_3.series_name FROM Join_3 WHERE series_name IN (SELECT series_name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Michael Chang' INTERSECT SELECT T1.series_name , T1.country FROM tvshow.TV_Channel AS T1  JOIN tvshow.cartoon AS T2  ON T1.id = T2.Channel WHERE T2.directed_by = 'Ben Jones'"
  },
  {
    "id":"c64e0faa9e89897971fbbb82dd7381df2d0f37bc67ff227a876b71f041eb036f",
    "db_id":"tvshow",
    "question":"find the pixel aspect ratio and nation of the tv channels that do not use English.",
    "query":"SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ Language <> 'English' ] Output [ Country , Pixel_aspect_ratio_PAR , Language ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language <> 'English' ] Output [ Country , Pixel_aspect_ratio_PAR , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Country, Pixel_aspect_ratio_PAR, Language FROM tvshow.TV_Channel WHERE Language <> 'English' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel  WHERE LANGUAGE ! = 'English'"
  },
  {
    "id":"216deec7ce39e86c5ef67a4c5259db2aeabae0a3db17c2270cc93df36cee7e30",
    "db_id":"tvshow",
    "question":"What is the pixel aspect ratio and country of origin for all TV channels that do not use English?",
    "query":"SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ TV_Channel ] Predicate [ Language <> 'English' ] Output [ Country , Pixel_aspect_ratio_PAR , Language ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Predicate [ Language <> 'English' ] Output [ Country , Pixel_aspect_ratio_PAR , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Country, Pixel_aspect_ratio_PAR, Language FROM tvshow.TV_Channel WHERE Language <> 'English' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Pixel_aspect_ratio_PAR , country FROM tvshow.tv_channel  WHERE LANGUAGE ! = 'English'"
  },
  {
    "id":"34ae116d68862a3d031e45083c8c14f67053408224f2484c61530216d7152422",
    "db_id":"tvshow",
    "question":"Find the ids of tv channels that are from countries that have more than two\u00a0tv\u00a0channels.",
    "query":"SELECT id FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE Country IN (SELECT Country FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY Country HAVING COUNT\u00a0(\u00a0*\u00a0)\u00a0>\u00a02)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ id , country ] ; #2 = Aggregate [ #1 ] GroupBy [ country ] Output [ countstar AS Count_Star , country ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 2 ] Output [ country ] ; #4 = Intersect [ #1 , #3 ] Predicate [ #1.country = #3.country ] Output [ #1.id ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ id , country ] ; #2 = Aggregate [ #1 ] GroupBy [ country ] Output [ countstar AS Count_Star , country ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 2 ] Output [ country ] ; #4 = Intersect [ #1 , #3 ] Predicate [ #1.country = #3.country ] Output [ #1.id ]",
    "cte":"WITH Scan_1 AS ( SELECT id, country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country FROM Scan_1 GROUP BY country ), Filter_3 AS ( SELECT country FROM Aggregate_2 WHERE Count_Star > 2 ), Intersect_4 AS ( SELECT Scan_1.id FROM Scan_1 WHERE country IN (SELECT country FROM Filter_3) ) SELECT * FROM Intersect_4",
    "clean_query":"SELECT id FROM tvshow.TV_Channel  WHERE Country IN (SELECT Country FROM tvshow.TV_Channel  GROUP BY Country HAVING COUNT\u00a0(\u00a0*\u00a0)\u00a0>\u00a02)"
  },
  {
    "id":"4030ca9a53a02732ea943743b6fe00d6d8750e215cf82b9ad4d9d63fd796c938",
    "db_id":"tvshow",
    "question":"What are the ids of all tv channels that have more than 2 TV channels?",
    "query":"SELECT id FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE Country IN (SELECT Country FROM tvshow.TV_Channel WITH (FORCESCAN) GROUP BY Country HAVING COUNT\u00a0(\u00a0*\u00a0)\u00a0>\u00a02)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ id , country ] ; #2 = Aggregate [ #1 ] GroupBy [ country ] Output [ countstar AS Count_Star , country ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 2 ] Output [ country ] ; #4 = Intersect [ #1 , #3 ] Predicate [ #1.country = #3.country ] Output [ #1.id ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ id , country ] ; #2 = Aggregate [ #1 ] GroupBy [ country ] Output [ countstar AS Count_Star , country ] ; #3 = Filter [ #2 ] Predicate [ Count_Star > 2 ] Output [ country ] ; #4 = Intersect [ #1 , #3 ] Predicate [ #1.country = #3.country ] Output [ #1.id ]",
    "cte":"WITH Scan_1 AS ( SELECT id, country FROM tvshow.TV_Channel ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, country FROM Scan_1 GROUP BY country ), Filter_3 AS ( SELECT country FROM Aggregate_2 WHERE Count_Star > 2 ), Intersect_4 AS ( SELECT Scan_1.id FROM Scan_1 WHERE country IN (SELECT country FROM Filter_3) ) SELECT * FROM Intersect_4",
    "clean_query":"SELECT id FROM tvshow.TV_Channel  WHERE Country IN (SELECT Country FROM tvshow.TV_Channel  GROUP BY Country HAVING COUNT\u00a0(\u00a0*\u00a0)\u00a0>\u00a02)"
  },
  {
    "id":"327bca9bb7bc2bad6f1c5c3550a309028f5d3855e7c1ec6922cdd503aa6bd187",
    "db_id":"tvshow",
    "question":"find the id of tv channels that do not play any cartoon directed by Ben Jones.",
    "query":"SELECT id FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel = #1.id ] Output [ #1.id ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel = #1.id ] Output [ #1.id ]",
    "cte":"WITH Scan_1 AS ( SELECT id FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.id FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT id FROM tvshow.TV_Channel  EXCEPT SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones'"
  },
  {
    "id":"26be22a865b394ee60cdcb1dadda77678afbeceda9793eee650b327d8025b6a4",
    "db_id":"tvshow",
    "question":"What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?",
    "query":"SELECT id FROM tvshow.TV_Channel WITH (FORCESCAN) EXCEPT SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel = #1.id ] Output [ #1.id ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel = #1.id ] Output [ #1.id ]",
    "cte":"WITH Scan_1 AS ( SELECT id FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.id FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT id FROM tvshow.TV_Channel  EXCEPT SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones'"
  },
  {
    "id":"5916846cb35aee32cb93f7b29358c8341b8cd43935cd8392e41b0cc4bd7f0183",
    "db_id":"tvshow",
    "question":"find the package option of the tv channel that do not have any cartoon directed by Ben Jones.",
    "query":"SELECT package_option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Package_Option , id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel IS NULL OR #1.id = #2.Channel ] Output [ #1.Package_Option ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Package_Option , id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel IS NULL OR #1.id = #2.Channel ] Output [ #1.Package_Option ]",
    "cte":"WITH Scan_1 AS ( SELECT Package_Option, id FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.Package_Option FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT package_option FROM tvshow.TV_Channel  WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones' )"
  },
  {
    "id":"fe5adb59a95ba76edd9fc8f6822e8954695aa539cb3d1facb8be2529f01ddacf",
    "db_id":"tvshow",
    "question":"What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?",
    "query":"SELECT package_option FROM tvshow.TV_Channel WITH (FORCESCAN) WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon WITH (FORCESCAN) WHERE directed_by = 'Ben Jones' ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ TV_Channel ] Output [ Package_Option , id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel IS NULL OR #1.id = #2.Channel ] Output [ #1.Package_Option ]",
    "prefixed_qpl":"tvshow | #1 = Scan Table [ TV_Channel ] Output [ Package_Option , id ] ; #2 = Scan Table [ Cartoon ] Predicate [ Directed_by = 'Ben Jones' ] Output [ Directed_by , Channel ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Channel IS NULL OR #1.id = #2.Channel ] Output [ #1.Package_Option ]",
    "cte":"WITH Scan_1 AS ( SELECT Package_Option, id FROM tvshow.TV_Channel ), Scan_2 AS ( SELECT Directed_by, Channel FROM tvshow.Cartoon WHERE Directed_by = 'Ben Jones' ), Except_3 AS ( SELECT Scan_1.Package_Option FROM Scan_1 WHERE id NOT IN (SELECT Channel FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT package_option FROM tvshow.TV_Channel  WHERE id NOT IN ( SELECT channel FROM tvshow.cartoon  WHERE directed_by = 'Ben Jones' )"
  },
  {
    "id":"e7fcce4afab160c8a195796f3ea815d73d529587aa5c18bb9f11330e7cef0a2e",
    "db_id":"poker_player",
    "question":"How many poker players are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM poker_player.poker_player"
  },
  {
    "id":"ad8d6ae8b20c0d4474d54cfe992634403c35dd7cd7909986e366c0e742b93105",
    "db_id":"poker_player",
    "question":"Count the number of poker players.",
    "query":"SELECT count ( * ) AS Count_Star FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM poker_player.poker_player"
  },
  {
    "id":"7fddb3f9985c9698f0563fda7153bc19b66174ba26976910b80a60aaf59640a5",
    "db_id":"poker_player",
    "question":"List the earnings of poker players in descending order.",
    "query":"SELECT Earnings FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Sort [ #1 ] OrderBy [ Earnings DESC ] Output [ Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Sort [ #1 ] OrderBy [ Earnings DESC ] Output [ Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ) SELECT Earnings FROM Scan_1 ORDER BY Earnings DESC",
    "clean_query":"SELECT Earnings FROM poker_player.poker_player  ORDER BY Earnings DESC"
  },
  {
    "id":"61f7da4b5c699fa47aef91b666d0b11804b094b4fb440fc88764c661cc7fb277",
    "db_id":"poker_player",
    "question":"What are the earnings of poker players, ordered descending by value?",
    "query":"SELECT Earnings FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Sort [ #1 ] OrderBy [ Earnings DESC ] Output [ Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Sort [ #1 ] OrderBy [ Earnings DESC ] Output [ Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ) SELECT Earnings FROM Scan_1 ORDER BY Earnings DESC",
    "clean_query":"SELECT Earnings FROM poker_player.poker_player  ORDER BY Earnings DESC"
  },
  {
    "id":"67d0d7311467f93130cc61ed07eb52dea243bb0b8805dada1872d0b4869b620e",
    "db_id":"poker_player",
    "question":"List the final tables made and the best finishes of poker players.",
    "query":"SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Best_Finish , Final_Table_Made ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Best_Finish , Final_Table_Made ]",
    "cte":"WITH Scan_1 AS ( SELECT Best_Finish, Final_Table_Made FROM poker_player.poker_player ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player"
  },
  {
    "id":"501aeb236dcd162233fa7f85eef288c637da8ef7000d13a300b753843ca5d84c",
    "db_id":"poker_player",
    "question":"What are the final tables made and best finishes for all poker players?",
    "query":"SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Best_Finish , Final_Table_Made ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Best_Finish , Final_Table_Made ]",
    "cte":"WITH Scan_1 AS ( SELECT Best_Finish, Final_Table_Made FROM poker_player.poker_player ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Final_Table_Made , Best_Finish FROM poker_player.poker_player"
  },
  {
    "id":"c348d12b01b02a3eddb926cec1d07d17ee281ad2cebf76d0f34fbec50d2a8658",
    "db_id":"poker_player",
    "question":"What is the average earnings of poker players?",
    "query":"SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Aggregate [ #1 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Aggregate [ #1 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player"
  },
  {
    "id":"e7fa38db30c3db68836b1449b6438e029192143eb94fa382df17ec3e016760e1",
    "db_id":"poker_player",
    "question":"Return the average earnings across all poker players.",
    "query":"SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Aggregate [ #1 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Earnings ] ; #2 = Aggregate [ #1 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT Earnings FROM poker_player.poker_player ), Aggregate_2 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( Earnings ) AS Avg_Earnings FROM poker_player.poker_player"
  },
  {
    "id":"4f5e7016459adb9ad44e4ca87c1111a03cc59859b725f473faf61852f6d447b4",
    "db_id":"poker_player",
    "question":"What is the money rank of the poker player with the highest earnings?",
    "query":"SELECT TOP 1 Money_Rank FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Money_Rank , Earnings ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Earnings DESC ] Output [ Money_Rank , Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Money_Rank , Earnings ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Earnings DESC ] Output [ Money_Rank , Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT Money_Rank, Earnings FROM poker_player.poker_player ), TopSort_2 AS ( SELECT TOP 1 Money_Rank, Earnings FROM Scan_1 ORDER BY Earnings DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Money_Rank FROM poker_player.poker_player  ORDER BY Earnings DESC"
  },
  {
    "id":"d3843868bf41d4824aeaf42e48f823c66c1cddefe42f17b1af2797eb10d4404a",
    "db_id":"poker_player",
    "question":"Return the money rank of the player with the greatest earnings.",
    "query":"SELECT TOP 1 Money_Rank FROM poker_player.poker_player WITH (FORCESCAN) ORDER BY Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ Money_Rank , Earnings ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Earnings DESC ] Output [ Money_Rank , Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ Money_Rank , Earnings ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Earnings DESC ] Output [ Money_Rank , Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT Money_Rank, Earnings FROM poker_player.poker_player ), TopSort_2 AS ( SELECT TOP 1 Money_Rank, Earnings FROM Scan_1 ORDER BY Earnings DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Money_Rank FROM poker_player.poker_player  ORDER BY Earnings DESC"
  },
  {
    "id":"a9c17fcf19a13f223416ed82289c1000f806514655d35b1590c3ad2d5f84cebf",
    "db_id":"poker_player",
    "question":"What is the maximum number of final tables made among poker players with earnings less than 200000?",
    "query":"SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player WITH (FORCESCAN) WHERE Earnings < 200000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Predicate [ Earnings < 200000.0 ] Output [ Earnings , Final_Table_Made ] ; #2 = Aggregate [ #1 ] Output [ MAX(Final_Table_Made) AS Max_Final_Table_Made ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings < 200000.0 ] Output [ Earnings , Final_Table_Made ] ; #2 = Aggregate [ #1 ] Output [ MAX(Final_Table_Made) AS Max_Final_Table_Made ]",
    "cte":"WITH Scan_1 AS ( SELECT Earnings, Final_Table_Made FROM poker_player.poker_player WHERE Earnings < 200000.0 ), Aggregate_2 AS ( SELECT MAX(Final_Table_Made) AS Max_Final_Table_Made FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player  WHERE Earnings < 200000"
  },
  {
    "id":"3102cd9aae10b96ebbf6c9abc056927ab9dbbab64da7a97f17bb5757b07eb70f",
    "db_id":"poker_player",
    "question":"Return the maximum final tables made across all poker players who have earnings below 200000.",
    "query":"SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player WITH (FORCESCAN) WHERE Earnings < 200000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Predicate [ Earnings < 200000.0 ] Output [ Earnings , Final_Table_Made ] ; #2 = Aggregate [ #1 ] Output [ MAX(Final_Table_Made) AS Max_Final_Table_Made ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings < 200000.0 ] Output [ Earnings , Final_Table_Made ] ; #2 = Aggregate [ #1 ] Output [ MAX(Final_Table_Made) AS Max_Final_Table_Made ]",
    "cte":"WITH Scan_1 AS ( SELECT Earnings, Final_Table_Made FROM poker_player.poker_player WHERE Earnings < 200000.0 ), Aggregate_2 AS ( SELECT MAX(Final_Table_Made) AS Max_Final_Table_Made FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( Final_Table_Made ) AS Max_Final_Table_Made FROM poker_player.poker_player  WHERE Earnings < 200000"
  },
  {
    "id":"08a69a180305a344c510949c19179114ef27795b2597f6b53a9e8f126b7cde94",
    "db_id":"poker_player",
    "question":"What are the names of poker players?",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID"
  },
  {
    "id":"9e5201c6e248666fa311ea7cccc6d4189470d448be20a0380a4062d80f82c71e",
    "db_id":"poker_player",
    "question":"Return the names of all the poker players.",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID"
  },
  {
    "id":"3854a4726f08605b3fc8736f407fd3320c4b070be41be27a18da970a13cabf86",
    "db_id":"poker_player",
    "question":"What are the names of poker players whose earnings is higher than 300000?",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Predicate [ Earnings > 300000.0 ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings > 300000.0 ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player WHERE Earnings > 300000.0 ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
  },
  {
    "id":"0304ccac6215bdeb68fee72019cb089b06fd44940d8a52dd0a70443824e39952",
    "db_id":"poker_player",
    "question":"Give the names of poker players who have earnings above 300000.",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Predicate [ Earnings > 300000.0 ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Predicate [ Earnings > 300000.0 ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player WHERE Earnings > 300000.0 ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T2.Earnings > 300000"
  },
  {
    "id":"044f714d672d32a325bbfb225b0075e090856f30f465f5e162edb51e8f2525c0",
    "db_id":"poker_player",
    "question":"List the names of poker players ordered by the final tables made in ascending order.",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Final_Table_Made ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Final_Table_Made , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Final_Table_Made ASC ] Output [ Name , Final_Table_Made ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Final_Table_Made ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Final_Table_Made , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Final_Table_Made ASC ] Output [ Name , Final_Table_Made ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Final_Table_Made FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Final_Table_Made, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Final_Table_Made FROM Join_3 ORDER BY Final_Table_Made ASC",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made"
  },
  {
    "id":"862cf18a84d6b570717481f1cee798370bd820600fed8d9fb547212392fc97d1",
    "db_id":"poker_player",
    "question":"What are the names of poker players, ordered ascending by the number of final tables they have made?",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Final_Table_Made ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Final_Table_Made , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Final_Table_Made ASC ] Output [ Name , Final_Table_Made ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Final_Table_Made ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Final_Table_Made , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Final_Table_Made ASC ] Output [ Name , Final_Table_Made ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Final_Table_Made FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Final_Table_Made, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Final_Table_Made FROM Join_3 ORDER BY Final_Table_Made ASC",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Final_Table_Made"
  },
  {
    "id":"4eaa950c1003fdf45a32673b42ff643ccb4dd6ed5d95e36682f364519dcc349b",
    "db_id":"poker_player",
    "question":"What is the birth date of the poker player with the lowest earnings?",
    "query":"SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Birth_Date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Birth_Date , #1.Earnings ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Earnings ASC ] Output [ Earnings , Birth_Date ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Birth_Date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Birth_Date , #1.Earnings ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Earnings ASC ] Output [ Earnings , Birth_Date ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Birth_Date FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Birth_Date, Scan_1.Earnings FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Earnings, Birth_Date FROM Join_3 ORDER BY Earnings ASC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC"
  },
  {
    "id":"134c01a812f1d002b8ec3b1bada53172b4e50778eb87d5b24cb776d6a94c731f",
    "db_id":"poker_player",
    "question":"Return the birth date of the poker player with the lowest earnings.",
    "query":"SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Birth_Date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Birth_Date , #1.Earnings ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Earnings ASC ] Output [ Earnings , Birth_Date ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Birth_Date ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Birth_Date , #1.Earnings ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Earnings ASC ] Output [ Earnings , Birth_Date ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Birth_Date FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Birth_Date, Scan_1.Earnings FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Earnings, Birth_Date FROM Join_3 ORDER BY Earnings ASC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Birth_Date FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings ASC"
  },
  {
    "id":"d01287301b3ab267c9011c0d72455a523c3ac26d89ed5a67dbe3e23e670b9d15",
    "db_id":"poker_player",
    "question":"What is the money rank of the tallest poker player?",
    "query":"SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Money_Rank ] ; #2 = Scan Table [ people ] Output [ People_ID , Height ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Height , #1.Money_Rank ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Height DESC ] Output [ Height , Money_Rank ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Money_Rank ] ; #2 = Scan Table [ people ] Output [ People_ID , Height ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Height , #1.Money_Rank ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Height DESC ] Output [ Height , Money_Rank ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Money_Rank FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Height FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Height, Scan_1.Money_Rank FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Height, Money_Rank FROM Join_3 ORDER BY Height DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC"
  },
  {
    "id":"3527f8c88c2c02b87402400adb4ca1df78d5a8ed8137a2e68e5ae161490f83b2",
    "db_id":"poker_player",
    "question":"Return the money rank of the poker player with the greatest height.",
    "query":"SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Money_Rank ] ; #2 = Scan Table [ people ] Output [ People_ID , Height ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Height , #1.Money_Rank ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Height DESC ] Output [ Height , Money_Rank ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Money_Rank ] ; #2 = Scan Table [ people ] Output [ People_ID , Height ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Height , #1.Money_Rank ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Height DESC ] Output [ Height , Money_Rank ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Money_Rank FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Height FROM poker_player.people ), Join_3 AS ( SELECT Scan_2.Height, Scan_1.Money_Rank FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), TopSort_4 AS ( SELECT TOP 1 Height, Money_Rank FROM Join_3 ORDER BY Height DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T2.Money_Rank FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T1.Height DESC"
  },
  {
    "id":"7bcbec7f9317af4cda4f934c99013fba1b27971fdf1e19b737506f1e2bbbadb7",
    "db_id":"poker_player",
    "question":"What is the average earnings of poker players with height higher than 200?",
    "query":"SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T1.Height > 200 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ people ] Predicate [ Height > 200.0 ] Output [ People_ID , Height ] ; #2 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Earnings ] ; #4 = Aggregate [ #3 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Predicate [ Height > 200.0 ] Output [ People_ID , Height ] ; #2 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Earnings ] ; #4 = Aggregate [ #3 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Height FROM poker_player.people WHERE Height > 200.0 ), Scan_2 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player ), Join_3 AS ( SELECT Scan_2.Earnings FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), Aggregate_4 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
  },
  {
    "id":"a1bf2d8958be8dd95641c593f66002a2c88d11a9c30eb564d954c166ea5ddb70",
    "db_id":"poker_player",
    "question":"Give average earnings of poker players who are taller than 200.",
    "query":"SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID WHERE T1.Height > 200 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ people ] Predicate [ Height > 200.0 ] Output [ People_ID , Height ] ; #2 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Earnings ] ; #4 = Aggregate [ #3 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Predicate [ Height > 200.0 ] Output [ People_ID , Height ] ; #2 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #2.Earnings ] ; #4 = Aggregate [ #3 ] Output [ AVG(Earnings) AS Avg_Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Height FROM poker_player.people WHERE Height > 200.0 ), Scan_2 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player ), Join_3 AS ( SELECT Scan_2.Earnings FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ), Aggregate_4 AS ( SELECT AVG(Earnings) AS Avg_Earnings FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( T2.Earnings ) AS Avg_Earnings FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID WHERE T1.Height > 200"
  },
  {
    "id":"3ea56ea638859870f74c819e5d8def86954d9136b038c68200c5e910b918ea0b",
    "db_id":"poker_player",
    "question":"What are the names of poker players in descending order of earnings?",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Earnings DESC ] Output [ Name , Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Earnings DESC ] Output [ Name , Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Earnings, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Earnings FROM Join_3 ORDER BY Earnings DESC",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
  },
  {
    "id":"3b8ab4e1d255f68608b86f8899d6adfb0367f92a350579daf6bc26437288a126",
    "db_id":"poker_player",
    "question":"Return the names of poker players sorted by their earnings descending.",
    "query":"SELECT T1.Name FROM poker_player.people AS T1 WITH (FORCESCAN) JOIN poker_player.poker_player AS T2 WITH (FORCESCAN) ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Earnings DESC ] Output [ Name , Earnings ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ poker_player ] Output [ People_ID , Earnings ] ; #2 = Scan Table [ people ] Output [ People_ID , Name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.People_ID = #2.People_ID ] Output [ #1.Earnings , #2.Name ] ; #4 = Sort [ #3 ] OrderBy [ Earnings DESC ] Output [ Name , Earnings ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Earnings FROM poker_player.poker_player ), Scan_2 AS ( SELECT People_ID, Name FROM poker_player.people ), Join_3 AS ( SELECT Scan_1.Earnings, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.People_ID = Scan_2.People_ID ) SELECT Name, Earnings FROM Join_3 ORDER BY Earnings DESC",
    "clean_query":"SELECT T1.Name FROM poker_player.people AS T1  JOIN poker_player.poker_player AS T2  ON T1.People_ID = T2.People_ID ORDER BY T2.Earnings DESC"
  },
  {
    "id":"a007a938175d709e14791598607b8aeb8b640dd14dd48f3e56eb97824e0acacd",
    "db_id":"poker_player",
    "question":"What are different nationalities of people and the corresponding number of people from each nation?",
    "query":"SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT Nationality, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Nationality ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people  GROUP BY Nationality"
  },
  {
    "id":"60381fe18778956685f148ed16d9626f22531748406bdbd7c0c99be5af63cc29",
    "db_id":"poker_player",
    "question":"How many people are there of each nationality?",
    "query":"SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT Nationality, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Nationality ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Nationality , COUNT ( * ) AS Count_Star FROM poker_player.people  GROUP BY Nationality"
  },
  {
    "id":"073332a5fd4d410cbe407ca5590f3591cff693649f96109da43bc8619671d08b",
    "db_id":"poker_player",
    "question":"What is the most common nationality of people?",
    "query":"SELECT TOP 1 Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT Nationality, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Nationality ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Nationality FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Nationality FROM poker_player.people  GROUP BY Nationality ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"50dd67121490bcdaef67b0fa8e7b7c482ff5154f3c6dd54446ce3ba29ec3e40f",
    "db_id":"poker_player",
    "question":"Give the nationality that is most common across all people.",
    "query":"SELECT TOP 1 Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT Nationality, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Nationality ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Nationality FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Nationality FROM poker_player.people  GROUP BY Nationality ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"d5a39686bba741ef689bc307f2c36a0afe1e3e7005626c834320c78d825a40e5",
    "db_id":"poker_player",
    "question":"What are the nationalities that are shared by at least two people?",
    "query":"SELECT Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT Nationality, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Nationality ), Filter_3 AS ( SELECT Nationality FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT Nationality FROM poker_player.people  GROUP BY Nationality HAVING COUNT ( * ) > = 2"
  },
  {
    "id":"4d5cee55fec256b8f6850ffd68ea37b824569ff2bdd66b6393e896020179a357",
    "db_id":"poker_player",
    "question":"Return the nationalities for which there are two or more people.",
    "query":"SELECT Nationality FROM poker_player.people WITH (FORCESCAN) GROUP BY Nationality HAVING COUNT ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] GroupBy [ Nationality ] Output [ Nationality , countstar AS Count_Star ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 2 ] Output [ Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT Nationality, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Nationality ), Filter_3 AS ( SELECT Nationality FROM Aggregate_2 WHERE Count_Star >= 2 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT Nationality FROM poker_player.people  GROUP BY Nationality HAVING COUNT ( * ) > = 2"
  },
  {
    "id":"f3fa903b24fa8f9dc20a193fcf0256b80e56cd8c75cebe52ed4d28b5badf9486",
    "db_id":"poker_player",
    "question":"List the names and birth dates of people in ascending alphabetical order of name.",
    "query":"SELECT Name , Birth_Date FROM poker_player.people WITH (FORCESCAN) ORDER BY Name ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ people ] Output [ Name , Birth_Date ] ; #2 = Sort [ #1 ] OrderBy [ Name ASC ] Output [ Name , Birth_Date ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Name , Birth_Date ] ; #2 = Sort [ #1 ] OrderBy [ Name ASC ] Output [ Name , Birth_Date ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Birth_Date FROM poker_player.people ) SELECT Name, Birth_Date FROM Scan_1 ORDER BY Name ASC",
    "clean_query":"SELECT Name , Birth_Date FROM poker_player.people  ORDER BY Name ASC"
  },
  {
    "id":"91bee6c64b55ed007541ee7bc3edc5cd2ac530d2f8aa720ebe0a6ac76f71ac0e",
    "db_id":"poker_player",
    "question":"What are the names and birth dates of people, ordered by their names in alphabetical order?",
    "query":"SELECT Name , Birth_Date FROM poker_player.people WITH (FORCESCAN) ORDER BY Name ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ people ] Output [ Name , Birth_Date ] ; #2 = Sort [ #1 ] OrderBy [ Name ASC ] Output [ Name , Birth_Date ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ Name , Birth_Date ] ; #2 = Sort [ #1 ] OrderBy [ Name ASC ] Output [ Name , Birth_Date ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Birth_Date FROM poker_player.people ) SELECT Name, Birth_Date FROM Scan_1 ORDER BY Name ASC",
    "clean_query":"SELECT Name , Birth_Date FROM poker_player.people  ORDER BY Name ASC"
  },
  {
    "id":"e414d32b5423f613066d3bcdc923aeacd8d20f30e56c3f129024985e74d76087",
    "db_id":"poker_player",
    "question":"Show names of people whose nationality is not \"Russia\".",
    "query":"SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE Nationality ! = 'Russia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ people ] Predicate [ Nationality <> 'Russia' ] Output [ Name , Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Predicate [ Nationality <> 'Russia' ] Output [ Name , Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Nationality FROM poker_player.people WHERE Nationality <> 'Russia' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM poker_player.people  WHERE Nationality ! = 'Russia'"
  },
  {
    "id":"dbbf44711e8fd308d37064f71594e0580d43a6aff100d52e2b3c507f986e8094",
    "db_id":"poker_player",
    "question":"What are the names of people who are not from Russia?",
    "query":"SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE Nationality ! = 'Russia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ people ] Predicate [ Nationality <> 'Russia' ] Output [ Name , Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Predicate [ Nationality <> 'Russia' ] Output [ Name , Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Nationality FROM poker_player.people WHERE Nationality <> 'Russia' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM poker_player.people  WHERE Nationality ! = 'Russia'"
  },
  {
    "id":"7e71dfe9b226654ff253bf9928829d6497f2bd6209adea612d4187885a79975a",
    "db_id":"poker_player",
    "question":"List the names of people that are not poker players.",
    "query":"SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ people ] Output [ People_ID , Name ] ; #2 = Scan Table [ poker_player ] Output [ People_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.People_ID IS NULL OR #1.People_ID = #2.People_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ People_ID , Name ] ; #2 = Scan Table [ poker_player ] Output [ People_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.People_ID IS NULL OR #1.People_ID = #2.People_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Name FROM poker_player.people ), Scan_2 AS ( SELECT People_ID FROM poker_player.poker_player ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE People_ID NOT IN (SELECT People_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Name FROM poker_player.people  WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player  )"
  },
  {
    "id":"cbdbda7f6b5a8cb8a3e91eb569ed7fe4af064e5e9da84de6721c53d11042f4a6",
    "db_id":"poker_player",
    "question":"What are the names of people who do not play poker?",
    "query":"SELECT Name FROM poker_player.people WITH (FORCESCAN) WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ people ] Output [ People_ID , Name ] ; #2 = Scan Table [ poker_player ] Output [ People_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.People_ID IS NULL OR #1.People_ID = #2.People_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Output [ People_ID , Name ] ; #2 = Scan Table [ poker_player ] Output [ People_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.People_ID IS NULL OR #1.People_ID = #2.People_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT People_ID, Name FROM poker_player.people ), Scan_2 AS ( SELECT People_ID FROM poker_player.poker_player ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE People_ID NOT IN (SELECT People_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Name FROM poker_player.people  WHERE People_ID NOT IN ( SELECT People_ID FROM poker_player.poker_player  )"
  },
  {
    "id":"9a74739b1de108b16cb952da7dc049a7c4df7890b6f39ef2440ff75f46bd86ad",
    "db_id":"poker_player",
    "question":"How many distinct nationalities are there?",
    "query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ people ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people"
  },
  {
    "id":"fbc04bab781dade7000cb80dc5e8d4b3dfa2941ca1a1e387497976c05365209d",
    "db_id":"poker_player",
    "question":"Count the number of different nationalities.",
    "query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ people ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "prefixed_qpl":"poker_player | #1 = Scan Table [ people ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM poker_player.people ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM poker_player.people"
  },
  {
    "id":"f43bc5903436fd6a4ae16ce9b91ac3a7775e605b398c5ad823d597286507bbf1",
    "db_id":"voter_1",
    "question":"How many states are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM voter_1.area_code_state WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ AREA_CODE_STATE ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ AREA_CODE_STATE ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM voter_1.AREA_CODE_STATE ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM voter_1.area_code_state"
  },
  {
    "id":"b792df4f0b5acb59b2cc8ad354f46c20b196000a4a1ee857ec47b5beef92fe3f",
    "db_id":"voter_1",
    "question":"List the contestant numbers and names, ordered by contestant name descending.",
    "query":"SELECT contestant_number , contestant_name FROM voter_1.contestants WITH (FORCESCAN) ORDER BY contestant_name DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ CONTESTANTS ] Output [ contestant_number , contestant_name ] ; #2 = Sort [ #1 ] OrderBy [ contestant_name DESC ] Output [ contestant_number , contestant_name ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ CONTESTANTS ] Output [ contestant_number , contestant_name ] ; #2 = Sort [ #1 ] OrderBy [ contestant_name DESC ] Output [ contestant_number , contestant_name ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_number, contestant_name FROM voter_1.CONTESTANTS ) SELECT contestant_number, contestant_name FROM Scan_1 ORDER BY contestant_name DESC",
    "clean_query":"SELECT contestant_number , contestant_name FROM voter_1.contestants  ORDER BY contestant_name DESC"
  },
  {
    "id":"575ec295377477c9f31c046cc32ced0bff5306588047cf8a44524f07e76db154",
    "db_id":"voter_1",
    "question":"List the vote ids, phone numbers and states of all votes.",
    "query":"SELECT vote_id , phone_number , state FROM voter_1.votes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ VOTES ] Output [ phone_number , state , vote_id ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ VOTES ] Output [ phone_number , state , vote_id ]",
    "cte":"WITH Scan_1 AS ( SELECT phone_number, state, vote_id FROM voter_1.VOTES ) SELECT * FROM Scan_1",
    "clean_query":"SELECT vote_id , phone_number , state FROM voter_1.votes"
  },
  {
    "id":"e24254d972f8ecf7aa0697d04ee3434c79327bfec5fcb6eaa7ff5ba5537f66f6",
    "db_id":"voter_1",
    "question":"What are the maximum and minimum values of area codes?",
    "query":"SELECT max ( area_code ) AS Max_area_code , min ( area_code ) AS Min_area_code FROM voter_1.area_code_state WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ AREA_CODE_STATE ] Output [ area_code ] ; #2 = Aggregate [ #1 ] Output [ MIN(area_code) AS Min_area_code , MAX(area_code) AS Max_area_code ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ AREA_CODE_STATE ] Output [ area_code ] ; #2 = Aggregate [ #1 ] Output [ MIN(area_code) AS Min_area_code , MAX(area_code) AS Max_area_code ]",
    "cte":"WITH Scan_1 AS ( SELECT area_code FROM voter_1.AREA_CODE_STATE ), Aggregate_2 AS ( SELECT MIN(area_code) AS Min_area_code, MAX(area_code) AS Max_area_code FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( area_code ) AS Max_area_code , min ( area_code ) AS Min_area_code FROM voter_1.area_code_state"
  },
  {
    "id":"8ac627d9be26faacaad933328aa777c2ba3faa7b21cb4f3c343c13997de5c7a0",
    "db_id":"voter_1",
    "question":"What is last date created of votes from the state 'CA'?",
    "query":"SELECT max ( created ) AS Max_created FROM voter_1.votes WITH (FORCESCAN) WHERE state = 'CA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ VOTES ] Predicate [ state = 'CA' ] Output [ state , created ] ; #2 = Aggregate [ #1 ] Output [ MAX(created) AS Max_created ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ VOTES ] Predicate [ state = 'CA' ] Output [ state , created ] ; #2 = Aggregate [ #1 ] Output [ MAX(created) AS Max_created ]",
    "cte":"WITH Scan_1 AS ( SELECT state, created FROM voter_1.VOTES WHERE state = 'CA' ), Aggregate_2 AS ( SELECT MAX(created) AS Max_created FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( created ) AS Max_created FROM voter_1.votes  WHERE state = 'CA'"
  },
  {
    "id":"5a8d71c970603ffa83f98d138980d8fe30589cc89224720daea8e4acd0e86daa",
    "db_id":"voter_1",
    "question":"What are the names of the contestants whose names are not 'Jessie Alloway'",
    "query":"SELECT contestant_name FROM voter_1.contestants WITH (FORCESCAN) WHERE contestant_name ! = 'Jessie Alloway' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name <> 'Jessie Alloway' ] Output [ contestant_name ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name <> 'Jessie Alloway' ] Output [ contestant_name ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name <> 'Jessie Alloway' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT contestant_name FROM voter_1.contestants  WHERE contestant_name ! = 'Jessie Alloway'"
  },
  {
    "id":"c1517697f4905f2a0efa5559d00932403e977d6eed11d9b1a5ddadf709b72f34",
    "db_id":"voter_1",
    "question":"What are the distinct states and create time of all votes?",
    "query":"SELECT DISTINCT state , created FROM voter_1.votes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ VOTES ] Distinct [ true ] Output [ state , created ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ VOTES ] Distinct [ true ] Output [ state , created ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT state, created FROM voter_1.VOTES ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT state , created FROM voter_1.votes"
  },
  {
    "id":"df8e2eaea9db6a1d91940430669a0e36d2ac025433b2a3df977d949a20aefcd3",
    "db_id":"voter_1",
    "question":"What are the contestant numbers and names of the contestants who had at least two votes?",
    "query":"SELECT T1.contestant_number , T1.contestant_name FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number GROUP BY T1.contestant_number , T1.contestant_name HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ VOTES ] Output [ contestant_number ] ; #2 = Aggregate [ #1 ] GroupBy [ contestant_number ] Output [ contestant_number , countstar AS Count_Star ] ; #3 = Scan Table [ CONTESTANTS ] Output [ contestant_number , contestant_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.contestant_number = #3.contestant_number ] Output [ #2.Count_Star , #3.contestant_number , #3.contestant_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ contestant_number , contestant_name ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ VOTES ] Output [ contestant_number ] ; #2 = Aggregate [ #1 ] GroupBy [ contestant_number ] Output [ contestant_number , countstar AS Count_Star ] ; #3 = Scan Table [ CONTESTANTS ] Output [ contestant_number , contestant_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.contestant_number = #3.contestant_number ] Output [ #2.Count_Star , #3.contestant_number , #3.contestant_name ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ contestant_number , contestant_name ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_number FROM voter_1.VOTES ), Aggregate_2 AS ( SELECT contestant_number, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY contestant_number ), Scan_3 AS ( SELECT contestant_number, contestant_name FROM voter_1.CONTESTANTS ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.contestant_number, Scan_3.contestant_name FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.contestant_number = Scan_3.contestant_number ), Filter_5 AS ( SELECT contestant_number, contestant_name FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.contestant_number , T1.contestant_name FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number GROUP BY T1.contestant_number , T1.contestant_name HAVING count ( * ) > = 2"
  },
  {
    "id":"bff2974c43a128f711181e493e2036cb2b26cb7aa8f12d9009b047620bef2c21",
    "db_id":"voter_1",
    "question":"Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?",
    "query":"select TOP 1 WITH TIES t1.contestant_number , t1.contestant_name FROM voter_1.contestants AS T1 WITH (FORCESCAN) join voter_1.votes as t2 WITH (FORCESCAN) ON t1.contestant_number = t2.contestant_number group by t1.contestant_number , t1.contestant_name order by count ( * ) asc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ votes ] Output [ contestant_number ] ; #2 = Scan Table [ contestants ] Output [ contestant_number , contestant_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.contestant_number = #1.contestant_number ] Output [ #2.contestant_name , #2.contestant_number ] ; #4 = Aggregate [ #3 ] GroupBy [ contestant_name , contestant_number ] Output [ countstar AS Count_Star , contestant_number , contestant_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ contestant_number , contestant_name ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ votes ] Output [ contestant_number ] ; #2 = Scan Table [ contestants ] Output [ contestant_number , contestant_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.contestant_number = #1.contestant_number ] Output [ #2.contestant_name , #2.contestant_number ] ; #4 = Aggregate [ #3 ] GroupBy [ contestant_name , contestant_number ] Output [ countstar AS Count_Star , contestant_number , contestant_name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] WithTies [ true ] Output [ contestant_number , contestant_name ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_number FROM voter_1.votes ), Scan_2 AS ( SELECT contestant_number, contestant_name FROM voter_1.contestants ), Join_3 AS ( SELECT Scan_2.contestant_name, Scan_2.contestant_number FROM Scan_1 JOIN Scan_2 ON Scan_2.contestant_number = Scan_1.contestant_number ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, contestant_number, contestant_name FROM Join_3 GROUP BY contestant_name , contestant_number, contestant_number, contestant_name ), TopSort_5 AS ( SELECT TOP 1 WITH TIES contestant_number, contestant_name FROM Aggregate_4 ORDER BY Count_Star ASC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 WITH TIES t1.contestant_number , t1.contestant_name FROM voter_1.contestants AS T1  join voter_1.votes as t2  ON t1.contestant_number = t2.contestant_number group by t1.contestant_number , t1.contestant_name order by count ( * ) asc"
  },
  {
    "id":"53f3c08f00b4abb2d3c3d200358f04020590cdb4126609068d72fb4b5cedda7e",
    "db_id":"voter_1",
    "question":"What are the number of votes from state 'NY' or 'CA'?",
    "query":"SELECT count ( * ) AS Count_Star FROM voter_1.votes WITH (FORCESCAN) WHERE state = 'NY' OR state = 'CA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ votes ] Output [ state ] ; #2 = Filter [ #1 ] Predicate [ state = 'ca' OR state = 'ny' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ votes ] Output [ state ] ; #2 = Filter [ #1 ] Predicate [ state = 'ca' OR state = 'ny' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT state FROM voter_1.votes ), Filter_2 AS ( SELECT 1 AS One FROM Scan_1 WHERE state = 'ca' OR state = 'ny' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM voter_1.votes  WHERE state = 'NY' OR state = 'CA'"
  },
  {
    "id":"5b137f43eb6a56ae4d554a5fbf6b1f1ad7fa607e9bad79dfc2d4daaba0ebdc2e",
    "db_id":"voter_1",
    "question":"How many contestants did not get voted?",
    "query":"SELECT count ( * ) AS Count_Star FROM voter_1.contestants WITH (FORCESCAN) WHERE contestant_number NOT IN ( SELECT contestant_number FROM voter_1.votes WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ CONTESTANTS ] Output [ contestant_number ] ; #2 = Scan Table [ VOTES ] Output [ contestant_number ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.contestant_number = #1.contestant_number ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ CONTESTANTS ] Output [ contestant_number ] ; #2 = Scan Table [ VOTES ] Output [ contestant_number ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.contestant_number = #1.contestant_number ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_number FROM voter_1.CONTESTANTS ), Scan_2 AS ( SELECT contestant_number FROM voter_1.VOTES ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE contestant_number NOT IN (SELECT contestant_number FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM voter_1.contestants  WHERE contestant_number NOT IN ( SELECT contestant_number FROM voter_1.votes  )"
  },
  {
    "id":"7f4d3002391a94f1350386c3c530f9f41872958aaab723ea73a778c124284968",
    "db_id":"voter_1",
    "question":"What is the area code in which the most voters voted?",
    "query":"SELECT TOP 1 T1.area_code FROM voter_1.area_code_state AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.state = T2.state GROUP BY T1.area_code ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ VOTES ] Output [ state ] ; #2 = Aggregate [ #1 ] GroupBy [ state ] Output [ state , countstar AS Count_Star ] ; #3 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.state = #3.state ] Output [ #2.Count_Star , #3.area_code ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , area_code ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ VOTES ] Output [ state ] ; #2 = Aggregate [ #1 ] GroupBy [ state ] Output [ state , countstar AS Count_Star ] ; #3 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.state = #3.state ] Output [ #2.Count_Star , #3.area_code ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , area_code ]",
    "cte":"WITH Scan_1 AS ( SELECT state FROM voter_1.VOTES ), Aggregate_2 AS ( SELECT state, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY state ), Scan_3 AS ( SELECT area_code, state FROM voter_1.AREA_CODE_STATE ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.area_code FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.state = Scan_3.state ), TopSort_5 AS ( SELECT TOP 1 Count_Star, area_code FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.area_code FROM voter_1.area_code_state AS T1  JOIN voter_1.votes AS T2  ON T1.state = T2.state GROUP BY T1.area_code ORDER BY count ( * ) DESC"
  },
  {
    "id":"3ef872547c3c849b72137303c2397e4ddfa5620f0a8444b059405f38009ac1b5",
    "db_id":"voter_1",
    "question":"What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?",
    "query":"SELECT T2.created , T2.state , T2.phone_number FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Tabatha Gehling' ] Output [ contestant_number , contestant_name ] ; #2 = Scan Table [ VOTES ] Output [ contestant_number , state , created , phone_number ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.contestant_number = #2.contestant_number ] Output [ #2.state , #2.created , #2.phone_number ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Tabatha Gehling' ] Output [ contestant_number , contestant_name ] ; #2 = Scan Table [ VOTES ] Output [ contestant_number , state , created , phone_number ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.contestant_number = #2.contestant_number ] Output [ #2.state , #2.created , #2.phone_number ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_number, contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name = 'Tabatha Gehling' ), Scan_2 AS ( SELECT contestant_number, state, created, phone_number FROM voter_1.VOTES ), Join_3 AS ( SELECT Scan_2.state, Scan_2.created, Scan_2.phone_number FROM Scan_1 JOIN Scan_2 ON Scan_1.contestant_number = Scan_2.contestant_number ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.created , T2.state , T2.phone_number FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number WHERE T1.contestant_name = 'Tabatha Gehling'"
  },
  {
    "id":"997a9d9b23d45ca4e3b077ba7f5a6f03f5475311200c92805f200366cfc56736",
    "db_id":"voter_1",
    "question":"List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.",
    "query":"SELECT T3.area_code FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3 WITH (FORCESCAN) ON T2.state = T3.state WHERE T1.contestant_name = 'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM voter_1.contestants AS T1 WITH (FORCESCAN) JOIN voter_1.votes AS T2 WITH (FORCESCAN) ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3 WITH (FORCESCAN) ON T2.state = T3.state WHERE T1.contestant_name = 'Kelly Clauss' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #2 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Tabatha Gehling' ] Output [ contestant_number , contestant_name ] ; #3 = Scan Table [ VOTES ] Output [ contestant_number , state ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.contestant_number = #3.contestant_number ] Output [ #3.state ] ; #5 = Intersect [ #1 , #4 ] Predicate [ #4.state = #1.state ] Output [ #1.area_code ] ; #6 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Kelly Clauss' ] Output [ contestant_number , contestant_name ] ; #7 = Scan Table [ VOTES ] Output [ contestant_number , state ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.contestant_number = #7.contestant_number ] Output [ #7.state ] ; #9 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.state = #9.state ] Output [ #9.area_code ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.area_code = #10.area_code ] Output [ #5.area_code ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #2 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Tabatha Gehling' ] Output [ contestant_number , contestant_name ] ; #3 = Scan Table [ VOTES ] Output [ contestant_number , state ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.contestant_number = #3.contestant_number ] Output [ #3.state ] ; #5 = Intersect [ #1 , #4 ] Predicate [ #4.state = #1.state ] Output [ #1.area_code ] ; #6 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name = 'Kelly Clauss' ] Output [ contestant_number , contestant_name ] ; #7 = Scan Table [ VOTES ] Output [ contestant_number , state ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.contestant_number = #7.contestant_number ] Output [ #7.state ] ; #9 = Scan Table [ AREA_CODE_STATE ] Output [ area_code , state ] ; #10 = Join [ #8 , #9 ] Predicate [ #8.state = #9.state ] Output [ #9.area_code ] ; #11 = Intersect [ #5 , #10 ] Predicate [ #5.area_code = #10.area_code ] Output [ #5.area_code ]",
    "cte":"WITH Scan_1 AS ( SELECT area_code, state FROM voter_1.AREA_CODE_STATE ), Scan_2 AS ( SELECT contestant_number, contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name = 'Tabatha Gehling' ), Scan_3 AS ( SELECT contestant_number, state FROM voter_1.VOTES ), Join_4 AS ( SELECT Scan_3.state FROM Scan_2 JOIN Scan_3 ON Scan_2.contestant_number = Scan_3.contestant_number ), Intersect_5 AS ( SELECT Scan_1.area_code FROM Scan_1 WHERE state IN (SELECT state FROM Join_4) ), Scan_6 AS ( SELECT contestant_number, contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name = 'Kelly Clauss' ), Scan_7 AS ( SELECT contestant_number, state FROM voter_1.VOTES ), Join_8 AS ( SELECT Scan_7.state FROM Scan_6 JOIN Scan_7 ON Scan_6.contestant_number = Scan_7.contestant_number ), Scan_9 AS ( SELECT area_code, state FROM voter_1.AREA_CODE_STATE ), Join_10 AS ( SELECT Scan_9.area_code FROM Join_8 JOIN Scan_9 ON Join_8.state = Scan_9.state ), Intersect_11 AS ( SELECT Intersect_5.area_code FROM Intersect_5 WHERE area_code IN (SELECT area_code FROM Join_10) ) SELECT * FROM Intersect_11",
    "clean_query":"SELECT T3.area_code FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3  ON T2.state = T3.state WHERE T1.contestant_name = 'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM voter_1.contestants AS T1  JOIN voter_1.votes AS T2  ON T1.contestant_number = T2.contestant_number JOIN voter_1.area_code_state AS T3  ON T2.state = T3.state WHERE T1.contestant_name = 'Kelly Clauss'"
  },
  {
    "id":"375f05a7144b42b7b01a5557989bdde5fbf222a82089e659eb469e04e6091ddb",
    "db_id":"voter_1",
    "question":"Return the names of the contestants whose names contain the substring 'Al' .",
    "query":"select contestant_name FROM voter_1.contestants WITH (FORCESCAN) where contestant_name like '%al%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name like '%al%' ] Output [ contestant_name ]",
    "prefixed_qpl":"voter_1 | #1 = Scan Table [ CONTESTANTS ] Predicate [ contestant_name like '%al%' ] Output [ contestant_name ]",
    "cte":"WITH Scan_1 AS ( SELECT contestant_name FROM voter_1.CONTESTANTS WHERE contestant_name like '%al%' ) SELECT * FROM Scan_1",
    "clean_query":"select contestant_name FROM voter_1.contestants  where contestant_name like '%al%'"
  },
  {
    "id":"cbf9f39d623b23fe3ba8c7aa545d5a25e98577e97afccb06037e8b79412519ea",
    "db_id":"world_1",
    "question":"What are the names of all the countries that became independent after 1950?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE IndepYear > 1950 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ IndepYear > 1950 ] Output [ Name , IndepYear ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear > 1950 ] Output [ Name , IndepYear ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, IndepYear FROM world_1.country WHERE IndepYear > 1950 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM world_1.country  WHERE IndepYear > 1950"
  },
  {
    "id":"1c36e57f9f01e92d2e032a36e5bd1662f81d141e75079ff1d91e1611247d3278",
    "db_id":"world_1",
    "question":"Give the names of the nations that were founded after 1950.",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE IndepYear > 1950 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ IndepYear > 1950 ] Output [ Name , IndepYear ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear > 1950 ] Output [ Name , IndepYear ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, IndepYear FROM world_1.country WHERE IndepYear > 1950 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM world_1.country  WHERE IndepYear > 1950"
  },
  {
    "id":"eda66e735c51570820c08ac218e6aa49fb6d80f3b459827f5ebb9b608188d08f",
    "db_id":"world_1",
    "question":"How many countries have a republic as their form of government?",
    "query":"SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm FROM world_1.country WHERE GovernmentForm = 'Republic' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE GovernmentForm = 'Republic'"
  },
  {
    "id":"4f0586d6a811c9dd3d73bdee44c39fc23377c7738abf1a2060ccbab35237dec4",
    "db_id":"world_1",
    "question":"How many countries have governments that are republics?",
    "query":"SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm FROM world_1.country WHERE GovernmentForm = 'Republic' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE GovernmentForm = 'Republic'"
  },
  {
    "id":"42e2d31ab3ab8660506a198d447bbeb3fe7a87e3dd1ce9a1ef067e3a6612d09f",
    "db_id":"world_1",
    "question":"What is the total surface area of the countries in the Caribbean region?",
    "query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Caribbean' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Region = 'Caribbean' ] Output [ SurfaceArea , Region ] ; #2 = Aggregate [ #1 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Caribbean' ] Output [ SurfaceArea , Region ] ; #2 = Aggregate [ #1 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Region FROM world_1.country WHERE Region = 'Caribbean' ), Aggregate_2 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Region = 'Caribbean'"
  },
  {
    "id":"9b0b35fe9d58a109152308667dfc887aad2df9802bb5be1a0a5a212734da450d",
    "db_id":"world_1",
    "question":"How much surface area do the countires in the Carribean cover together?",
    "query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Caribbean' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Region = 'Caribbean' ] Output [ SurfaceArea , Region ] ; #2 = Aggregate [ #1 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Caribbean' ] Output [ SurfaceArea , Region ] ; #2 = Aggregate [ #1 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Region FROM world_1.country WHERE Region = 'Caribbean' ), Aggregate_2 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Region = 'Caribbean'"
  },
  {
    "id":"3193d5beb7c66a6847f2c9dbe3f4f3078a8c1d60b15e1d257646ae05dc950b32",
    "db_id":"world_1",
    "question":"Which continent is Anguilla in?",
    "query":"SELECT Continent FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Anguilla' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Anguilla' ] Output [ Name , Continent ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Anguilla' ] Output [ Name , Continent ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent FROM world_1.country WHERE Name = 'Anguilla' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Continent FROM world_1.country  WHERE Name = 'Anguilla'"
  },
  {
    "id":"90a8fb09639d78d2f2cca85fcc342eebec55dbb742658bab91e55d242e256e6b",
    "db_id":"world_1",
    "question":"What is the continent name which Anguilla belongs to?",
    "query":"SELECT Continent FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Anguilla' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Anguilla' ] Output [ Name , Continent ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Anguilla' ] Output [ Name , Continent ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent FROM world_1.country WHERE Name = 'Anguilla' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Continent FROM world_1.country  WHERE Name = 'Anguilla'"
  },
  {
    "id":"a7077b7a0f70fac078e95093cec8fb26d721a60f9c4c08398d4592e55fcb39c8",
    "db_id":"world_1",
    "question":"Which region is the city Kabul located in?",
    "query":"SELECT Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ city ] Predicate [ Name = 'Kabul' ] Output [ Name , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Region ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Predicate [ Name = 'Kabul' ] Output [ Name , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Region ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, CountryCode FROM world_1.city WHERE Name = 'Kabul' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
    "clean_query":"SELECT Region FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
  },
  {
    "id":"f13ab0950e935045b8c2cf6da9d54577f46a2563067fbd21c9f82411262a20ba",
    "db_id":"world_1",
    "question":"What region is Kabul in?",
    "query":"SELECT Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ city ] Predicate [ Name = 'Kabul' ] Output [ Name , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Region ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Predicate [ Name = 'Kabul' ] Output [ Name , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Region ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, CountryCode FROM world_1.city WHERE Name = 'Kabul' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
    "clean_query":"SELECT Region FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T1.Code = T2.CountryCode WHERE T2.Name = 'Kabul'"
  },
  {
    "id":"b42c56ca3986518a42d21d9a1861a788415493c0260395d2d232b10d6da2bb65",
    "db_id":"world_1",
    "question":"Which language is the most popular in Aruba?",
    "query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Percentage , Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language , #2.Percentage ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Percentage DESC ] Output [ Percentage , Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Percentage , Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language , #2.Percentage ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Percentage DESC ] Output [ Percentage , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT Percentage, Language, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Language, Scan_2.Percentage FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Percentage, Language FROM Join_3 ORDER BY Percentage DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC"
  },
  {
    "id":"1e42d2900c9e527b66357dcab22aba24c3b4847d0413b659e3577639518175f7",
    "db_id":"world_1",
    "question":"What language is predominantly spoken in Aruba?",
    "query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Percentage , Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language , #2.Percentage ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Percentage DESC ] Output [ Percentage , Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Percentage , Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language , #2.Percentage ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Percentage DESC ] Output [ Percentage , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT Percentage, Language, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Language, Scan_2.Percentage FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Percentage, Language FROM Join_3 ORDER BY Percentage DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' ORDER BY Percentage DESC"
  },
  {
    "id":"eaf31b9958df56510060b3166c48aad13728255fcd5fe25e6770bd3b14055dc6",
    "db_id":"world_1",
    "question":"What are the population and life expectancies in Brazil?",
    "query":"SELECT Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Brazil' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Brazil' ] Output [ Name , Population , LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Brazil' ] Output [ Name , Population , LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population, LifeExpectancy FROM world_1.country WHERE Name = 'Brazil' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Population , LifeExpectancy FROM world_1.country  WHERE Name = 'Brazil'"
  },
  {
    "id":"b8eb279e57648803c6d1bf4c7b1a4c8242049aa9b87445bb05f609181fb3dc50",
    "db_id":"world_1",
    "question":"Give me Brazil's population and life expectancies.",
    "query":"SELECT Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Brazil' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Brazil' ] Output [ Name , Population , LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Brazil' ] Output [ Name , Population , LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population, LifeExpectancy FROM world_1.country WHERE Name = 'Brazil' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Population , LifeExpectancy FROM world_1.country  WHERE Name = 'Brazil'"
  },
  {
    "id":"e1606375d3c23c6a2f2818d49e782b1425a672757cbc62f62375fa926d4a216c",
    "db_id":"world_1",
    "question":"What are the region and population of Angola?",
    "query":"SELECT Population , Region FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Angola' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Angola' ] Output [ Name , Population , Region ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Angola' ] Output [ Name , Population , Region ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population, Region FROM world_1.country WHERE Name = 'Angola' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Population , Region FROM world_1.country  WHERE Name = 'Angola'"
  },
  {
    "id":"7956562de86b573a31dfeb98d0b90656fb45a70318182803401388262c78da8b",
    "db_id":"world_1",
    "question":"What region does Angola belong to and what is its population?",
    "query":"SELECT Population , Region FROM world_1.country WITH (FORCESCAN) WHERE Name = 'Angola' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Angola' ] Output [ Name , Population , Region ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Angola' ] Output [ Name , Population , Region ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population, Region FROM world_1.country WHERE Name = 'Angola' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Population , Region FROM world_1.country  WHERE Name = 'Angola'"
  },
  {
    "id":"447bf0c569ae8d2fdba890134e396060901e148955b831579e829629ea319d33",
    "db_id":"world_1",
    "question":"What is the average expected life expectancy for countries in the region of Central Africa?",
    "query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Central Africa' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Region = 'Central Africa' ] Output [ LifeExpectancy , Region ] ; #2 = Aggregate [ #1 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Central Africa' ] Output [ LifeExpectancy , Region ] ; #2 = Aggregate [ #1 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT LifeExpectancy, Region FROM world_1.country WHERE Region = 'Central Africa' ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Region = 'Central Africa'"
  },
  {
    "id":"350ce507e25e14e8dc42ed1910caf123b3252f15286f9b7b2cebf148c1fce446",
    "db_id":"world_1",
    "question":"How long is the people's average life expectancy in Central Africa?",
    "query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Region = 'Central Africa' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Region = 'Central Africa' ] Output [ LifeExpectancy , Region ] ; #2 = Aggregate [ #1 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Region = 'Central Africa' ] Output [ LifeExpectancy , Region ] ; #2 = Aggregate [ #1 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT LifeExpectancy, Region FROM world_1.country WHERE Region = 'Central Africa' ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Region = 'Central Africa'"
  },
  {
    "id":"b6dbcf35e637466fb878964b2ca6759c7d8c27b687b8e18916214f47b4fb9708",
    "db_id":"world_1",
    "question":"What is the name of country that has the shortest life expectancy in Asia?",
    "query":"SELECT TOP 1 Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY LifeExpectancy OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Continent , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ LifeExpectancy ASC ] Output [ Name , LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Continent , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ LifeExpectancy ASC ] Output [ Name , LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent, LifeExpectancy FROM world_1.country ), Filter_2 AS ( SELECT Name, LifeExpectancy FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, LifeExpectancy FROM Filter_2 ORDER BY LifeExpectancy ASC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Name FROM world_1.country  WHERE Continent = 'Asia' ORDER BY LifeExpectancy"
  },
  {
    "id":"6c9d0187eaa14d3822b76fab25575f0bd029a4aae739341d09c7aa944fbb9678",
    "db_id":"world_1",
    "question":"Give the name of the country in Asia with the lowest life expectancy.",
    "query":"SELECT TOP 1 Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY LifeExpectancy OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Continent , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ LifeExpectancy ASC ] Output [ Name , LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Continent , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ LifeExpectancy ASC ] Output [ Name , LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent, LifeExpectancy FROM world_1.country ), Filter_2 AS ( SELECT Name, LifeExpectancy FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, LifeExpectancy FROM Filter_2 ORDER BY LifeExpectancy ASC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Name FROM world_1.country  WHERE Continent = 'Asia' ORDER BY LifeExpectancy"
  },
  {
    "id":"ad1402fa95fd3fadae44e208dbad1503f63f97dff7c87df4e4ad632bf12f911b",
    "db_id":"world_1",
    "question":"What is the total population and maximum GNP in Asia?",
    "query":"SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ GNP , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ GNP , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , MAX(GNP) AS Max_GNP ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ GNP , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ GNP , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , MAX(GNP) AS Max_GNP ]",
    "cte":"WITH Scan_1 AS ( SELECT GNP, Continent, Population FROM world_1.country ), Filter_2 AS ( SELECT GNP, Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, MAX(GNP) AS Max_GNP FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country  WHERE Continent = 'Asia'"
  },
  {
    "id":"a063d955c79fd05ec31becccdbd310b4bc3d29e965130d1e7c2b89b7f0e3e1b2",
    "db_id":"world_1",
    "question":"How many people live in Asia, and what is the largest GNP among them?",
    "query":"SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ GNP , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ GNP , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , MAX(GNP) AS Max_GNP ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ GNP , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ GNP , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , MAX(GNP) AS Max_GNP ]",
    "cte":"WITH Scan_1 AS ( SELECT GNP, Continent, Population FROM world_1.country ), Filter_2 AS ( SELECT GNP, Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, MAX(GNP) AS Max_GNP FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population , max ( GNP ) AS Max_GNP FROM world_1.country  WHERE Continent = 'Asia'"
  },
  {
    "id":"a413d0d9c13eaf0c7ba05ab34db24918f93f106adeb3d8c794efab911446ac22",
    "db_id":"world_1",
    "question":"What is the average life expectancy in African countries that are republics?",
    "query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ Continent , GovernmentForm , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ LifeExpectancy ] ; #3 = Aggregate [ #2 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ Continent , GovernmentForm , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ LifeExpectancy ] ; #3 = Aggregate [ #2 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, GovernmentForm, LifeExpectancy FROM world_1.country WHERE GovernmentForm = 'Republic' ), Filter_2 AS ( SELECT LifeExpectancy FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'"
  },
  {
    "id":"48d3b1951efeabcc1977bdb8ee2d1140c1f13dd2d22d9335243284834c4c12e1",
    "db_id":"world_1",
    "question":"Give the average life expectancy for countries in Africa which are republics?",
    "query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND GovernmentForm = 'Republic' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ Continent , GovernmentForm , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ LifeExpectancy ] ; #3 = Aggregate [ #2 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ Continent , GovernmentForm , LifeExpectancy ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ LifeExpectancy ] ; #3 = Aggregate [ #2 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, GovernmentForm, LifeExpectancy FROM world_1.country WHERE GovernmentForm = 'Republic' ), Filter_2 AS ( SELECT LifeExpectancy FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Continent = 'Africa' AND GovernmentForm = 'Republic'"
  },
  {
    "id":"6cc665c83afd60499ff4e24745c41e5fb4724d43e9409a2e72f07d8b013a4814",
    "db_id":"world_1",
    "question":"What is the total surface area of the continents Asia and Europe?",
    "query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OR Continent = 'Europe' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' OR Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' OR Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Asia' OR Continent = 'Europe' ), Aggregate_3 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Continent = 'Asia' OR Continent = 'Europe'"
  },
  {
    "id":"86c55881b46a5a574126c33dc389f48f0015abfa067f0bf84d197424dcfeab3f",
    "db_id":"world_1",
    "question":"Give the total surface area covered by countries in Asia or Europe.",
    "query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' OR Continent = 'Europe' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' OR Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' OR Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ SUM(SurfaceArea) AS Sum_SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Asia' OR Continent = 'Europe' ), Aggregate_3 AS ( SELECT SUM(SurfaceArea) AS Sum_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT sum ( SurfaceArea ) AS Sum_SurfaceArea FROM world_1.country  WHERE Continent = 'Asia' OR Continent = 'Europe'"
  },
  {
    "id":"87a14e66e6e77a9297169720ad579f780bf39faa6d4b05b82771e1e62f75d873",
    "db_id":"world_1",
    "question":"How many people live in Gelderland district?",
    "query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.city WITH (FORCESCAN) WHERE District = 'Gelderland' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ city ] Predicate [ District = 'Gelderland' ] Output [ District , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Predicate [ District = 'Gelderland' ] Output [ District , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population ]",
    "cte":"WITH Scan_1 AS ( SELECT District, Population FROM world_1.city WHERE District = 'Gelderland' ), Aggregate_2 AS ( SELECT SUM(Population) AS Sum_Population FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.city  WHERE District = 'Gelderland'"
  },
  {
    "id":"d63af966914473b096de571cad64b5b43edd5043e710afc66f28430d0095ca9b",
    "db_id":"world_1",
    "question":"What is the total population of Gelderland district?",
    "query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.city WITH (FORCESCAN) WHERE District = 'Gelderland' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ city ] Predicate [ District = 'Gelderland' ] Output [ District , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Predicate [ District = 'Gelderland' ] Output [ District , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population ]",
    "cte":"WITH Scan_1 AS ( SELECT District, Population FROM world_1.city WHERE District = 'Gelderland' ), Aggregate_2 AS ( SELECT SUM(Population) AS Sum_Population FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.city  WHERE District = 'Gelderland'"
  },
  {
    "id":"b08ef71ef93254d405738b9cd0374cff3985ee5e36c497a19f987ccff4384b5f",
    "db_id":"world_1",
    "question":"What is the average GNP and total population in all nations whose government is US territory?",
    "query":"SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'US Territory' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'US Territory' ] Output [ GNP , GovernmentForm , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population , AVG(GNP) AS Avg_GNP ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'US Territory' ] Output [ GNP , GovernmentForm , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population , AVG(GNP) AS Avg_GNP ]",
    "cte":"WITH Scan_1 AS ( SELECT GNP, GovernmentForm, Population FROM world_1.country WHERE GovernmentForm = 'US Territory' ), Aggregate_2 AS ( SELECT SUM(Population) AS Sum_Population, AVG(GNP) AS Avg_GNP FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country  WHERE GovernmentForm = 'US Territory'"
  },
  {
    "id":"38149da0bf176f61c70db72f6915039e6dee7a9e184475459d86407d032bdf3d",
    "db_id":"world_1",
    "question":"Give the mean GNP and total population of nations which are considered US territory.",
    "query":"SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm = 'US Territory' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'US Territory' ] Output [ GNP , GovernmentForm , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population , AVG(GNP) AS Avg_GNP ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'US Territory' ] Output [ GNP , GovernmentForm , Population ] ; #2 = Aggregate [ #1 ] Output [ SUM(Population) AS Sum_Population , AVG(GNP) AS Avg_GNP ]",
    "cte":"WITH Scan_1 AS ( SELECT GNP, GovernmentForm, Population FROM world_1.country WHERE GovernmentForm = 'US Territory' ), Aggregate_2 AS ( SELECT SUM(Population) AS Sum_Population, AVG(GNP) AS Avg_GNP FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( GNP ) AS Avg_GNP , sum ( population ) AS Sum_population FROM world_1.country  WHERE GovernmentForm = 'US Territory'"
  },
  {
    "id":"0107b0ffdcc55beb72507d69c0c32359b7bb551e3bcd2bac2dfb332b5809dc57",
    "db_id":"world_1",
    "question":"How many unique languages are spoken in the world?",
    "query":"SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ countrylanguage ] Distinct [ true ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Distinct [ true ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage"
  },
  {
    "id":"3c4d21d33530da607dd924e2bc3544cedcadf73d4cfb0e585c45b6a36baf5b23",
    "db_id":"world_1",
    "question":"What is the number of distinct languages used around the world?",
    "query":"SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ countrylanguage ] Distinct [ true ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Distinct [ true ] Output [ Language ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT LANGUAGE ) AS Count_Dist_LANGUAGE FROM world_1.countrylanguage"
  },
  {
    "id":"40e5da0fbd145acd54d3d006d747228d77045559ef4773caa086c8734be6f556",
    "db_id":"world_1",
    "question":"How many type of governments are in Africa?",
    "query":"SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , GovernmentForm ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Distinct [ true ] Output [ GovernmentForm ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , GovernmentForm ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Distinct [ true ] Output [ GovernmentForm ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, GovernmentForm FROM world_1.country ), Filter_2 AS ( SELECT DISTINCT GovernmentForm FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country  WHERE Continent = 'Africa'"
  },
  {
    "id":"c806b535829c219151ad9a84fea53ee58667be3b934659c7d28adde55c6b46f0",
    "db_id":"world_1",
    "question":"How many different forms of governments are there in Africa?",
    "query":"SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , GovernmentForm ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Distinct [ true ] Output [ GovernmentForm ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , GovernmentForm ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Distinct [ true ] Output [ GovernmentForm ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, GovernmentForm FROM world_1.country ), Filter_2 AS ( SELECT DISTINCT GovernmentForm FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT count ( DISTINCT GovernmentForm ) AS Count_Dist_GovernmentForm FROM world_1.country  WHERE Continent = 'Africa'"
  },
  {
    "id":"26ad51ff8d130d2aa117e8cb6d7ef07ce38bfbc418daa39207a4140fd1f93afa",
    "db_id":"world_1",
    "question":"What is the total number of languages used in Aruba?",
    "query":"SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Code , #1.Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Code , #1.Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba'"
  },
  {
    "id":"a1757bd28d3c99a6d0f79e9427ace21cf824ba79417c1559f8b20ff238b12c32",
    "db_id":"world_1",
    "question":"How many languages are spoken in Aruba?",
    "query":"SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Code , #1.Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Aruba' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Code , #1.Name ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Aruba' ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT COUNT ( T2.Language ) AS Count_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Aruba'"
  },
  {
    "id":"2d5af1ae79c1eadb9a64c4e4ee431c883c34d42643e1275086b93079bebd1da4",
    "db_id":"world_1",
    "question":"How many official languages does Afghanistan have?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Afghanistan' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #1.Code , #1.Name ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Afghanistan' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #1.Code , #1.Name ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Afghanistan' ), Scan_2 AS ( SELECT CountryCode, IsOfficial FROM world_1.countrylanguage ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T'"
  },
  {
    "id":"fcb55729d495351ebf7cd2023a68b2f96ba3ef9f97bf285aa825d8e40b9fb5b0",
    "db_id":"world_1",
    "question":"How many official languages are spoken in Afghanistan?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Name = 'Afghanistan' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #1.Code , #1.Name ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Name = 'Afghanistan' ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #1.Code , #1.Name ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country WHERE Name = 'Afghanistan' ), Scan_2 AS ( SELECT CountryCode, IsOfficial FROM world_1.countrylanguage ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Scan_1.Code, Scan_1.Name FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Name = 'Afghanistan' AND IsOfficial = 'T'"
  },
  {
    "id":"6f2b7f8fdc2f6cbf4c2b61688a16fbb31573f8fc967ef5acad0f68f46876e896",
    "db_id":"world_1",
    "question":"What is name of the country that speaks the largest number of languages?",
    "query":"SELECT TOP 1 T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"4bd4410da025c4c92f23a5169756fb4e81a8495682cd19482dd9e8f84a988855",
    "db_id":"world_1",
    "question":"Give the name of the nation that uses the greatest amount of languages.",
    "query":"SELECT TOP 1 T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), TopSort_5 AS ( SELECT TOP 1 Name, Count_Star FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"196aa60352af0cf7e4ef042eadf2f963c0c3073019e762a018959cca24f67b02",
    "db_id":"world_1",
    "question":"Which continent has the most diverse languages?",
    "query":"SELECT TOP 1 T1.Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Continent ] ; #4 = Aggregate [ #3 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Continent ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Continent ] ; #4 = Aggregate [ #3 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Continent ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Continent, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Continent ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Continent FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"7ddb8484384a410a4ee334b2add390a2c95c81ba0d19f7b4fce4db288fef6f2b",
    "db_id":"world_1",
    "question":"Which continent speaks the most languages?",
    "query":"SELECT TOP 1 T1.Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Continent ] ; #4 = Aggregate [ #3 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Continent ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Continent ] ; #4 = Aggregate [ #3 ] GroupBy [ Continent ] Output [ Continent , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Continent ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Continent, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Continent ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Continent FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"fdfea30a058eb1515bcf094ea6132c66bcd901c2ecc1be5f888c488c81485f8e",
    "db_id":"world_1",
    "question":"How many countries speak both English and Dutch?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ CountryCode , Language ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Distinct [ true ] Output [ #1.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ CountryCode , Language ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.CountryCode = #4.Code ] Distinct [ true ] Output [ #4.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Distinct [ true ] Output [ #3.Name ] ; #8 = Aggregate [ #7 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ CountryCode , Language ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Distinct [ true ] Output [ #1.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ CountryCode , Language ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.CountryCode = #4.Code ] Distinct [ true ] Output [ #4.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Distinct [ true ] Output [ #3.Name ] ; #8 = Aggregate [ #7 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'english' ), Join_3 AS ( SELECT DISTINCT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_2.CountryCode = Scan_1.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Scan_5 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'dutch' ), Join_6 AS ( SELECT DISTINCT Scan_4.Name FROM Scan_4 JOIN Scan_5 ON Scan_5.CountryCode = Scan_4.Code ), Intersect_7 AS ( SELECT Join_3.Name FROM Join_3 WHERE Name IN (SELECT Name FROM Join_6) ), Aggregate_8 AS ( SELECT COUNT(*) AS Count_Star FROM Intersect_7 ) SELECT * FROM Aggregate_8",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10"
  },
  {
    "id":"b23e766b20d801d1a7c381585433382250fd7b37aeabd1fa122e67c8d8381468",
    "db_id":"world_1",
    "question":"What is the number of nations that use English and Dutch?",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ CountryCode , Language ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Distinct [ true ] Output [ #1.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ CountryCode , Language ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.CountryCode = #4.Code ] Distinct [ true ] Output [ #4.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Distinct [ true ] Output [ #3.Name ] ; #8 = Aggregate [ #7 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ CountryCode , Language ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Distinct [ true ] Output [ #1.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ CountryCode , Language ] ; #6 = Join [ #4 , #5 ] Predicate [ #5.CountryCode = #4.Code ] Distinct [ true ] Output [ #4.Name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.Name = #6.Name ] Distinct [ true ] Output [ #3.Name ] ; #8 = Aggregate [ #7 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'english' ), Join_3 AS ( SELECT DISTINCT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_2.CountryCode = Scan_1.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Scan_5 AS ( SELECT CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'dutch' ), Join_6 AS ( SELECT DISTINCT Scan_4.Name FROM Scan_4 JOIN Scan_5 ON Scan_5.CountryCode = Scan_4.Code ), Intersect_7 AS ( SELECT Join_3.Name FROM Join_3 WHERE Name IN (SELECT Name FROM Join_6) ), Aggregate_8 AS ( SELECT COUNT(*) AS Count_Star FROM Intersect_7 ) SELECT * FROM Aggregate_8",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' )  AS T10"
  },
  {
    "id":"5c61e85b2ff5cd14b865b09f64f10986de9093ff1ecd8910423dc80bd72b86ba",
    "db_id":"world_1",
    "question":"What are the names of nations speak both English and French?",
    "query":"SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Name , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Code , #2.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Intersect [ #3 , #4 ] Predicate [ #3.Name = #4.Name ] Output [ #3.Code , #3.Name ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.Code = #6.CountryCode ] Distinct [ true ] Output [ #5.Code , #5.Name ] ; #8 = Aggregate [ #7 ] GroupBy [ Name ] Output [ Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Name , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Code , #2.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Intersect [ #3 , #4 ] Predicate [ #3.Name = #4.Name ] Output [ #3.Code , #3.Name ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.Code = #6.CountryCode ] Distinct [ true ] Output [ #5.Code , #5.Name ] ; #8 = Aggregate [ #7 ] GroupBy [ Name ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Scan_2 AS ( SELECT Name, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Code, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Intersect_5 AS ( SELECT Join_3.Code, Join_3.Name FROM Join_3 WHERE Name IN (SELECT Name FROM Scan_4) ), Scan_6 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Join_7 AS ( SELECT DISTINCT Intersect_5.Code, Intersect_5.Name FROM Intersect_5 JOIN Scan_6 ON Intersect_5.Code = Scan_6.CountryCode ), Aggregate_8 AS ( SELECT Name FROM Join_7 GROUP BY Name ) SELECT * FROM Aggregate_8",
    "clean_query":"SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'"
  },
  {
    "id":"fe1e4fc69d4dfc7f14ea8c7ccb0d3d686be08850c06a3118dbb5c2c166fec18d",
    "db_id":"world_1",
    "question":"Give the names of nations that speak both English and French.",
    "query":"SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Name , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Code , #2.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Intersect [ #3 , #4 ] Predicate [ #3.Name = #4.Name ] Output [ #3.Code , #3.Name ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.Code = #6.CountryCode ] Distinct [ true ] Output [ #5.Code , #5.Name ] ; #8 = Aggregate [ #7 ] GroupBy [ Name ] Output [ Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Name , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Output [ #2.Code , #2.Name ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Intersect [ #3 , #4 ] Predicate [ #3.Name = #4.Name ] Output [ #3.Code , #3.Name ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.Code = #6.CountryCode ] Distinct [ true ] Output [ #5.Code , #5.Name ] ; #8 = Aggregate [ #7 ] GroupBy [ Name ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Scan_2 AS ( SELECT Name, Code FROM world_1.country ), Join_3 AS ( SELECT Scan_2.Code, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Intersect_5 AS ( SELECT Join_3.Code, Join_3.Name FROM Join_3 WHERE Name IN (SELECT Name FROM Scan_4) ), Scan_6 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Join_7 AS ( SELECT DISTINCT Intersect_5.Code, Intersect_5.Name FROM Intersect_5 JOIN Scan_6 ON Intersect_5.Code = Scan_6.CountryCode ), Aggregate_8 AS ( SELECT Name FROM Join_7 GROUP BY Name ) SELECT * FROM Aggregate_8",
    "clean_query":"SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'"
  },
  {
    "id":"cf7eea7b6f50c57390d38c86939bf535a224b057c31c25a666208629c5ce7a00",
    "db_id":"world_1",
    "question":"What are the names of nations where both English and French are official languages?",
    "query":"SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Code , #3.Name ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Intersect [ #4 , #5 ] Predicate [ #4.Name = #5.Name ] Output [ #4.Name , #4.Code ] ; #7 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #8 = Filter [ #7 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #9 = Join [ #6 , #8 ] Predicate [ #6.Code = #8.CountryCode ] Distinct [ true ] Output [ #6.Code , #6.Name ] ; #10 = Aggregate [ #9 ] GroupBy [ Name ] Output [ Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Code , #3.Name ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Intersect [ #4 , #5 ] Predicate [ #4.Name = #5.Name ] Output [ #4.Name , #4.Code ] ; #7 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #8 = Filter [ #7 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #9 = Join [ #6 , #8 ] Predicate [ #6.Code = #8.CountryCode ] Distinct [ true ] Output [ #6.Code , #6.Name ] ; #10 = Aggregate [ #9 ] GroupBy [ Name ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 'T' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Code, Scan_3.Name FROM Filter_2 JOIN Scan_3 ON Filter_2.CountryCode = Scan_3.Code ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Intersect_6 AS ( SELECT Join_4.Name, Join_4.Code FROM Join_4 WHERE Name IN (SELECT Name FROM Scan_5) ), Scan_7 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_8 AS ( SELECT CountryCode FROM Scan_7 WHERE IsOfficial = 'T' ), Join_9 AS ( SELECT DISTINCT Intersect_6.Code, Intersect_6.Name FROM Intersect_6 JOIN Filter_8 ON Intersect_6.Code = Filter_8.CountryCode ), Aggregate_10 AS ( SELECT Name FROM Join_9 GROUP BY Name ) SELECT * FROM Aggregate_10",
    "clean_query":"SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
  },
  {
    "id":"dc5f3fb7030d664528f7de029349056a952430b2c758a96323474d603b11c727",
    "db_id":"world_1",
    "question":"Give the names of countries with English and French as official languages.",
    "query":"SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Code , #3.Name ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Intersect [ #4 , #5 ] Predicate [ #4.Name = #5.Name ] Output [ #4.Name , #4.Code ] ; #7 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #8 = Filter [ #7 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #9 = Join [ #6 , #8 ] Predicate [ #6.Code = #8.CountryCode ] Distinct [ true ] Output [ #6.Code , #6.Name ] ; #10 = Aggregate [ #9 ] GroupBy [ Name ] Output [ Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'French' ] Output [ Language , IsOfficial , CountryCode ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Code , #3.Name ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Intersect [ #4 , #5 ] Predicate [ #4.Name = #5.Name ] Output [ #4.Name , #4.Code ] ; #7 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , IsOfficial , CountryCode ] ; #8 = Filter [ #7 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #9 = Join [ #6 , #8 ] Predicate [ #6.Code = #8.CountryCode ] Distinct [ true ] Output [ #6.Code , #6.Name ] ; #10 = Aggregate [ #9 ] GroupBy [ Name ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'French' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 'T' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Code, Scan_3.Name FROM Filter_2 JOIN Scan_3 ON Filter_2.CountryCode = Scan_3.Code ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Intersect_6 AS ( SELECT Join_4.Name, Join_4.Code FROM Join_4 WHERE Name IN (SELECT Name FROM Scan_5) ), Scan_7 AS ( SELECT Language, IsOfficial, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_8 AS ( SELECT CountryCode FROM Scan_7 WHERE IsOfficial = 'T' ), Join_9 AS ( SELECT DISTINCT Intersect_6.Code, Intersect_6.Name FROM Intersect_6 JOIN Filter_8 ON Intersect_6.Code = Filter_8.CountryCode ), Aggregate_10 AS ( SELECT Name FROM Join_9 GROUP BY Name ) SELECT * FROM Aggregate_10",
    "clean_query":"SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' INTERSECT SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'French' AND T2.IsOfficial = 'T'"
  },
  {
    "id":"50b5150d0be2fb25fb3c75ba5f9efedab022b25ddecc1718f39ef2cd8d319782",
    "db_id":"world_1",
    "question":"What is the number of distinct continents where Chinese is spoken?",
    "query":"SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Continent , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Continent ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Continent , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Continent ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Chinese' ), Scan_2 AS ( SELECT Continent, Code FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese'"
  },
  {
    "id":"caf62133487d41ae6c81bff1ac1282aecfff3503c87cfb30cb05002b66459a4f",
    "db_id":"world_1",
    "question":"How many continents speak Chinese?",
    "query":"SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Continent , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Continent ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Continent , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Continent ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Chinese' ), Scan_2 AS ( SELECT Continent, Code FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Continent FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT COUNT ( DISTINCT Continent ) AS Count_Dist_Continent FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Chinese'"
  },
  {
    "id":"4951f1256981c4e699025f83ed4e0568f0da2b0adfeb2a539dc76094ae288c84",
    "db_id":"world_1",
    "question":"What are the regions that use English or Dutch?",
    "query":"SELECT DISTINCT T1.Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' OR Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Region ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' OR Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Region ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Dutch' OR Language = 'English' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.Region FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
  },
  {
    "id":"67897312488350728a9012ddf25e860149ea5ed4025d589030cc862639fddb39",
    "db_id":"world_1",
    "question":"Which regions speak Dutch or English?",
    "query":"SELECT DISTINCT T1.Region FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' OR Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Region ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' OR Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ country ] Output [ Region , Code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.Code ] Distinct [ true ] Output [ #2.Region ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'Dutch' OR Language = 'English' ), Scan_2 AS ( SELECT Region, Code FROM world_1.country ), Join_3 AS ( SELECT DISTINCT Scan_2.Region FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.Code ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.Region FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch'"
  },
  {
    "id":"9613549d75cadf3aaf9e382df3277d0bf72df467f14c96d5783c19c5479f5f9b",
    "db_id":"world_1",
    "question":"What are the countries where either English or Dutch is the official language ?",
    "query":"select t1.name FROM world_1.country AS t1 WITH (FORCESCAN) join world_1.countrylanguage as t2 WITH (FORCESCAN) on t1.code = t2.countrycode where t2.language = 'english' and isofficial = 't' union select t1.name FROM world_1.country AS t1 WITH (FORCESCAN) join world_1.countrylanguage as t2 WITH (FORCESCAN) on t1.code = t2.countrycode where t2.language = 'dutch' and isofficial = 't' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ Language , CountryCode , IsOfficial ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ Language , CountryCode , IsOfficial ] ; #6 = Filter [ #5 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #7 = Scan Table [ country ] Output [ Name , Code ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.CountryCode = #7.Code ] Output [ #7.Name ] ; #9 = Union [ #4 , #8 ] Output [ #4.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'english' ] Output [ Language , CountryCode , IsOfficial ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Scan Table [ countrylanguage ] Predicate [ Language = 'dutch' ] Output [ Language , CountryCode , IsOfficial ] ; #6 = Filter [ #5 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #7 = Scan Table [ country ] Output [ Name , Code ] ; #8 = Join [ #6 , #7 ] Predicate [ #6.CountryCode = #7.Code ] Output [ #7.Name ] ; #9 = Union [ #4 , #8 ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'english' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 't' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Name FROM Filter_2 JOIN Scan_3 ON Filter_2.CountryCode = Scan_3.Code ), Scan_5 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'dutch' ), Filter_6 AS ( SELECT CountryCode FROM Scan_5 WHERE IsOfficial = 't' ), Scan_7 AS ( SELECT Name, Code FROM world_1.country ), Join_8 AS ( SELECT Scan_7.Name FROM Filter_6 JOIN Scan_7 ON Filter_6.CountryCode = Scan_7.Code ), Union_9 AS ( SELECT Name FROM Join_4 UNION SELECT Name FROM Join_8 ) SELECT * FROM Union_9",
    "clean_query":"select t1.name FROM world_1.country AS t1  join world_1.countrylanguage as t2  on t1.code = t2.countrycode where t2.language = 'english' and isofficial = 't' union select t1.name FROM world_1.country AS t1  join world_1.countrylanguage as t2  on t1.code = t2.countrycode where t2.language = 'dutch' and isofficial = 't'"
  },
  {
    "id":"5f6c5c97e4535a57a648be9149e33db7045c08bc96516c2e753c41f04e1e2583",
    "db_id":"world_1",
    "question":"Which countries have either English or Dutch as an official language?",
    "query":"SELECT * FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND IsOfficial = 'T' UNION SELECT * FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' AND IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Code2 , Region , IndepYear , HeadOfState , Name , GNPOld , Continent , GNP , Capital , LifeExpectancy , LocalName , SurfaceArea , Code , Population , GovernmentForm ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.CountryCode = #1.Code ] Output [ #3.IsOfficial , #1.LifeExpectancy , #3.Percentage , #1.Code , #1.IndepYear , #1.Region , #1.Capital , #1.LocalName , #1.Name , #1.Continent , #1.Population , #1.HeadOfState , #1.GovernmentForm , #1.GNP , #1.Code2 , #1.SurfaceArea , #1.GNPOld , #3.Language , #3.CountryCode ] ; #5 = Scan Table [ country ] Output [ Code2 , Region , IndepYear , HeadOfState , Name , GNPOld , Continent , GNP , Capital , LifeExpectancy , LocalName , SurfaceArea , Code , Population , GovernmentForm ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #7 = Filter [ #6 ] Predicate [ IsOfficial = 'T' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #8 = Join [ #5 , #7 ] Predicate [ #7.CountryCode = #5.Code ] Output [ #5.Population , #5.Code2 , #7.IsOfficial , #5.Name , #5.LifeExpectancy , #5.Code , #7.Percentage , #5.Continent , #5.GNP , #7.Language , #5.GNPOld , #5.SurfaceArea , #5.IndepYear , #5.Region , #5.HeadOfState , #5.GovernmentForm , #7.CountryCode , #5.LocalName , #5.Capital ] ; #9 = Union [ #4 , #8 ] Output [ #4.CountryCode , #4.IsOfficial , #4.Code2 , #4.Percentage , #4.Language , #4.LifeExpectancy , #4.GNP , #4.Region , #4.GNPOld , #4.Name , #4.IndepYear , #4.SurfaceArea , #4.Capital , #4.HeadOfState , #4.Population , #4.GovernmentForm , #4.Code , #4.Continent , #4.LocalName ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Code2 , Region , IndepYear , HeadOfState , Name , GNPOld , Continent , GNP , Capital , LifeExpectancy , LocalName , SurfaceArea , Code , Population , GovernmentForm ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #4 = Join [ #1 , #3 ] Predicate [ #3.CountryCode = #1.Code ] Output [ #3.IsOfficial , #1.LifeExpectancy , #3.Percentage , #1.Code , #1.IndepYear , #1.Region , #1.Capital , #1.LocalName , #1.Name , #1.Continent , #1.Population , #1.HeadOfState , #1.GovernmentForm , #1.GNP , #1.Code2 , #1.SurfaceArea , #1.GNPOld , #3.Language , #3.CountryCode ] ; #5 = Scan Table [ country ] Output [ Code2 , Region , IndepYear , HeadOfState , Name , GNPOld , Continent , GNP , Capital , LifeExpectancy , LocalName , SurfaceArea , Code , Population , GovernmentForm ] ; #6 = Scan Table [ countrylanguage ] Predicate [ Language = 'Dutch' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #7 = Filter [ #6 ] Predicate [ IsOfficial = 'T' ] Output [ IsOfficial , CountryCode , Language , Percentage ] ; #8 = Join [ #5 , #7 ] Predicate [ #7.CountryCode = #5.Code ] Output [ #5.Population , #5.Code2 , #7.IsOfficial , #5.Name , #5.LifeExpectancy , #5.Code , #7.Percentage , #5.Continent , #5.GNP , #7.Language , #5.GNPOld , #5.SurfaceArea , #5.IndepYear , #5.Region , #5.HeadOfState , #5.GovernmentForm , #7.CountryCode , #5.LocalName , #5.Capital ] ; #9 = Union [ #4 , #8 ] Output [ #4.CountryCode , #4.IsOfficial , #4.Code2 , #4.Percentage , #4.Language , #4.LifeExpectancy , #4.GNP , #4.Region , #4.GNPOld , #4.Name , #4.IndepYear , #4.SurfaceArea , #4.Capital , #4.HeadOfState , #4.Population , #4.GovernmentForm , #4.Code , #4.Continent , #4.LocalName ]",
    "cte":"WITH Scan_1 AS ( SELECT Code2, Region, IndepYear, HeadOfState, Name, GNPOld, Continent, GNP, Capital, LifeExpectancy, LocalName, SurfaceArea, Code, Population, GovernmentForm FROM world_1.country ), Scan_2 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_3 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Filter_3.IsOfficial, Scan_1.LifeExpectancy, Filter_3.Percentage, Scan_1.Code, Scan_1.IndepYear, Scan_1.Region, Scan_1.Capital, Scan_1.LocalName, Scan_1.Name, Scan_1.Continent, Scan_1.Population, Scan_1.HeadOfState, Scan_1.GovernmentForm, Scan_1.GNP, Scan_1.Code2, Scan_1.SurfaceArea, Scan_1.GNPOld, Filter_3.Language, Filter_3.CountryCode FROM Scan_1 JOIN Filter_3 ON Filter_3.CountryCode = Scan_1.Code ), Scan_5 AS ( SELECT Code2, Region, IndepYear, HeadOfState, Name, GNPOld, Continent, GNP, Capital, LifeExpectancy, LocalName, SurfaceArea, Code, Population, GovernmentForm FROM world_1.country ), Scan_6 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM world_1.countrylanguage WHERE Language = 'Dutch' ), Filter_7 AS ( SELECT IsOfficial, CountryCode, Language, Percentage FROM Scan_6 WHERE IsOfficial = 'T' ), Join_8 AS ( SELECT Scan_5.Population, Scan_5.Code2, Filter_7.IsOfficial, Scan_5.Name, Scan_5.LifeExpectancy, Scan_5.Code, Filter_7.Percentage, Scan_5.Continent, Scan_5.GNP, Filter_7.Language, Scan_5.GNPOld, Scan_5.SurfaceArea, Scan_5.IndepYear, Scan_5.Region, Scan_5.HeadOfState, Scan_5.GovernmentForm, Filter_7.CountryCode, Scan_5.LocalName, Scan_5.Capital FROM Scan_5 JOIN Filter_7 ON Filter_7.CountryCode = Scan_5.Code ), Union_9 AS ( SELECT CountryCode, IsOfficial, Code2, Percentage, Language, LifeExpectancy, GNP, Region, GNPOld, Name, IndepYear, SurfaceArea, Capital, HeadOfState, Population, GovernmentForm, Code, Continent, LocalName FROM Join_4 UNION SELECT CountryCode, IsOfficial, Code2, Percentage, Language, LifeExpectancy, GNP, Region, GNPOld, Name, IndepYear, SurfaceArea, Capital, HeadOfState, Population, GovernmentForm, Code, Continent, LocalName FROM Join_8 ) SELECT * FROM Union_9",
    "clean_query":"SELECT * FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND IsOfficial = 'T' UNION SELECT * FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch' AND IsOfficial = 'T'"
  },
  {
    "id":"ec825644def6d351087212ad83bc285b307c370ff3598206227c45b0b4188c7f",
    "db_id":"world_1",
    "question":"Which language is the most popular on the Asian continent?",
    "query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #3 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Code = #3.CountryCode ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #3 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Code = #3.CountryCode ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Code FROM world_1.country ), Filter_2 AS ( SELECT Code FROM Scan_1 WHERE Continent = 'Asia' ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_4 AS ( SELECT Scan_3.Language FROM Filter_2 JOIN Scan_3 ON Filter_2.Code = Scan_3.CountryCode ), Aggregate_5 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Language ), TopSort_6 AS ( SELECT TOP 1 Count_Star, Language FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"bd6c48013f2fe3554e4971954f587f19ac143f32bfc43bc64107385601892a7f",
    "db_id":"world_1",
    "question":"What is the language that is used by the largest number of Asian nations?",
    "query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #3 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Code = #3.CountryCode ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #3 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.Code = #3.CountryCode ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #6 = TopSort [ #5 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Code FROM world_1.country ), Filter_2 AS ( SELECT Code FROM Scan_1 WHERE Continent = 'Asia' ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_4 AS ( SELECT Scan_3.Language FROM Filter_2 JOIN Scan_3 ON Filter_2.Code = Scan_3.CountryCode ), Aggregate_5 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_4 GROUP BY Language ), TopSort_6 AS ( SELECT TOP 1 Count_Star, Language FROM Aggregate_5 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_6",
    "clean_query":"SELECT TOP 1 T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' GROUP BY T2.Language ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"325a3137319c748777644852730ad792ab3dcc7f88ab2407ae185d7899dde3c2",
    "db_id":"world_1",
    "question":"Which languages are spoken by only one country in republic governments?",
    "query":"SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language ] ; #4 = Aggregate [ #3 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 1 ] Output [ Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language ] ; #4 = Aggregate [ #3 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 1 ] Output [ Language ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm = 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Language FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Language ), Filter_5 AS ( SELECT Language FROM Aggregate_4 WHERE Count_Star = 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1"
  },
  {
    "id":"b903ad5349ab796f8ca5e9ac20b113a4b545f06cd1b8fd03918a5b11ed313a29",
    "db_id":"world_1",
    "question":"What languages are only used by a single country with a republic government?",
    "query":"SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language ] ; #4 = Aggregate [ #3 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 1 ] Output [ Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm = 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #2.Language ] ; #4 = Aggregate [ #3 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star = 1 ] Output [ Language ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm = 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_2.Language FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Language ), Filter_5 AS ( SELECT Language FROM Aggregate_4 WHERE Count_Star = 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT ( * ) = 1"
  },
  {
    "id":"26edc7b34917846dc6fb176c89ec97752e591daa31f3fadc5e0bcb84f4b56b2c",
    "db_id":"world_1",
    "question":"Find the city with the largest population that uses English.",
    "query":"SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ city ] Output [ Name , Population , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.CountryCode ] Output [ #2.Population , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ city ] Output [ Name , Population , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.CountryCode ] Output [ #2.Population , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_2 AS ( SELECT Name, Population, CountryCode FROM world_1.city ), Join_3 AS ( SELECT Scan_2.Population, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Name, Population FROM Join_3 ORDER BY Population DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1  JOIN world_1.countrylanguage AS T2  ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC"
  },
  {
    "id":"5ef06542a1781f98163159be9c68e3f95ece37b1693cc50f7cbc6bb37dbda369",
    "db_id":"world_1",
    "question":"What is the most populace city that speaks English?",
    "query":"SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ city ] Output [ Name , Population , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.CountryCode ] Output [ #2.Population , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #2 = Scan Table [ city ] Output [ Name , Population , CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.CountryCode = #2.CountryCode ] Output [ #2.Population , #2.Name ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_2 AS ( SELECT Name, Population, CountryCode FROM world_1.city ), Join_3 AS ( SELECT Scan_2.Population, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.CountryCode = Scan_2.CountryCode ), TopSort_4 AS ( SELECT TOP 1 Name, Population FROM Join_3 ORDER BY Population DESC ) SELECT * FROM TopSort_4",
    "clean_query":"SELECT TOP 1 T1.Name , T1.Population FROM world_1.city AS T1  JOIN world_1.countrylanguage AS T2  ON T1.CountryCode = T2.CountryCode WHERE T2.Language = 'English' ORDER BY T1.Population DESC"
  },
  {
    "id":"cf1777ff01be53121ea57ad7746f882c2f961f98fea981a64849e65d84fc5d67",
    "db_id":"world_1",
    "question":"Find the name, population and expected life length of asian country with the largest area?",
    "query":"SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Output [ Population , LifeExpectancy , SurfaceArea , Continent , Name ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , SurfaceArea , Population , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Population , LifeExpectancy , SurfaceArea , Continent , Name ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , SurfaceArea , Population , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Population, LifeExpectancy, SurfaceArea, Continent, Name FROM world_1.country ), Filter_2 AS ( SELECT Name, SurfaceArea, Population, LifeExpectancy FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, SurfaceArea, Population, LifeExpectancy FROM Filter_2 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country  WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC"
  },
  {
    "id":"076c9d19590b6ed576e8cbc4b87736164794b7f67abce410318e4a5a36166a83",
    "db_id":"world_1",
    "question":"What are the name, population, and life expectancy of the largest Asian country by land?",
    "query":"SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Output [ Population , LifeExpectancy , SurfaceArea , Continent , Name ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , SurfaceArea , Population , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Population , LifeExpectancy , SurfaceArea , Continent , Name ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Name , SurfaceArea , Population , LifeExpectancy ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Population, LifeExpectancy, SurfaceArea, Continent, Name FROM world_1.country ), Filter_2 AS ( SELECT Name, SurfaceArea, Population, LifeExpectancy FROM Scan_1 WHERE Continent = 'Asia' ), TopSort_3 AS ( SELECT TOP 1 Name, SurfaceArea, Population, LifeExpectancy FROM Filter_2 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Name , Population , LifeExpectancy FROM world_1.country  WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC"
  },
  {
    "id":"77339ce451bff4db5fb89e5639a28995743d1ebb7b76c82c33c1f952c058812d",
    "db_id":"world_1",
    "question":"What is average life expectancy in the countries where English is not the official language?",
    "query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , LifeExpectancy ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryCode = #4.Code ] Output [ #4.Name ] ; #6 = Except [ #1 , #5 ] Predicate [ #1.Name = #5.Name ] Output [ #1.LifeExpectancy ] ; #7 = Aggregate [ #6 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , LifeExpectancy ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryCode = #4.Code ] Output [ #4.Name ] ; #6 = Except [ #1 , #5 ] Predicate [ #1.Name = #5.Name ] Output [ #1.LifeExpectancy ] ; #7 = Aggregate [ #6 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, LifeExpectancy FROM world_1.country ), Scan_2 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Join_5 AS ( SELECT Scan_4.Name FROM Filter_3 JOIN Scan_4 ON Filter_3.CountryCode = Scan_4.Code ), Except_6 AS ( SELECT Scan_1.LifeExpectancy FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_5) ), Aggregate_7 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Except_6 ) SELECT * FROM Aggregate_7",
    "clean_query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' )"
  },
  {
    "id":"9e169afed9298dcaf606f723081977a0d33d4f22d10fc326ab83da4d35bc80d6",
    "db_id":"world_1",
    "question":"Give the mean life expectancy of countries in which English is not the official language.",
    "query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , LifeExpectancy ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryCode = #4.Code ] Output [ #4.Name ] ; #6 = Except [ #1 , #5 ] Predicate [ #1.Name = #5.Name ] Output [ #1.LifeExpectancy ] ; #7 = Aggregate [ #6 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , LifeExpectancy ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #4 = Scan Table [ country ] Output [ Name , Code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.CountryCode = #4.Code ] Output [ #4.Name ] ; #6 = Except [ #1 , #5 ] Predicate [ #1.Name = #5.Name ] Output [ #1.LifeExpectancy ] ; #7 = Aggregate [ #6 ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, LifeExpectancy FROM world_1.country ), Scan_2 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_3 AS ( SELECT CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Scan_4 AS ( SELECT Name, Code FROM world_1.country ), Join_5 AS ( SELECT Scan_4.Name FROM Filter_3 JOIN Scan_4 ON Filter_3.CountryCode = Scan_4.Code ), Except_6 AS ( SELECT Scan_1.LifeExpectancy FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_5) ), Aggregate_7 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy FROM Except_6 ) SELECT * FROM Aggregate_7",
    "clean_query":"SELECT avg ( LifeExpectancy ) AS Avg_LifeExpectancy FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' )"
  },
  {
    "id":"f7f4826cde3d4d2d0ff201160a9274986c4dc75f8346cba26e99e80fd3ccc0b4",
    "db_id":"world_1",
    "question":"What is the total number of people living in the nations that do not use English?",
    "query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Population ] ; #6 = Aggregate [ #5 ] Output [ SUM(Population) AS Sum_Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Population ] ; #6 = Aggregate [ #5 ] Output [ SUM(Population) AS Sum_Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryCode = Scan_3.Code ), Except_5 AS ( SELECT Scan_1.Population FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ), Aggregate_6 AS ( SELECT SUM(Population) AS Sum_Population FROM Except_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' )"
  },
  {
    "id":"aead834686e53b5a28f6330568c6b82b64797de7cded35cbc5b1feab82bda05c",
    "db_id":"world_1",
    "question":"How many people live in countries that do not speak English?",
    "query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.country WITH (FORCESCAN) WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Population ] ; #6 = Aggregate [ #5 ] Output [ SUM(Population) AS Sum_Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Scan Table [ country ] Output [ Name , Code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.CountryCode = #3.Code ] Output [ #3.Name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.Name = #4.Name ] Output [ #1.Population ] ; #6 = Aggregate [ #5 ] Output [ SUM(Population) AS Sum_Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Scan_3 AS ( SELECT Name, Code FROM world_1.country ), Join_4 AS ( SELECT Scan_3.Name FROM Scan_2 JOIN Scan_3 ON Scan_2.CountryCode = Scan_3.Code ), Except_5 AS ( SELECT Scan_1.Population FROM Scan_1 WHERE Name NOT IN (SELECT Name FROM Join_4) ), Aggregate_6 AS ( SELECT SUM(Population) AS Sum_Population FROM Except_5 ) SELECT * FROM Aggregate_6",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population FROM world_1.country  WHERE Name NOT IN ( SELECT T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' )"
  },
  {
    "id":"76aabb0a0ad501bbb8c847b9056b539fcd3780a5c7da5f754aee2fc436378746",
    "db_id":"world_1",
    "question":"What is the official language spoken in the country whose head of state is Beatrix?",
    "query":"SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ HeadOfState = 'Beatrix' ] Output [ HeadOfState , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #3.Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ HeadOfState = 'Beatrix' ] Output [ HeadOfState , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #3.Language ]",
    "cte":"WITH Scan_1 AS ( SELECT HeadOfState, Code FROM world_1.country WHERE HeadOfState = 'Beatrix' ), Scan_2 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ) SELECT * FROM Join_4",
    "clean_query":"SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T'"
  },
  {
    "id":"1d2463926c06c0b305d781cd6e0713784fbcac3498b19ded257d886e67364acc",
    "db_id":"world_1",
    "question":"What is the official language used in the country the name of whose head of state is Beatrix.",
    "query":"SELECT T2.Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ HeadOfState = 'Beatrix' ] Output [ HeadOfState , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #3.Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ HeadOfState = 'Beatrix' ] Output [ HeadOfState , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Output [ #3.Language ]",
    "cte":"WITH Scan_1 AS ( SELECT HeadOfState, Code FROM world_1.country WHERE HeadOfState = 'Beatrix' ), Scan_2 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ) SELECT * FROM Join_4",
    "clean_query":"SELECT T2.Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Beatrix' AND T2.IsOfficial = 'T'"
  },
  {
    "id":"24b9e3ac13501e8a2eb99f6d37af002f21006457b42f6138786b9a75515062a4",
    "db_id":"world_1",
    "question":"What is the total number of unique official languages spoken in the countries that are founded before 1930?",
    "query":"SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ IndepYear < 1930 ] Output [ IndepYear , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Distinct [ true ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear < 1930 ] Output [ IndepYear , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Distinct [ true ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT IndepYear, Code FROM world_1.country WHERE IndepYear < 1930 ), Scan_2 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT DISTINCT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T'"
  },
  {
    "id":"4081e5d7bc31db228a3c170e395df647ce46a1fd16e6f1ac5d2606249a8b1d37",
    "db_id":"world_1",
    "question":"For the countries founded before 1930, what is the total number of distinct official languages?",
    "query":"SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ IndepYear < 1930 ] Output [ IndepYear , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Distinct [ true ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ IndepYear < 1930 ] Output [ IndepYear , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ Language , CountryCode , IsOfficial ] ; #3 = Filter [ #2 ] Predicate [ IsOfficial = 'T' ] Output [ Language , CountryCode ] ; #4 = Join [ #1 , #3 ] Predicate [ #1.Code = #3.CountryCode ] Distinct [ true ] Output [ #3.Language ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT IndepYear, Code FROM world_1.country WHERE IndepYear < 1930 ), Scan_2 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage ), Filter_3 AS ( SELECT Language, CountryCode FROM Scan_2 WHERE IsOfficial = 'T' ), Join_4 AS ( SELECT DISTINCT Filter_3.Language FROM Scan_1 JOIN Filter_3 ON Scan_1.Code = Filter_3.CountryCode ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT count ( DISTINCT T2.Language ) AS Count_Dist_T2_Language FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode WHERE IndepYear < 1930 AND T2.IsOfficial = 'T'"
  },
  {
    "id":"1c3db4eb8cdcb620190283407819418853749cad50efe83d47189b48e2ecdde4",
    "db_id":"world_1",
    "question":"What are the countries that have greater surface area than any country in Europe?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Europe' ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ MIN(SurfaceArea) AS Min_SurfaceArea ] ; #4 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.SurfaceArea > #3.Min_SurfaceArea ] Output [ #4.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ MIN(SurfaceArea) AS Min_SurfaceArea ] ; #4 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.SurfaceArea > #3.Min_SurfaceArea ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Europe' ), Aggregate_3 AS ( SELECT MIN(SurfaceArea) AS Min_SurfaceArea FROM Filter_2 ), Scan_4 AS ( SELECT Name, SurfaceArea FROM world_1.country ), Join_5 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.SurfaceArea > Aggregate_3.Min_SurfaceArea ) SELECT * FROM Join_5",
    "clean_query":"SELECT Name FROM world_1.country  WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country  WHERE Continent = 'Europe' )"
  },
  {
    "id":"a1fb0df29395bbcc497b10676e7f0fcc9e1a41b4362640374d47995c3510d7a2",
    "db_id":"world_1",
    "question":"Which countries have greater area than that of any country in Europe?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Europe' ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ MIN(SurfaceArea) AS Min_SurfaceArea ] ; #4 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.SurfaceArea > #3.Min_SurfaceArea ] Output [ #4.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ SurfaceArea , Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ SurfaceArea ] ; #3 = Aggregate [ #2 ] Output [ MIN(SurfaceArea) AS Min_SurfaceArea ] ; #4 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #5 = Join [ #3 , #4 ] Predicate [ #4.SurfaceArea > #3.Min_SurfaceArea ] Output [ #4.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Continent FROM world_1.country ), Filter_2 AS ( SELECT SurfaceArea FROM Scan_1 WHERE Continent = 'Europe' ), Aggregate_3 AS ( SELECT MIN(SurfaceArea) AS Min_SurfaceArea FROM Filter_2 ), Scan_4 AS ( SELECT Name, SurfaceArea FROM world_1.country ), Join_5 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Scan_4 WHERE Scan_4.SurfaceArea > Aggregate_3.Min_SurfaceArea ) SELECT * FROM Join_5",
    "clean_query":"SELECT Name FROM world_1.country  WHERE SurfaceArea > ( SELECT min ( SurfaceArea ) AS Min_SurfaceArea FROM world_1.country  WHERE Continent = 'Europe' )"
  },
  {
    "id":"8e3e0c5cc6890da0f2ac1becf06e642b0b35b4f63f9c20289406a40c69a77641",
    "db_id":"world_1",
    "question":"What are the African countries that have a  population less than any country in Asia?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND population < ( SELECT max ( population ) AS Max_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MAX(Population) AS Max_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Africa' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population < #3.Max_Population ] Output [ #5.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MAX(Population) AS Max_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Africa' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population < #3.Max_Population ] Output [ #5.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Population FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT MAX(Population) AS Max_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Continent, Population FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Africa' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population < Aggregate_3.Max_Population ) SELECT * FROM Join_6",
    "clean_query":"SELECT Name FROM world_1.country  WHERE Continent = 'Africa' AND population < ( SELECT max ( population ) AS Max_population FROM world_1.country  WHERE Continent = 'Asia' )"
  },
  {
    "id":"1e24f527faaaa8d4bbae1ada8b98e945ff2183598b52186f41e56c2ea6b45afa",
    "db_id":"world_1",
    "question":"Which African countries have a smaller population than that of any country in Asia?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' AND population < ( SELECT min ( population ) AS Min_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MIN(Population) AS Min_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Africa' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population < #3.Min_Population ] Output [ #5.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Asia' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MIN(Population) AS Min_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Africa' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population < #3.Min_Population ] Output [ #5.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Population FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Asia' ), Aggregate_3 AS ( SELECT MIN(Population) AS Min_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Continent, Population FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Africa' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population < Aggregate_3.Min_Population ) SELECT * FROM Join_6",
    "clean_query":"SELECT Name FROM world_1.country  WHERE Continent = 'Africa' AND population < ( SELECT min ( population ) AS Min_population FROM world_1.country  WHERE Continent = 'Asia' )"
  },
  {
    "id":"b23e0c05a205accabd7aae54026cd0c93fc6315ab33314ad9de359fdc652715e",
    "db_id":"world_1",
    "question":"Which Asian countries have a population that is larger than any country in Africa?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' AND population > ( SELECT max ( population ) AS Max_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MAX(Population) AS Max_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Asia' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population > #3.Max_Population ] Output [ #5.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MAX(Population) AS Max_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Asia' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population > #3.Max_Population ] Output [ #5.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Population FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT MAX(Population) AS Max_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Continent, Population FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Asia' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population > Aggregate_3.Max_Population ) SELECT * FROM Join_6",
    "clean_query":"SELECT Name FROM world_1.country  WHERE Continent = 'Asia' AND population > ( SELECT max ( population ) AS Max_population FROM world_1.country  WHERE Continent = 'Africa' )"
  },
  {
    "id":"4a26693e8b64b388a869f74c12041375fe55f7851e8138794063998f3b04f9f3",
    "db_id":"world_1",
    "question":"What are the Asian countries which have a population larger than that of any country in Africa?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Asia' AND population > ( SELECT min ( population ) AS Min_population FROM world_1.country WITH (FORCESCAN) WHERE Continent = 'Africa' ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MIN(Population) AS Min_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Asia' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population > #3.Min_Population ] Output [ #5.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Africa' ] Output [ Population ] ; #3 = Aggregate [ #2 ] Output [ MIN(Population) AS Min_Population ] ; #4 = Scan Table [ country ] Output [ Name , Continent , Population ] ; #5 = Filter [ #4 ] Predicate [ Continent = 'Asia' ] Output [ Name , Population ] ; #6 = Join [ #3 , #5 ] Predicate [ #5.Population > #3.Min_Population ] Output [ #5.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Population FROM world_1.country ), Filter_2 AS ( SELECT Population FROM Scan_1 WHERE Continent = 'Africa' ), Aggregate_3 AS ( SELECT MIN(Population) AS Min_Population FROM Filter_2 ), Scan_4 AS ( SELECT Name, Continent, Population FROM world_1.country ), Filter_5 AS ( SELECT Name, Population FROM Scan_4 WHERE Continent = 'Asia' ), Join_6 AS ( SELECT Name FROM Aggregate_3 CROSS JOIN Filter_5 WHERE Filter_5.Population > Aggregate_3.Min_Population ) SELECT * FROM Join_6",
    "clean_query":"SELECT Name FROM world_1.country  WHERE Continent = 'Asia' AND population > ( SELECT min ( population ) AS Min_population FROM world_1.country  WHERE Continent = 'Africa' )"
  },
  {
    "id":"3344efc6cf9baa0bfa29c17aab9d688f6b48c8f4b7d92cf472dd385b9d171429",
    "db_id":"world_1",
    "question":"What are the country codes for countries that do not speak English?",
    "query":"SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #4 = Except [ #2 , #3 ] Predicate [ #2.CountryCode = #3.CountryCode ] Output [ #2.CountryCode ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #4 = Except [ #2 , #3 ] Predicate [ #2.CountryCode = #3.CountryCode ] Output [ #2.CountryCode ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_4 AS ( SELECT Aggregate_2.CountryCode FROM Aggregate_2 WHERE CountryCode NOT IN (SELECT CountryCode FROM Scan_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT CountryCode FROM world_1.countrylanguage  EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'"
  },
  {
    "id":"d75c9b7a13adce151a16d7cca833ab0cb99145f5a35857c3008c4f22ddb3bf44",
    "db_id":"world_1",
    "question":"Return the country codes for countries that do not speak English.",
    "query":"SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #4 = Except [ #2 , #3 ] Predicate [ #2.CountryCode = #3.CountryCode ] Output [ #2.CountryCode ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #4 = Except [ #2 , #3 ] Predicate [ #2.CountryCode = #3.CountryCode ] Output [ #2.CountryCode ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ), Scan_3 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_4 AS ( SELECT Aggregate_2.CountryCode FROM Aggregate_2 WHERE CountryCode NOT IN (SELECT CountryCode FROM Scan_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT CountryCode FROM world_1.countrylanguage  EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'"
  },
  {
    "id":"deabaedeb3981927bf1f396a795b435a3035bd61ca255b76038121b2dbae91d2",
    "db_id":"world_1",
    "question":"What are the country codes of countries where people use languages other than English?",
    "query":"SELECT DISTINCT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language <> 'English' ] Output [ Language , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language <> 'English' ] Output [ Language , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language <> 'English' ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT DISTINCT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE ! = 'English'"
  },
  {
    "id":"d1f8533f2672bfc50cab0c09ffe4250953ede5126b08584e81b5315b1947af94",
    "db_id":"world_1",
    "question":"Give the country codes for countries in which people speak langauges that are not English.",
    "query":"SELECT DISTINCT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE ! = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language <> 'English' ] Output [ Language , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language <> 'English' ] Output [ Language , CountryCode ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language <> 'English' ), Aggregate_2 AS ( SELECT CountryCode FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT DISTINCT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE ! = 'English'"
  },
  {
    "id":"411e3a9f339783dbf100ebab4a646a530bbbf7c0315e64cb7fc5982f87dd007e",
    "db_id":"world_1",
    "question":"What are the codes of the countries that do not speak English and whose government forms are not Republic?",
    "query":"SELECT Code FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm <> 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Output [ #1.Code ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm <> 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Output [ #1.Code ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm <> 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_3 AS ( SELECT Scan_1.Code FROM Scan_1 WHERE Code NOT IN (SELECT CountryCode FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Code FROM world_1.country  WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'"
  },
  {
    "id":"37f9a40298fb04b95b25179baa94b661d7fd499541ebb2c201308c9abf2387cf",
    "db_id":"world_1",
    "question":"Return the codes of countries that do not speak English and do not have Republics for governments.",
    "query":"SELECT Code FROM world_1.country WITH (FORCESCAN) WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'English' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Predicate [ GovernmentForm <> 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Output [ #1.Code ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ GovernmentForm <> 'Republic' ] Output [ GovernmentForm , Code ] ; #2 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.CountryCode = #1.Code ] Output [ #1.Code ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm, Code FROM world_1.country WHERE GovernmentForm <> 'Republic' ), Scan_2 AS ( SELECT Language, CountryCode FROM world_1.countrylanguage WHERE Language = 'English' ), Except_3 AS ( SELECT Scan_1.Code FROM Scan_1 WHERE Code NOT IN (SELECT CountryCode FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Code FROM world_1.country  WHERE GovernmentForm ! = 'Republic' EXCEPT SELECT CountryCode FROM world_1.countrylanguage  WHERE LANGUAGE = 'English'"
  },
  {
    "id":"c0a940b8887f4c7ef794eee72ddfb7b8c13f2f0d081cf6d873573933faf69e99",
    "db_id":"world_1",
    "question":"Which cities are in European countries where English is not the official language?",
    "query":"SELECT DISTINCT T2.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T4 WITH (FORCESCAN) ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name , Code ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #4 = Filter [ #3 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.CountryCode = #5.Code ] Output [ #5.Name ] ; #7 = Except [ #2 , #6 ] Predicate [ #2.Name = #6.Name ] Output [ #2.Code ] ; #8 = Scan Table [ city ] Output [ Name , CountryCode ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.Code = #8.CountryCode ] Distinct [ true ] Output [ #8.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name , Code ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #4 = Filter [ #3 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.CountryCode = #5.Code ] Output [ #5.Name ] ; #7 = Except [ #2 , #6 ] Predicate [ #2.Name = #6.Name ] Output [ #2.Code ] ; #8 = Scan Table [ city ] Output [ Name , CountryCode ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.Code = #8.CountryCode ] Distinct [ true ] Output [ #8.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent, Code FROM world_1.country ), Filter_2 AS ( SELECT Name, Code FROM Scan_1 WHERE Continent = 'Europe' ), Scan_3 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_4 AS ( SELECT CountryCode FROM Scan_3 WHERE IsOfficial = 'T' ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Join_6 AS ( SELECT Scan_5.Name FROM Filter_4 JOIN Scan_5 ON Filter_4.CountryCode = Scan_5.Code ), Except_7 AS ( SELECT Filter_2.Code FROM Filter_2 WHERE Name NOT IN (SELECT Name FROM Join_6) ), Scan_8 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_9 AS ( SELECT DISTINCT Scan_8.Name FROM Except_7 JOIN Scan_8 ON Except_7.Code = Scan_8.CountryCode ) SELECT * FROM Join_9",
    "clean_query":"SELECT DISTINCT T2.Name FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3  JOIN world_1.countrylanguage AS T4  ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' )"
  },
  {
    "id":"0d84fb9681915bfd4ab3a629c27b5ce0af8fc3c65ff7132f2d4cee75b10a0153",
    "db_id":"world_1",
    "question":"What are the names of cities in Europe for which English is not the official language?",
    "query":"SELECT DISTINCT T2.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.city AS T2 WITH (FORCESCAN) ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T4 WITH (FORCESCAN) ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name , Code ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #4 = Filter [ #3 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.CountryCode = #5.Code ] Output [ #5.Name ] ; #7 = Except [ #2 , #6 ] Predicate [ #2.Name = #6.Name ] Output [ #2.Code ] ; #8 = Scan Table [ city ] Output [ Name , CountryCode ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.Code = #8.CountryCode ] Distinct [ true ] Output [ #8.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Continent , Code ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name , Code ] ; #3 = Scan Table [ countrylanguage ] Predicate [ Language = 'English' ] Output [ Language , CountryCode , IsOfficial ] ; #4 = Filter [ #3 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #5 = Scan Table [ country ] Output [ Name , Code ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.CountryCode = #5.Code ] Output [ #5.Name ] ; #7 = Except [ #2 , #6 ] Predicate [ #2.Name = #6.Name ] Output [ #2.Code ] ; #8 = Scan Table [ city ] Output [ Name , CountryCode ] ; #9 = Join [ #7 , #8 ] Predicate [ #7.Code = #8.CountryCode ] Distinct [ true ] Output [ #8.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent, Code FROM world_1.country ), Filter_2 AS ( SELECT Name, Code FROM Scan_1 WHERE Continent = 'Europe' ), Scan_3 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'English' ), Filter_4 AS ( SELECT CountryCode FROM Scan_3 WHERE IsOfficial = 'T' ), Scan_5 AS ( SELECT Name, Code FROM world_1.country ), Join_6 AS ( SELECT Scan_5.Name FROM Filter_4 JOIN Scan_5 ON Filter_4.CountryCode = Scan_5.Code ), Except_7 AS ( SELECT Filter_2.Code FROM Filter_2 WHERE Name NOT IN (SELECT Name FROM Join_6) ), Scan_8 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_9 AS ( SELECT DISTINCT Scan_8.Name FROM Except_7 JOIN Scan_8 ON Except_7.Code = Scan_8.CountryCode ) SELECT * FROM Join_9",
    "clean_query":"SELECT DISTINCT T2.Name FROM world_1.country AS T1  JOIN world_1.city AS T2  ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Europe' AND T1.Name NOT IN ( SELECT T3.Name FROM world_1.country AS T3  JOIN world_1.countrylanguage AS T4  ON T3.Code = T4.CountryCode WHERE T4.IsOfficial = 'T' AND T4.Language = 'English' )"
  },
  {
    "id":"d4255528f288011bf282f9c70db59fb67c2df7481c80b30ccdb2bb1bb10a28d6",
    "db_id":"world_1",
    "question":"Which unique cities are in Asian countries where Chinese is the official language ?",
    "query":"select distinct t3.name FROM world_1.country AS t1 WITH (FORCESCAN) join world_1.countrylanguage as t2 WITH (FORCESCAN) on t1.code = t2.countrycode join world_1.city as t3 WITH (FORCESCAN) on t1.code = t3.countrycode where t2.isofficial = 't' and t2.language = 'chinese' and t1.continent = 'asia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'chinese' ] Output [ Language , CountryCode , IsOfficial ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Continent , Code ] ; #4 = Filter [ #3 ] Predicate [ Continent = 'asia' ] Output [ Code ] ; #5 = Join [ #2 , #4 ] Predicate [ #2.CountryCode = #4.Code ] Output [ #2.CountryCode ] ; #6 = Scan Table [ city ] Output [ Name , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.CountryCode = #6.CountryCode ] Distinct [ true ] Output [ #6.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'chinese' ] Output [ Language , CountryCode , IsOfficial ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 't' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Continent , Code ] ; #4 = Filter [ #3 ] Predicate [ Continent = 'asia' ] Output [ Code ] ; #5 = Join [ #2 , #4 ] Predicate [ #2.CountryCode = #4.Code ] Output [ #2.CountryCode ] ; #6 = Scan Table [ city ] Output [ Name , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.CountryCode = #6.CountryCode ] Distinct [ true ] Output [ #6.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'chinese' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 't' ), Scan_3 AS ( SELECT Continent, Code FROM world_1.country ), Filter_4 AS ( SELECT Code FROM Scan_3 WHERE Continent = 'asia' ), Join_5 AS ( SELECT Filter_2.CountryCode FROM Filter_2 JOIN Filter_4 ON Filter_2.CountryCode = Filter_4.Code ), Scan_6 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_7 AS ( SELECT DISTINCT Scan_6.Name FROM Join_5 JOIN Scan_6 ON Join_5.CountryCode = Scan_6.CountryCode ) SELECT * FROM Join_7",
    "clean_query":"select distinct t3.name FROM world_1.country AS t1  join world_1.countrylanguage as t2  on t1.code = t2.countrycode join world_1.city as t3  on t1.code = t3.countrycode where t2.isofficial = 't' and t2.language = 'chinese' and t1.continent = 'asia'"
  },
  {
    "id":"0236e60074389525ae99b74bd2a1c01b56e74854227b6ac59849d44d9a5c6c00",
    "db_id":"world_1",
    "question":"Return the different names of cities that are in Asia and for which Chinese is the official language.",
    "query":"SELECT DISTINCT T3.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode JOIN world_1.city AS T3 WITH (FORCESCAN) ON T1.Code = T3.CountryCode WHERE T2.IsOfficial = 'T' AND T2.Language = 'Chinese' AND T1.Continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode , IsOfficial ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Continent , Code ] ; #4 = Filter [ #3 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #5 = Join [ #2 , #4 ] Predicate [ #2.CountryCode = #4.Code ] Output [ #2.CountryCode ] ; #6 = Scan Table [ city ] Output [ Name , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.CountryCode = #6.CountryCode ] Distinct [ true ] Output [ #6.Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Chinese' ] Output [ Language , CountryCode , IsOfficial ] ; #2 = Filter [ #1 ] Predicate [ IsOfficial = 'T' ] Output [ CountryCode ] ; #3 = Scan Table [ country ] Output [ Continent , Code ] ; #4 = Filter [ #3 ] Predicate [ Continent = 'Asia' ] Output [ Code ] ; #5 = Join [ #2 , #4 ] Predicate [ #2.CountryCode = #4.Code ] Output [ #2.CountryCode ] ; #6 = Scan Table [ city ] Output [ Name , CountryCode ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.CountryCode = #6.CountryCode ] Distinct [ true ] Output [ #6.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Language, CountryCode, IsOfficial FROM world_1.countrylanguage WHERE Language = 'Chinese' ), Filter_2 AS ( SELECT CountryCode FROM Scan_1 WHERE IsOfficial = 'T' ), Scan_3 AS ( SELECT Continent, Code FROM world_1.country ), Filter_4 AS ( SELECT Code FROM Scan_3 WHERE Continent = 'Asia' ), Join_5 AS ( SELECT Filter_2.CountryCode FROM Filter_2 JOIN Filter_4 ON Filter_2.CountryCode = Filter_4.Code ), Scan_6 AS ( SELECT Name, CountryCode FROM world_1.city ), Join_7 AS ( SELECT DISTINCT Scan_6.Name FROM Join_5 JOIN Scan_6 ON Join_5.CountryCode = Scan_6.CountryCode ) SELECT * FROM Join_7",
    "clean_query":"SELECT DISTINCT T3.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode JOIN world_1.city AS T3  ON T1.Code = T3.CountryCode WHERE T2.IsOfficial = 'T' AND T2.Language = 'Chinese' AND T1.Continent = 'Asia'"
  },
  {
    "id":"4a689d6560058bdd8adf9567862f41d9fd0787c77beb5f837b9b44c155a76705",
    "db_id":"world_1",
    "question":"What are the name, independence year, and surface area of the country with the smallest population?",
    "query":"SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country WITH (FORCESCAN) ORDER BY Population OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , IndepYear ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Population ASC ] Output [ Name , SurfaceArea , Population , IndepYear ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , IndepYear ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Population ASC ] Output [ Name , SurfaceArea , Population , IndepYear ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, SurfaceArea, Population, IndepYear FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, Population, IndepYear FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country  ORDER BY Population"
  },
  {
    "id":"e4c52b785e1632bd04805745f66503d7b650c8b3033ce632e1c491a6b718b3cf",
    "db_id":"world_1",
    "question":"Give the name, year of independence, and surface area of the country that has the lowest population.",
    "query":"SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country WITH (FORCESCAN) ORDER BY Population OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , IndepYear ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Population ASC ] Output [ Name , SurfaceArea , Population , IndepYear ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , IndepYear ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Population ASC ] Output [ Name , SurfaceArea , Population , IndepYear ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, SurfaceArea, Population, IndepYear FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, Population, IndepYear FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name , SurfaceArea , IndepYear FROM world_1.country  ORDER BY Population"
  },
  {
    "id":"8501b8421d3703c0f326d035b6a98713416838884d95dce6d6d6f9e9785e9513",
    "db_id":"world_1",
    "question":"What are the population, name and leader of the country with the largest area?",
    "query":"SELECT TOP 1 Name , population , HeadOfState FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , HeadOfState ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , HeadOfState ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , HeadOfState ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , HeadOfState ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, SurfaceArea, Population, HeadOfState FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, Population, HeadOfState FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name , population , HeadOfState FROM world_1.country  ORDER BY SurfaceArea DESC"
  },
  {
    "id":"d7fc07e68990b36dc06d1e0618a67411b9ca8d0cdbb2507c1994df52cec72a11",
    "db_id":"world_1",
    "question":"Give the name, population, and head of state for the country that has the largest area.",
    "query":"SELECT TOP 1 Name , population , HeadOfState FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , HeadOfState ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , HeadOfState ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea , Population , HeadOfState ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea , Population , HeadOfState ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, SurfaceArea, Population, HeadOfState FROM world_1.country ), TopSort_2 AS ( SELECT TOP 1 Name, SurfaceArea, Population, HeadOfState FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name , population , HeadOfState FROM world_1.country  ORDER BY SurfaceArea DESC"
  },
  {
    "id":"e8085d6ad1c2965658080e2c0ebc3816ca37ec522dd5cad2606e9607878526d6",
    "db_id":"world_1",
    "question":"Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages.",
    "query":"SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name, Count_Star FROM Aggregate_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2"
  },
  {
    "id":"2c0de20779e40a8f22108d64a6d535afadb5261fca03a654dfb32a79b1987e60",
    "db_id":"world_1",
    "question":"What are the names of countries that speak more than 2 languages, as well as how many languages they speak?",
    "query":"SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1 WITH (FORCESCAN) JOIN world_1.countrylanguage AS T2 WITH (FORCESCAN) ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Name , Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Code ] ; #2 = Scan Table [ countrylanguage ] Output [ CountryCode ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Code = #2.CountryCode ] Output [ #1.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 2 ] Output [ Name , Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Code FROM world_1.country ), Scan_2 AS ( SELECT CountryCode FROM world_1.countrylanguage ), Join_3 AS ( SELECT Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Code = Scan_2.CountryCode ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name, Count_Star FROM Aggregate_4 WHERE Count_Star > 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT COUNT ( T2.Language ) AS Count_Language , T1.Name FROM world_1.country AS T1  JOIN world_1.countrylanguage AS T2  ON T1.Code = T2.CountryCode GROUP BY T1.Name HAVING COUNT ( * ) > 2"
  },
  {
    "id":"b5f8586908d9c60a605f91dcdce8a372301ffec88f551fc7611f66e2e04a5840",
    "db_id":"world_1",
    "question":"Find the number of cities in each district whose population is greater than the average population of cities?",
    "query":"SELECT count ( * ) AS Count_Star , District FROM world_1.city WITH (FORCESCAN) WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city WITH (FORCESCAN) ) GROUP BY District ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ city ] Output [ Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(Population) AS Avg_Population ] ; #3 = Scan Table [ city ] Output [ District , Population ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Population > #2.Avg_Population ] Output [ #3.District ] ; #5 = Aggregate [ #4 ] GroupBy [ District ] Output [ District , countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Output [ Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(Population) AS Avg_Population ] ; #3 = Scan Table [ city ] Output [ District , Population ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Population > #2.Avg_Population ] Output [ #3.District ] ; #5 = Aggregate [ #4 ] GroupBy [ District ] Output [ District , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Population FROM world_1.city ), Aggregate_2 AS ( SELECT AVG(Population) AS Avg_Population FROM Scan_1 ), Scan_3 AS ( SELECT District, Population FROM world_1.city ), Join_4 AS ( SELECT District FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Population > Aggregate_2.Avg_Population ), Aggregate_5 AS ( SELECT District, COUNT(*) AS Count_Star FROM Join_4 GROUP BY District ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT count ( * ) AS Count_Star , District FROM world_1.city  WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city  ) GROUP BY District"
  },
  {
    "id":"f5e097f81472a5f1334b7da4a4ef498e2d1370ef2466d6fe70ffd87c12059458",
    "db_id":"world_1",
    "question":"How many cities in each district have a population that is above the average population across all cities?",
    "query":"SELECT count ( * ) AS Count_Star , District FROM world_1.city WITH (FORCESCAN) WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city WITH (FORCESCAN) ) GROUP BY District ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ city ] Output [ Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(Population) AS Avg_Population ] ; #3 = Scan Table [ city ] Output [ District , Population ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Population > #2.Avg_Population ] Output [ #3.District ] ; #5 = Aggregate [ #4 ] GroupBy [ District ] Output [ District , countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Output [ Population ] ; #2 = Aggregate [ #1 ] Output [ AVG(Population) AS Avg_Population ] ; #3 = Scan Table [ city ] Output [ District , Population ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.Population > #2.Avg_Population ] Output [ #3.District ] ; #5 = Aggregate [ #4 ] GroupBy [ District ] Output [ District , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Population FROM world_1.city ), Aggregate_2 AS ( SELECT AVG(Population) AS Avg_Population FROM Scan_1 ), Scan_3 AS ( SELECT District, Population FROM world_1.city ), Join_4 AS ( SELECT District FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.Population > Aggregate_2.Avg_Population ), Aggregate_5 AS ( SELECT District, COUNT(*) AS Count_Star FROM Join_4 GROUP BY District ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT count ( * ) AS Count_Star , District FROM world_1.city  WHERE Population > ( SELECT avg ( Population ) AS Avg_Population FROM world_1.city  ) GROUP BY District"
  },
  {
    "id":"d470e09983752f911b63e42f813e74b44f366f7c126cfd843b5dc8b70d8a80dd",
    "db_id":"world_1",
    "question":"Find the government form name and total population for each government form whose average life expectancy is longer than 72.",
    "query":"SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country WITH (FORCESCAN) GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ GovernmentForm , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ GovernmentForm ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , GovernmentForm , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy > 72.0 ] Output [ GovernmentForm , Sum_Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ GovernmentForm , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ GovernmentForm ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , GovernmentForm , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy > 72.0 ] Output [ GovernmentForm , Sum_Population ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm, Population, LifeExpectancy FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, GovernmentForm, SUM(Population) AS Sum_Population FROM Scan_1 GROUP BY GovernmentForm ), Filter_3 AS ( SELECT GovernmentForm, Sum_Population FROM Aggregate_2 WHERE Avg_LifeExpectancy > 72.0 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country  GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72"
  },
  {
    "id":"effadf8df6dc99841f6c5970c502b75ffa1c1763e6c4dbecda029eb47c339b71",
    "db_id":"world_1",
    "question":"What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?",
    "query":"SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country WITH (FORCESCAN) GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ GovernmentForm , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ GovernmentForm ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , GovernmentForm , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy > 72.0 ] Output [ GovernmentForm , Sum_Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ GovernmentForm , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ GovernmentForm ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , GovernmentForm , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy > 72.0 ] Output [ GovernmentForm , Sum_Population ]",
    "cte":"WITH Scan_1 AS ( SELECT GovernmentForm, Population, LifeExpectancy FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, GovernmentForm, SUM(Population) AS Sum_Population FROM Scan_1 GROUP BY GovernmentForm ), Filter_3 AS ( SELECT GovernmentForm, Sum_Population FROM Aggregate_2 WHERE Avg_LifeExpectancy > 72.0 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population , GovernmentForm FROM world_1.country  GROUP BY GovernmentForm HAVING avg ( LifeExpectancy ) > 72"
  },
  {
    "id":"e60ca4d3c1158e28353a8f15c12a2c2846a2d48f2f3bf754959163476896c575",
    "db_id":"world_1",
    "question":"Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?",
    "query":"SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country WITH (FORCESCAN) GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , Continent , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy < 72.0 ] Output [ Continent , Sum_Population , Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , Continent , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy < 72.0 ] Output [ Continent , Sum_Population , Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Population, LifeExpectancy FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, Continent, SUM(Population) AS Sum_Population FROM Scan_1 GROUP BY Continent ), Filter_3 AS ( SELECT Continent, Sum_Population, Avg_LifeExpectancy FROM Aggregate_2 WHERE Avg_LifeExpectancy < 72.0 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country  GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72"
  },
  {
    "id":"44db72f54c47304dbbd1f800ba4272ad3c910e06f260585d08261e5501deaddd",
    "db_id":"world_1",
    "question":"What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?",
    "query":"SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country WITH (FORCESCAN) GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , Continent , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy < 72.0 ] Output [ Continent , Sum_Population , Avg_LifeExpectancy ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent , Population , LifeExpectancy ] ; #2 = Aggregate [ #1 ] GroupBy [ Continent ] Output [ AVG(LifeExpectancy) AS Avg_LifeExpectancy , Continent , SUM(Population) AS Sum_Population ] ; #3 = Filter [ #2 ] Predicate [ Avg_LifeExpectancy < 72.0 ] Output [ Continent , Sum_Population , Avg_LifeExpectancy ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent, Population, LifeExpectancy FROM world_1.country ), Aggregate_2 AS ( SELECT AVG(LifeExpectancy) AS Avg_LifeExpectancy, Continent, SUM(Population) AS Sum_Population FROM Scan_1 GROUP BY Continent ), Filter_3 AS ( SELECT Continent, Sum_Population, Avg_LifeExpectancy FROM Aggregate_2 WHERE Avg_LifeExpectancy < 72.0 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT sum ( Population ) AS Sum_Population , avg ( LifeExpectancy ) AS Avg_LifeExpectancy , Continent FROM world_1.country  GROUP BY Continent HAVING avg ( LifeExpectancy ) < 72"
  },
  {
    "id":"22fcbb5f6a1777be8b833f8a2bc392d1c77031be64764d8c10e70ae9a4d5e94b",
    "db_id":"world_1",
    "question":"What are the names and areas of countries with the top 5 largest area?",
    "query":"SELECT TOP 5 Name , SurfaceArea FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #2 = TopSort [ #1 ] Rows [ 5 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #2 = TopSort [ #1 ] Rows [ 5 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, SurfaceArea FROM world_1.country ), TopSort_2 AS ( SELECT TOP 5 Name, SurfaceArea FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 5 Name , SurfaceArea FROM world_1.country  ORDER BY SurfaceArea DESC"
  },
  {
    "id":"cd4f8032e1b1e509a1649a730f3394d342daf5f43398b10aed829e6a4dfbe85b",
    "db_id":"world_1",
    "question":"Return the names and surface areas of the 5 largest countries.",
    "query":"SELECT TOP 5 Name , SurfaceArea FROM world_1.country WITH (FORCESCAN) ORDER BY SurfaceArea DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #2 = TopSort [ #1 ] Rows [ 5 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , SurfaceArea ] ; #2 = TopSort [ #1 ] Rows [ 5 ] OrderBy [ SurfaceArea DESC ] Output [ Name , SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, SurfaceArea FROM world_1.country ), TopSort_2 AS ( SELECT TOP 5 Name, SurfaceArea FROM Scan_1 ORDER BY SurfaceArea DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 5 Name , SurfaceArea FROM world_1.country  ORDER BY SurfaceArea DESC"
  },
  {
    "id":"28ddb7e6b593e16d58aa021532f2d9e57af7b7574f003c9bc9d699893cf9f603",
    "db_id":"world_1",
    "question":"What are names of countries with the top 3 largest population?",
    "query":"SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 3 Name FROM world_1.country  ORDER BY Population DESC"
  },
  {
    "id":"a0d50025a0dacc9b581e55f5d52ab1998a2dbf2f8f5f5d67a453d729b68fa414",
    "db_id":"world_1",
    "question":"Return the names of the 3 most populated countries.",
    "query":"SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population DESC ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 3 Name FROM world_1.country  ORDER BY Population DESC"
  },
  {
    "id":"942ebb3b2f283625abe8cb0f069bc441f28e042e63ea9dbad0891cdf9bdcf33b",
    "db_id":"world_1",
    "question":"What are the names of the nations with the 3 lowest populations?",
    "query":"SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population ASC ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population ASC ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 3 Name FROM world_1.country  ORDER BY Population ASC"
  },
  {
    "id":"173f849d4bec55e9caad720de4a82d892641f70b6b43abbd5c0e7447006ac41b",
    "db_id":"world_1",
    "question":"Return the names of the 3 countries with the fewest people.",
    "query":"SELECT TOP 3 Name FROM world_1.country WITH (FORCESCAN) ORDER BY Population ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population ASC ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Name , Population ] ; #2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ Population ASC ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.country ), TopSort_2 AS ( SELECT TOP 3 Name, Population FROM Scan_1 ORDER BY Population ASC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 3 Name FROM world_1.country  ORDER BY Population ASC"
  },
  {
    "id":"5cba4e69aae92b9f05c0830dd3c8732a06eb00f0a2fa55052e50eba9644d1333",
    "db_id":"world_1",
    "question":"how many countries are in Asia?",
    "query":"SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'asia' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'asia' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent FROM world_1.country ), Filter_2 AS ( SELECT 1 AS One FROM Scan_1 WHERE Continent = 'asia' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE continent = 'Asia'"
  },
  {
    "id":"52dc4eb9635d36ed792f4224850acccdee7af499d06a3a62e4d20a8fe807686a",
    "db_id":"world_1",
    "question":"Count the number of countries in Asia.",
    "query":"SELECT count ( * ) AS Count_Star FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Asia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ country ] Output [ Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'asia' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Output [ Continent ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'asia' ] Output [ 1 AS One ] ; #3 = Aggregate [ #2 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Continent FROM world_1.country ), Filter_2 AS ( SELECT 1 AS One FROM Scan_1 WHERE Continent = 'asia' ), Aggregate_3 AS ( SELECT COUNT(*) AS Count_Star FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM world_1.country  WHERE continent = 'Asia'"
  },
  {
    "id":"3a1b4170c50ef2fb65e0ffaa67b45ab9282a898ec6581c895060e31332cf025b",
    "db_id":"world_1",
    "question":"What are the names of the countries that are in the continent of Europe and have a population larger than 80000?",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Europe' AND Population > 80000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Population > 80000 ] Output [ Name , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Population > 80000 ] Output [ Name , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent, Population FROM world_1.country WHERE Population > 80000 ), Filter_2 AS ( SELECT Name FROM Scan_1 WHERE Continent = 'Europe' ) SELECT * FROM Filter_2",
    "clean_query":"SELECT Name FROM world_1.country  WHERE continent = 'Europe' AND Population > 80000"
  },
  {
    "id":"96e58374f4e8995981abdae0add2d49bb797fb8e70ebe07715e6906b533c1775",
    "db_id":"world_1",
    "question":"Give the names of countries that are in Europe and have a population larger than 80000.",
    "query":"SELECT Name FROM world_1.country WITH (FORCESCAN) WHERE continent = 'Europe' AND Population > 80000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ country ] Predicate [ Population > 80000 ] Output [ Name , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ Population > 80000 ] Output [ Name , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'Europe' ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Continent, Population FROM world_1.country WHERE Population > 80000 ), Filter_2 AS ( SELECT Name FROM Scan_1 WHERE Continent = 'Europe' ) SELECT * FROM Filter_2",
    "clean_query":"SELECT Name FROM world_1.country  WHERE continent = 'Europe' AND Population > 80000"
  },
  {
    "id":"18f17add3885280a0a30c8986a4b02372b3efe4cc11524ebcf759748834e7f3f",
    "db_id":"world_1",
    "question":"What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?",
    "query":"select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country WITH (FORCESCAN) where continent = 'north america' and surfacearea > 3000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Predicate [ SurfaceArea > 3000.0 ] Output [ SurfaceArea , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'north america' ] Output [ SurfaceArea , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , AVG(SurfaceArea) AS Avg_SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ SurfaceArea > 3000.0 ] Output [ SurfaceArea , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'north america' ] Output [ SurfaceArea , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , AVG(SurfaceArea) AS Avg_SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Continent, Population FROM world_1.country WHERE SurfaceArea > 3000.0 ), Filter_2 AS ( SELECT SurfaceArea, Population FROM Scan_1 WHERE Continent = 'north america' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, AVG(SurfaceArea) AS Avg_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country  where continent = 'north america' and surfacearea > 3000"
  },
  {
    "id":"a7b231276cbde5622a0f9f60560e0af1bab62d204e97a49af38c91aa73d0f2c0",
    "db_id":"world_1",
    "question":"Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .",
    "query":"select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country WITH (FORCESCAN) where continent = 'north america' and surfacearea > 3000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ country ] Predicate [ SurfaceArea > 3000.0 ] Output [ SurfaceArea , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'north america' ] Output [ SurfaceArea , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , AVG(SurfaceArea) AS Avg_SurfaceArea ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ country ] Predicate [ SurfaceArea > 3000.0 ] Output [ SurfaceArea , Continent , Population ] ; #2 = Filter [ #1 ] Predicate [ Continent = 'north america' ] Output [ SurfaceArea , Population ] ; #3 = Aggregate [ #2 ] Output [ SUM(Population) AS Sum_Population , AVG(SurfaceArea) AS Avg_SurfaceArea ]",
    "cte":"WITH Scan_1 AS ( SELECT SurfaceArea, Continent, Population FROM world_1.country WHERE SurfaceArea > 3000.0 ), Filter_2 AS ( SELECT SurfaceArea, Population FROM Scan_1 WHERE Continent = 'north america' ), Aggregate_3 AS ( SELECT SUM(Population) AS Sum_Population, AVG(SurfaceArea) AS Avg_SurfaceArea FROM Filter_2 ) SELECT * FROM Aggregate_3",
    "clean_query":"select sum ( population ) AS Sum_population , avg ( surfacearea ) AS Avg_surfacearea FROM world_1.country  where continent = 'north america' and surfacearea > 3000"
  },
  {
    "id":"2531b53784175464db3290bd4ce5272d913cecfecb1ae586d9d36047e4493035",
    "db_id":"world_1",
    "question":"What are the cities whose population is between 160000 and 900000?",
    "query":"SELECT name FROM world_1.city WITH (FORCESCAN) WHERE Population BETWEEN 160000 AND 900000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ city ] Predicate [ Population >= 160000 AND Population <= 900000 ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Predicate [ Population >= 160000 AND Population <= 900000 ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.city WHERE Population >= 160000 AND Population <= 900000 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name FROM world_1.city  WHERE Population BETWEEN 160000 AND 900000"
  },
  {
    "id":"066534f971100acbd4ecf9d5a5ec2ac78b6c117238983af48d09b97b812e2236",
    "db_id":"world_1",
    "question":"Return the names of cities that have a population between 160000 and 900000 .",
    "query":"select name FROM world_1.city WITH (FORCESCAN) where population between 160000 and 900000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ city ] Predicate [ Population >= 160000 AND Population <= 900000 ] Output [ Name , Population ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ city ] Predicate [ Population >= 160000 AND Population <= 900000 ] Output [ Name , Population ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Population FROM world_1.city WHERE Population >= 160000 AND Population <= 900000 ) SELECT * FROM Scan_1",
    "clean_query":"select name FROM world_1.city  where population between 160000 and 900000"
  },
  {
    "id":"7d87dde5ac17ed632e07ab362831b1b48cbfcfa82d40bf5164a4590ca7894143",
    "db_id":"world_1",
    "question":"Which language is spoken by the largest number of countries?",
    "query":"SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Language FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage  GROUP BY LANGUAGE ORDER BY count ( * ) DESC"
  },
  {
    "id":"92a0c46b93d249a1e5a2e1086fd87aae4f97324b1cca25ecbdad7407df10a42f",
    "db_id":"world_1",
    "question":"Give the language that is spoken in the most countries.",
    "query":"SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ countrylanguage ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Output [ Language ] ; #2 = Aggregate [ #1 ] GroupBy [ Language ] Output [ Language , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Language ]",
    "cte":"WITH Scan_1 AS ( SELECT Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT Language, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Language ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Language FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 LANGUAGE FROM world_1.countrylanguage  GROUP BY LANGUAGE ORDER BY count ( * ) DESC"
  },
  {
    "id":"68c96d827202512a504df23f6ab033cb7b1ac9782afc82257aeab24e8c645959",
    "db_id":"world_1",
    "question":"What is the language spoken by the largest percentage of people in each country?",
    "query":"SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE , CountryCode OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countrylanguage ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode , Language ] Output [ CountryCode, Language, MAX(percentage) AS Max_percentage ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode , Language ] Output [ CountryCode, Language, MAX(percentage) AS Max_percentage ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode, Language, MAX(percentage) AS Max_percentage FROM Scan_1 GROUP BY Language, CountryCode, CountryCode , Language ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  GROUP BY LANGUAGE , CountryCode"
  },
  {
    "id":"a5a6fef561cf350fc2c0f61225c80048d3e41977999c3e030b470ed1c19485e9",
    "db_id":"world_1",
    "question":"What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?",
    "query":"SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) GROUP BY LANGUAGE , CountryCode OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countrylanguage ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode , Language ] Output [ CountryCode, Language, MAX(percentage) AS Max_percentage ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode , Language ] Output [ CountryCode, Language, MAX(percentage) AS Max_percentage ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage ), Aggregate_2 AS ( SELECT CountryCode, Language, MAX(percentage) AS Max_percentage FROM Scan_1 GROUP BY Language, CountryCode, CountryCode , Language ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT LANGUAGE , CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  GROUP BY LANGUAGE , CountryCode"
  },
  {
    "id":"16efa1d00b88ef4622bb7345796502ef8e42ddb5fdc95f2e66d3ed8ca53f44cf",
    "db_id":"world_1",
    "question":"What is the total number of countries where Spanish is spoken by the largest percentage of people?",
    "query":"SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Spanish' ] Output [ Percentage , CountryCode , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ MAX(Percentage) AS Max_Percentage , countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Spanish' ] Output [ Percentage , CountryCode , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ MAX(Percentage) AS Max_Percentage , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Percentage, CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'Spanish' ), Aggregate_2 AS ( SELECT MAX(Percentage) AS Max_Percentage, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode"
  },
  {
    "id":"a1fd3e36763de62d67634d2be00cc30e68e90ed8288550458734eb39e0156e48",
    "db_id":"world_1",
    "question":"Count the number of countries for which Spanish is the predominantly spoken language.",
    "query":"SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Spanish' ] Output [ Percentage , CountryCode , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ MAX(Percentage) AS Max_Percentage , countstar AS Count_Star ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'Spanish' ] Output [ Percentage , CountryCode , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ MAX(Percentage) AS Max_Percentage , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Percentage, CountryCode, Language FROM world_1.countrylanguage WHERE Language = 'Spanish' ), Aggregate_2 AS ( SELECT MAX(Percentage) AS Max_Percentage, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode"
  },
  {
    "id":"5ff7298e82e25f73402caec694fb894b9528e6e8552ae504972b448f45281a6b",
    "db_id":"world_1",
    "question":"What are the codes of countries where Spanish is spoken by the largest percentage of people?",
    "query":"SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'spanish' ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode , MAX(Percentage) AS Max_Percentage ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'spanish' ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode , MAX(Percentage) AS Max_Percentage ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage WHERE Language = 'spanish' ), Aggregate_2 AS ( SELECT CountryCode, MAX(Percentage) AS Max_Percentage FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode"
  },
  {
    "id":"e0f60ed999370f8735907bbe27e1dc40ae9fe4e929fb31a12cc67e9f84d28816",
    "db_id":"world_1",
    "question":"Return the codes of countries for which Spanish is the predominantly spoken language.",
    "query":"SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage WITH (FORCESCAN) WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ countrylanguage ] Predicate [ Language = 'spanish' ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode , MAX(Percentage) AS Max_Percentage ]",
    "prefixed_qpl":"world_1 | #1 = Scan Table [ countrylanguage ] Predicate [ Language = 'spanish' ] Output [ CountryCode , Percentage , Language ] ; #2 = Aggregate [ #1 ] GroupBy [ CountryCode ] Output [ CountryCode , MAX(Percentage) AS Max_Percentage ]",
    "cte":"WITH Scan_1 AS ( SELECT CountryCode, Percentage, Language FROM world_1.countrylanguage WHERE Language = 'spanish' ), Aggregate_2 AS ( SELECT CountryCode, MAX(Percentage) AS Max_Percentage FROM Scan_1 GROUP BY CountryCode ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT CountryCode , max ( Percentage ) AS Max_Percentage FROM world_1.countrylanguage  WHERE LANGUAGE = 'Spanish' GROUP BY CountryCode"
  },
  {
    "id":"e3cddc01a42e6e4c8742e8b32c7081491e9ad65503bb886b0e38660e5c8f9e59",
    "db_id":"orchestra",
    "question":"How many conductors are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM orchestra.conductor"
  },
  {
    "id":"29ca0628d7688ba66867d6b2b9c69262aed688372b572e9bfb32690f4dfb508c",
    "db_id":"orchestra",
    "question":"Count the number of conductors.",
    "query":"SELECT count ( * ) AS Count_Star FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM orchestra.conductor"
  },
  {
    "id":"1a9e7cad0a48794e4ee18f147764337a553b0709e9a446f572b6fc855fc872d2",
    "db_id":"orchestra",
    "question":"List the names of conductors in ascending order of age.",
    "query":"SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM orchestra.conductor ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
    "clean_query":"SELECT Name FROM orchestra.conductor  ORDER BY Age ASC"
  },
  {
    "id":"023663de7188fe415732228ff855e71fab5db97f44ddd42d8472b0f437beeb7a",
    "db_id":"orchestra",
    "question":"What are the names of conductors, ordered by age?",
    "query":"SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Age ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Age ] ; #2 = Sort [ #1 ] OrderBy [ Age ASC ] Output [ Name , Age ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Age FROM orchestra.conductor ) SELECT Name, Age FROM Scan_1 ORDER BY Age ASC",
    "clean_query":"SELECT Name FROM orchestra.conductor  ORDER BY Age ASC"
  },
  {
    "id":"e42e09df5ba3b939399271de5fec1b7bcb6fd4f75c9a0ebc3b54f0823831ff38",
    "db_id":"orchestra",
    "question":"What are the names of conductors whose nationalities are not \"USA\"?",
    "query":"SELECT Name FROM orchestra.conductor WITH (FORCESCAN) WHERE Nationality ! = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Predicate [ Nationality <> 'USA' ] Output [ Name , Nationality ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Predicate [ Nationality <> 'USA' ] Output [ Name , Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Nationality FROM orchestra.conductor WHERE Nationality <> 'USA' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM orchestra.conductor  WHERE Nationality ! = 'USA'"
  },
  {
    "id":"d52b2fe734438314b9c3e2d3f0bd85983be6b638f7cdd57539fce25c52bfaa38",
    "db_id":"orchestra",
    "question":"Return the names of conductors that do not have the nationality \"USA\".",
    "query":"SELECT Name FROM orchestra.conductor WITH (FORCESCAN) WHERE Nationality ! = 'USA' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Predicate [ Nationality <> 'USA' ] Output [ Name , Nationality ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Predicate [ Nationality <> 'USA' ] Output [ Name , Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Nationality FROM orchestra.conductor WHERE Nationality <> 'USA' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM orchestra.conductor  WHERE Nationality ! = 'USA'"
  },
  {
    "id":"6b65ceb9aba024837ed659880317510fa7c5a5b16560bf85c2308d4fb5e398fd",
    "db_id":"orchestra",
    "question":"What are the record companies of orchestras in descending order of years in which they were founded?",
    "query":"SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) ORDER BY Year_of_Founded DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Record_Company ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Founded DESC ] Output [ Year_of_Founded , Record_Company ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Record_Company ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Founded DESC ] Output [ Year_of_Founded , Record_Company ]",
    "cte":"WITH Scan_1 AS ( SELECT Year_of_Founded, Record_Company FROM orchestra.orchestra ) SELECT Year_of_Founded, Record_Company FROM Scan_1 ORDER BY Year_of_Founded DESC",
    "clean_query":"SELECT Record_Company FROM orchestra.orchestra  ORDER BY Year_of_Founded DESC"
  },
  {
    "id":"df0d5aca30e690984137713a6b519a67f62563e44b1d3e5c69ca9b4155364f3b",
    "db_id":"orchestra",
    "question":"Return the record companies of orchestras, sorted descending by the years in which they were founded.",
    "query":"SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) ORDER BY Year_of_Founded DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Record_Company ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Founded DESC ] Output [ Year_of_Founded , Record_Company ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Record_Company ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Founded DESC ] Output [ Year_of_Founded , Record_Company ]",
    "cte":"WITH Scan_1 AS ( SELECT Year_of_Founded, Record_Company FROM orchestra.orchestra ) SELECT Year_of_Founded, Record_Company FROM Scan_1 ORDER BY Year_of_Founded DESC",
    "clean_query":"SELECT Record_Company FROM orchestra.orchestra  ORDER BY Year_of_Founded DESC"
  },
  {
    "id":"998f04b839afe54f9a8e1ec684ceb8a3ee1a4ad91dda2611a9867a29391d132c",
    "db_id":"orchestra",
    "question":"What is the average attendance of shows?",
    "query":"SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ show ] Output [ Attendance ] ; #2 = Aggregate [ #1 ] Output [ AVG(Attendance) AS Avg_Attendance ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ show ] Output [ Attendance ] ; #2 = Aggregate [ #1 ] Output [ AVG(Attendance) AS Avg_Attendance ]",
    "cte":"WITH Scan_1 AS ( SELECT Attendance FROM orchestra.show ), Aggregate_2 AS ( SELECT AVG(Attendance) AS Avg_Attendance FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW"
  },
  {
    "id":"6bbd055316a1a875b11f3caec173eb5a08b28dcebb6f61a5fb6c67d187d5d415",
    "db_id":"orchestra",
    "question":"Return the average attendance across all shows.",
    "query":"SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ show ] Output [ Attendance ] ; #2 = Aggregate [ #1 ] Output [ AVG(Attendance) AS Avg_Attendance ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ show ] Output [ Attendance ] ; #2 = Aggregate [ #1 ] Output [ AVG(Attendance) AS Avg_Attendance ]",
    "cte":"WITH Scan_1 AS ( SELECT Attendance FROM orchestra.show ), Aggregate_2 AS ( SELECT AVG(Attendance) AS Avg_Attendance FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( Attendance ) AS Avg_Attendance FROM orchestra.SHOW"
  },
  {
    "id":"185d457b4daa3628c437828ee9ad39f78143b5f76428b6d1991904e89b9b7ec4",
    "db_id":"orchestra",
    "question":"What are the maximum and minimum share of performances whose type is not \"Live final\".",
    "query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance WITH (FORCESCAN) WHERE TYPE ! = 'Live final' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ performance ] Predicate [ Type <> 'Live final' ] Output [ Type , Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ performance ] Predicate [ Type <> 'Live final' ] Output [ Type , Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "cte":"WITH Scan_1 AS ( SELECT Type, Share FROM orchestra.performance WHERE Type <> 'Live final' ), Aggregate_2 AS ( SELECT MIN(Share) AS Min_Share, MAX(Share) AS Max_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance  WHERE TYPE ! = 'Live final'"
  },
  {
    "id":"bcc64c0bb22e3f9f4d8fd691b32c0951929c845558050f560d0cb8ec9d35aa9f",
    "db_id":"orchestra",
    "question":"Return the maximum and minimum shares for performances that do not have the type \"Live final\".",
    "query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance WITH (FORCESCAN) WHERE TYPE ! = 'Live final' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ performance ] Predicate [ Type <> 'Live final' ] Output [ Type , Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ performance ] Predicate [ Type <> 'Live final' ] Output [ Type , Share ] ; #2 = Aggregate [ #1 ] Output [ MIN(Share) AS Min_Share , MAX(Share) AS Max_Share ]",
    "cte":"WITH Scan_1 AS ( SELECT Type, Share FROM orchestra.performance WHERE Type <> 'Live final' ), Aggregate_2 AS ( SELECT MIN(Share) AS Min_Share, MAX(Share) AS Max_Share FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( SHARE ) AS Max_SHARE , min ( SHARE ) AS Min_SHARE FROM orchestra.performance  WHERE TYPE ! = 'Live final'"
  },
  {
    "id":"1945cc8311cc7faaa4f993120e9e91e02ec404f2dd194708081e7ac521de00ba",
    "db_id":"orchestra",
    "question":"How many different nationalities do conductors have?",
    "query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor"
  },
  {
    "id":"12ced80a38250c5c815da4230bfbddaf6b6310ee3e3c49b50a0747f812fdd80c",
    "db_id":"orchestra",
    "question":"Count the number of different nationalities of conductors.",
    "query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Distinct [ true ] Output [ Nationality ] ; #2 = Aggregate [ #1 ] Output [ COUNT(DISTINCT Nationality) AS Count_Dist_Nationality ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Nationality FROM orchestra.conductor ), Aggregate_2 AS ( SELECT COUNT(DISTINCT Nationality) AS Count_Dist_Nationality FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT Nationality ) AS Count_Dist_Nationality FROM orchestra.conductor"
  },
  {
    "id":"f32f921b7e1bb2c2a6a65e5e2c8979d5327e1a196ff0365c2e9f2547a5766f1b",
    "db_id":"orchestra",
    "question":"List names of conductors in descending order of years of work.",
    "query":"SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ) SELECT Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC",
    "clean_query":"SELECT Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC"
  },
  {
    "id":"e1c968c860459137f04af68da9abc88ba0199c805ad1c700791b8e06de9d9b00",
    "db_id":"orchestra",
    "question":"What are the names of conductors, sorted descending by the number of years they have worked?",
    "query":"SELECT Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = Sort [ #1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ) SELECT Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC",
    "clean_query":"SELECT Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC"
  },
  {
    "id":"6aa937ac96aa0f82051b2f20f694460c36d303d0182fbfdc794547f31f98e84d",
    "db_id":"orchestra",
    "question":"List the name of the conductor with the most years of work.",
    "query":"SELECT TOP 1 Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ), TopSort_2 AS ( SELECT TOP 1 Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC"
  },
  {
    "id":"7b60704a707282ff6d06ee3878ad4f01c67cc82227ec275359829b2c1cba6515",
    "db_id":"orchestra",
    "question":"What is the name of the conductor who has worked the greatest number of years?",
    "query":"SELECT TOP 1 Name FROM orchestra.conductor WITH (FORCESCAN) ORDER BY Year_of_Work DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Year_of_Work ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Year_of_Work DESC ] Output [ Name , Year_of_Work ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Year_of_Work FROM orchestra.conductor ), TopSort_2 AS ( SELECT TOP 1 Name, Year_of_Work FROM Scan_1 ORDER BY Year_of_Work DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name FROM orchestra.conductor  ORDER BY Year_of_Work DESC"
  },
  {
    "id":"47842e1ee406532450416aa3a3b74cc576643fbc9dfe9d4bffca7d9d676ecccf",
    "db_id":"orchestra",
    "question":"Show the names of conductors and the orchestras they have conducted.",
    "query":"SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #2 = Scan Table [ orchestra ] Output [ Orchestra , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Orchestra , #1.Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #2 = Scan Table [ orchestra ] Output [ Orchestra , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Orchestra , #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Conductor_ID FROM orchestra.conductor ), Scan_2 AS ( SELECT Orchestra, Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_2.Orchestra, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID"
  },
  {
    "id":"ff3b230011a43e158f188c66978cc47d9dafc64bc34fcc368317639768ba0419",
    "db_id":"orchestra",
    "question":"What are the names of conductors as well as the corresonding orchestras that they have conducted?",
    "query":"SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #2 = Scan Table [ orchestra ] Output [ Orchestra , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Orchestra , #1.Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #2 = Scan Table [ orchestra ] Output [ Orchestra , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Orchestra , #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Conductor_ID FROM orchestra.conductor ), Scan_2 AS ( SELECT Orchestra, Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_2.Orchestra, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name , T2.Orchestra FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID"
  },
  {
    "id":"bd62d7dedb5bfdf4408dfe5cc9e377d5b62d7a60f33ed0609c915537c6964341",
    "db_id":"orchestra",
    "question":"Show the names of conductors that have conducted more than one orchestras.",
    "query":"SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1"
  },
  {
    "id":"23198886c398bd787db193781c1338ba26d87ad2e4f9b63d02819e9fd757ecbc",
    "db_id":"orchestra",
    "question":"What are the names of conductors who have conducted at more than one orchestra?",
    "query":"SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID HAVING COUNT ( * ) > 1"
  },
  {
    "id":"3b3a4ebe0ad418bead19cc531246d103d023da54e666715365d14d3219b84639",
    "db_id":"orchestra",
    "question":"Show the name of the conductor that has conducted the most number of orchestras.",
    "query":"SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"029a30407cbfd44db13238d8122ed6af9d93a9a0eb4dfa9fafbdd7c07c9e6d91",
    "db_id":"orchestra",
    "question":"What is the name of the conductor who has conducted the most orchestras?",
    "query":"SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ conductor ] Output [ Conductor_ID , Name ] ; #2 = Scan Table [ orchestra ] Output [ Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Conductor_ID = #1.Conductor_ID ] Output [ #1.Name , #1.Conductor_ID ] ; #4 = Aggregate [ #3 ] GroupBy [ Name, Conductor_ID ] Output [ Name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Conductor_ID, Name FROM orchestra.conductor ), Scan_2 AS ( SELECT Conductor_ID FROM orchestra.orchestra ), Join_3 AS ( SELECT Scan_1.Name, Scan_1.Conductor_ID FROM Scan_1 JOIN Scan_2 ON Scan_2.Conductor_ID = Scan_1.Conductor_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name, Conductor_ID, Name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, Name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID GROUP BY T1.Name , T2.Conductor_ID ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"f6382cc791510b0b5267aa6fe2219f8af8fa14534798187ff413f54375b1333f",
    "db_id":"orchestra",
    "question":"Please show the name of the conductor that has conducted orchestras founded after 2008.",
    "query":"SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2008.0 ] Output [ Year_of_Founded , Conductor_ID ] ; #2 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2008.0 ] Output [ Year_of_Founded , Conductor_ID ] ; #2 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year_of_Founded, Conductor_ID FROM orchestra.orchestra WHERE Year_of_Founded > 2008.0 ), Scan_2 AS ( SELECT Name, Conductor_ID FROM orchestra.conductor ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008"
  },
  {
    "id":"eb81b335df82730a2915851df1bd7d6ce9dd0e5aab61ca14535b1f22398ebb9f",
    "db_id":"orchestra",
    "question":"What are the names of conductors who have conducted orchestras founded after the year 2008?",
    "query":"SELECT T1.Name FROM orchestra.conductor AS T1 WITH (FORCESCAN) JOIN orchestra.orchestra AS T2 WITH (FORCESCAN) ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2008.0 ] Output [ Year_of_Founded , Conductor_ID ] ; #2 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Name ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2008.0 ] Output [ Year_of_Founded , Conductor_ID ] ; #2 = Scan Table [ conductor ] Output [ Name , Conductor_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Conductor_ID = #2.Conductor_ID ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Year_of_Founded, Conductor_ID FROM orchestra.orchestra WHERE Year_of_Founded > 2008.0 ), Scan_2 AS ( SELECT Name, Conductor_ID FROM orchestra.conductor ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Conductor_ID = Scan_2.Conductor_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.Name FROM orchestra.conductor AS T1  JOIN orchestra.orchestra AS T2  ON T1.Conductor_ID = T2.Conductor_ID WHERE Year_of_Founded > 2008"
  },
  {
    "id":"2b498fdf0e61dd8e384e559787a60d74066bf3945e4a574b958a7e65d8676f8b",
    "db_id":"orchestra",
    "question":"Please show the different record companies and the corresponding number of orchestras.",
    "query":"SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra  GROUP BY Record_Company"
  },
  {
    "id":"a580c27e04c6eaff182b09c757eac7709d4949a57857163ecf6f41adeb7e5063",
    "db_id":"orchestra",
    "question":"How many orchestras does each record company manage?",
    "query":"SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Record_Company , COUNT ( * ) AS Count_Star FROM orchestra.orchestra  GROUP BY Record_Company"
  },
  {
    "id":"8f5134a55bcc35aa15116970a07f380e26620ed0e44157fb4a7a5afdeea9b368",
    "db_id":"orchestra",
    "question":"Please show the record formats of orchestras in ascending order of count.",
    "query":"SELECT Major_Record_Format FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] GroupBy [ Major_Record_Format ] Output [ Major_Record_Format , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Major_Record_Format ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] GroupBy [ Major_Record_Format ] Output [ Major_Record_Format , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Major_Record_Format ]",
    "cte":"WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Major_Record_Format, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Major_Record_Format ) SELECT Count_Star, Major_Record_Format FROM Aggregate_2 ORDER BY Count_Star ASC",
    "clean_query":"SELECT Major_Record_Format FROM orchestra.orchestra  GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC"
  },
  {
    "id":"7569cefc19424ebb6ee479425b4d76d5f2227a77640326c89b0d7ecc30cb1451",
    "db_id":"orchestra",
    "question":"What are the major record formats of orchestras, sorted by their frequency?",
    "query":"SELECT Major_Record_Format FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] GroupBy [ Major_Record_Format ] Output [ Major_Record_Format , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Major_Record_Format ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] GroupBy [ Major_Record_Format ] Output [ Major_Record_Format , countstar AS Count_Star ] ; #3 = Sort [ #2 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , Major_Record_Format ]",
    "cte":"WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Major_Record_Format, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Major_Record_Format ) SELECT Count_Star, Major_Record_Format FROM Aggregate_2 ORDER BY Count_Star ASC",
    "clean_query":"SELECT Major_Record_Format FROM orchestra.orchestra  GROUP BY Major_Record_Format ORDER BY COUNT ( * ) ASC"
  },
  {
    "id":"f1cf3d5bc498895a312f9d97a3c23ed602f4cb8b41f09d88666d37f56f9a4c4b",
    "db_id":"orchestra",
    "question":"List the record company shared by the most number of orchestras.",
    "query":"SELECT TOP 1 Record_Company FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Record_Company ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Record_Company ]",
    "cte":"WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Record_Company FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Record_Company FROM orchestra.orchestra  GROUP BY Record_Company ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"ca57dfe053d7730d47f8a7dec696ff0bffb0c4a5ae2eddc518636c0a9cc93899",
    "db_id":"orchestra",
    "question":"What is the record company used by the greatest number of orchestras?",
    "query":"SELECT TOP 1 Record_Company FROM orchestra.orchestra WITH (FORCESCAN) GROUP BY Record_Company ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Record_Company ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Record_Company ] ; #2 = Aggregate [ #1 ] GroupBy [ Record_Company ] Output [ Record_Company , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Record_Company ]",
    "cte":"WITH Scan_1 AS ( SELECT Record_Company FROM orchestra.orchestra ), Aggregate_2 AS ( SELECT Record_Company, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Record_Company ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Record_Company FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Record_Company FROM orchestra.orchestra  GROUP BY Record_Company ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"a5b58ec921e463893a58faab86400b125f114b5c0469aa70c41f39267cc6731e",
    "db_id":"orchestra",
    "question":"List the names of orchestras that have no performance.",
    "query":"SELECT Orchestra FROM orchestra.orchestra WITH (FORCESCAN) WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Orchestra_ID , Orchestra ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Orchestra_ID IS NULL OR #1.Orchestra_ID = #2.Orchestra_ID ] Output [ #1.Orchestra ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Orchestra_ID , Orchestra ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Orchestra_ID IS NULL OR #1.Orchestra_ID = #2.Orchestra_ID ] Output [ #1.Orchestra ]",
    "cte":"WITH Scan_1 AS ( SELECT Orchestra_ID, Orchestra FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Except_3 AS ( SELECT Scan_1.Orchestra FROM Scan_1 WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Orchestra FROM orchestra.orchestra  WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance  )"
  },
  {
    "id":"d7ae9ecca2a02d1ea9bab41b4eb1fb9f4020c46bb3c6f7cf3723d9032eb7b454",
    "db_id":"orchestra",
    "question":"What are the orchestras that do not have any performances?",
    "query":"SELECT Orchestra FROM orchestra.orchestra WITH (FORCESCAN) WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Orchestra_ID , Orchestra ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Orchestra_ID IS NULL OR #1.Orchestra_ID = #2.Orchestra_ID ] Output [ #1.Orchestra ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Orchestra_ID , Orchestra ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Orchestra_ID IS NULL OR #1.Orchestra_ID = #2.Orchestra_ID ] Output [ #1.Orchestra ]",
    "cte":"WITH Scan_1 AS ( SELECT Orchestra_ID, Orchestra FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Except_3 AS ( SELECT Scan_1.Orchestra FROM Scan_1 WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Orchestra FROM orchestra.orchestra  WHERE Orchestra_ID NOT IN ( SELECT Orchestra_ID FROM orchestra.performance  )"
  },
  {
    "id":"ee422562896a77aa11e6c9ce20da92a2899b4cc499fba146b5cdd42528824b2b",
    "db_id":"orchestra",
    "question":"Show the record companies shared by orchestras founded before 2003 and after 2003.",
    "query":"SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded > 2003 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded < 2003.0 ] Distinct [ true ] Output [ Year_of_Founded , Record_Company ] ; #2 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2003.0 ] Output [ Year_of_Founded , Record_Company ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Record_Company = #2.Record_Company ] Output [ #1.Record_Company ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded < 2003.0 ] Distinct [ true ] Output [ Year_of_Founded , Record_Company ] ; #2 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2003.0 ] Output [ Year_of_Founded , Record_Company ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Record_Company = #2.Record_Company ] Output [ #1.Record_Company ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Year_of_Founded, Record_Company FROM orchestra.orchestra WHERE Year_of_Founded < 2003.0 ), Scan_2 AS ( SELECT Year_of_Founded, Record_Company FROM orchestra.orchestra WHERE Year_of_Founded > 2003.0 ), Intersect_3 AS ( SELECT Scan_1.Record_Company FROM Scan_1 WHERE Record_Company IN (SELECT Record_Company FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded > 2003"
  },
  {
    "id":"8459b8d82356291d3db2f69ff1945ee3befbb954a1417532e973e93e6b13ad59",
    "db_id":"orchestra",
    "question":"What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?",
    "query":"SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra WITH (FORCESCAN) WHERE Year_of_Founded > 2003 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded < 2003.0 ] Distinct [ true ] Output [ Year_of_Founded , Record_Company ] ; #2 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2003.0 ] Output [ Year_of_Founded , Record_Company ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Record_Company = #2.Record_Company ] Output [ #1.Record_Company ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Predicate [ Year_of_Founded < 2003.0 ] Distinct [ true ] Output [ Year_of_Founded , Record_Company ] ; #2 = Scan Table [ orchestra ] Predicate [ Year_of_Founded > 2003.0 ] Output [ Year_of_Founded , Record_Company ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Record_Company = #2.Record_Company ] Output [ #1.Record_Company ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Year_of_Founded, Record_Company FROM orchestra.orchestra WHERE Year_of_Founded < 2003.0 ), Scan_2 AS ( SELECT Year_of_Founded, Record_Company FROM orchestra.orchestra WHERE Year_of_Founded > 2003.0 ), Intersect_3 AS ( SELECT Scan_1.Record_Company FROM Scan_1 WHERE Record_Company IN (SELECT Record_Company FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra.orchestra  WHERE Year_of_Founded > 2003"
  },
  {
    "id":"d23e45e01461740b309c05a03a6520364714fb42bf3fee6b1e3eac7a4799d8ce",
    "db_id":"orchestra",
    "question":"Find the number of orchestras whose record format is \"CD\" or \"DVD\".",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Predicate [ Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Predicate [ Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra  WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD'"
  },
  {
    "id":"7d60a9326e8a1da50b5701c2e6673c4f854992058ca200c3a5559c18d5021645",
    "db_id":"orchestra",
    "question":"Count the number of orchestras that have CD or DVD as their record format.",
    "query":"SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra WITH (FORCESCAN) WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Predicate [ Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Predicate [ Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ] Output [ Major_Record_Format ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Major_Record_Format FROM orchestra.orchestra WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD' ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT COUNT ( * ) AS Count_Star FROM orchestra.orchestra  WHERE Major_Record_Format = 'CD' OR Major_Record_Format = 'DVD'"
  },
  {
    "id":"59326357caa3607e771939182ff7aba6e9ba310af53c484ee2df9ae783da60ac",
    "db_id":"orchestra",
    "question":"Show the years in which orchestras that have given more than one performance are founded.",
    "query":"SELECT Year_of_Founded FROM orchestra.orchestra AS T1 WITH (FORCESCAN) JOIN orchestra.performance AS T2 WITH (FORCESCAN) ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Orchestra_ID ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Orchestra_ID = #1.Orchestra_ID ] Output [ #1.Orchestra_ID , #1.Year_of_Founded ] ; #4 = Aggregate [ #3 ] GroupBy [ Year_of_Founded, Orchestra_ID ] Output [ Year_of_Founded , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Year_of_Founded ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Orchestra_ID ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Orchestra_ID = #1.Orchestra_ID ] Output [ #1.Orchestra_ID , #1.Year_of_Founded ] ; #4 = Aggregate [ #3 ] GroupBy [ Year_of_Founded, Orchestra_ID ] Output [ Year_of_Founded , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Year_of_Founded ]",
    "cte":"WITH Scan_1 AS ( SELECT Year_of_Founded, Orchestra_ID FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Join_3 AS ( SELECT Scan_1.Orchestra_ID, Scan_1.Year_of_Founded FROM Scan_1 JOIN Scan_2 ON Scan_2.Orchestra_ID = Scan_1.Orchestra_ID ), Aggregate_4 AS ( SELECT Year_of_Founded, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Year_of_Founded, Orchestra_ID, Year_of_Founded ), Filter_5 AS ( SELECT Year_of_Founded FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT Year_of_Founded FROM orchestra.orchestra AS T1  JOIN orchestra.performance AS T2  ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1"
  },
  {
    "id":"481adaa806fc03fa0926f62a1fe0fe0d32e3d298f98873d4b71f0ff3030c88c8",
    "db_id":"orchestra",
    "question":"What are years of founding for orchestras that have had more than a single performance?",
    "query":"SELECT Year_of_Founded FROM orchestra.orchestra AS T1 WITH (FORCESCAN) JOIN orchestra.performance AS T2 WITH (FORCESCAN) ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Orchestra_ID ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Orchestra_ID = #1.Orchestra_ID ] Output [ #1.Orchestra_ID , #1.Year_of_Founded ] ; #4 = Aggregate [ #3 ] GroupBy [ Year_of_Founded, Orchestra_ID ] Output [ Year_of_Founded , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Year_of_Founded ]",
    "prefixed_qpl":"orchestra | #1 = Scan Table [ orchestra ] Output [ Year_of_Founded , Orchestra_ID ] ; #2 = Scan Table [ performance ] Output [ Orchestra_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.Orchestra_ID = #1.Orchestra_ID ] Output [ #1.Orchestra_ID , #1.Year_of_Founded ] ; #4 = Aggregate [ #3 ] GroupBy [ Year_of_Founded, Orchestra_ID ] Output [ Year_of_Founded , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Year_of_Founded ]",
    "cte":"WITH Scan_1 AS ( SELECT Year_of_Founded, Orchestra_ID FROM orchestra.orchestra ), Scan_2 AS ( SELECT Orchestra_ID FROM orchestra.performance ), Join_3 AS ( SELECT Scan_1.Orchestra_ID, Scan_1.Year_of_Founded FROM Scan_1 JOIN Scan_2 ON Scan_2.Orchestra_ID = Scan_1.Orchestra_ID ), Aggregate_4 AS ( SELECT Year_of_Founded, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Year_of_Founded, Orchestra_ID, Year_of_Founded ), Filter_5 AS ( SELECT Year_of_Founded FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT Year_of_Founded FROM orchestra.orchestra AS T1  JOIN orchestra.performance AS T2  ON T1.Orchestra_ID = T2.Orchestra_ID GROUP BY Year_of_Founded , T2.Orchestra_ID HAVING COUNT ( * ) > 1"
  },
  {
    "id":"a207ddf9057f47af297b04e7f41856ac20a50fd2ed34907fb81ce862098d865b",
    "db_id":"network_1",
    "question":"How many high schoolers are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler"
  },
  {
    "id":"50c5d19b474f0dd61efdf6f2d8172cfb693e85bb6d2ee13d375870cddfb4fbac",
    "db_id":"network_1",
    "question":"Count the number of high schoolers.",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler"
  },
  {
    "id":"ac7fe855633f31421a9bd706d23dfb20d80b0b538b0dc8520b1ebb91bc942e58",
    "db_id":"network_1",
    "question":"Show the names and grades of each high schooler.",
    "query":"SELECT name , grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ name , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ name , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT name, grade FROM network_1.Highschooler ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , grade FROM network_1.Highschooler"
  },
  {
    "id":"236dcef9e2b84f096ed08b1920b85a8df68af104b942aa599e0635cdb1e04178",
    "db_id":"network_1",
    "question":"What are the names and grades for each high schooler?",
    "query":"SELECT name , grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ name , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ name , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT name, grade FROM network_1.Highschooler ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , grade FROM network_1.Highschooler"
  },
  {
    "id":"e26742908088fa6b5a4a123e0c3d581e1de7fab7b51949cba4c73da7766784f9",
    "db_id":"network_1",
    "question":"Show all the grades of the high schoolers.",
    "query":"SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ) SELECT * FROM Scan_1",
    "clean_query":"SELECT grade FROM network_1.Highschooler"
  },
  {
    "id":"a78bd98cec62dcd2412bb4c46df0a833d83f005bae19b95ec2402f74142e86b9",
    "db_id":"network_1",
    "question":"What is the grade of each high schooler?",
    "query":"SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ) SELECT * FROM Scan_1",
    "clean_query":"SELECT grade FROM network_1.Highschooler"
  },
  {
    "id":"6df74d6511b3ad4d9033a1211957b3e5a2d11dba71e49fa907fd46472495da9e",
    "db_id":"network_1",
    "question":"What grade is Kyle in?",
    "query":"SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ name , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ name , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT name, grade FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT grade FROM network_1.Highschooler  WHERE name = 'Kyle'"
  },
  {
    "id":"83bd88f309e485989759ac4a128180397925d2a7c8d9281b6ea2185f18b060b7",
    "db_id":"network_1",
    "question":"Return the grade for the high schooler named Kyle.",
    "query":"SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ name , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ name , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT name, grade FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT grade FROM network_1.Highschooler  WHERE name = 'Kyle'"
  },
  {
    "id":"8a7eabc2f2afb4a40166c43715cce40cf1f8c574ace9542f0fc2f58fe4eb1b29",
    "db_id":"network_1",
    "question":"Show the names of all high schoolers in grade 10.",
    "query":"SELECT name FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ grade = 10 ] Output [ name , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 10 ] Output [ name , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT name, grade FROM network_1.Highschooler WHERE grade = 10 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name FROM network_1.Highschooler  WHERE grade = 10"
  },
  {
    "id":"7094eb8f4f43e802578dfb2597cdb2cf41222e5ebbf4ff0686bba8aa79a0b702",
    "db_id":"network_1",
    "question":"What are the names of all high schoolers in grade 10?",
    "query":"SELECT name FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ grade = 10 ] Output [ name , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 10 ] Output [ name , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT name, grade FROM network_1.Highschooler WHERE grade = 10 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name FROM network_1.Highschooler  WHERE grade = 10"
  },
  {
    "id":"0139e20814b0aee45d3111cbedd1d8d1b6453db970e4bf1a7b8b7202091a6f35",
    "db_id":"network_1",
    "question":"Show the ID of the high schooler named Kyle.",
    "query":"SELECT ID FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT ID FROM network_1.Highschooler  WHERE name = 'Kyle'"
  },
  {
    "id":"5cf1353ac1891a373d83fb718050a23c6c0ec5d44a08d41958a4d89149fef383",
    "db_id":"network_1",
    "question":"What is Kyle's id?",
    "query":"SELECT ID FROM network_1.Highschooler WITH (FORCESCAN) WHERE name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT ID FROM network_1.Highschooler  WHERE name = 'Kyle'"
  },
  {
    "id":"3305381ed75e65f12ec11aaaaf8facba1833f5626c1485c860de2fda47f7085d",
    "db_id":"network_1",
    "question":"How many high schoolers are there in grade 9 or 10?",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 9 OR grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ grade = 9 OR grade = 10 ] Output [ grade ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 9 OR grade = 10 ] Output [ grade ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler WHERE grade = 9 OR grade = 10 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler  WHERE grade = 9 OR grade = 10"
  },
  {
    "id":"bd1edcbd11ce93f7ca5db25e0f6a2121942bb60f441d1551ad5bfaedcaa0bad0",
    "db_id":"network_1",
    "question":"Count the number of high schoolers in grades 9 or 10.",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) WHERE grade = 9 OR grade = 10 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ grade = 9 OR grade = 10 ] Output [ grade ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade = 9 OR grade = 10 ] Output [ grade ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler WHERE grade = 9 OR grade = 10 ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Highschooler  WHERE grade = 9 OR grade = 10"
  },
  {
    "id":"2fd1f2fb8e00ca6198f226e0484c696991787954ae2f6ca11ca96be1973dd548",
    "db_id":"network_1",
    "question":"Show the number of high schoolers for each grade.",
    "query":"SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler  GROUP BY grade"
  },
  {
    "id":"22ee91deb377e46643d31c252f10263c8b22928407d5e83e3dfea73e93a2912f",
    "db_id":"network_1",
    "question":"How many high schoolers are in each grade?",
    "query":"SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT grade , count ( * ) AS Count_Star FROM network_1.Highschooler  GROUP BY grade"
  },
  {
    "id":"442a4d8280938cee442476698a6d9ec2f0f13c4983f75bd715496be8f10bb3ef",
    "db_id":"network_1",
    "question":"Which grade has the most high schoolers?",
    "query":"SELECT TOP 1 grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), TopSort_3 AS ( SELECT TOP 1 Count_Star, grade FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 grade FROM network_1.Highschooler  GROUP BY grade ORDER BY count ( * ) DESC"
  },
  {
    "id":"7e3bd780ec04ba80fb47a192efc6c0fff9a6a083d07990a499435bf06c681be3",
    "db_id":"network_1",
    "question":"Return the grade that has the greatest number of high schoolers.",
    "query":"SELECT TOP 1 grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), TopSort_3 AS ( SELECT TOP 1 Count_Star, grade FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 grade FROM network_1.Highschooler  GROUP BY grade ORDER BY count ( * ) DESC"
  },
  {
    "id":"23c4fe45297b48d8ee466d2d1d6ec177bcea9379322d3dc4925ed1db0e1ecdd1",
    "db_id":"network_1",
    "question":"Show me all grades that have at least 4 students.",
    "query":"SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade HAVING count ( * ) > = 4 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 4 ] Output [ grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 4 ] Output [ grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), Filter_3 AS ( SELECT grade FROM Aggregate_2 WHERE Count_Star >= 4 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT grade FROM network_1.Highschooler  GROUP BY grade HAVING count ( * ) > = 4"
  },
  {
    "id":"525bacec227d0a51200bf17117551ede5163d4d834a2d0362f0855cbea4248ee",
    "db_id":"network_1",
    "question":"Which grades have 4 or more high schoolers?",
    "query":"SELECT grade FROM network_1.Highschooler WITH (FORCESCAN) GROUP BY grade HAVING count ( * ) > = 4 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 4 ] Output [ grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ grade ] ; #2 = Aggregate [ #1 ] GroupBy [ grade ] Output [ countstar AS Count_Star , grade ] ; #3 = Filter [ #2 ] Predicate [ Count_Star >= 4 ] Output [ grade ]",
    "cte":"WITH Scan_1 AS ( SELECT grade FROM network_1.Highschooler ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, grade FROM Scan_1 GROUP BY grade ), Filter_3 AS ( SELECT grade FROM Aggregate_2 WHERE Count_Star >= 4 ) SELECT * FROM Filter_3",
    "clean_query":"SELECT grade FROM network_1.Highschooler  GROUP BY grade HAVING count ( * ) > = 4"
  },
  {
    "id":"75f66dc81cbf3a3f27d33d5d675fd43a1794de57f3234cbc274fa97f50765b86",
    "db_id":"network_1",
    "question":"Show the student IDs and numbers of friends corresponding to each.",
    "query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend  GROUP BY student_id"
  },
  {
    "id":"62e0e49372c6619ec2e9e395882058f8052df231fccbd47054d60d4d0cece143",
    "db_id":"network_1",
    "question":"How many friends does each student have?",
    "query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Friend  GROUP BY student_id"
  },
  {
    "id":"507830019925b62844542338e9b6778272fc8cc3a8c55222862e45e5cc10eec6",
    "db_id":"network_1",
    "question":"Show the names of high school students and their corresponding number of friends.",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id"
  },
  {
    "id":"7b30574d1ca66d7665e969229dd704a800f08994530b06fe62e3eb4fb57a6ab5",
    "db_id":"network_1",
    "question":"What are the names of the high schoolers and how many friends does each have?",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id"
  },
  {
    "id":"9ac26cfb14e02c1544639c9d16255b9fe612fbbfbf90f627a8c841571f1565b1",
    "db_id":"network_1",
    "question":"What is the name of the high schooler who has the greatest number of friends?",
    "query":"SELECT TOP 1 T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Highschooler ] Output [ ID , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Highschooler ] Output [ ID , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_4 AS ( SELECT Scan_3.name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"72a560902ad1a26b3705b36166d2d4bb791b70869b75743abfae8ace99e81301",
    "db_id":"network_1",
    "question":"Return the name of the high school student with the most friends.",
    "query":"SELECT TOP 1 T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Highschooler ] Output [ ID , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ] ; #3 = Scan Table [ Highschooler ] Output [ ID , name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.name , #2.Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_4 AS ( SELECT Scan_3.name, Aggregate_2.Count_Star FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), TopSort_5 AS ( SELECT TOP 1 Count_Star, name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id ORDER BY count ( * ) DESC"
  },
  {
    "id":"263ffac75ab9c422dd579995c62f4fdbd85d5041d6cdb5c017af4d1158c376a7",
    "db_id":"network_1",
    "question":"Show the names of high schoolers who have at least 3 friends.",
    "query":"SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 3 ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 3 ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 3 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3"
  },
  {
    "id":"07a63f1a5bc074a87b3ef04fa8dda9f595a429c36cc22af4b69b862e7c6ec7bf",
    "db_id":"network_1",
    "question":"What are the names of high schoolers who have 3 or more friends?",
    "query":"SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 3 ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 3 ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 3 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 3"
  },
  {
    "id":"76315f6ac3350f7af835b9f7f6a46ec89579cd792877b93f61a84ee2ad621932",
    "db_id":"network_1",
    "question":"Show the names of all of the high schooler Kyle's friends.",
    "query":"SELECT T3.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3 WITH (FORCESCAN) ON T1.friend_id = T3.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id , friend_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.friend_id ] ; #4 = Scan Table [ Highschooler ] Output [ ID , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.friend_id = #4.ID ] Output [ #4.name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id , friend_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.friend_id ] ; #4 = Scan Table [ Highschooler ] Output [ ID , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.friend_id = #4.ID ] Output [ #4.name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id, friend_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.friend_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_5 AS ( SELECT Scan_4.name FROM Join_3 JOIN Scan_4 ON Join_3.friend_id = Scan_4.ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T3.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3  ON T1.friend_id = T3.id WHERE T2.name = 'Kyle'"
  },
  {
    "id":"d8eacdf8a3d6a1f89099265b0457ac988f631378f30f90fd38ada84b418b65c0",
    "db_id":"network_1",
    "question":"Return the names of friends of the high school student Kyle.",
    "query":"SELECT T3.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3 WITH (FORCESCAN) ON T1.friend_id = T3.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id , friend_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.friend_id ] ; #4 = Scan Table [ Highschooler ] Output [ ID , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.friend_id = #4.ID ] Output [ #4.name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id , friend_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #2.friend_id ] ; #4 = Scan Table [ Highschooler ] Output [ ID , name ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.friend_id = #4.ID ] Output [ #4.name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id, friend_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_2.friend_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_5 AS ( SELECT Scan_4.name FROM Join_3 JOIN Scan_4 ON Join_3.friend_id = Scan_4.ID ) SELECT * FROM Join_5",
    "clean_query":"SELECT T3.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id JOIN network_1.Highschooler AS T3  ON T1.friend_id = T3.id WHERE T2.name = 'Kyle'"
  },
  {
    "id":"b7b03db85ab48e278ad66f39305dfa4aa1bf37d7b21f77b565e7d380007d2127",
    "db_id":"network_1",
    "question":"How many friends does the high school student Kyle have?",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_1.ID FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'"
  },
  {
    "id":"aaea944f7fbfe65c0aa2473b9e9ade93b8f024fc0c932efc0b05d3c9fe2cd13f",
    "db_id":"network_1",
    "question":"Count the number of friends Kyle has.",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_1.ID FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'"
  },
  {
    "id":"2a1d61f34fe5ad0f7a58c53d75caa500a2803b2c6147c10377c44408591e4e43",
    "db_id":"network_1",
    "question":"Show ids of all students who do not have any friends.",
    "query":"SELECT id FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT student_id FROM network_1.Friend WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.ID ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.ID ]",
    "cte":"WITH Scan_1 AS ( SELECT ID FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.ID FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT id FROM network_1.Highschooler  EXCEPT SELECT student_id FROM network_1.Friend"
  },
  {
    "id":"329f0c5f35657ebf6607ade381231dcb736e68b0a28915213b0fd689088299d5",
    "db_id":"network_1",
    "question":"What are the ids of high school students who do not have friends?",
    "query":"SELECT id FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT student_id FROM network_1.Friend WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.ID ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.ID ]",
    "cte":"WITH Scan_1 AS ( SELECT ID FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.ID FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ) SELECT * FROM Except_4",
    "clean_query":"SELECT id FROM network_1.Highschooler  EXCEPT SELECT student_id FROM network_1.Friend"
  },
  {
    "id":"bd4233682bf105762e3a9cb82f6a771c3ebd7fdecb6567ca4cce013ad6c9bbdf",
    "db_id":"network_1",
    "question":"Show names of all high school students who do not have any friends.",
    "query":"SELECT name FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Distinct [ true ] Output [ name ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Scan Table [ Friend ] Output [ student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.ID = #3.student_id ] Output [ #2.name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Distinct [ true ] Output [ name ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Scan Table [ Friend ] Output [ student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.ID = #3.student_id ] Output [ #2.name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT name FROM network_1.Highschooler ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_3 AS ( SELECT student_id FROM network_1.Friend ), Join_4 AS ( SELECT Scan_2.name FROM Scan_2 JOIN Scan_3 ON Scan_2.ID = Scan_3.student_id ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE name NOT IN (SELECT name FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT name FROM network_1.Highschooler  EXCEPT SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id"
  },
  {
    "id":"33d486052fda33a467d56045245ac5652e2c7e0abde302e86bd834c64c63b41b",
    "db_id":"network_1",
    "question":"What are the names of students who have no friends?",
    "query":"SELECT name FROM network_1.Highschooler WITH (FORCESCAN) EXCEPT SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Distinct [ true ] Output [ name ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Scan Table [ Friend ] Output [ student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.ID = #3.student_id ] Output [ #2.name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Distinct [ true ] Output [ name ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Scan Table [ Friend ] Output [ student_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.ID = #3.student_id ] Output [ #2.name ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.name = #4.name ] Output [ #1.name ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT name FROM network_1.Highschooler ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_3 AS ( SELECT student_id FROM network_1.Friend ), Join_4 AS ( SELECT Scan_2.name FROM Scan_2 JOIN Scan_3 ON Scan_2.ID = Scan_3.student_id ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE name NOT IN (SELECT name FROM Join_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT name FROM network_1.Highschooler  EXCEPT SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id"
  },
  {
    "id":"76ef862e3c511c50ec1ff363f7b90eadbad4ccac85a6b9d3d4cf4b027b49a5d1",
    "db_id":"network_1",
    "question":"Show the ids of high schoolers who have friends and are also liked by someone else.",
    "query":"SELECT student_id FROM network_1.Friend WITH (FORCESCAN) INTERSECT SELECT liked_id FROM network_1.Likes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Likes ] Output [ liked_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.liked_id = #2.student_id ] Output [ #2.student_id ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Likes ] Output [ liked_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.liked_id = #2.student_id ] Output [ #2.student_id ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT liked_id FROM network_1.Likes ), Intersect_4 AS ( SELECT Aggregate_2.student_id FROM Aggregate_2 WHERE student_id IN (SELECT liked_id FROM Scan_3) ) SELECT * FROM Intersect_4",
    "clean_query":"SELECT student_id FROM network_1.Friend  INTERSECT SELECT liked_id FROM network_1.Likes"
  },
  {
    "id":"0b31c5a9abc4e7a1d92494ccca165c2c92d1134087b6c066d1b3ce747a13c3f7",
    "db_id":"network_1",
    "question":"What are the ids of students who both have friends and are liked?",
    "query":"SELECT student_id FROM network_1.Friend WITH (FORCESCAN) INTERSECT SELECT liked_id FROM network_1.Likes WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Likes ] Output [ liked_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.liked_id = #2.student_id ] Output [ #2.student_id ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Likes ] Output [ liked_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.liked_id = #2.student_id ] Output [ #2.student_id ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT liked_id FROM network_1.Likes ), Intersect_4 AS ( SELECT Aggregate_2.student_id FROM Aggregate_2 WHERE student_id IN (SELECT liked_id FROM Scan_3) ) SELECT * FROM Intersect_4",
    "clean_query":"SELECT student_id FROM network_1.Friend  INTERSECT SELECT liked_id FROM network_1.Likes"
  },
  {
    "id":"56d9b7569da6cfd36c31daac378eeebeed9acb76698e67c63f49a3fce4e8d187",
    "db_id":"network_1",
    "question":"Show name of all students who have some friends and also are liked by someone else.",
    "query":"SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.liked_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Distinct [ true ] Output [ #1.name ] ; #4 = Scan Table [ Likes ] Output [ liked_id ] ; #5 = Scan Table [ Highschooler ] Output [ ID , name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.liked_id = #5.ID ] Output [ #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Distinct [ true ] Output [ #1.name ] ; #4 = Scan Table [ Likes ] Output [ liked_id ] ; #5 = Scan Table [ Highschooler ] Output [ ID , name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.liked_id = #5.ID ] Output [ #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT DISTINCT Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT liked_id FROM network_1.Likes ), Scan_5 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_6 AS ( SELECT Scan_5.name FROM Scan_4 JOIN Scan_5 ON Scan_4.liked_id = Scan_5.ID ), Intersect_7 AS ( SELECT Join_3.name FROM Join_3 WHERE name IN (SELECT name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.liked_id = T2.id"
  },
  {
    "id":"751312a14e1b895457b1e3416dd352a7abcadef9679147be4cb3252af11101a7",
    "db_id":"network_1",
    "question":"What are the names of high schoolers who both have friends and are liked?",
    "query":"SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.liked_id = T2.id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Distinct [ true ] Output [ #1.name ] ; #4 = Scan Table [ Likes ] Output [ liked_id ] ; #5 = Scan Table [ Highschooler ] Output [ ID , name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.liked_id = #5.ID ] Output [ #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Distinct [ true ] Output [ #1.name ] ; #4 = Scan Table [ Likes ] Output [ liked_id ] ; #5 = Scan Table [ Highschooler ] Output [ ID , name ] ; #6 = Join [ #4 , #5 ] Predicate [ #4.liked_id = #5.ID ] Output [ #5.name ] ; #7 = Intersect [ #3 , #6 ] Predicate [ #3.name = #6.name ] Output [ #3.name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT DISTINCT Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Scan_4 AS ( SELECT liked_id FROM network_1.Likes ), Scan_5 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_6 AS ( SELECT Scan_5.name FROM Scan_4 JOIN Scan_5 ON Scan_4.liked_id = Scan_5.ID ), Intersect_7 AS ( SELECT Join_3.name FROM Join_3 WHERE name IN (SELECT name FROM Join_6) ) SELECT * FROM Intersect_7",
    "clean_query":"SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id INTERSECT SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.liked_id = T2.id"
  },
  {
    "id":"6aac79de3dfb498f14e452ccffef52b0fbffb19db5276bb259b6dd6196e2c474",
    "db_id":"network_1",
    "question":"Count the number of likes for each student id.",
    "query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes  GROUP BY student_id"
  },
  {
    "id":"f58f82e66f2a77494424f80aa471496689fb273caf330128dc3b95ffc6d3ace7",
    "db_id":"network_1",
    "question":"How many likes correspond to each student id?",
    "query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes WITH (FORCESCAN) GROUP BY student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Aggregate_2 AS ( SELECT student_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY student_id ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT student_id , count ( * ) AS Count_Star FROM network_1.Likes  GROUP BY student_id"
  },
  {
    "id":"ff92bf186cb026e0855344183504608a989cfe970c6d5cc696280faa3f1ed561",
    "db_id":"network_1",
    "question":"Show the names of high schoolers who have likes, and numbers of likes for each.",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id"
  },
  {
    "id":"26ba285d395198118d592f466d811b5cfb823cb3e3c6b816162f719160149536",
    "db_id":"network_1",
    "question":"What are the names of high schoolers who have likes, and how many likes does each have?",
    "query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T2.name , count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id"
  },
  {
    "id":"587e9458cada672d2d3927d405dbd2f9bca706e71eb19a1a0e6d26d029033252",
    "db_id":"network_1",
    "question":"What is the name of the high schooler who has the greatest number of likes?",
    "query":"select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) join network_1.highschooler as t2 WITH (FORCESCAN) ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.student_id = #1.ID ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] WithTies [ true ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.student_id = #1.ID ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] WithTies [ true ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_2.student_id = Scan_1.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), TopSort_5 AS ( SELECT TOP 1 WITH TIES name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1  join network_1.highschooler as t2  ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc"
  },
  {
    "id":"92f7870d8e544dec954c41ef4da65daa4fb2cba5f0706f1d73c2442f423a6dd8",
    "db_id":"network_1",
    "question":"Give the name of the student with the most likes.",
    "query":"select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) join network_1.highschooler as t2 WITH (FORCESCAN) ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.student_id = #1.ID ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] WithTies [ true ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #2.student_id = #1.ID ] Output [ #2.student_id , #1.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ countstar AS Count_Star , name ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] WithTies [ true ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_2.student_id, Scan_1.name FROM Scan_1 JOIN Scan_2 ON Scan_2.student_id = Scan_1.ID ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star, name FROM Join_3 GROUP BY student_id, name ), TopSort_5 AS ( SELECT TOP 1 WITH TIES name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"select TOP 1 WITH TIES t2.name FROM network_1.Likes AS T1  join network_1.highschooler as t2  ON t1.student_id = t2.id group by t2.name , t1.student_id order by count ( * ) desc"
  },
  {
    "id":"a5718dce78aa6a1cb4b8449f5ac89c6e167966f9905923340a77326aba16ba34",
    "db_id":"network_1",
    "question":"Show the names of students who have at least 2 likes.",
    "query":"SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2"
  },
  {
    "id":"5f078cf8840141aae2115e123c9cdd40f90ec682501edb26c3d06816b9a4eca2",
    "db_id":"network_1",
    "question":"What are the names of students who have 2 or more likes?",
    "query":"SELECT T2.name FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Likes ] Output [ student_id ] ; #2 = Scan Table [ Highschooler ] Output [ ID , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.student_id = #2.ID ] Output [ #1.student_id , #2.name ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Likes ), Scan_2 AS ( SELECT ID, name FROM network_1.Highschooler ), Join_3 AS ( SELECT Scan_1.student_id, Scan_2.name FROM Scan_1 JOIN Scan_2 ON Scan_1.student_id = Scan_2.ID ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.name FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2"
  },
  {
    "id":"664f0c6f067262d02049ca69c3f9f7726e6d086c3325b29eca9eb11398448854",
    "db_id":"network_1",
    "question":"Show the names of students who have a grade higher than 5 and have at least 2 friends.",
    "query":"SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ grade > 5 ] Output [ ID , name , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade > 5 ] Output [ ID , name , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name, grade FROM network_1.Highschooler WHERE grade > 5 ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2"
  },
  {
    "id":"0958c0b2d43af122aef2fbe2e3aa770ae881b8f5b43febf6c3f9a3b5cf13e025",
    "db_id":"network_1",
    "question":"What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?",
    "query":"SELECT T2.name FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ grade > 5 ] Output [ ID , name , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ grade > 5 ] Output [ ID , name , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #2.student_id ] ; #4 = Aggregate [ #3 ] GroupBy [ student_id ] Output [ name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ name ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name, grade FROM network_1.Highschooler WHERE grade > 5 ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Join_3 AS ( SELECT Scan_1.name, Scan_2.student_id FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY student_id, name ), Filter_5 AS ( SELECT name FROM Aggregate_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T2.name FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.grade > 5 GROUP BY T2.name , T1.student_id HAVING count ( * ) > = 2"
  },
  {
    "id":"3682b3829c0ef3cdd72b77929881f34ffb80f004698e5f6de20618175c13a2b2",
    "db_id":"network_1",
    "question":"How many likes does Kyle have?",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_1.name, Scan_1.ID FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'"
  },
  {
    "id":"3124e28ac1a7fe690afecd460ac8ece90d118c90179e403c6d3922793b87a58c",
    "db_id":"network_1",
    "question":"Return the number of likes that the high schooler named Kyle has.",
    "query":"SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id WHERE T2.name = 'Kyle' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Predicate [ name = 'Kyle' ] Output [ ID , name ] ; #2 = Scan Table [ Likes ] Output [ student_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.ID = #2.student_id ] Output [ #1.name , #1.ID ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, name FROM network_1.Highschooler WHERE name = 'Kyle' ), Scan_2 AS ( SELECT student_id FROM network_1.Likes ), Join_3 AS ( SELECT Scan_1.name, Scan_1.ID FROM Scan_1 JOIN Scan_2 ON Scan_1.ID = Scan_2.student_id ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Join_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM network_1.Likes AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id WHERE T2.name = 'Kyle'"
  },
  {
    "id":"e60783a38fbe587fae22b5119c426af2faa291ec352b32ee73bd46e4d75c0c43",
    "db_id":"network_1",
    "question":"Find the average grade of all students who have some friends.",
    "query":"SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.grade ] ; #5 = Aggregate [ #4 ] Output [ AVG(grade) AS Avg_grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.grade ] ; #5 = Aggregate [ #4 ] Output [ AVG(grade) AS Avg_grade ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT ID, grade FROM network_1.Highschooler ), Join_4 AS ( SELECT Scan_3.grade FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), Aggregate_5 AS ( SELECT AVG(grade) AS Avg_grade FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler  WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )"
  },
  {
    "id":"e2e869b34513e5bed08d8f4fbbc0bbf12e76f971c72c6a06fd9e413fda048afc",
    "db_id":"network_1",
    "question":"What is the average grade of students who have friends?",
    "query":"SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.grade ] ; #5 = Aggregate [ #4 ] Output [ AVG(grade) AS Avg_grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Friend ] Output [ student_id ] ; #2 = Aggregate [ #1 ] GroupBy [ student_id ] Output [ student_id ] ; #3 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.student_id = #3.ID ] Output [ #3.grade ] ; #5 = Aggregate [ #4 ] Output [ AVG(grade) AS Avg_grade ]",
    "cte":"WITH Scan_1 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_2 AS ( SELECT student_id FROM Scan_1 GROUP BY student_id ), Scan_3 AS ( SELECT ID, grade FROM network_1.Highschooler ), Join_4 AS ( SELECT Scan_3.grade FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.student_id = Scan_3.ID ), Aggregate_5 AS ( SELECT AVG(grade) AS Avg_grade FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT avg ( grade ) AS Avg_grade FROM network_1.Highschooler  WHERE id IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )"
  },
  {
    "id":"bf6b1d29e11ed83843dd7359807c686a7503effa62469509bf03de3a88b35b89",
    "db_id":"network_1",
    "question":"Find the minimum grade of students who have no friends.",
    "query":"SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.grade ] ; #5 = Aggregate [ #4 ] Output [ MIN(grade) AS Min_grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.grade ] ; #5 = Aggregate [ #4 ] Output [ MIN(grade) AS Min_grade ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, grade FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.grade FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ), Aggregate_5 AS ( SELECT MIN(grade) AS Min_grade FROM Except_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler  WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )"
  },
  {
    "id":"ba2f6f7ee2f6c495a1a659ea8490d0ed8808d5ae72b806c1fc73d1ca4972d780",
    "db_id":"network_1",
    "question":"What is the lowest grade of students who do not have any friends?",
    "query":"SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler WITH (FORCESCAN) WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1 WITH (FORCESCAN) JOIN network_1.Highschooler AS T2 WITH (FORCESCAN) ON T1.student_id = T2.id ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.grade ] ; #5 = Aggregate [ #4 ] Output [ MIN(grade) AS Min_grade ]",
    "prefixed_qpl":"network_1 | #1 = Scan Table [ Highschooler ] Output [ ID , grade ] ; #2 = Scan Table [ Friend ] Output [ student_id ] ; #3 = Aggregate [ #2 ] GroupBy [ student_id ] Output [ student_id ] ; #4 = Except [ #1 , #3 ] Predicate [ #3.student_id = #1.ID ] Output [ #1.grade ] ; #5 = Aggregate [ #4 ] Output [ MIN(grade) AS Min_grade ]",
    "cte":"WITH Scan_1 AS ( SELECT ID, grade FROM network_1.Highschooler ), Scan_2 AS ( SELECT student_id FROM network_1.Friend ), Aggregate_3 AS ( SELECT student_id FROM Scan_2 GROUP BY student_id ), Except_4 AS ( SELECT Scan_1.grade FROM Scan_1 WHERE ID NOT IN (SELECT student_id FROM Aggregate_3) ), Aggregate_5 AS ( SELECT MIN(grade) AS Min_grade FROM Except_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT min ( grade ) AS Min_grade FROM network_1.Highschooler  WHERE id NOT IN ( SELECT T1.student_id FROM network_1.Friend AS T1  JOIN network_1.Highschooler AS T2  ON T1.student_id = T2.id )"
  },
  {
    "id":"f626b9a2929fc139061b844dbf890d7ba521f6aa73d94c8973a3d0c6049a9e93",
    "db_id":"dog_kennels",
    "question":"Which states have both owners and professionals living there?",
    "query":"SELECT state FROM dog_kennels.Owners WITH (FORCESCAN) INTERSECT SELECT state FROM dog_kennels.Professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Owners ] Distinct [ true ] Output [ state ] ; #2 = Scan Table [ Professionals ] Output [ state ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.state = #2.state ] Output [ #1.state ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Distinct [ true ] Output [ state ] ; #2 = Scan Table [ Professionals ] Output [ state ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.state = #2.state ] Output [ #1.state ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT state FROM dog_kennels.Owners ), Scan_2 AS ( SELECT state FROM dog_kennels.Professionals ), Intersect_3 AS ( SELECT Scan_1.state FROM Scan_1 WHERE state IN (SELECT state FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT state FROM dog_kennels.Owners  INTERSECT SELECT state FROM dog_kennels.Professionals"
  },
  {
    "id":"9fb99b3230c59f8e93e31e9f3330ec2ef766cee0661a5362446bccfa564a4dc5",
    "db_id":"dog_kennels",
    "question":"Find the states where both owners and professionals live.",
    "query":"SELECT state FROM dog_kennels.Owners WITH (FORCESCAN) INTERSECT SELECT state FROM dog_kennels.Professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Owners ] Distinct [ true ] Output [ state ] ; #2 = Scan Table [ Professionals ] Output [ state ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.state = #2.state ] Output [ #1.state ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Distinct [ true ] Output [ state ] ; #2 = Scan Table [ Professionals ] Output [ state ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.state = #2.state ] Output [ #1.state ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT state FROM dog_kennels.Owners ), Scan_2 AS ( SELECT state FROM dog_kennels.Professionals ), Intersect_3 AS ( SELECT Scan_1.state FROM Scan_1 WHERE state IN (SELECT state FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT state FROM dog_kennels.Owners  INTERSECT SELECT state FROM dog_kennels.Professionals"
  },
  {
    "id":"decfc871b13ceaffd983db7df7c5c5dd6962b493f507d45cc62e8e2e3a87588a",
    "db_id":"dog_kennels",
    "question":"What is the average age of the dogs who have gone through any treatments?",
    "query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age , dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.dog_id = #1.dog_id ] Output [ #1.age ] ; #4 = Aggregate [ #3 ] Output [ AVG(age) AS Avg_age ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age , dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.dog_id = #1.dog_id ] Output [ #1.age ] ; #4 = Aggregate [ #3 ] Output [ AVG(age) AS Avg_age ]",
    "cte":"WITH Scan_1 AS ( SELECT age, dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Intersect_3 AS ( SELECT Scan_1.age FROM Scan_1 WHERE dog_id IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(age) AS Avg_age FROM Intersect_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments  )"
  },
  {
    "id":"157adfc6e10475a6903221bfc25168a40ae9a2ef7302d6de45ef016f64c3a329",
    "db_id":"dog_kennels",
    "question":"Find the average age of the dogs who went through treatments.",
    "query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age , dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.dog_id = #1.dog_id ] Output [ #1.age ] ; #4 = Aggregate [ #3 ] Output [ AVG(age) AS Avg_age ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age , dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #2.dog_id = #1.dog_id ] Output [ #1.age ] ; #4 = Aggregate [ #3 ] Output [ AVG(age) AS Avg_age ]",
    "cte":"WITH Scan_1 AS ( SELECT age, dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Intersect_3 AS ( SELECT Scan_1.age FROM Scan_1 WHERE dog_id IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT AVG(age) AS Avg_age FROM Intersect_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  WHERE dog_id IN ( SELECT dog_id FROM dog_kennels.Treatments  )"
  },
  {
    "id":"2d5aaf3ed4a87a7bfd3f47e80b31b63bc9cb52e1d5ab8aadfb5e21f80c15d4f4",
    "db_id":"dog_kennels",
    "question":"Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.",
    "query":"SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Professionals ] Predicate [ state = 'Indiana' ] Output [ cell_number , state , professional_id , last_name ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.cell_number , #3.last_name , #3.professional_id ] ; #5 = Aggregate [ #4 ] GroupBy [ professional_id ] Output [ cell_number , professional_id , last_name , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star > 2 ] Output [ cell_number , professional_id , last_name ] ; #7 = Union [ #1 , #6 ] Output [ #1.professional_id , #1.cell_number , #1.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Indiana' ] Output [ cell_number , state , professional_id , last_name ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.cell_number , #3.last_name , #3.professional_id ] ; #5 = Aggregate [ #4 ] GroupBy [ professional_id ] Output [ cell_number , professional_id , last_name , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star > 2 ] Output [ cell_number , professional_id , last_name ] ; #7 = Union [ #1 , #6 ] Output [ #1.professional_id , #1.cell_number , #1.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT cell_number, state, professional_id, last_name FROM dog_kennels.Professionals WHERE state = 'Indiana' ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT cell_number, professional_id, last_name FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.cell_number, Scan_3.last_name, Scan_3.professional_id FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Aggregate_5 AS ( SELECT cell_number, professional_id, last_name, COUNT(*) AS Count_Star FROM Join_4 GROUP BY last_name, professional_id, cell_number ), Filter_6 AS ( SELECT cell_number, professional_id, last_name FROM Aggregate_5 WHERE Count_Star > 2 ), Union_7 AS ( SELECT professional_id, cell_number, last_name FROM Scan_1 UNION SELECT professional_id, cell_number, last_name FROM Filter_6 ) SELECT * FROM Union_7",
    "clean_query":"SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals  WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2"
  },
  {
    "id":"8b33d8ebee3c820fd9c6f45fa6f76eeda92b42b72cc32487f29cfa4b79175f7b",
    "db_id":"dog_kennels",
    "question":"Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.",
    "query":"SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Professionals ] Predicate [ state = 'Indiana' ] Output [ cell_number , state , professional_id , last_name ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.cell_number , #3.last_name , #3.professional_id ] ; #5 = Aggregate [ #4 ] GroupBy [ professional_id ] Output [ cell_number , professional_id , last_name , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star > 2 ] Output [ cell_number , professional_id , last_name ] ; #7 = Union [ #1 , #6 ] Output [ #1.professional_id , #1.cell_number , #1.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Indiana' ] Output [ cell_number , state , professional_id , last_name ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.cell_number , #3.last_name , #3.professional_id ] ; #5 = Aggregate [ #4 ] GroupBy [ professional_id ] Output [ cell_number , professional_id , last_name , countstar AS Count_Star ] ; #6 = Filter [ #5 ] Predicate [ Count_Star > 2 ] Output [ cell_number , professional_id , last_name ] ; #7 = Union [ #1 , #6 ] Output [ #1.professional_id , #1.cell_number , #1.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT cell_number, state, professional_id, last_name FROM dog_kennels.Professionals WHERE state = 'Indiana' ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT cell_number, professional_id, last_name FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.cell_number, Scan_3.last_name, Scan_3.professional_id FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Aggregate_5 AS ( SELECT cell_number, professional_id, last_name, COUNT(*) AS Count_Star FROM Join_4 GROUP BY last_name, professional_id, cell_number ), Filter_6 AS ( SELECT cell_number, professional_id, last_name FROM Aggregate_5 WHERE Count_Star > 2 ), Union_7 AS ( SELECT professional_id, cell_number, last_name FROM Scan_1 UNION SELECT professional_id, cell_number, last_name FROM Filter_6 ) SELECT * FROM Union_7",
    "clean_query":"SELECT professional_id , last_name , cell_number FROM dog_kennels.Professionals  WHERE state = 'Indiana' UNION SELECT T1.professional_id , T1.last_name , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.last_name , T1.cell_number HAVING count ( * ) > 2"
  },
  {
    "id":"8ff76f894695250cc3219a3776484c51d536e913fbbfae05da57575988b3aaeb",
    "db_id":"dog_kennels",
    "question":"Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .",
    "query":"select name FROM dog_kennels.dogs WITH (FORCESCAN) where dog_id not in ( select dog_id FROM dog_kennels.treatments WITH (FORCESCAN) group by dog_id having sum ( cost_of_treatment ) > 1000 ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ dog_id , name ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #3 = Aggregate [ #2 ] GroupBy [ dog_id ] Output [ dog_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment ] ; #4 = Filter [ #3 ] Predicate [ Sum_cost_of_treatment > 1000.0 ] Output [ dog_id ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.dog_id = #1.dog_id ] Output [ #1.name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id , name ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #3 = Aggregate [ #2 ] GroupBy [ dog_id ] Output [ dog_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment ] ; #4 = Filter [ #3 ] Predicate [ Sum_cost_of_treatment > 1000.0 ] Output [ dog_id ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.dog_id = #1.dog_id ] Output [ #1.name ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id, name FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Aggregate_3 AS ( SELECT dog_id, SUM(cost_of_treatment) AS Sum_cost_of_treatment FROM Scan_2 GROUP BY dog_id ), Filter_4 AS ( SELECT dog_id FROM Aggregate_3 WHERE Sum_cost_of_treatment > 1000.0 ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Filter_4) ) SELECT * FROM Except_5",
    "clean_query":"select name FROM dog_kennels.dogs  where dog_id not in ( select dog_id FROM dog_kennels.treatments  group by dog_id having sum ( cost_of_treatment ) > 1000 )"
  },
  {
    "id":"2e6a21ea522f1a50f525947926f0f042d7a8194f313d7a60aa58fe70c5062144",
    "db_id":"dog_kennels",
    "question":"What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?",
    "query":"select name FROM dog_kennels.dogs WITH (FORCESCAN) where dog_id not in ( select dog_id FROM dog_kennels.treatments WITH (FORCESCAN) group by dog_id having sum ( cost_of_treatment ) > 1000 ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ dog_id , name ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #3 = Aggregate [ #2 ] GroupBy [ dog_id ] Output [ dog_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment ] ; #4 = Filter [ #3 ] Predicate [ Sum_cost_of_treatment > 1000.0 ] Output [ dog_id ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.dog_id = #1.dog_id ] Output [ #1.name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id , name ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #3 = Aggregate [ #2 ] GroupBy [ dog_id ] Output [ dog_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment ] ; #4 = Filter [ #3 ] Predicate [ Sum_cost_of_treatment > 1000.0 ] Output [ dog_id ] ; #5 = Except [ #1 , #4 ] Predicate [ #4.dog_id = #1.dog_id ] Output [ #1.name ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id, name FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Aggregate_3 AS ( SELECT dog_id, SUM(cost_of_treatment) AS Sum_cost_of_treatment FROM Scan_2 GROUP BY dog_id ), Filter_4 AS ( SELECT dog_id FROM Aggregate_3 WHERE Sum_cost_of_treatment > 1000.0 ), Except_5 AS ( SELECT Scan_1.name FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Filter_4) ) SELECT * FROM Except_5",
    "clean_query":"select name FROM dog_kennels.dogs  where dog_id not in ( select dog_id FROM dog_kennels.treatments  group by dog_id having sum ( cost_of_treatment ) > 1000 )"
  },
  {
    "id":"1f6246464b62f765bf1b1cd4fb9ab00f47b5ee2aa8b7ba1ac9112ecf774c5483",
    "db_id":"dog_kennels",
    "question":"Which first names are used for professionals or owners but are not used as dog names?",
    "query":"SELECT first_name FROM dog_kennels.Professionals WITH (FORCESCAN) UNION SELECT first_name FROM dog_kennels.Owners WITH (FORCESCAN) EXCEPT SELECT name FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ first_name ] ; #2 = Scan Table [ Owners ] Output [ first_name ] ; #3 = Union [ #1 , #2 ] Output [ #1.first_name ] ; #4 = Scan Table [ Dogs ] Output [ name ] ; #5 = Except [ #3 , #4 ] Predicate [ #4.name = #3.first_name ] Output [ #3.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ first_name ] ; #2 = Scan Table [ Owners ] Output [ first_name ] ; #3 = Union [ #1 , #2 ] Output [ #1.first_name ] ; #4 = Scan Table [ Dogs ] Output [ name ] ; #5 = Except [ #3 , #4 ] Predicate [ #4.name = #3.first_name ] Output [ #3.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT first_name FROM dog_kennels.Owners ), Union_3 AS ( SELECT first_name FROM Scan_1 UNION SELECT first_name FROM Scan_2 ), Scan_4 AS ( SELECT name FROM dog_kennels.Dogs ), Except_5 AS ( SELECT Union_3.first_name FROM Union_3 WHERE first_name NOT IN (SELECT name FROM Scan_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT first_name FROM dog_kennels.Professionals  UNION SELECT first_name FROM dog_kennels.Owners  EXCEPT SELECT name FROM dog_kennels.Dogs"
  },
  {
    "id":"79cef8a73b2fd8b66f165d4c4c9e563cfeea07472ea739d817c32c35983b8c2f",
    "db_id":"dog_kennels",
    "question":"Find the first names that are used for professionals or owners but are not used as dog names.",
    "query":"SELECT first_name FROM dog_kennels.Professionals WITH (FORCESCAN) UNION SELECT first_name FROM dog_kennels.Owners WITH (FORCESCAN) EXCEPT SELECT name FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ first_name ] ; #2 = Scan Table [ Owners ] Output [ first_name ] ; #3 = Union [ #1 , #2 ] Output [ #1.first_name ] ; #4 = Scan Table [ Dogs ] Output [ name ] ; #5 = Except [ #3 , #4 ] Predicate [ #4.name = #3.first_name ] Output [ #3.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ first_name ] ; #2 = Scan Table [ Owners ] Output [ first_name ] ; #3 = Union [ #1 , #2 ] Output [ #1.first_name ] ; #4 = Scan Table [ Dogs ] Output [ name ] ; #5 = Except [ #3 , #4 ] Predicate [ #4.name = #3.first_name ] Output [ #3.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT first_name FROM dog_kennels.Owners ), Union_3 AS ( SELECT first_name FROM Scan_1 UNION SELECT first_name FROM Scan_2 ), Scan_4 AS ( SELECT name FROM dog_kennels.Dogs ), Except_5 AS ( SELECT Union_3.first_name FROM Union_3 WHERE first_name NOT IN (SELECT name FROM Scan_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT first_name FROM dog_kennels.Professionals  UNION SELECT first_name FROM dog_kennels.Owners  EXCEPT SELECT name FROM dog_kennels.Dogs"
  },
  {
    "id":"8fc7a2ee5a2eb6023b8e472bb2464ab3199f614879d09a2882a8e5e7053c079b",
    "db_id":"dog_kennels",
    "question":"Which professional did not operate any treatment on dogs? List the professional's id, role and email.",
    "query":"SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals WITH (FORCESCAN) EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #2 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #3 = Scan Table [ Treatments ] Output [ professional_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.professional_id = #2.professional_id ] Output [ #2.role_code , #2.professional_id , #2.email_address ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.professional_id = #4.professional_id ] Output [ #1.professional_id , #1.role_code , #1.email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #2 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #3 = Scan Table [ Treatments ] Output [ professional_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.professional_id = #2.professional_id ] Output [ #2.role_code , #2.professional_id , #2.email_address ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.professional_id = #4.professional_id ] Output [ #1.professional_id , #1.role_code , #1.email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT role_code, professional_id, email_address FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT role_code, professional_id, email_address FROM dog_kennels.Professionals ), Scan_3 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Intersect_4 AS ( SELECT Scan_2.role_code, Scan_2.professional_id, Scan_2.email_address FROM Scan_2 WHERE professional_id IN (SELECT professional_id FROM Scan_3) ), Except_5 AS ( SELECT Scan_1.professional_id, Scan_1.role_code, Scan_1.email_address FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Intersect_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals  EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id"
  },
  {
    "id":"36adc0f401efd9e40060af9ac99b36de507b24338108ea1174f7e522094865df",
    "db_id":"dog_kennels",
    "question":"Give me the id, role and email of the professionals who did not perform any treatment on dogs.",
    "query":"SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals WITH (FORCESCAN) EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #2 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #3 = Scan Table [ Treatments ] Output [ professional_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.professional_id = #2.professional_id ] Output [ #2.role_code , #2.professional_id , #2.email_address ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.professional_id = #4.professional_id ] Output [ #1.professional_id , #1.role_code , #1.email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #2 = Scan Table [ Professionals ] Output [ role_code , professional_id , email_address ] ; #3 = Scan Table [ Treatments ] Output [ professional_id ] ; #4 = Intersect [ #2 , #3 ] Predicate [ #3.professional_id = #2.professional_id ] Output [ #2.role_code , #2.professional_id , #2.email_address ] ; #5 = Except [ #1 , #4 ] Predicate [ #1.professional_id = #4.professional_id ] Output [ #1.professional_id , #1.role_code , #1.email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT role_code, professional_id, email_address FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT role_code, professional_id, email_address FROM dog_kennels.Professionals ), Scan_3 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Intersect_4 AS ( SELECT Scan_2.role_code, Scan_2.professional_id, Scan_2.email_address FROM Scan_2 WHERE professional_id IN (SELECT professional_id FROM Scan_3) ), Except_5 AS ( SELECT Scan_1.professional_id, Scan_1.role_code, Scan_1.email_address FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Intersect_4) ) SELECT * FROM Except_5",
    "clean_query":"SELECT professional_id , role_code , email_address FROM dog_kennels.Professionals  EXCEPT SELECT T1.professional_id , T1.role_code , T1.email_address FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id"
  },
  {
    "id":"4c7d617842ecf4c2c442a7865d9226b92d5fc0b85e7dbe47701a24899111864b",
    "db_id":"dog_kennels",
    "question":"Which owner owns the most dogs? List the owner id, first name and last name.",
    "query":"SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Owners AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ owner_id ] ; #2 = Aggregate [ #1 ] GroupBy [ owner_id ] Output [ owner_id , countstar AS Count_Star ] ; #3 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #2.Count_Star , #3.last_name , #3.first_name , #2.owner_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , owner_id , last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ owner_id ] ; #2 = Aggregate [ #1 ] GroupBy [ owner_id ] Output [ owner_id , countstar AS Count_Star ] ; #3 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #2.Count_Star , #3.last_name , #3.first_name , #2.owner_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , owner_id , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT owner_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY owner_id ), Scan_3 AS ( SELECT first_name, owner_id, last_name FROM dog_kennels.Owners ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.last_name, Scan_3.first_name, Aggregate_2.owner_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.owner_id = Scan_3.owner_id ), TopSort_5 AS ( SELECT TOP 1 first_name, Count_Star, owner_id, last_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Owners AS T2  ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"66ca5dbbeaf6330e1e4962deede1ffbb618a38a3ed59cf7c08d11c553f1497cb",
    "db_id":"dog_kennels",
    "question":"Return the owner id, first name and last name of the owner who has the most dogs.",
    "query":"SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Owners AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ owner_id ] ; #2 = Aggregate [ #1 ] GroupBy [ owner_id ] Output [ owner_id , countstar AS Count_Star ] ; #3 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #2.Count_Star , #3.last_name , #3.first_name , #2.owner_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , owner_id , last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ owner_id ] ; #2 = Aggregate [ #1 ] GroupBy [ owner_id ] Output [ owner_id , countstar AS Count_Star ] ; #3 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #2.Count_Star , #3.last_name , #3.first_name , #2.owner_id ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ first_name , Count_Star , owner_id , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT owner_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY owner_id ), Scan_3 AS ( SELECT first_name, owner_id, last_name FROM dog_kennels.Owners ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.last_name, Scan_3.first_name, Aggregate_2.owner_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.owner_id = Scan_3.owner_id ), TopSort_5 AS ( SELECT TOP 1 first_name, Count_Star, owner_id, last_name FROM Join_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.owner_id , T2.first_name , T2.last_name FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Owners AS T2  ON T1.owner_id = T2.owner_id GROUP BY T1.owner_id , T2.first_name , T2.last_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"846e09f26beeee5ebb3abf7a28810861967194e38262b68ea53c0d47e8b2709e",
    "db_id":"dog_kennels",
    "question":"Which professionals have done at least two treatments? List the professional's id, role, and first name.",
    "query":"SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ first_name , role_code , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.first_name , #3.role_code , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ first_name , role_code , professional_id ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ first_name , role_code , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.first_name , #3.role_code , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ first_name , role_code , professional_id ]",
    "cte":"WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT professional_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT first_name, role_code, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.first_name, Scan_3.role_code, Scan_3.professional_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT first_name, role_code, professional_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2"
  },
  {
    "id":"ef4c1b5e130aa488efbf131f5a392c01c95c1e9be40ff4af6960a1d9f3e744a0",
    "db_id":"dog_kennels",
    "question":"What are the id, role, and first name of the professionals who have performed two or more treatments?",
    "query":"SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ first_name , role_code , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.first_name , #3.role_code , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ first_name , role_code , professional_id ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ first_name , role_code , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.first_name , #3.role_code , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ first_name , role_code , professional_id ]",
    "cte":"WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT professional_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT first_name, role_code, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.first_name, Scan_3.role_code, Scan_3.professional_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT first_name, role_code, professional_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.professional_id , T1.role_code , T1.first_name FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.role_code , T1.first_name HAVING count ( * ) > = 2"
  },
  {
    "id":"ad9d991e1f140de0bcbb72b639b2b2c55ef989561d953b6b65c0c60098413bba",
    "db_id":"dog_kennels",
    "question":"What is the name of the breed with the most dogs?",
    "query":"SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Breeds ] Output [ breed_name , breed_code ] ; #2 = Scan Table [ Dogs ] Output [ breed_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.breed_code = #2.breed_code ] Output [ #1.breed_name ] ; #4 = Aggregate [ #3 ] GroupBy [ breed_name ] Output [ breed_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , breed_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Breeds ] Output [ breed_name , breed_code ] ; #2 = Scan Table [ Dogs ] Output [ breed_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.breed_code = #2.breed_code ] Output [ #1.breed_name ] ; #4 = Aggregate [ #3 ] GroupBy [ breed_name ] Output [ breed_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , breed_name ]",
    "cte":"WITH Scan_1 AS ( SELECT breed_name, breed_code FROM dog_kennels.Breeds ), Scan_2 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.breed_name FROM Scan_1 JOIN Scan_2 ON Scan_1.breed_code = Scan_2.breed_code ), Aggregate_4 AS ( SELECT breed_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY breed_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, breed_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"6940b25b51becbeb25e648b50fc48812060854804e93b48086f08f8e01bd3638",
    "db_id":"dog_kennels",
    "question":"Which breed do the most dogs have? Give me the breed name.",
    "query":"SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Breeds ] Output [ breed_name , breed_code ] ; #2 = Scan Table [ Dogs ] Output [ breed_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.breed_code = #2.breed_code ] Output [ #1.breed_name ] ; #4 = Aggregate [ #3 ] GroupBy [ breed_name ] Output [ breed_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , breed_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Breeds ] Output [ breed_name , breed_code ] ; #2 = Scan Table [ Dogs ] Output [ breed_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.breed_code = #2.breed_code ] Output [ #1.breed_name ] ; #4 = Aggregate [ #3 ] GroupBy [ breed_name ] Output [ breed_name , countstar AS Count_Star ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , breed_name ]",
    "cte":"WITH Scan_1 AS ( SELECT breed_name, breed_code FROM dog_kennels.Breeds ), Scan_2 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_1.breed_name FROM Scan_1 JOIN Scan_2 ON Scan_1.breed_code = Scan_2.breed_code ), Aggregate_4 AS ( SELECT breed_name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY breed_name ), TopSort_5 AS ( SELECT TOP 1 Count_Star, breed_name FROM Aggregate_4 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.breed_name FROM dog_kennels.Breeds AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.breed_code = T2.breed_code GROUP BY T1.breed_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"661ea27e7e8bc59503dbef3470b98ed3b9d917be0339f18d8dcb7f4268ed669f",
    "db_id":"dog_kennels",
    "question":"Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.",
    "query":"SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #3.last_name , #2.dog_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.last_name , #4.owner_id ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , last_name , countstar AS Count_Star ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , owner_id , last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #3.last_name , #2.dog_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.last_name , #4.owner_id ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , last_name , countstar AS Count_Star ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , owner_id , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT owner_id, last_name FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.owner_id, Scan_3.last_name, Scan_2.dog_id FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.last_name, Join_4.owner_id FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT owner_id, last_name, COUNT(*) AS Count_Star FROM Join_5 GROUP BY owner_id, last_name ), TopSort_7 AS ( SELECT TOP 1 Count_Star, owner_id, last_name FROM Aggregate_6 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_7",
    "clean_query":"SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"e8547401e95957bca35ed38ffb63b21c97fd2a30d03f18821da27f7671f398df",
    "db_id":"dog_kennels",
    "question":"Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.",
    "query":"SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #3.last_name , #2.dog_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.last_name , #4.owner_id ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , last_name , countstar AS Count_Star ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , owner_id , last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #3.last_name , #2.dog_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.last_name , #4.owner_id ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , last_name , countstar AS Count_Star ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , owner_id , last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT owner_id, last_name FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.owner_id, Scan_3.last_name, Scan_2.dog_id FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.last_name, Join_4.owner_id FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT owner_id, last_name, COUNT(*) AS Count_Star FROM Join_5 GROUP BY owner_id, last_name ), TopSort_7 AS ( SELECT TOP 1 Count_Star, owner_id, last_name FROM Aggregate_6 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_7",
    "clean_query":"SELECT TOP 1 T1.owner_id , T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.last_name ORDER BY count ( * ) DESC"
  },
  {
    "id":"769c4f1348155baa4d093eb503db38362725a9c83d68fe615b476ac3e3c2d803",
    "db_id":"dog_kennels",
    "question":"What is the description of the treatment type that costs the least money in total?",
    "query":"SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #2 = Aggregate [ #1 ] GroupBy [ treatment_type_code ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , treatment_type_code ] ; #3 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.treatment_type_code = #3.treatment_type_code ] Output [ #3.treatment_type_description , #2.Sum_cost_of_treatment ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment ASC ] Output [ Sum_cost_of_treatment , treatment_type_description ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #2 = Aggregate [ #1 ] GroupBy [ treatment_type_code ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , treatment_type_code ] ; #3 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.treatment_type_code = #3.treatment_type_code ] Output [ #3.treatment_type_description , #2.Sum_cost_of_treatment ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment ASC ] Output [ Sum_cost_of_treatment , treatment_type_description ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT SUM(cost_of_treatment) AS Sum_cost_of_treatment, treatment_type_code FROM Scan_1 GROUP BY treatment_type_code ), Scan_3 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Join_4 AS ( SELECT Scan_3.treatment_type_description, Aggregate_2.Sum_cost_of_treatment FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.treatment_type_code = Scan_3.treatment_type_code ), TopSort_5 AS ( SELECT TOP 1 Sum_cost_of_treatment, treatment_type_description FROM Join_4 ORDER BY Sum_cost_of_treatment ASC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC"
  },
  {
    "id":"8712f813e382b9eadb483db8adea6999189ff315c912822cb725e49f6fb06f95",
    "db_id":"dog_kennels",
    "question":"Give me the description of the treatment type whose total cost is the lowest.",
    "query":"SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #2 = Aggregate [ #1 ] GroupBy [ treatment_type_code ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , treatment_type_code ] ; #3 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.treatment_type_code = #3.treatment_type_code ] Output [ #3.treatment_type_description , #2.Sum_cost_of_treatment ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment ASC ] Output [ Sum_cost_of_treatment , treatment_type_description ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #2 = Aggregate [ #1 ] GroupBy [ treatment_type_code ] Output [ SUM(cost_of_treatment) AS Sum_cost_of_treatment , treatment_type_code ] ; #3 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.treatment_type_code = #3.treatment_type_code ] Output [ #3.treatment_type_description , #2.Sum_cost_of_treatment ] ; #5 = TopSort [ #4 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment ASC ] Output [ Sum_cost_of_treatment , treatment_type_description ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT SUM(cost_of_treatment) AS Sum_cost_of_treatment, treatment_type_code FROM Scan_1 GROUP BY treatment_type_code ), Scan_3 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Join_4 AS ( SELECT Scan_3.treatment_type_description, Aggregate_2.Sum_cost_of_treatment FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.treatment_type_code = Scan_3.treatment_type_code ), TopSort_5 AS ( SELECT TOP 1 Sum_cost_of_treatment, treatment_type_description FROM Join_4 ORDER BY Sum_cost_of_treatment ASC ) SELECT * FROM TopSort_5",
    "clean_query":"SELECT TOP 1 T1.treatment_type_description FROM dog_kennels.Treatment_types AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.treatment_type_code = T2.treatment_type_code GROUP BY T1.treatment_type_description , T1.treatment_type_code ORDER BY sum ( cost_of_treatment ) ASC"
  },
  {
    "id":"d4c083cb95db6dcb9ca733446fc4c7c4a43e2b085ee182b10d387d7b8d4694d6",
    "db_id":"dog_kennels",
    "question":"Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.",
    "query":"SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , zip_code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #2.dog_id , #3.zip_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.zip_code , #4.owner_id , #1.cost_of_treatment ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment , zip_code ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment DESC ] Output [ owner_id , Sum_cost_of_treatment , zip_code ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , zip_code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #2.dog_id , #3.zip_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.zip_code , #4.owner_id , #1.cost_of_treatment ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment , zip_code ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment DESC ] Output [ owner_id , Sum_cost_of_treatment , zip_code ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT owner_id, zip_code FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.owner_id, Scan_2.dog_id, Scan_3.zip_code FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.zip_code, Join_4.owner_id, Scan_1.cost_of_treatment FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT owner_id, SUM(cost_of_treatment) AS Sum_cost_of_treatment, zip_code FROM Join_5 GROUP BY owner_id, zip_code ), TopSort_7 AS ( SELECT TOP 1 owner_id, Sum_cost_of_treatment, zip_code FROM Aggregate_6 ORDER BY Sum_cost_of_treatment DESC ) SELECT * FROM TopSort_7",
    "clean_query":"SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC"
  },
  {
    "id":"78201a51f6489492d9712ea0074012d00b05eae33689bd9392a73b71b99c588a",
    "db_id":"dog_kennels",
    "question":"Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.",
    "query":"SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3 WITH (FORCESCAN) ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , zip_code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #2.dog_id , #3.zip_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.zip_code , #4.owner_id , #1.cost_of_treatment ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment , zip_code ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment DESC ] Output [ owner_id , Sum_cost_of_treatment , zip_code ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , dog_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , dog_id ] ; #3 = Scan Table [ Owners ] Output [ owner_id , zip_code ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.owner_id = #3.owner_id ] Output [ #3.owner_id , #2.dog_id , #3.zip_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.dog_id = #4.dog_id ] Output [ #4.zip_code , #4.owner_id , #1.cost_of_treatment ] ; #6 = Aggregate [ #5 ] GroupBy [ owner_id ] Output [ owner_id , SUM(cost_of_treatment) AS Sum_cost_of_treatment , zip_code ] ; #7 = TopSort [ #6 ] Rows [ 1 ] OrderBy [ Sum_cost_of_treatment DESC ] Output [ owner_id , Sum_cost_of_treatment , zip_code ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment, dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT owner_id, dog_id FROM dog_kennels.Dogs ), Scan_3 AS ( SELECT owner_id, zip_code FROM dog_kennels.Owners ), Join_4 AS ( SELECT Scan_3.owner_id, Scan_2.dog_id, Scan_3.zip_code FROM Scan_2 JOIN Scan_3 ON Scan_2.owner_id = Scan_3.owner_id ), Join_5 AS ( SELECT Join_4.zip_code, Join_4.owner_id, Scan_1.cost_of_treatment FROM Scan_1 JOIN Join_4 ON Scan_1.dog_id = Join_4.dog_id ), Aggregate_6 AS ( SELECT owner_id, SUM(cost_of_treatment) AS Sum_cost_of_treatment, zip_code FROM Join_5 GROUP BY owner_id, zip_code ), TopSort_7 AS ( SELECT TOP 1 owner_id, Sum_cost_of_treatment, zip_code FROM Aggregate_6 ORDER BY Sum_cost_of_treatment DESC ) SELECT * FROM TopSort_7",
    "clean_query":"SELECT TOP 1 T1.owner_id , T1.zip_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id JOIN dog_kennels.Treatments AS T3  ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id , T1.zip_code ORDER BY sum ( T3.cost_of_treatment ) DESC"
  },
  {
    "id":"a7ac46f6fac1b59f3e7af600f51d43c2cb3e999a65bed7a25b53c188b5ea89d5",
    "db_id":"dog_kennels",
    "question":"Which professionals have done at least two types of treatments? List the professional id and cell phone.",
    "query":"SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.cell_number , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ cell_number , professional_id ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.cell_number , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ cell_number , professional_id ]",
    "cte":"WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT professional_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT cell_number, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.cell_number, Scan_3.professional_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT cell_number, professional_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2"
  },
  {
    "id":"a72bc94122c8335bb8ef116a28ae80c1bcafdbcf89ef8fca8233fe7a04a89520",
    "db_id":"dog_kennels",
    "question":"Find the id and cell phone of the professionals who operate two or more types of treatments.",
    "query":"SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.cell_number , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ cell_number , professional_id ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] GroupBy [ professional_id ] Output [ professional_id , countstar AS Count_Star ] ; #3 = Scan Table [ Professionals ] Output [ cell_number , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #2.Count_Star , #3.cell_number , #3.professional_id ] ; #5 = Filter [ #4 ] Predicate [ Count_Star >= 2 ] Output [ cell_number , professional_id ]",
    "cte":"WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT professional_id, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY professional_id ), Scan_3 AS ( SELECT cell_number, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Aggregate_2.Count_Star, Scan_3.cell_number, Scan_3.professional_id FROM Aggregate_2 JOIN Scan_3 ON Aggregate_2.professional_id = Scan_3.professional_id ), Filter_5 AS ( SELECT cell_number, professional_id FROM Join_4 WHERE Count_Star >= 2 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.professional_id , T1.cell_number FROM dog_kennels.Professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id , T1.cell_number HAVING count ( * ) > = 2"
  },
  {
    "id":"74853798510bb1be5881fc985b194c00060b2fa3fafaf8b2d0658e70f2d759f0",
    "db_id":"dog_kennels",
    "question":"What are the first name and last name of the professionals who have done treatment with cost below average?",
    "query":"SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #2 = Aggregate [ #1 ] Output [ AVG(cost_of_treatment) AS Avg_cost_of_treatment ] ; #3 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.cost_of_treatment < #2.Avg_cost_of_treatment ] Output [ #3.cost_of_treatment ] ; #5 = Scan Table [ Professionals ] Output [ first_name , last_name ] ; #6 = Join [ #4 , #5 ] Distinct [ true ] Output [ #5.first_name , #5.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #2 = Aggregate [ #1 ] Output [ AVG(cost_of_treatment) AS Avg_cost_of_treatment ] ; #3 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.cost_of_treatment < #2.Avg_cost_of_treatment ] Output [ #3.cost_of_treatment ] ; #5 = Scan Table [ Professionals ] Output [ first_name , last_name ] ; #6 = Join [ #4 , #5 ] Distinct [ true ] Output [ #5.first_name , #5.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT AVG(cost_of_treatment) AS Avg_cost_of_treatment FROM Scan_1 ), Scan_3 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Join_4 AS ( SELECT cost_of_treatment FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.cost_of_treatment < Aggregate_2.Avg_cost_of_treatment ), Scan_5 AS ( SELECT first_name, last_name FROM dog_kennels.Professionals ), Join_6 AS ( SELECT DISTINCT Scan_5.first_name, Scan_5.last_name FROM Join_4 CROSS JOIN Scan_5 ) SELECT * FROM Join_6",
    "clean_query":"SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1  CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments  )"
  },
  {
    "id":"c8a261b56b3fd317715e20ae964633fe39d27e415421d119333cd698a3f48fb7",
    "db_id":"dog_kennels",
    "question":"Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.",
    "query":"SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1 WITH (FORCESCAN) CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ) ",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #2 = Aggregate [ #1 ] Output [ AVG(cost_of_treatment) AS Avg_cost_of_treatment ] ; #3 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.cost_of_treatment < #2.Avg_cost_of_treatment ] Output [ #3.cost_of_treatment ] ; #5 = Scan Table [ Professionals ] Output [ first_name , last_name ] ; #6 = Join [ #4 , #5 ] Distinct [ true ] Output [ #5.first_name , #5.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #2 = Aggregate [ #1 ] Output [ AVG(cost_of_treatment) AS Avg_cost_of_treatment ] ; #3 = Scan Table [ Treatments ] Output [ cost_of_treatment ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.cost_of_treatment < #2.Avg_cost_of_treatment ] Output [ #3.cost_of_treatment ] ; #5 = Scan Table [ Professionals ] Output [ first_name , last_name ] ; #6 = Join [ #4 , #5 ] Distinct [ true ] Output [ #5.first_name , #5.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT AVG(cost_of_treatment) AS Avg_cost_of_treatment FROM Scan_1 ), Scan_3 AS ( SELECT cost_of_treatment FROM dog_kennels.Treatments ), Join_4 AS ( SELECT cost_of_treatment FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.cost_of_treatment < Aggregate_2.Avg_cost_of_treatment ), Scan_5 AS ( SELECT first_name, last_name FROM dog_kennels.Professionals ), Join_6 AS ( SELECT DISTINCT Scan_5.first_name, Scan_5.last_name FROM Join_4 CROSS JOIN Scan_5 ) SELECT * FROM Join_6",
    "clean_query":"SELECT DISTINCT T1.first_name , T1.last_name FROM dog_kennels.Professionals AS T1  CROSS JOIN dog_kennels.Treatments AS T2 WHERE cost_of_treatment < ( SELECT avg ( cost_of_treatment ) AS Avg_cost_of_treatment FROM dog_kennels.Treatments  )"
  },
  {
    "id":"6b6e1c6478e1e38f5482e86be34aee7b06e9b39a193ea87dfdd42bee7e5d3092",
    "db_id":"dog_kennels",
    "question":"List the date of each treatment, together with the first name of the professional who operated it.",
    "query":"SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.Professionals AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ date_of_treatment , professional_id ] ; #2 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ #2.first_name , #1.date_of_treatment ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ date_of_treatment , professional_id ] ; #2 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ #2.first_name , #1.date_of_treatment ]",
    "cte":"WITH Scan_1 AS ( SELECT date_of_treatment, professional_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_3 AS ( SELECT Scan_2.first_name, Scan_1.date_of_treatment FROM Scan_1 JOIN Scan_2 ON Scan_1.professional_id = Scan_2.professional_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.Professionals AS T2  ON T1.professional_id = T2.professional_id"
  },
  {
    "id":"5cce379b4051e866afaec01797e5a9818e966ef70d3e2d375c35ce632f044540",
    "db_id":"dog_kennels",
    "question":"What are the date and the operating professional's first name of each treatment?",
    "query":"SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.Professionals AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ date_of_treatment , professional_id ] ; #2 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ #2.first_name , #1.date_of_treatment ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ date_of_treatment , professional_id ] ; #2 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ #2.first_name , #1.date_of_treatment ]",
    "cte":"WITH Scan_1 AS ( SELECT date_of_treatment, professional_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_3 AS ( SELECT Scan_2.first_name, Scan_1.date_of_treatment FROM Scan_1 JOIN Scan_2 ON Scan_1.professional_id = Scan_2.professional_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.date_of_treatment , T2.first_name FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.Professionals AS T2  ON T1.professional_id = T2.professional_id"
  },
  {
    "id":"a2a172d7d2a542d70069554cde5ff036f577151c427f34994ab64326401a47dc",
    "db_id":"dog_kennels",
    "question":"List the cost of each treatment and the corresponding treatment type description.",
    "query":"SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.treatment_types AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.treatment_type_code = #2.treatment_type_code ] Output [ #1.treatment_type_description , #2.cost_of_treatment ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.treatment_type_code = #2.treatment_type_code ] Output [ #1.treatment_type_description , #2.cost_of_treatment ]",
    "cte":"WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Join_3 AS ( SELECT Scan_1.treatment_type_description, Scan_2.cost_of_treatment FROM Scan_1 JOIN Scan_2 ON Scan_1.treatment_type_code = Scan_2.treatment_type_code ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.treatment_types AS T2  ON T1.treatment_type_code = T2.treatment_type_code"
  },
  {
    "id":"95b58705014ea9cafe1d2b2967eceea55b90e10025390a1d8c79348f47380569",
    "db_id":"dog_kennels",
    "question":"What are the cost and treatment type description of each treatment?",
    "query":"SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1 WITH (FORCESCAN) JOIN dog_kennels.treatment_types AS T2 WITH (FORCESCAN) ON T1.treatment_type_code = T2.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.treatment_type_code = #2.treatment_type_code ] Output [ #1.treatment_type_description , #2.cost_of_treatment ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ cost_of_treatment , treatment_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.treatment_type_code = #2.treatment_type_code ] Output [ #1.treatment_type_description , #2.cost_of_treatment ]",
    "cte":"WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT cost_of_treatment, treatment_type_code FROM dog_kennels.Treatments ), Join_3 AS ( SELECT Scan_1.treatment_type_description, Scan_2.cost_of_treatment FROM Scan_1 JOIN Scan_2 ON Scan_1.treatment_type_code = Scan_2.treatment_type_code ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.cost_of_treatment , T2.treatment_type_description FROM dog_kennels.Treatments AS T1  JOIN dog_kennels.treatment_types AS T2  ON T1.treatment_type_code = T2.treatment_type_code"
  },
  {
    "id":"fc8eb2a4b3514db63e9649bd5c29860d9397dcfdb5806eefd7e7f601c363bf28",
    "db_id":"dog_kennels",
    "question":"List each owner's first name, last name, and the size of his for her dog.",
    "query":"SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ size_code , owner_id ] ; #2 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.first_name , #1.size_code , #2.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ size_code , owner_id ] ; #2 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.first_name , #1.size_code , #2.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT size_code, owner_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT first_name, owner_id, last_name FROM dog_kennels.Owners ), Join_3 AS ( SELECT Scan_2.first_name, Scan_1.size_code, Scan_2.last_name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id"
  },
  {
    "id":"09a03a898de94d379933b176c750be6d83e799a2d7d31e03de82e63888e69ed1",
    "db_id":"dog_kennels",
    "question":"What are each owner's first name, last name, and the size of their dog?",
    "query":"SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ size_code , owner_id ] ; #2 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.first_name , #1.size_code , #2.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ size_code , owner_id ] ; #2 = Scan Table [ Owners ] Output [ first_name , owner_id , last_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.first_name , #1.size_code , #2.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT size_code, owner_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT first_name, owner_id, last_name FROM dog_kennels.Owners ), Join_3 AS ( SELECT Scan_2.first_name, Scan_1.size_code, Scan_2.last_name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.first_name , T1.last_name , T2.size_code FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id"
  },
  {
    "id":"eded0e3c6d25bb3895cd6104eb9495428d4b8d1a9186de3ce6786eedecc9a792",
    "db_id":"dog_kennels",
    "question":"List pairs of the owner's first name and the dogs's name.",
    "query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Owners ] Output [ first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Output [ first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_2.name, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id"
  },
  {
    "id":"a18b1ec289665e858ed449e97f2baf04c419f3a8ecbc84d40b899776cc8686ec",
    "db_id":"dog_kennels",
    "question":"What are each owner's first name and their dogs's name?",
    "query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Owners ] Output [ first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Output [ first_name , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_2.name, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id"
  },
  {
    "id":"17831c8c47493e469a43da0b31f0b95d91ce356b726429b57d3929c4aa04974e",
    "db_id":"dog_kennels",
    "question":"List the names of the dogs of the rarest breed and the treatment dates of them.",
    "query":"SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs WITH (FORCESCAN) GROUP BY breed_code ORDER BY count ( * ) ASC ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ breed_code ] ; #2 = Aggregate [ #1 ] GroupBy [ breed_code ] Output [ countstar AS Count_Star , breed_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , breed_code ] ; #4 = Scan Table [ Dogs ] Output [ dog_id , name , breed_code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.breed_code = #4.breed_code ] Output [ #4.name , #4.dog_id ] ; #6 = Scan Table [ Treatments ] Output [ dog_id , date_of_treatment ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.dog_id = #6.dog_id ] Output [ #6.date_of_treatment , #5.name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ breed_code ] ; #2 = Aggregate [ #1 ] GroupBy [ breed_code ] Output [ countstar AS Count_Star , breed_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , breed_code ] ; #4 = Scan Table [ Dogs ] Output [ dog_id , name , breed_code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.breed_code = #4.breed_code ] Output [ #4.name , #4.dog_id ] ; #6 = Scan Table [ Treatments ] Output [ dog_id , date_of_treatment ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.dog_id = #6.dog_id ] Output [ #6.date_of_treatment , #5.name ]",
    "cte":"WITH Scan_1 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, breed_code FROM Scan_1 GROUP BY breed_code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, breed_code FROM Aggregate_2 ORDER BY Count_Star ASC ), Scan_4 AS ( SELECT dog_id, name, breed_code FROM dog_kennels.Dogs ), Join_5 AS ( SELECT Scan_4.name, Scan_4.dog_id FROM TopSort_3 JOIN Scan_4 ON TopSort_3.breed_code = Scan_4.breed_code ), Scan_6 AS ( SELECT dog_id, date_of_treatment FROM dog_kennels.Treatments ), Join_7 AS ( SELECT Scan_6.date_of_treatment, Join_5.name FROM Join_5 JOIN Scan_6 ON Join_5.dog_id = Scan_6.dog_id ) SELECT * FROM Join_7",
    "clean_query":"SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs  GROUP BY breed_code ORDER BY count ( * ) ASC )"
  },
  {
    "id":"55985502904668903fc70726bab09acf27f4a63cb38da420aac63d72edfcc8ac",
    "db_id":"dog_kennels",
    "question":"Which dogs are of the rarest breed? Show their names and treatment dates.",
    "query":"SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs WITH (FORCESCAN) GROUP BY breed_code ORDER BY count ( * ) ASC ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ breed_code ] ; #2 = Aggregate [ #1 ] GroupBy [ breed_code ] Output [ countstar AS Count_Star , breed_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , breed_code ] ; #4 = Scan Table [ Dogs ] Output [ dog_id , name , breed_code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.breed_code = #4.breed_code ] Output [ #4.name , #4.dog_id ] ; #6 = Scan Table [ Treatments ] Output [ dog_id , date_of_treatment ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.dog_id = #6.dog_id ] Output [ #6.date_of_treatment , #5.name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ breed_code ] ; #2 = Aggregate [ #1 ] GroupBy [ breed_code ] Output [ countstar AS Count_Star , breed_code ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star ASC ] Output [ Count_Star , breed_code ] ; #4 = Scan Table [ Dogs ] Output [ dog_id , name , breed_code ] ; #5 = Join [ #3 , #4 ] Predicate [ #3.breed_code = #4.breed_code ] Output [ #4.name , #4.dog_id ] ; #6 = Scan Table [ Treatments ] Output [ dog_id , date_of_treatment ] ; #7 = Join [ #5 , #6 ] Predicate [ #5.dog_id = #6.dog_id ] Output [ #6.date_of_treatment , #5.name ]",
    "cte":"WITH Scan_1 AS ( SELECT breed_code FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star, breed_code FROM Scan_1 GROUP BY breed_code ), TopSort_3 AS ( SELECT TOP 1 Count_Star, breed_code FROM Aggregate_2 ORDER BY Count_Star ASC ), Scan_4 AS ( SELECT dog_id, name, breed_code FROM dog_kennels.Dogs ), Join_5 AS ( SELECT Scan_4.name, Scan_4.dog_id FROM TopSort_3 JOIN Scan_4 ON TopSort_3.breed_code = Scan_4.breed_code ), Scan_6 AS ( SELECT dog_id, date_of_treatment FROM dog_kennels.Treatments ), Join_7 AS ( SELECT Scan_6.date_of_treatment, Join_5.name FROM Join_5 JOIN Scan_6 ON Join_5.dog_id = Scan_6.dog_id ) SELECT * FROM Join_7",
    "clean_query":"SELECT T1.name , T2.date_of_treatment FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id WHERE T1.breed_code = ( SELECT TOP 1 breed_code FROM dog_kennels.Dogs  GROUP BY breed_code ORDER BY count ( * ) ASC )"
  },
  {
    "id":"01d36d186ac9bd072310196a084016e2239ab53dc2afc337552b1b90e333e482",
    "db_id":"dog_kennels",
    "question":"Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.",
    "query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Owners ] Predicate [ state = 'Virginia' ] Output [ first_name , state , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state = 'Virginia' ] Output [ first_name , state , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, state, owner_id FROM dog_kennels.Owners WHERE state = 'Virginia' ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_2.name, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia'"
  },
  {
    "id":"3def30b1ac991f058d5d2835e68edd88f98f0b397ec317e4db5c6ad6cacb91fb",
    "db_id":"dog_kennels",
    "question":"Find the first names of owners living in Virginia and the names of dogs they own.",
    "query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Owners ] Predicate [ state = 'Virginia' ] Output [ first_name , state , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state = 'Virginia' ] Output [ first_name , state , owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ #2.name , #1.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, state, owner_id FROM dog_kennels.Owners WHERE state = 'Virginia' ), Scan_2 AS ( SELECT owner_id, name FROM dog_kennels.Dogs ), Join_3 AS ( SELECT Scan_2.name, Scan_1.first_name FROM Scan_1 JOIN Scan_2 ON Scan_1.owner_id = Scan_2.owner_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT T1.first_name , T2.name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T1.state = 'Virginia'"
  },
  {
    "id":"96ecc85b71033293fa2c714428724abb820b7d37ef95d0c06006e19e54d286a8",
    "db_id":"dog_kennels",
    "question":"What are the arriving date and the departing date of the dogs who have gone through a treatment?",
    "query":"SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ date_departed , date_arrived , dog_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Distinct [ true ] Output [ #2.date_departed , #2.date_arrived ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ date_departed , date_arrived , dog_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Distinct [ true ] Output [ #2.date_departed , #2.date_arrived ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT date_departed, date_arrived, dog_id FROM dog_kennels.Dogs ), Join_3 AS ( SELECT DISTINCT Scan_2.date_departed, Scan_2.date_arrived FROM Scan_1 JOIN Scan_2 ON Scan_1.dog_id = Scan_2.dog_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id"
  },
  {
    "id":"52e8fb837195616b49756027ccc6ca0ce0a8345e015fb0650c436258d6d84414",
    "db_id":"dog_kennels",
    "question":"Find the arriving date and the departing date of the dogs that received a treatment.",
    "query":"SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.dog_id = T2.dog_id OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ date_departed , date_arrived , dog_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Distinct [ true ] Output [ #2.date_departed , #2.date_arrived ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ dog_id ] ; #2 = Scan Table [ Dogs ] Output [ date_departed , date_arrived , dog_id ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Distinct [ true ] Output [ #2.date_departed , #2.date_arrived ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Scan_2 AS ( SELECT date_departed, date_arrived, dog_id FROM dog_kennels.Dogs ), Join_3 AS ( SELECT DISTINCT Scan_2.date_departed, Scan_2.date_arrived FROM Scan_1 JOIN Scan_2 ON Scan_1.dog_id = Scan_2.dog_id ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.date_arrived , T1.date_departed FROM dog_kennels.Dogs AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.dog_id = T2.dog_id"
  },
  {
    "id":"cb384f0755ee64aadab7999c2dfdc55442be5549699fa4be5be6b2bc0a111457",
    "db_id":"dog_kennels",
    "question":"List the last name of the owner owning the youngest dog.",
    "query":"SELECT T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ owners ] Output [ owner_id , last_name ] ; #2 = Scan Table [ dogs ] Output [ owner_id , age ] ; #3 = Filter [ #2 ] Predicate [ age IS NOT NULL ] Output [ owner_id , age ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ age DESC ] WithTies [ true ] Output [ age, owner_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #4.owner_id = #1.owner_id ] Output [ #1.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ owners ] Output [ owner_id , last_name ] ; #2 = Scan Table [ dogs ] Output [ owner_id , age ] ; #3 = Filter [ #2 ] Predicate [ age IS NOT NULL ] Output [ owner_id , age ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ age DESC ] WithTies [ true ] Output [ age, owner_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #4.owner_id = #1.owner_id ] Output [ #1.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT owner_id, last_name FROM dog_kennels.owners ), Scan_2 AS ( SELECT owner_id, age FROM dog_kennels.dogs ), Filter_3 AS ( SELECT owner_id, age FROM Scan_2 WHERE age IS NOT NULL ), TopSort_4 AS ( SELECT TOP 1 WITH TIES age, owner_id FROM Filter_3 ORDER BY age DESC ), Join_5 AS ( SELECT Scan_1.last_name FROM Scan_1 JOIN TopSort_4 ON TopSort_4.owner_id = Scan_1.owner_id ) SELECT * FROM Join_5",
    "clean_query":"SELECT T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs  )"
  },
  {
    "id":"bb647a855ae3fa4248d333184af9d583778c8243f925a40ea45b59085a0376b2",
    "db_id":"dog_kennels",
    "question":"Who owns the youngest dog? Give me his or her last name.",
    "query":"SELECT T1.last_name FROM dog_kennels.Owners AS T1 WITH (FORCESCAN) JOIN dog_kennels.Dogs AS T2 WITH (FORCESCAN) ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , age ] ; #3 = Filter [ #2 ] Predicate [ age IS NOT NULL ] Output [ owner_id , age ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ age DESC ] WithTies [ true ] Output [ owner_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #4.owner_id = #1.owner_id ] Output [ #1.last_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Output [ owner_id , last_name ] ; #2 = Scan Table [ Dogs ] Output [ owner_id , age ] ; #3 = Filter [ #2 ] Predicate [ age IS NOT NULL ] Output [ owner_id , age ] ; #4 = TopSort [ #3 ] Rows [ 1 ] OrderBy [ age DESC ] WithTies [ true ] Output [ owner_id ] ; #5 = Join [ #1 , #4 ] Predicate [ #4.owner_id = #1.owner_id ] Output [ #1.last_name ]",
    "cte":"WITH Scan_1 AS ( SELECT owner_id, last_name FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id, age FROM dog_kennels.Dogs ), Filter_3 AS ( SELECT owner_id, age FROM Scan_2 WHERE age IS NOT NULL ), TopSort_4 AS ( SELECT TOP 1 WITH TIES owner_id FROM Filter_3 ORDER BY age DESC ), Join_5 AS ( SELECT Scan_1.last_name FROM Scan_1 JOIN TopSort_4 ON TopSort_4.owner_id = Scan_1.owner_id ) SELECT * FROM Join_5",
    "clean_query":"SELECT T1.last_name FROM dog_kennels.Owners AS T1  JOIN dog_kennels.Dogs AS T2  ON T1.owner_id = T2.owner_id WHERE T2.age = ( SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs  )"
  },
  {
    "id":"92e6a8f3680fa91a51338547b40a58e01a2044a47b181bc2301d2f71ed3a9817",
    "db_id":"dog_kennels",
    "question":"List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.",
    "query":"SELECT email_address FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Hawaii' OR state = 'Wisconsin' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Professionals ] Predicate [ state = 'Hawaii' OR state = 'Wisconsin' ] Output [ state , email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Hawaii' OR state = 'Wisconsin' ] Output [ state , email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT state, email_address FROM dog_kennels.Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT email_address FROM dog_kennels.Professionals  WHERE state = 'Hawaii' OR state = 'Wisconsin'"
  },
  {
    "id":"2cf656ceb1eb210f1f81d421ee219bde550d715a32a6c7677ff2fa5526174d2f",
    "db_id":"dog_kennels",
    "question":"What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?",
    "query":"SELECT email_address FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE state = 'Hawaii' OR state = 'Wisconsin' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Professionals ] Predicate [ state = 'Hawaii' OR state = 'Wisconsin' ] Output [ state , email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ state = 'Hawaii' OR state = 'Wisconsin' ] Output [ state , email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT state, email_address FROM dog_kennels.Professionals WHERE state = 'Hawaii' OR state = 'Wisconsin' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT email_address FROM dog_kennels.Professionals  WHERE state = 'Hawaii' OR state = 'Wisconsin'"
  },
  {
    "id":"73901c0e2644fd7bcca864ab987842eae3371572f3f1c7c7323bba227247e5a3",
    "db_id":"dog_kennels",
    "question":"What are the arriving date and the departing date of all the dogs?",
    "query":"SELECT date_arrived , date_departed FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ date_departed , date_arrived ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ date_departed , date_arrived ]",
    "cte":"WITH Scan_1 AS ( SELECT date_departed, date_arrived FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
    "clean_query":"SELECT date_arrived , date_departed FROM dog_kennels.Dogs"
  },
  {
    "id":"179ac3c6aa019713305f70d101ac1fc9a2c0fb2b8dafbb0ee2a5290079d80fc0",
    "db_id":"dog_kennels",
    "question":"List the arrival date and the departure date for all the dogs.",
    "query":"SELECT date_arrived , date_departed FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ date_departed , date_arrived ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ date_departed , date_arrived ]",
    "cte":"WITH Scan_1 AS ( SELECT date_departed, date_arrived FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
    "clean_query":"SELECT date_arrived , date_departed FROM dog_kennels.Dogs"
  },
  {
    "id":"64fc77b18d68161ef02cddfa0391c902fd60785ca67c788616dce5eff2d8ec7c",
    "db_id":"dog_kennels",
    "question":"How many dogs went through any treatments?",
    "query":"SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Treatments ] Distinct [ true ] Output [ dog_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ dog_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT dog_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments"
  },
  {
    "id":"fe44aae95327f765fe37a47604e56e4242c7f5a1ebc738c17d59cda92f4e9cc5",
    "db_id":"dog_kennels",
    "question":"Count the number of dogs that went through a treatment.",
    "query":"SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Treatments ] Distinct [ true ] Output [ dog_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ dog_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT dog_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT dog_id ) AS Count_Dist_dog_id FROM dog_kennels.Treatments"
  },
  {
    "id":"cdc8145fd792a6edaffb1bd812a01f52de104c77fbc0a642f538ef1ea0887887",
    "db_id":"dog_kennels",
    "question":"How many professionals have performed any treatment to dogs?",
    "query":"SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Treatments ] Distinct [ true ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments"
  },
  {
    "id":"064cdc0cdd3190421bd5ff7a37e51119776ea589c73a6415f867acf56fce848d",
    "db_id":"dog_kennels",
    "question":"Find the number of professionals who have ever treated dogs.",
    "query":"SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Treatments ] Distinct [ true ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Distinct [ true ] Output [ professional_id ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT professional_id FROM dog_kennels.Treatments ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( DISTINCT professional_id ) AS Count_Dist_professional_id FROM dog_kennels.Treatments"
  },
  {
    "id":"5c621a2c9379a00f609d9e0aa243a240affd345c59eac074076072a0019e1f3e",
    "db_id":"dog_kennels",
    "question":"Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.",
    "query":"SELECT role_code , street , city , state FROM dog_kennels.professionals WITH (FORCESCAN) WHERE city LIKE '%West%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Professionals ] Predicate [ city like '%West%' ] Output [ role_code , state , city , street ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ city like '%West%' ] Output [ role_code , state , city , street ]",
    "cte":"WITH Scan_1 AS ( SELECT role_code, state, city, street FROM dog_kennels.Professionals WHERE city like '%West%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT role_code , street , city , state FROM dog_kennels.professionals  WHERE city LIKE '%West%'"
  },
  {
    "id":"967c3c6ebe4369045d9dde46ef6cc5d3dad46a05783e44a3d183ee2c1b3b1d59",
    "db_id":"dog_kennels",
    "question":"Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.",
    "query":"SELECT role_code , street , city , state FROM dog_kennels.professionals WITH (FORCESCAN) WHERE city LIKE '%West%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Professionals ] Predicate [ city like '%West%' ] Output [ role_code , state , city , street ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Predicate [ city like '%West%' ] Output [ role_code , state , city , street ]",
    "cte":"WITH Scan_1 AS ( SELECT role_code, state, city, street FROM dog_kennels.Professionals WHERE city like '%West%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT role_code , street , city , state FROM dog_kennels.professionals  WHERE city LIKE '%West%'"
  },
  {
    "id":"dfeb5c39fcfaa04fbe29e401a052a5057e480adbb6384afdcf777c02c5a13a38",
    "db_id":"dog_kennels",
    "question":"Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.",
    "query":"SELECT first_name , last_name , email_address FROM dog_kennels.Owners WITH (FORCESCAN) WHERE state LIKE '%North%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Owners ] Predicate [ state like '%North%' ] Output [ first_name , state , last_name , email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state like '%North%' ] Output [ first_name , state , last_name , email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, state, last_name, email_address FROM dog_kennels.Owners WHERE state like '%North%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT first_name , last_name , email_address FROM dog_kennels.Owners  WHERE state LIKE '%North%'"
  },
  {
    "id":"02ee31443afa5b62019b5b08c0de715d262a4191a0e90dd4451a9d5d1a293efc",
    "db_id":"dog_kennels",
    "question":"Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.",
    "query":"SELECT first_name , last_name , email_address FROM dog_kennels.Owners WITH (FORCESCAN) WHERE state LIKE '%North%' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Owners ] Predicate [ state like '%North%' ] Output [ first_name , state , last_name , email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Predicate [ state like '%North%' ] Output [ first_name , state , last_name , email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT first_name, state, last_name, email_address FROM dog_kennels.Owners WHERE state like '%North%' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT first_name , last_name , email_address FROM dog_kennels.Owners  WHERE state LIKE '%North%'"
  },
  {
    "id":"5e6dcd4f1c2e3953b79fdcda1cbd89c2bb9db999951cce84429b3be188edd3ba",
    "db_id":"dog_kennels",
    "question":"How many dogs have an age below the average?",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ] ; #3 = Scan Table [ Dogs ] Output [ age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.age < #2.Avg_age ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ] ; #3 = Scan Table [ Dogs ] Output [ age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.age < #2.Avg_age ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ), Scan_3 AS ( SELECT age FROM dog_kennels.Dogs ), Join_4 AS ( SELECT 1 AS One FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.age < Aggregate_2.Avg_age ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs  WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  )"
  },
  {
    "id":"d99c040d6524f2a05b4ba4f4ffe1aebca0489bba1ed41e3d2f14264a23dcaab2",
    "db_id":"dog_kennels",
    "question":"Count the number of dogs of an age below the average.",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ] ; #3 = Scan Table [ Dogs ] Output [ age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.age < #2.Avg_age ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ] ; #3 = Scan Table [ Dogs ] Output [ age ] ; #4 = Join [ #2 , #3 ] Predicate [ #3.age < #2.Avg_age ] Output [ 1 AS One ] ; #5 = Aggregate [ #4 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ), Scan_3 AS ( SELECT age FROM dog_kennels.Dogs ), Join_4 AS ( SELECT 1 AS One FROM Aggregate_2 CROSS JOIN Scan_3 WHERE Scan_3.age < Aggregate_2.Avg_age ), Aggregate_5 AS ( SELECT COUNT(*) AS Count_Star FROM Join_4 ) SELECT * FROM Aggregate_5",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs  WHERE age < ( SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs  )"
  },
  {
    "id":"433878795dbaeb06e20ccdf8f7b8f57b4490fc5649d2e72bce7e7585deacbf03",
    "db_id":"dog_kennels",
    "question":"How much does the most recent treatment cost?",
    "query":"SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ORDER BY date_of_treatment DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment , date_of_treatment ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_of_treatment DESC ] Output [ cost_of_treatment , date_of_treatment ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , date_of_treatment ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_of_treatment DESC ] Output [ cost_of_treatment , date_of_treatment ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment, date_of_treatment FROM dog_kennels.Treatments ), TopSort_2 AS ( SELECT TOP 1 cost_of_treatment, date_of_treatment FROM Scan_1 ORDER BY date_of_treatment DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments  ORDER BY date_of_treatment DESC"
  },
  {
    "id":"261b8f31c3472cd304eb89de390eab8847db8e7264ae2f27808562dbb6c75d24",
    "db_id":"dog_kennels",
    "question":"Show me the cost of the most recently performed treatment.",
    "query":"SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments WITH (FORCESCAN) ORDER BY date_of_treatment DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatments ] Output [ cost_of_treatment , date_of_treatment ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_of_treatment DESC ] Output [ cost_of_treatment , date_of_treatment ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatments ] Output [ cost_of_treatment , date_of_treatment ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ date_of_treatment DESC ] Output [ cost_of_treatment , date_of_treatment ]",
    "cte":"WITH Scan_1 AS ( SELECT cost_of_treatment, date_of_treatment FROM dog_kennels.Treatments ), TopSort_2 AS ( SELECT TOP 1 cost_of_treatment, date_of_treatment FROM Scan_1 ORDER BY date_of_treatment DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 cost_of_treatment FROM dog_kennels.Treatments  ORDER BY date_of_treatment DESC"
  },
  {
    "id":"78dcba3c4a0a01a2b294e2d6c29257905932d8253d58e95ad5b2a863957910ae",
    "db_id":"dog_kennels",
    "question":"How many dogs have not gone through any treatment?",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE dog_id NOT IN ( SELECT dog_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Dogs  WHERE dog_id NOT IN ( SELECT dog_id FROM dog_kennels.Treatments  )"
  },
  {
    "id":"2a8ea35ad7f723889d27b267bef72d3992a72b5dba5bd3d7c127682db1db41aa",
    "db_id":"dog_kennels",
    "question":"Tell me the number of dogs that have not received any treatment .",
    "query":"select count ( * ) AS Count_Star FROM dog_kennels.dogs WITH (FORCESCAN) where dog_id not in ( select dog_id FROM dog_kennels.treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ dog_id ] ; #2 = Scan Table [ Treatments ] Output [ dog_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.dog_id = #2.dog_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT dog_id FROM dog_kennels.Dogs ), Scan_2 AS ( SELECT dog_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE dog_id NOT IN (SELECT dog_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"select count ( * ) AS Count_Star FROM dog_kennels.dogs  where dog_id not in ( select dog_id FROM dog_kennels.treatments  )"
  },
  {
    "id":"c77304be5a473c9034ca40868437e0b9f90523b4106fb5e2fa4db8724e5109b5",
    "db_id":"dog_kennels",
    "question":"How many owners temporarily do not have any dogs?",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners WITH (FORCESCAN) WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Owners ] Output [ owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Output [ owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE owner_id NOT IN (SELECT owner_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners  WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs  )"
  },
  {
    "id":"767f67bdff974cd007a4ef44b18713af81def3a6d3999f59653e9508ab25c234",
    "db_id":"dog_kennels",
    "question":"Find the number of owners who do not own any dogs at this moment.",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners WITH (FORCESCAN) WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Owners ] Output [ owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Owners ] Output [ owner_id ] ; #2 = Scan Table [ Dogs ] Output [ owner_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.owner_id = #2.owner_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT owner_id FROM dog_kennels.Owners ), Scan_2 AS ( SELECT owner_id FROM dog_kennels.Dogs ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE owner_id NOT IN (SELECT owner_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Owners  WHERE owner_id NOT IN ( SELECT owner_id FROM dog_kennels.Dogs  )"
  },
  {
    "id":"6606a29dd2b7f2d93ea8e171a867970cf5da5496ddb77658dc04d73678da4f44",
    "db_id":"dog_kennels",
    "question":"How many professionals did not operate any treatment on dogs?",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ professional_id ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ professional_id ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals  WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments  )"
  },
  {
    "id":"ea3eaa087a14e4f6fc7c7c334cff9088ec99f3d6c4c5e9da66d1ce24146ede11",
    "db_id":"dog_kennels",
    "question":"Find the number of professionals who have not treated any dogs.",
    "query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals WITH (FORCESCAN) WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments WITH (FORCESCAN) ) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"extra",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ professional_id ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ professional_id ] ; #2 = Scan Table [ Treatments ] Output [ professional_id ] ; #3 = Except [ #1 , #2 ] Predicate [ #1.professional_id = #2.professional_id ] Output [ 1 AS One ] ; #4 = Aggregate [ #3 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT professional_id FROM dog_kennels.Professionals ), Scan_2 AS ( SELECT professional_id FROM dog_kennels.Treatments ), Except_3 AS ( SELECT 1 AS One FROM Scan_1 WHERE professional_id NOT IN (SELECT professional_id FROM Scan_2) ), Aggregate_4 AS ( SELECT COUNT(*) AS Count_Star FROM Except_3 ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM dog_kennels.Professionals  WHERE professional_id NOT IN ( SELECT professional_id FROM dog_kennels.Treatments  )"
  },
  {
    "id":"11757dbf072cf94f23cb22210fb8ca4455a8343fc40e151645d31758e9de045d",
    "db_id":"dog_kennels",
    "question":"List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.",
    "query":"SELECT name , age , weight FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE abandoned_yn = 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Predicate [ abandoned_yn = 1 ] Output [ weight , age , abandoned_yn , name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Predicate [ abandoned_yn = 1 ] Output [ weight , age , abandoned_yn , name ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, age, abandoned_yn, name FROM dog_kennels.Dogs WHERE abandoned_yn = 1 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , age , weight FROM dog_kennels.Dogs  WHERE abandoned_yn = 1"
  },
  {
    "id":"32ff77c2b84d8fdfca0153500392286944ab8a6286191e53738a1bbf35ae9632",
    "db_id":"dog_kennels",
    "question":"What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.",
    "query":"SELECT name , age , weight FROM dog_kennels.Dogs WITH (FORCESCAN) WHERE abandoned_yn = 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Predicate [ abandoned_yn = 1 ] Output [ weight , age , abandoned_yn , name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Predicate [ abandoned_yn = 1 ] Output [ weight , age , abandoned_yn , name ]",
    "cte":"WITH Scan_1 AS ( SELECT weight, age, abandoned_yn, name FROM dog_kennels.Dogs WHERE abandoned_yn = 1 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT name , age , weight FROM dog_kennels.Dogs  WHERE abandoned_yn = 1"
  },
  {
    "id":"b5a4050650d175c17ca4a9ec4d0c3a55e0950b773d6cd0d07c3d7f1204ea44e5",
    "db_id":"dog_kennels",
    "question":"What is the average age of all the dogs?",
    "query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ]",
    "cte":"WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs"
  },
  {
    "id":"753b0e7cd97e2a2870fcc6afa6c4512421986fad6e8ffc72c01b48e16e203d9d",
    "db_id":"dog_kennels",
    "question":"Compute the average age of all the dogs.",
    "query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ AVG(age) AS Avg_age ]",
    "cte":"WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT AVG(age) AS Avg_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT avg ( age ) AS Avg_age FROM dog_kennels.Dogs"
  },
  {
    "id":"508534bf0da2fdfac341224de99be1122d48ac8789e1c28ff1cb466571264236",
    "db_id":"dog_kennels",
    "question":"What is the age of the oldest dog?",
    "query":"SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ MAX(age) AS Max_age ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ MAX(age) AS Max_age ]",
    "cte":"WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT MAX(age) AS Max_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs"
  },
  {
    "id":"0fafa609fb687bd11e39aafb14e0ffb70a27929a9b591f3c196cc875ede3ebf9",
    "db_id":"dog_kennels",
    "question":"Tell me the age of the oldest dog.",
    "query":"SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ MAX(age) AS Max_age ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Output [ age ] ; #2 = Aggregate [ #1 ] Output [ MAX(age) AS Max_age ]",
    "cte":"WITH Scan_1 AS ( SELECT age FROM dog_kennels.Dogs ), Aggregate_2 AS ( SELECT MAX(age) AS Max_age FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( age ) AS Max_age FROM dog_kennels.Dogs"
  },
  {
    "id":"71de702627518d63a910bbd9bb7f366eddb8c5bd2464b78e4637839084874c71",
    "db_id":"dog_kennels",
    "question":"How much does each charge type costs? List both charge type and amount.",
    "query":"SELECT charge_type , charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Charges ] Output [ charge_type , charge_amount ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_type , charge_amount ]",
    "cte":"WITH Scan_1 AS ( SELECT charge_type, charge_amount FROM dog_kennels.Charges ) SELECT * FROM Scan_1",
    "clean_query":"SELECT charge_type , charge_amount FROM dog_kennels.Charges"
  },
  {
    "id":"5f2da74090ff46835a02f0b81d6fba00e4efcc8ddf7d14a503595b0354bdb3b6",
    "db_id":"dog_kennels",
    "question":"List each charge type and its amount.",
    "query":"SELECT charge_type , charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Charges ] Output [ charge_type , charge_amount ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_type , charge_amount ]",
    "cte":"WITH Scan_1 AS ( SELECT charge_type, charge_amount FROM dog_kennels.Charges ) SELECT * FROM Scan_1",
    "clean_query":"SELECT charge_type , charge_amount FROM dog_kennels.Charges"
  },
  {
    "id":"0b041ebce208085bea5e35531b4a6cdbde7156f9c58a9b2bd26415a0ebd102b1",
    "db_id":"dog_kennels",
    "question":"How much does the most expensive charge type costs?",
    "query":"SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Charges ] Output [ charge_amount ] ; #2 = Aggregate [ #1 ] Output [ MAX(charge_amount) AS Max_charge_amount ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_amount ] ; #2 = Aggregate [ #1 ] Output [ MAX(charge_amount) AS Max_charge_amount ]",
    "cte":"WITH Scan_1 AS ( SELECT charge_amount FROM dog_kennels.Charges ), Aggregate_2 AS ( SELECT MAX(charge_amount) AS Max_charge_amount FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges"
  },
  {
    "id":"fc656750ad557e7b823554bc96113a1f7f9ecc12fbb70e851c875598e29ecd85",
    "db_id":"dog_kennels",
    "question":"What is the charge amount of the most expensive charge type?",
    "query":"SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Charges ] Output [ charge_amount ] ; #2 = Aggregate [ #1 ] Output [ MAX(charge_amount) AS Max_charge_amount ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Charges ] Output [ charge_amount ] ; #2 = Aggregate [ #1 ] Output [ MAX(charge_amount) AS Max_charge_amount ]",
    "cte":"WITH Scan_1 AS ( SELECT charge_amount FROM dog_kennels.Charges ), Aggregate_2 AS ( SELECT MAX(charge_amount) AS Max_charge_amount FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT max ( charge_amount ) AS Max_charge_amount FROM dog_kennels.Charges"
  },
  {
    "id":"09c9bbb573dcab0c927cbe7d112f91c8834c15a2eb31f230e5f325df5793bdf6",
    "db_id":"dog_kennels",
    "question":"List the email, cell phone and home phone of all the professionals.",
    "query":"SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ cell_number , home_phone , email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ cell_number , home_phone , email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT cell_number, home_phone, email_address FROM dog_kennels.Professionals ) SELECT * FROM Scan_1",
    "clean_query":"SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals"
  },
  {
    "id":"e2aacdecf6d3b52d1802827572ef278aa2c5f3d76b5c6d26fcae103c47a8f0f2",
    "db_id":"dog_kennels",
    "question":"What are the email, cell phone and home phone of each professional?",
    "query":"SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Professionals ] Output [ cell_number , home_phone , email_address ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Professionals ] Output [ cell_number , home_phone , email_address ]",
    "cte":"WITH Scan_1 AS ( SELECT cell_number, home_phone, email_address FROM dog_kennels.Professionals ) SELECT * FROM Scan_1",
    "clean_query":"SELECT email_address , cell_number , home_phone FROM dog_kennels.professionals"
  },
  {
    "id":"4b2ac205277d7c5884472a73b7c2e9091542447d1c927af072dc0edc0bac2b1e",
    "db_id":"dog_kennels",
    "question":"What are all the possible breed type and size type combinations?",
    "query":"SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Distinct [ true ] Output [ size_code , breed_code ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Distinct [ true ] Output [ size_code , breed_code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT size_code, breed_code FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs"
  },
  {
    "id":"4776864cae0889340c0a3b3d4cf577b53714a560aac3a5e0b584b2fad0fede8f",
    "db_id":"dog_kennels",
    "question":"Find the distinct breed type and size type combinations for dogs.",
    "query":"SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Dogs ] Distinct [ true ] Output [ size_code , breed_code ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Dogs ] Distinct [ true ] Output [ size_code , breed_code ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT size_code, breed_code FROM dog_kennels.Dogs ) SELECT * FROM Scan_1",
    "clean_query":"SELECT DISTINCT breed_code , size_code FROM dog_kennels.dogs"
  },
  {
    "id":"9468ef5d219c1fc8111244fca69f0d535063a6e7bc3bb6219ce500e89256e5d0",
    "db_id":"dog_kennels",
    "question":"List the first name of all the professionals along with the description of the treatment they have done.",
    "query":"SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3 WITH (FORCESCAN) ON T2.treatment_type_code = T3.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ professional_id , treatment_type_code ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #2.treatment_type_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.treatment_type_code = #4.treatment_type_code ] Distinct [ true ] Output [ #1.treatment_type_description , #4.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ professional_id , treatment_type_code ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #2.treatment_type_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.treatment_type_code = #4.treatment_type_code ] Distinct [ true ] Output [ #1.treatment_type_description , #4.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT professional_id, treatment_type_code FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.first_name, Scan_2.treatment_type_code FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Join_5 AS ( SELECT DISTINCT Scan_1.treatment_type_description, Join_4.first_name FROM Scan_1 JOIN Join_4 ON Scan_1.treatment_type_code = Join_4.treatment_type_code ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3  ON T2.treatment_type_code = T3.treatment_type_code"
  },
  {
    "id":"af31c2dbac0d1ab65d2339c0d55235dc257c160e670af45309e001bba3098cdd",
    "db_id":"dog_kennels",
    "question":"What are each professional's first name and description of the treatment they have performed?",
    "query":"SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1 WITH (FORCESCAN) JOIN dog_kennels.Treatments AS T2 WITH (FORCESCAN) ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3 WITH (FORCESCAN) ON T2.treatment_type_code = T3.treatment_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ professional_id , treatment_type_code ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #2.treatment_type_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.treatment_type_code = #4.treatment_type_code ] Distinct [ true ] Output [ #1.treatment_type_description , #4.first_name ]",
    "prefixed_qpl":"dog_kennels | #1 = Scan Table [ Treatment_Types ] Output [ treatment_type_code , treatment_type_description ] ; #2 = Scan Table [ Treatments ] Output [ professional_id , treatment_type_code ] ; #3 = Scan Table [ Professionals ] Output [ first_name , professional_id ] ; #4 = Join [ #2 , #3 ] Predicate [ #2.professional_id = #3.professional_id ] Output [ #3.first_name , #2.treatment_type_code ] ; #5 = Join [ #1 , #4 ] Predicate [ #1.treatment_type_code = #4.treatment_type_code ] Distinct [ true ] Output [ #1.treatment_type_description , #4.first_name ]",
    "cte":"WITH Scan_1 AS ( SELECT treatment_type_code, treatment_type_description FROM dog_kennels.Treatment_Types ), Scan_2 AS ( SELECT professional_id, treatment_type_code FROM dog_kennels.Treatments ), Scan_3 AS ( SELECT first_name, professional_id FROM dog_kennels.Professionals ), Join_4 AS ( SELECT Scan_3.first_name, Scan_2.treatment_type_code FROM Scan_2 JOIN Scan_3 ON Scan_2.professional_id = Scan_3.professional_id ), Join_5 AS ( SELECT DISTINCT Scan_1.treatment_type_description, Join_4.first_name FROM Scan_1 JOIN Join_4 ON Scan_1.treatment_type_code = Join_4.treatment_type_code ) SELECT * FROM Join_5",
    "clean_query":"SELECT DISTINCT T1.first_name , T3.treatment_type_description FROM dog_kennels.professionals AS T1  JOIN dog_kennels.Treatments AS T2  ON T1.professional_id = T2.professional_id JOIN dog_kennels.Treatment_types AS T3  ON T2.treatment_type_code = T3.treatment_type_code"
  },
  {
    "id":"8c12cf9b50cade1629258a9e8344630d0a188e5a5d2f19b038075767850b934f",
    "db_id":"singer",
    "question":"How many singers are there?",
    "query":"SELECT count ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM singer.singer"
  },
  {
    "id":"804c8e18ba30e708d50724b2884ec025fcc5e03cf2f010b2e756c50555cf7bb3",
    "db_id":"singer",
    "question":"What is the count of singers?",
    "query":"SELECT count ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM singer.singer ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM singer.singer"
  },
  {
    "id":"b9ea969d4c1a883ed38c19942e7eb9b608a8f06861c97fdde9839c049fa21c88",
    "db_id":"singer",
    "question":"List the name of singers in ascending order of net worth.",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = Sort [ #1 ] OrderBy [ Net_Worth_Millions ASC ] Output [ Name , Net_Worth_Millions ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = Sort [ #1 ] OrderBy [ Net_Worth_Millions ASC ] Output [ Name , Net_Worth_Millions ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ) SELECT Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions ASC",
    "clean_query":"SELECT Name FROM singer.singer  ORDER BY Net_Worth_Millions ASC"
  },
  {
    "id":"011a772567169c804c61ebdecf6dcc9f19f77788577f9b41c55d6f917bd638fc",
    "db_id":"singer",
    "question":"What are the names of singers ordered by ascending net worth?",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions ASC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = Sort [ #1 ] OrderBy [ Net_Worth_Millions ASC ] Output [ Name , Net_Worth_Millions ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = Sort [ #1 ] OrderBy [ Net_Worth_Millions ASC ] Output [ Name , Net_Worth_Millions ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ) SELECT Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions ASC",
    "clean_query":"SELECT Name FROM singer.singer  ORDER BY Net_Worth_Millions ASC"
  },
  {
    "id":"c9a7efa3930c9f7e3a10444caceb7e50835b86408bdd65b9a89aebbd3db71302",
    "db_id":"singer",
    "question":"What are the birth year and citizenship of singers?",
    "query":"SELECT Birth_Year , Citizenship FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Citizenship , Birth_Year ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Citizenship , Birth_Year ]",
    "cte":"WITH Scan_1 AS ( SELECT Citizenship, Birth_Year FROM singer.singer ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Birth_Year , Citizenship FROM singer.singer"
  },
  {
    "id":"b949490e009a7f50dfe5876c63c8f31a252c1e327bee7cf800057e949a391ee3",
    "db_id":"singer",
    "question":"What are the birth years and citizenships of the singers?",
    "query":"SELECT Birth_Year , Citizenship FROM singer.singer WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Citizenship , Birth_Year ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Citizenship , Birth_Year ]",
    "cte":"WITH Scan_1 AS ( SELECT Citizenship, Birth_Year FROM singer.singer ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Birth_Year , Citizenship FROM singer.singer"
  },
  {
    "id":"8c8870ec05f32246c5b7955c28f5c81d57e9115f47091d631a393c7bd79a4581",
    "db_id":"singer",
    "question":"List the name of singers whose citizenship is not \"France\".",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Citizenship ! = 'France' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Citizenship <> 'France' ] Output [ Name , Citizenship ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Predicate [ Citizenship <> 'France' ] Output [ Name , Citizenship ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Citizenship FROM singer.singer WHERE Citizenship <> 'France' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM singer.singer  WHERE Citizenship ! = 'France'"
  },
  {
    "id":"550e5e82df704280579aec36cce4557a6a0a38b91cf057b63a589c368210022a",
    "db_id":"singer",
    "question":"What are the names of the singers who are not French citizens?",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Citizenship ! = 'France' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Citizenship <> 'France' ] Output [ Name , Citizenship ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Predicate [ Citizenship <> 'France' ] Output [ Name , Citizenship ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Citizenship FROM singer.singer WHERE Citizenship <> 'France' ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM singer.singer  WHERE Citizenship ! = 'France'"
  },
  {
    "id":"d98f8fe8157483e3c7d8cfc11da276a7efd8100150eb4e6e7170ed40aa5b1e4f",
    "db_id":"singer",
    "question":"Show the name of singers whose birth year is either 1948 or 1949?",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year = 1948 OR Birth_Year = 1949 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Birth_Year = 1948.0 OR Birth_Year = 1949.0 ] Output [ Name , Birth_Year ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year = 1948.0 OR Birth_Year = 1949.0 ] Output [ Name , Birth_Year ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Birth_Year FROM singer.singer WHERE Birth_Year = 1948.0 OR Birth_Year = 1949.0 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM singer.singer  WHERE Birth_Year = 1948 OR Birth_Year = 1949"
  },
  {
    "id":"5b29113c5ab990f62b686fbdc871914d99e8e268ea27a89a31141d06be57b7a9",
    "db_id":"singer",
    "question":"What are the names of the singers whose birth years are either 1948 or 1949?",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year = 1948 OR Birth_Year = 1949 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Birth_Year = 1948.0 OR Birth_Year = 1949.0 ] Output [ Name , Birth_Year ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year = 1948.0 OR Birth_Year = 1949.0 ] Output [ Name , Birth_Year ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Birth_Year FROM singer.singer WHERE Birth_Year = 1948.0 OR Birth_Year = 1949.0 ) SELECT * FROM Scan_1",
    "clean_query":"SELECT Name FROM singer.singer  WHERE Birth_Year = 1948 OR Birth_Year = 1949"
  },
  {
    "id":"58c46fcc34a7383d2e710c843d03f5bf99d9592aa7e497a33a507a2e6058fe5f",
    "db_id":"singer",
    "question":"What is the name of the singer with the largest net worth?",
    "query":"SELECT TOP 1 Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Net_Worth_Millions DESC ] Output [ Name , Net_Worth_Millions ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Net_Worth_Millions DESC ] Output [ Name , Net_Worth_Millions ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ), TopSort_2 AS ( SELECT TOP 1 Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name FROM singer.singer  ORDER BY Net_Worth_Millions DESC"
  },
  {
    "id":"73af14f9e8271c97b343c331de6a984ba197bd3ba69a66b4418187b22f316392",
    "db_id":"singer",
    "question":"What is the name of the singer who is worth the most?",
    "query":"SELECT TOP 1 Name FROM singer.singer WITH (FORCESCAN) ORDER BY Net_Worth_Millions DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Net_Worth_Millions DESC ] Output [ Name , Net_Worth_Millions ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Net_Worth_Millions ] ; #2 = TopSort [ #1 ] Rows [ 1 ] OrderBy [ Net_Worth_Millions DESC ] Output [ Name , Net_Worth_Millions ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Net_Worth_Millions FROM singer.singer ), TopSort_2 AS ( SELECT TOP 1 Name, Net_Worth_Millions FROM Scan_1 ORDER BY Net_Worth_Millions DESC ) SELECT * FROM TopSort_2",
    "clean_query":"SELECT TOP 1 Name FROM singer.singer  ORDER BY Net_Worth_Millions DESC"
  },
  {
    "id":"4f42fde37cbd059904929409566173c2576d719495a3d5923a4e396355823e91",
    "db_id":"singer",
    "question":"Show different citizenship of singers and the number of singers of each citizenship.",
    "query":"SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT Citizenship, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer  GROUP BY Citizenship"
  },
  {
    "id":"99d01cadde9a3a585cfb95149c86e586e956c4807f67adea88f25cac11d941cf",
    "db_id":"singer",
    "question":"For each citizenship, how many singers are from that country?",
    "query":"SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT Citizenship, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Citizenship , COUNT ( * ) AS Count_Star FROM singer.singer  GROUP BY Citizenship"
  },
  {
    "id":"87a3b0989ee1dc1513ab72ca2965ce5304ba36e5ef0d89b458a1814f7fbcdb6c",
    "db_id":"singer",
    "question":"Please show the most common citizenship of singers.",
    "query":"SELECT TOP 1 Citizenship FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship ORDER BY COUNT ( * ) DESC OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Citizenship ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Citizenship ]",
    "cte":"WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT Citizenship, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Citizenship ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Citizenship FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"SELECT TOP 1 Citizenship FROM singer.singer  GROUP BY Citizenship ORDER BY COUNT ( * ) DESC"
  },
  {
    "id":"7c9e7a7be63f400ff33df576791e0fd53332a3d954a89aa0cb953b4eb70b1682",
    "db_id":"singer",
    "question":"What is the most common singer citizenship ?",
    "query":"select TOP 1 citizenship FROM singer.singer WITH (FORCESCAN) group by citizenship order by count ( * ) desc OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Citizenship ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , countstar AS Count_Star ] ; #3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Count_Star DESC ] Output [ Count_Star , Citizenship ]",
    "cte":"WITH Scan_1 AS ( SELECT Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT Citizenship, COUNT(*) AS Count_Star FROM Scan_1 GROUP BY Citizenship ), TopSort_3 AS ( SELECT TOP 1 Count_Star, Citizenship FROM Aggregate_2 ORDER BY Count_Star DESC ) SELECT * FROM TopSort_3",
    "clean_query":"select TOP 1 citizenship FROM singer.singer  group by citizenship order by count ( * ) desc"
  },
  {
    "id":"9561b97b13a187930d20fc2c295e7c02162337366bbcd10dbbf6095d1bfd95ce",
    "db_id":"singer",
    "question":"Show different citizenships and the maximum net worth of singers of each citizenship.",
    "query":"SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Net_Worth_Millions , Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Net_Worth_Millions , Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions ]",
    "cte":"WITH Scan_1 AS ( SELECT Net_Worth_Millions, Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer  GROUP BY Citizenship"
  },
  {
    "id":"697dfd5ef5b2393132d9a7c62561764004455e1c985cc95ce70a0ccc10fa9cd6",
    "db_id":"singer",
    "question":"For each citizenship, what is the maximum net worth?",
    "query":"SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer WITH (FORCESCAN) GROUP BY Citizenship OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Net_Worth_Millions , Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Net_Worth_Millions , Citizenship ] ; #2 = Aggregate [ #1 ] GroupBy [ Citizenship ] Output [ Citizenship , MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions ]",
    "cte":"WITH Scan_1 AS ( SELECT Net_Worth_Millions, Citizenship FROM singer.singer ), Aggregate_2 AS ( SELECT Citizenship, MAX(Net_Worth_Millions) AS Max_Net_Worth_Millions FROM Scan_1 GROUP BY Citizenship ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT Citizenship , max ( Net_Worth_Millions ) AS Max_Net_Worth_Millions FROM singer.singer  GROUP BY Citizenship"
  },
  {
    "id":"e75d3a7f87b0a33d06fce6ca17196f4c588fc1be645276004b8fc026e5de12d8",
    "db_id":"singer",
    "question":"Show titles of songs and names of singers.",
    "query":"SELECT T2.Title , T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Title , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Title , #1.Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Title , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Title , #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Singer_ID FROM singer.singer ), Scan_2 AS ( SELECT Title, Singer_ID FROM singer.song ), Join_3 AS ( SELECT Scan_2.Title, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.Title , T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID"
  },
  {
    "id":"95b11b7b6da3a1a61a86398786d17ce1182a1250691e9475819940d233798069",
    "db_id":"singer",
    "question":"What are the song titles and singer names?",
    "query":"SELECT T2.Title , T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Title , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Title , #1.Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Title , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Title , #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Singer_ID FROM singer.singer ), Scan_2 AS ( SELECT Title, Singer_ID FROM singer.song ), Join_3 AS ( SELECT Scan_2.Title, Scan_1.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.Title , T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID"
  },
  {
    "id":"6526137048ae8dec7f67b1d156501fe03e65412e05ce2362239d91b62eb64ae3",
    "db_id":"singer",
    "question":"Show distinct names of singers that have songs with sales more than 300000.",
    "query":"SELECT DISTINCT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ song ] Predicate [ Sales > 300000.0 ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Distinct [ true ] Output [ #2.Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ song ] Predicate [ Sales > 300000.0 ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Distinct [ true ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song WHERE Sales > 300000.0 ), Scan_2 AS ( SELECT Name, Singer_ID FROM singer.singer ), Join_3 AS ( SELECT DISTINCT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
  },
  {
    "id":"993f7da6bf9f3c08f1e566829f9baa9a8e5d5f1ec7f62cd1cc76d32e74fc924a",
    "db_id":"singer",
    "question":"what are the different names of the singers that have sales more than 300000?",
    "query":"SELECT DISTINCT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ song ] Predicate [ Sales > 300000.0 ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Distinct [ true ] Output [ #2.Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ song ] Predicate [ Sales > 300000.0 ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Distinct [ true ] Output [ #2.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song WHERE Sales > 300000.0 ), Scan_2 AS ( SELECT Name, Singer_ID FROM singer.singer ), Join_3 AS ( SELECT DISTINCT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ) SELECT * FROM Join_3",
    "clean_query":"SELECT DISTINCT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID WHERE T2.Sales > 300000"
  },
  {
    "id":"0185d5551797ce6214ec07f1a2a8d2791d103019f6b83bb6fe52fc6322a0807b",
    "db_id":"singer",
    "question":"Show the names of singers that have more than one song.",
    "query":"SELECT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ song ] Output [ Singer_ID ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ song ] Output [ Singer_ID ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID FROM singer.song ), Scan_2 AS ( SELECT Name, Singer_ID FROM singer.singer ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1"
  },
  {
    "id":"3b3211d0463e7b65bdc40f6c3989d1bfeb949e049510419df985111529653097",
    "db_id":"singer",
    "question":"What are the names of the singers that have more than one songs?",
    "query":"SELECT T1.Name FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ song ] Output [ Singer_ID ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ song ] Output [ Singer_ID ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , countstar AS Count_Star ] ; #5 = Filter [ #4 ] Predicate [ Count_Star > 1 ] Output [ Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID FROM singer.song ), Scan_2 AS ( SELECT Name, Singer_ID FROM singer.singer ), Join_3 AS ( SELECT Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, COUNT(*) AS Count_Star FROM Join_3 GROUP BY Name ), Filter_5 AS ( SELECT Name FROM Aggregate_4 WHERE Count_Star > 1 ) SELECT * FROM Filter_5",
    "clean_query":"SELECT T1.Name FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name HAVING COUNT ( * ) > 1"
  },
  {
    "id":"979d85d193f3882cf9f01bfff9c1151c9ab871fd99ba917b143d4970cf33cc05",
    "db_id":"singer",
    "question":"Show the names of singers and the total sales of their songs.",
    "query":"SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ song ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Sales , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , SUM(Sales) AS Sum_Sales ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ song ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Sales , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , SUM(Sales) AS Sum_Sales ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song ), Scan_2 AS ( SELECT Name, Singer_ID FROM singer.singer ), Join_3 AS ( SELECT Scan_1.Sales, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, SUM(Sales) AS Sum_Sales FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name"
  },
  {
    "id":"8ddb7c07d3458e79a1b0ab40bec542aa9573847464da7037e2e78d99b362b74d",
    "db_id":"singer",
    "question":"For each singer name, what is the total sales for their songs?",
    "query":"SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1 WITH (FORCESCAN) JOIN singer.song AS T2 WITH (FORCESCAN) ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ song ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Sales , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , SUM(Sales) AS Sum_Sales ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ song ] Output [ Singer_ID , Sales ] ; #2 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.Singer_ID = #2.Singer_ID ] Output [ #1.Sales , #2.Name ] ; #4 = Aggregate [ #3 ] GroupBy [ Name ] Output [ Name , SUM(Sales) AS Sum_Sales ]",
    "cte":"WITH Scan_1 AS ( SELECT Singer_ID, Sales FROM singer.song ), Scan_2 AS ( SELECT Name, Singer_ID FROM singer.singer ), Join_3 AS ( SELECT Scan_1.Sales, Scan_2.Name FROM Scan_1 JOIN Scan_2 ON Scan_1.Singer_ID = Scan_2.Singer_ID ), Aggregate_4 AS ( SELECT Name, SUM(Sales) AS Sum_Sales FROM Join_3 GROUP BY Name ) SELECT * FROM Aggregate_4",
    "clean_query":"SELECT T1.Name , sum ( T2.Sales ) AS Sum_Sales FROM singer.singer AS T1  JOIN singer.song AS T2  ON T1.Singer_ID = T2.Singer_ID GROUP BY T1.Name"
  },
  {
    "id":"1285a88105c026db53a8c6bc8a43ea895a25c3eef88da5796b307750abd1692f",
    "db_id":"singer",
    "question":"List the name of singers that do not have any song.",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Singer_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Singer_ID IS NULL OR #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Singer_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Singer_ID IS NULL OR #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Singer_ID FROM singer.singer ), Scan_2 AS ( SELECT Singer_ID FROM singer.song ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Singer_ID NOT IN (SELECT Singer_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Name FROM singer.singer  WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song  )"
  },
  {
    "id":"32e1d3180f2d4a1423db0aafca0f239d324b1efe137c80c4c83049c8a3525e55",
    "db_id":"singer",
    "question":"What is the sname of every sing that does not have any song?",
    "query":"SELECT Name FROM singer.singer WITH (FORCESCAN) WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song WITH (FORCESCAN) ) ",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Singer_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Singer_ID IS NULL OR #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Output [ Name , Singer_ID ] ; #2 = Scan Table [ song ] Output [ Singer_ID ] ; #3 = Except [ #1 , #2 ] Predicate [ #2.Singer_ID IS NULL OR #1.Singer_ID = #2.Singer_ID ] Output [ #1.Name ]",
    "cte":"WITH Scan_1 AS ( SELECT Name, Singer_ID FROM singer.singer ), Scan_2 AS ( SELECT Singer_ID FROM singer.song ), Except_3 AS ( SELECT Scan_1.Name FROM Scan_1 WHERE Singer_ID NOT IN (SELECT Singer_ID FROM Scan_2) ) SELECT * FROM Except_3",
    "clean_query":"SELECT Name FROM singer.singer  WHERE Singer_ID NOT IN ( SELECT Singer_ID FROM singer.song  )"
  },
  {
    "id":"28a57a5b75f7a8f40eec87da513ebdcad210610f006d483f39f4de5e4d14f7a7",
    "db_id":"singer",
    "question":"Show the citizenship shared by singers with birth year before 1945 and after 1955.",
    "query":"SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year > 1955 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Birth_Year < 1945.0 ] Distinct [ true ] Output [ Citizenship , Birth_Year ] ; #2 = Scan Table [ singer ] Predicate [ Birth_Year > 1955.0 ] Output [ Citizenship , Birth_Year ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Citizenship = #2.Citizenship ] Output [ #1.Citizenship ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year < 1945.0 ] Distinct [ true ] Output [ Citizenship , Birth_Year ] ; #2 = Scan Table [ singer ] Predicate [ Birth_Year > 1955.0 ] Output [ Citizenship , Birth_Year ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Citizenship = #2.Citizenship ] Output [ #1.Citizenship ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Citizenship, Birth_Year FROM singer.singer WHERE Birth_Year < 1945.0 ), Scan_2 AS ( SELECT Citizenship, Birth_Year FROM singer.singer WHERE Birth_Year > 1955.0 ), Intersect_3 AS ( SELECT Scan_1.Citizenship FROM Scan_1 WHERE Citizenship IN (SELECT Citizenship FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT Citizenship FROM singer.singer  WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer  WHERE Birth_Year > 1955"
  },
  {
    "id":"341f8b90b4223634d3f86dfbdbdb6e798b7ae3bffe8641e55dafa4f3b7536d88",
    "db_id":"singer",
    "question":"What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?",
    "query":"SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer WITH (FORCESCAN) WHERE Birth_Year > 1955 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ singer ] Predicate [ Birth_Year < 1945.0 ] Distinct [ true ] Output [ Citizenship , Birth_Year ] ; #2 = Scan Table [ singer ] Predicate [ Birth_Year > 1955.0 ] Output [ Citizenship , Birth_Year ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Citizenship = #2.Citizenship ] Output [ #1.Citizenship ]",
    "prefixed_qpl":"singer | #1 = Scan Table [ singer ] Predicate [ Birth_Year < 1945.0 ] Distinct [ true ] Output [ Citizenship , Birth_Year ] ; #2 = Scan Table [ singer ] Predicate [ Birth_Year > 1955.0 ] Output [ Citizenship , Birth_Year ] ; #3 = Intersect [ #1 , #2 ] Predicate [ #1.Citizenship = #2.Citizenship ] Output [ #1.Citizenship ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT Citizenship, Birth_Year FROM singer.singer WHERE Birth_Year < 1945.0 ), Scan_2 AS ( SELECT Citizenship, Birth_Year FROM singer.singer WHERE Birth_Year > 1955.0 ), Intersect_3 AS ( SELECT Scan_1.Citizenship FROM Scan_1 WHERE Citizenship IN (SELECT Citizenship FROM Scan_2) ) SELECT * FROM Intersect_3",
    "clean_query":"SELECT Citizenship FROM singer.singer  WHERE Birth_Year < 1945 INTERSECT SELECT Citizenship FROM singer.singer  WHERE Birth_Year > 1955"
  },
  {
    "id":"b3221e9c112854ef99fba5d334b12427914fef6cde224429b25a501e64e6c4ae",
    "db_id":"real_estate_properties",
    "question":"How many available features are there in total?",
    "query":"SELECT count ( * ) AS Count_Star FROM real_estate_properties.Other_Available_Features WITH (FORCESCAN) OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"easy",
    "qpl":"#1 = Scan Table [ Other_Available_Features ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "prefixed_qpl":"real_estate_properties | #1 = Scan Table [ Other_Available_Features ] Output [ 1 AS One ] ; #2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]",
    "cte":"WITH Scan_1 AS ( SELECT 1 AS One FROM real_estate_properties.Other_Available_Features ), Aggregate_2 AS ( SELECT COUNT(*) AS Count_Star FROM Scan_1 ) SELECT * FROM Aggregate_2",
    "clean_query":"SELECT count ( * ) AS Count_Star FROM real_estate_properties.Other_Available_Features"
  },
  {
    "id":"2eae79665e670663f892b02b5ab203781851af06ec08b956ad48104a9ff70be6",
    "db_id":"real_estate_properties",
    "question":"What is the feature type name of feature AirCon?",
    "query":"SELECT T2.feature_type_name FROM real_estate_properties.Other_Available_Features AS T1 WITH (FORCESCAN) JOIN real_estate_properties.Ref_Feature_Types AS T2 WITH (FORCESCAN) ON T1.feature_type_code = T2.feature_type_code WHERE T1.feature_name = 'AirCon' OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Other_Available_Features ] Predicate [ feature_name = 'AirCon' ] Output [ feature_type_code , feature_name ] ; #2 = Scan Table [ Ref_Feature_Types ] Output [ feature_type_code , feature_type_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.feature_type_code = #2.feature_type_code ] Output [ #2.feature_type_name ]",
    "prefixed_qpl":"real_estate_properties | #1 = Scan Table [ Other_Available_Features ] Predicate [ feature_name = 'AirCon' ] Output [ feature_type_code , feature_name ] ; #2 = Scan Table [ Ref_Feature_Types ] Output [ feature_type_code , feature_type_name ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.feature_type_code = #2.feature_type_code ] Output [ #2.feature_type_name ]",
    "cte":"WITH Scan_1 AS ( SELECT feature_type_code, feature_name FROM real_estate_properties.Other_Available_Features WHERE feature_name = 'AirCon' ), Scan_2 AS ( SELECT feature_type_code, feature_type_name FROM real_estate_properties.Ref_Feature_Types ), Join_3 AS ( SELECT Scan_2.feature_type_name FROM Scan_1 JOIN Scan_2 ON Scan_1.feature_type_code = Scan_2.feature_type_code ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.feature_type_name FROM real_estate_properties.Other_Available_Features AS T1  JOIN real_estate_properties.Ref_Feature_Types AS T2  ON T1.feature_type_code = T2.feature_type_code WHERE T1.feature_name = 'AirCon'"
  },
  {
    "id":"767d8f34f1b268c7832d789fbb1f662604e9db7d49975fb7b642cb8ca235ce34",
    "db_id":"real_estate_properties",
    "question":"Show the property type descriptions of properties belonging to that code.",
    "query":"SELECT T2.property_type_description FROM real_estate_properties.Properties AS T1 WITH (FORCESCAN) JOIN real_estate_properties.Ref_Property_Types AS T2 WITH (FORCESCAN) ON T1.property_type_code = T2.property_type_code GROUP BY T2.property_type_description , T1.property_type_code OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"medium",
    "qpl":"#1 = Scan Table [ Properties ] Distinct [ true ] Output [ property_type_code ] ; #2 = Scan Table [ Ref_Property_Types ] Output [ property_type_description , property_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.property_type_code = #2.property_type_code ] Output [ #2.property_type_description ]",
    "prefixed_qpl":"real_estate_properties | #1 = Scan Table [ Properties ] Distinct [ true ] Output [ property_type_code ] ; #2 = Scan Table [ Ref_Property_Types ] Output [ property_type_description , property_type_code ] ; #3 = Join [ #1 , #2 ] Predicate [ #1.property_type_code = #2.property_type_code ] Output [ #2.property_type_description ]",
    "cte":"WITH Scan_1 AS ( SELECT DISTINCT property_type_code FROM real_estate_properties.Properties ), Scan_2 AS ( SELECT property_type_description, property_type_code FROM real_estate_properties.Ref_Property_Types ), Join_3 AS ( SELECT Scan_2.property_type_description FROM Scan_1 JOIN Scan_2 ON Scan_1.property_type_code = Scan_2.property_type_code ) SELECT * FROM Join_3",
    "clean_query":"SELECT T2.property_type_description FROM real_estate_properties.Properties AS T1  JOIN real_estate_properties.Ref_Property_Types AS T2  ON T1.property_type_code = T2.property_type_code GROUP BY T2.property_type_description , T1.property_type_code"
  },
  {
    "id":"226cd9a74a1b2e51610774012d114c254e10c37065ac9d0b0e0f451343dcc72e",
    "db_id":"real_estate_properties",
    "question":"What are the names of properties that are either houses or apartments with more than 1 room?",
    "query":"SELECT property_name FROM real_estate_properties.Properties WITH (FORCESCAN) WHERE property_type_code = 'House' UNION SELECT property_name FROM real_estate_properties.Properties WITH (FORCESCAN) WHERE property_type_code = 'Apartment' AND room_count > 1 OPTION (HASH JOIN, ORDER GROUP)",
    "difficulty":"hard",
    "qpl":"#1 = Scan Table [ Properties ] Predicate [ property_type_code = 'House' ] Output [ property_name , property_type_code ] ; #2 = Scan Table [ Properties ] Predicate [ room_count > 1 AND property_type_code = 'Apartment' ] Output [ property_name , room_count , property_type_code ] ; #3 = Union [ #1 , #2 ] Output [ #1.property_name ]",
    "prefixed_qpl":"real_estate_properties | #1 = Scan Table [ Properties ] Predicate [ property_type_code = 'House' ] Output [ property_name , property_type_code ] ; #2 = Scan Table [ Properties ] Predicate [ room_count > 1 AND property_type_code = 'Apartment' ] Output [ property_name , room_count , property_type_code ] ; #3 = Union [ #1 , #2 ] Output [ #1.property_name ]",
    "cte":"WITH Scan_1 AS ( SELECT property_name, property_type_code FROM real_estate_properties.Properties WHERE property_type_code = 'House' ), Scan_2 AS ( SELECT property_name, room_count, property_type_code FROM real_estate_properties.Properties WHERE room_count > 1 AND property_type_code = 'Apartment' ), Union_3 AS ( SELECT property_name FROM Scan_1 UNION SELECT property_name FROM Scan_2 ) SELECT * FROM Union_3",
    "clean_query":"SELECT property_name FROM real_estate_properties.Properties  WHERE property_type_code = 'House' UNION SELECT property_name FROM real_estate_properties.Properties  WHERE property_type_code = 'Apartment' AND room_count > 1"
  }
]